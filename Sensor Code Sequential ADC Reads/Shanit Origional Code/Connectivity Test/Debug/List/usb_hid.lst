###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        20/Mar/2018  09:41:54
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\Class\usb_hid.c
#    Command line =  
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\Class\usb_hid.c" -D IAR --preprocess
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Debug\List\" -lC
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Debug\List\" -lB
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Debug\List\"
#        --diag_suppress Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Debug\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\rfrum\OneDrive\2018
#        Spring Semester\Senior Design\Sensor Code\Shanit Origional
#        Code\Connectivity Test\PLM\Configure\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Environment\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Interface\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Generic
#        Services\Interface\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Uart\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\CDC\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\Descriptor\" -I "C:\Users\rfrum\OneDrive\2018
#        Spring Semester\Senior Design\Sensor Code\Shanit Origional
#        Code\Connectivity Test\PLM\Source\USB\Class\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\"
#        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
#        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Radio\MC1324x\PHY\" -I "C:\Users\rfrum\OneDrive\2018
#        Spring Semester\Senior Design\Sensor Code\Shanit Origional
#        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\Sys Common\"
#        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Application\Source\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Application\Configure\"
#        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -On
#    List file    =  
#        C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Debug\List\usb_hid.lst
#    Object file  =  
#        C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Debug\Obj\usb_hid.o
#
###############################################################################

C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Class\usb_hid.c
      1          /******************************************************************************
      2           *
      3           * Freescale Semiconductor Inc.
      4           * (c) Copyright 2004-2010 Freescale Semiconductor, Inc.
      5           * ALL RIGHTS RESERVED.
      6           *
      7           ******************************************************************************
      8           *
      9           * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR 
     10           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
     11           * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
     12           * IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
     13           * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
     14           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
     15           * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
     16           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
     17           * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
     18           * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
     19           * THE POSSIBILITY OF SUCH DAMAGE.
     20           *
     21           **************************************************************************//*!
     22           *
     23           * @file usb_hid.c
     24           *
     25           * @author
     26           *
     27           * @version
     28           *
     29           * @date
     30           *
     31           * @brief The file contains USB stack HID layer implementation.
     32           *
     33           *****************************************************************************/
     34          
     35          /******************************************************************************
     36           * Includes
     37           *****************************************************************************/
     38          
     39           
     40          #include "USB_Interface.h" 
     41          #include "USB.h"
     42          #include "usb_hid.h"    /* USB HID Class Header File */
     43          #include "usb_descriptor.h"
     44          #include "usb_devapi.h" /* USB device Header File */
     45          
     46          #if gUsbHidEnabled_d 
     47           
     48          #if (gUsbIncluded_d == FALSE)
     49           #error If gUsbHidEnabled_d == TRUE, gUsbIncluded_d must be TRUE
     50          #endif
     51          
     52          /*****************************************************************************
     53           * Constant and Macro's
     54           *****************************************************************************/
     55          
     56          /****************************************************************************
     57           * Global Variables
     58           ****************************************************************************/
     59          
     60          
     61          /*****************************************************************************
     62           * Local Types - None
     63           *****************************************************************************/
     64          
     65          /*****************************************************************************
     66           * Local Functions Prototypes
     67           *****************************************************************************/
     68          static uint8_t USB_HID_OtherRequests
     69          (
     70            uint8_t controllerId,
     71            usbSetupPacket_t * pSetupPacket,
     72            uint8_t* *pData,
     73            usbPacketSize_t *pSize
     74          );
     75          
     76          /*****************************************************************************
     77           * Local Variables - None
     78           *****************************************************************************/
     79          
     80          /*****************************************************************************
     81           * Local Functions
     82           *****************************************************************************/
     83          
     84          /**************************************************************************//*!
     85           *
     86           * @name  USB_Class_HID_ServiceIn
     87           *
     88           * @brief The funtion is a callback function of HID endpoint
     89           *
     90           * @param event : Pointer to USB Event Structure
     91           *
     92           * @return None
     93           *
     94           ******************************************************************************
     95           * This function is called from lower layer when data is transfer is completed
     96           * on HID endpoint (non control endpoint)
     97           *****************************************************************************/
     98          static void USB_Class_HID_ServiceIn
     99          (
    100            usbDeviceEvent_t * pEvent /* [IN] Pointer to USB Event Structure */
    101          )
    102          {
    103            pfUsbToAppEventHandler_t hidClassCallback;
    104            hidClassCallback = gpaUsbClassDescriptor[pEvent->controllerId]->pfUsbToAppEventHandler;
    105            if(hidClassCallback != NULL)
    106            {
    107              /* notify the app of the send complete */
    108              usbMsg_t usbMsg;
    109              usbMsg.controllerId = pEvent->controllerId;
    110              if(pEvent->errors != 0)
    111              {
    112                usbMsg.eventType = gUsbToAppEvent_Error_c;
    113                usbMsg.eventParam.errorEvent.errors = pEvent->errors;
    114              }
    115              else if(pEvent->shortSend)
    116              {
    117                usbMsg.eventType = gUsbToAppEvent_ShortSendComplete_c;
    118                usbMsg.eventParam.shortSendCompleteEvent.epNum = pEvent->epNum;
    119                usbMsg.eventParam.shortSendCompleteEvent.pBuffer = pEvent->pBuffer;
    120                usbMsg.eventParam.shortSendCompleteEvent.len = pEvent->len;
    121              }
    122              else
    123              {
    124                usbMsg.eventType = gUsbToAppEvent_SendComplete_c;
    125                usbMsg.eventParam.sendCompleteEvent.epNum = pEvent->epNum;
    126                usbMsg.eventParam.sendCompleteEvent.pBuffer = pEvent->pBuffer;
    127                usbMsg.eventParam.sendCompleteEvent.len = pEvent->len;
    128              }
    129              USB_IsrEvent(&usbMsg);
    130            }
    131          }
    132          
    133          /**************************************************************************//*!
    134           *
    135           * @name  USB_Class_HID_ServiceOut
    136           *
    137           * @brief The funtion is a callback function of HID endpoint
    138           *
    139           * @param event : Pointer to USB Event Structure
    140           *
    141           * @return None
    142           *
    143           ******************************************************************************
    144           * This function is called from lower layer when data is transfer is completed
    145           * on HID endpoint (non control endpoint)
    146           *****************************************************************************/
    147          static void USB_Class_HID_ServiceOut
    148          (
    149            usbDeviceEvent_t * pEvent /* [IN] Pointer to USB Event Structure */
    150          )
    151          {
    152            pfUsbToAppEventHandler_t hidClassCallback;
    153            hidClassCallback = gpaUsbClassDescriptor[pEvent->controllerId]->pfUsbToAppEventHandler;
    154            if(hidClassCallback != NULL)
    155            {
    156              /* notify the app of the send complete */
    157              usbMsg_t usbMsg;
    158              usbMsg.controllerId = pEvent->controllerId;
    159              if(pEvent->errors != 0)
    160              {
    161                usbMsg.eventType = gUsbToAppEvent_Error_c;
    162                usbMsg.eventParam.errorEvent.errors = pEvent->errors;
    163              }
    164              else
    165              {
    166                usbMsg.eventType = gUsbToAppEvent_DataReceived_c;
    167                usbMsg.eventParam.dataReceivedEvent.epNum = pEvent->epNum;
    168                usbMsg.eventParam.dataReceivedEvent.pBuffer = pEvent->pBuffer;
    169                usbMsg.eventParam.dataReceivedEvent.len = pEvent->len;
    170              }
    171              USB_IsrEvent(&usbMsg);
    172            }
    173          }
    174          
    175          /**************************************************************************//*!
    176           *
    177           * @name  USB_Class_HID_Event
    178           *
    179           * @brief The funtion initializes HID endpoint
    180           *
    181           * @param controller_ID     : Controller ID
    182           * @param event             : Event Type
    183           * @param val               : Pointer to configuration Value
    184           *
    185           * @return None
    186           *
    187           ******************************************************************************
    188           * The funtion initializes the HID endpoints when Enumeration complete event is
    189           * received
    190           *****************************************************************************/
    191          static void USB_Class_HID_Event
    192          (
    193            uint8_t controllerId,   /* [IN] Controller ID */
    194            gUsbToAppEvent_t event,           /* [IN] Event Type */
    195            void* pVal               /* [IN] Pointer to configuration Value */
    196          )
    197          {
    198            pfUsbToAppEventHandler_t hidClassCallback;
    199            uint8_t index;
    200          
    201            if(event == gUsbToAppEvent_EnumComplete_c)
    202            {
    203              usbEpStruct_t* pHidNCEpDesc = gpaUsbClassDescriptor[controllerId]->usbNonControlEpDescriptor;    
    204              uint8_t count = gpaUsbClassDescriptor[controllerId]->numNonControlEp;
    205          		index = count;
    206          		while(index > 0) 
    207          		{ 
    208          		  index--;  
    209          			(void)USB_DeviceDeinitEndpoint(controllerId,pHidNCEpDesc[index].number, pHidNCEpDesc[index].direction);
    210          		}
    211          		  
    212              while( index < count )
    213              {
    214                usbEpStruct_t* pEpStruct = pHidNCEpDesc + index;
    215                (void)USB_DeviceInitEndpoint(controllerId, pEpStruct, TRUE);
    216                // register callback service for the endpoint 
    217                if(pEpStruct->direction == gUsbEpDirection_In_c) 
    218                {
    219                  (void)USB_DeviceRegisterService(controllerId,(uint8_t)(gUsbService_Ep0_d+pEpStruct->number),USB_Class_HID_ServiceIn);  
    220                } 
    221                else
    222                {
    223                  (void)USB_DeviceRegisterService(controllerId,(uint8_t)(gUsbService_Ep0_d+pEpStruct->number),USB_Class_HID_ServiceOut);
    224                }
    225                // set the EndPoint Status as Idle in the device layer 
    226                (void)USB_DeviceSetStatus(controllerId,
    227                      (uint8_t)(gUsbComponentStatus_Endpoint_d | pEpStruct->number |(pEpStruct->direction << gUsbComponent_DirectionShift_d)),
    228                      gUsbStatus_Idle_d);
    229                index++;
    230              }
    231          
    232            }//(event == gUsbToAppEvent_EnumComplete_c)
    233            
    234            hidClassCallback = gpaUsbClassDescriptor[controllerId]->pfUsbToAppEventHandler;
    235            if(hidClassCallback != NULL)
    236            {
    237              USB_IsrEvent((usbMsg_t*) pVal);    
    238            }
    239          }
    240          
    241          /**************************************************************************//*!
    242           *
    243           * @name  USB_Other_Requests
    244           *
    245           * @brief   The funtion provides flexibilty to add class and vendor specific
    246           *              requests
    247           *
    248           * @param controller_ID     : Controller ID
    249           * @param setup_packet      : Setup packet received
    250           * @param data              : Data to be send back
    251           * @param size              : Size to be returned
    252           *
    253           * @return status:
    254           *                        gUsbErr_NoError_c        : When Successfull
    255           *                        Others        : When Error
    256           *
    257           ******************************************************************************
    258           * Handles HID Class requests and forwards vendor specific request to the
    259           * application
    260           *****************************************************************************/
    261          static uint8_t USB_HID_OtherRequests
    262          (
    263            uint8_t controllerId,               /* [IN] Controller ID */
    264            usbSetupPacket_t * pSetupPacket,    /*[IN] Setup packet received */
    265            uint8_t* *pData,                   /* [OUT] Data to be send back */
    266            usbPacketSize_t *pSize               /* [OUT] Size to be returned*/
    267          )
    268          {
    269            uint8_t status = gUsbErr_InvalidReqType_c;
    270            if((pSetupPacket->requestType & gUsbRequestClassMask_d) == gUsbRequestClass_Class_d)
    271            {
    272              pfClassSpecificReqHandler_t pfClassSpecificReqAppHandler ;
    273              pfClassSpecificReqAppHandler =  gpaUsbClassDescriptor[controllerId]->pfClassSpecificReqHandler;
    274              if(pfClassSpecificReqAppHandler != NULL)
    275              {
    276                /* handle callback if the application has supplied it  */
    277                *pSize = (usbPacketSize_t)(pSetupPacket->length + gUsbSetupPacketSize_d); 
    278                *pData = ((uint8_t*)pSetupPacket);
    279                 status = pfClassSpecificReqAppHandler(controllerId,pSetupPacket->request,/* request type */
    280                          pSetupPacket->value,
    281                          pData,/* pointer to the data */
    282                          pSize);/* size of the transfer */
    283              }
    284            }
    285            else if((pSetupPacket->requestType & gUsbRequestClassMask_d) == gUsbRequestClass_Vendor_d)
    286            {
    287              /* vendor specific request  */
    288              pfusbReqHandler_t       pfVendorReqCallback;
    289              pfVendorReqCallback =  gpaUsbClassDescriptor[controllerId]->pfVendorReqHandler;
    290              if(pfVendorReqCallback != NULL)
    291              {
    292                status = pfVendorReqCallback(controllerId, pSetupPacket,pData, pSize);
    293              }
    294            }
    295            return status;
    296          }
    297          
    298          /*****************************************************************************
    299           * Global Functions
    300           *****************************************************************************/
    301          
    302          /**************************************************************************//*!
    303           *
    304           * @name  USB_Class_HID_Init
    305           *
    306           * @brief   The funtion initializes the Device and Controller layer
    307           *
    308           * @param   controller_ID               : Controller ID
    309           * @param   hid_class_callback          : HID Class Callback
    310           * @param   vendor_req_callback         : Vendor Request Callback
    311           * @param   param_callback              : Class requests Callback
    312           *
    313           * @return status:
    314           *                        gUsbErr_NoError_c        : When Successfull
    315           *                        Others        : When Error
    316           *
    317           ******************************************************************************
    318           *This function initializes the HID Class layer and layers it is dependent on
    319           *****************************************************************************/
    320          uint8_t USB_Class_HID_Init 
    321          (
    322            uint8_t    controllerId                /* [IN] Controller ID */
    323          )
    324          {
    325            uint8_t status;
    326            uint8_t count = gpaUsbClassDescriptor[controllerId]->numNonControlEp;
    327            /* Initialize the device layer*/
    328            status = USB_DeviceInit(controllerId,count + 1);
    329            if(status == gUsbErr_NoError_c)
    330            {
    331              /* Initialize the generic class functions */
    332              status = USB_ClassInit(controllerId,USB_Class_HID_Event,USB_HID_OtherRequests);
    333            }
    334            return status;
    335          }
    336          
    337          /**************************************************************************//*!
    338           *
    339           * @name  USB_Class_HID_DeInit
    340           *
    341           * @brief   The funtion de-initializes the Device and Controller layer
    342           *
    343           * @param   controller_ID               : Controller ID
    344           *
    345           * @return status:
    346           *                        gUsbErr_NoError_c        : When Successfull
    347           *                        Others        : When Error
    348           *
    349           ******************************************************************************
    350           *This function de-initializes the HID Class layer
    351           *****************************************************************************/
    352          uint8_t USB_Class_HID_DeInit 
    353          (
    354            uint8_t controllerId              /* [IN] Controller ID */
    355          ) 
    356          {
    357            uint8_t status;
    358            /* Call common class deinit function */
    359            status = USB_ClassDeInit(controllerId);
    360            return status;
    361          }
    362          
    363          #endif


 

 


Errors: none
Warnings: none
