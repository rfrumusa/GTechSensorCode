///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM       23/Mar/2018  14:45:44
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code - Copy\Shanit Origional Code\Connectivity
//        Test\Application\Source\main.c
//    Command line =  
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code - Copy\Shanit Origional Code\Connectivity
//        Test\Application\Source\main.c" -D IAR --preprocess
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code - Copy\Shanit Origional Code\Connectivity Test\Debug\List\" -lC
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code - Copy\Shanit Origional Code\Connectivity Test\Debug\List\" -lB
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code - Copy\Shanit Origional Code\Connectivity Test\Debug\List\"
//        --diag_suppress Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code - Copy\Shanit Origional Code\Connectivity Test\Debug\Obj\"
//        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
//        --no_clustering --no_scheduling --debug --endian=little
//        --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program Files
//        (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\rfrum\OneDrive\2018
//        Spring Semester\Senior Design\Sensor Code - Copy\Shanit Origional
//        Code\Connectivity Test\PLM\Configure\" -I
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code - Copy\Shanit Origional Code\Connectivity Test\PLM\Environment\"
//        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code - Copy\Shanit Origional Code\Connectivity Test\PLM\Interface\"
//        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code - Copy\Shanit Origional Code\Connectivity Test\Generic
//        Services\Interface\" -I "C:\Users\rfrum\OneDrive\2018 Spring
//        Semester\Senior Design\Sensor Code - Copy\Shanit Origional
//        Code\Connectivity Test\PLM\Source\Uart\" -I
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code - Copy\Shanit Origional Code\Connectivity Test\PLM\Source\USB\"
//        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code - Copy\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\APP\" -I "C:\Users\rfrum\OneDrive\2018 Spring
//        Semester\Senior Design\Sensor Code - Copy\Shanit Origional
//        Code\Connectivity Test\PLM\Source\USB\APP\CDC\" -I
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code - Copy\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\APP\Descriptor\" -I "C:\Users\rfrum\OneDrive\2018
//        Spring Semester\Senior Design\Sensor Code - Copy\Shanit Origional
//        Code\Connectivity Test\PLM\Source\USB\Class\" -I
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code - Copy\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\Common\" -I "C:\Users\rfrum\OneDrive\2018 Spring
//        Semester\Senior Design\Sensor Code - Copy\Shanit Origional
//        Code\Connectivity Test\PLM\Source\USB\Driver\" -I
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code - Copy\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\"
//        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code - Copy\Shanit Origional Code\Connectivity
//        Test\PLM\Source\Radio\MC1324x\PHY\" -I "C:\Users\rfrum\OneDrive\2018
//        Spring Semester\Senior Design\Sensor Code - Copy\Shanit Origional
//        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code - Copy\Shanit Origional Code\Connectivity Test\PLM\Source\Sys
//        Common\" -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior
//        Design\Sensor Code - Copy\Shanit Origional Code\Connectivity
//        Test\SMAC\Source\" -I "C:\Users\rfrum\OneDrive\2018 Spring
//        Semester\Senior Design\Sensor Code - Copy\Shanit Origional
//        Code\Connectivity Test\SMAC\Interface\" -I
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code - Copy\Shanit Origional Code\Connectivity Test\SMAC\Configure\"
//        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code - Copy\Shanit Origional Code\Connectivity
//        Test\Application\Source\" -I "C:\Users\rfrum\OneDrive\2018 Spring
//        Semester\Senior Design\Sensor Code - Copy\Shanit Origional
//        Code\Connectivity Test\Application\Configure\" -I
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code - Copy\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\"
//        -I "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior
//        Design\Sensor Code\Shanit Origional Code\Connectivity
//        Test\PLM\Source\NVM\" -I "C:\Users\Robert\SkyDrive\2018 Spring
//        Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity
//        Test\PLM\Source\ADC\" -I "C:\Users\rfrum\OneDrive\2018 Spring
//        Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity
//        Test\PLM\Source\ADC\" -On
//    List file    =  
//        C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code - Copy\Shanit Origional Code\Connectivity Test\Debug\List\main.s
//
///////////////////////////////////////////////////////////////////////////////

        #define SHT_PROGBITS 0x1

        EXTERN ADCInit
        EXTERN CommUtil_Print
        EXTERN ConversionAComplete
        EXTERN GetConversionValue
        EXTERN KeyboardInit
        EXTERN LED_Init
        EXTERN MC1324xDrv_SPIInit
        EXTERN MCPSDataRequest
        EXTERN MLMELinkQuality
        EXTERN MLMEPAOutputAdjust
        EXTERN MLMERXEnableRequest
        EXTERN MLMERadioInit
        EXTERN MLMESetChannelRequest
        EXTERN MLMESetPromiscuousMode
        EXTERN MLMEXtalAdjust
        EXTERN MM_Init
        EXTERN MemoryCpy
        EXTERN NVIC_DisableIRQ
        EXTERN NVIC_EnableIRQ
        EXTERN NVIC_SetPriority
        EXTERN NV_FlashEraseSector
        EXTERN NV_FlashInit
        EXTERN NV_FlashProgramLongword
        EXTERN NV_FlashProgramUnalignedLongword
        EXTERN NV_FlashRead
        EXTERN PrintWordOnDecimalFormatBlocking
        EXTERN StartBattConversion
        EXTERN StartTempConversion
        EXTERN StartXConversion
        EXTERN StartYConversion
        EXTERN StartZConversion
        EXTERN TMR_Init
        EXTERN Uart1_GetByteFromRxBuffer
        EXTERN Uart1_SetBaud
        EXTERN Uart1_SetRxCallBack
        EXTERN Uart_ModuleInit
        EXTERN __aeabi_memcpy4
        EXTERN maMacHeap
        EXTERN maMmPools
        EXTERN memcmp
        EXTERN poolInfo
        EXTERN sprintf

        PUBLIC AXIS
        PUBLIC ChangeOptions
        PUBLIC ChooseBestChannel
        PUBLIC CommRxCallback
        PUBLIC CommTxCallback
        PUBLIC CopyBinaryPacketToSMAC
        PUBLIC CopyOptPacketToSMAC
        PUBLIC CopyOptionsFromRecvPacket
        PUBLIC CopyPngPacketToSMAC
        PUBLIC FlashSaveOptions
        PUBLIC GetDeviceData
        PUBLIC GetFactoryOptions
        PUBLIC GetLinkQdBm
        PUBLIC GetRandomNibble
        PUBLIC GlobalDataInit
        PUBLIC INIT_PIT
        PUBLIC InitAccelControlls
        PUBLIC InitPacket
        PUBLIC InitSmac
        PUBLIC MCPSDataConfirm
        PUBLIC MCPSDataIndication
        PUBLIC MLMEResetIndication
        PUBLIC MLMEScanConfirm
        PUBLIC MLMEWakeConfirm
        PUBLIC OptSwapEndianness
        PUBLIC PIT_ISR
        PUBLIC PIT_ITTERATIONS
        PUBLIC PngSwapEndianness
        PUBLIC PrintPacketID
        PUBLIC ReceivePacket
        PUBLIC SendASCIIPacket
        PUBLIC SendBinaryPacket
        PUBLIC SendCurrentOptions
        PUBLIC ShortCutsParser
        PUBLIC SndSwapEndianness
        PUBLIC TempSumx
        PUBLIC TempSumy
        PUBLIC TempSumz
        PUBLIC ValidateOptions
        PUBLIC appState
        PUBLIC au8ScanResults
        PUBLIC bCommTxDone
        PUBLIC bRxDone
        PUBLIC bScanDone
        PUBLIC bTxDone
        PUBLIC bestChannel
        PUBLIC cTxRxState
        PUBLIC connState
        PUBLIC contTestRunning
        PUBLIC eRState
        PUBLIC evDataFromCOMM
        PUBLIC evTestParameters
        PUBLIC gFlashDeadBeef
        PUBLIC gFlashOptions
        PUBLIC gIsAck
        PUBLIC gIsMyAck
        PUBLIC gOpt
        PUBLIC gOptions
        PUBLIC gPng
        PUBLIC gRawSnd
        PUBLIC gRxTimeout
        PUBLIC g_DEAD_BEEF
        PUBLIC getRandomNumberInRange
        PUBLIC gu8CommData
        PUBLIC main
        PUBLIC oDRState
        PUBLIC oIRState
        PUBLIC perRxState
        PUBLIC perTxState
        PUBLIC prevOpMode
        PUBLIC rDRState
        PUBLIC rIRState
        PUBLIC rangeRxState
        PUBLIC rangeTxState
        PUBLIC rxTestIndex
        PUBLIC sensorID
        PUBLIC sentPackets
        PUBLIC settingsAddress
        PUBLIC shortCutsEnabled
        PUBLIC testChannel
        PUBLIC testOpMode
        PUBLIC testPayloadLen
        PUBLIC testPower
        PUBLIC testTrimmValue
        PUBLIC txTestIndex

// C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor Code - Copy\Shanit Origional Code\Connectivity Test\Application\Source\main.c
//    1 /*****************************************************************************
//    2 * Connectivity test demo main file.
//    3 * 
//    4 * Copyright (c) 2012, Freescale, Inc. All rights reserved.
//    5 *
//    6 * 
//    7 * No part of this document must be reproduced in any form - including copied,
//    8 * transcribed, printed or by any electronic means - without specific written
//    9 * permission from Freescale Semiconductor.
//   10 *
//   11 *  The Connectivity Test Demo  is  mainly  used  to perform radio performance 
//   12 *  test in hardware for wireless implementations. It allows users to exercise 
//   13 *  all the radio functionality and to get results for some important wireless 
//   14 *  tests as Packet Error Rate and Range test.
//   15 *  
//   16 *  The main functions provided by Connectivity test are:
//   17 *  - Perform Range test.
//   18 *  - Perform Packet Error Rate test.
//   19 *  - Manage radio parameters as Channel, Power and Crystal Trim.
//   20 *  - Perform Radio Tests as Continuous Modulated TX, Continuous PRBS9 packets 
//   21 *    Tx, Un-modulated TX, Continuous Rx and Channel energy Detect.
//   22 *  - Manage to read and write radio registers by address.
//   23 *
//   24 *****************************************************************************/
//   25 
//   26 #include "ApplicationConf.h"             /*Defines the Application default parameters*/
//   27 #include "SMAC.h"
//   28 #include <stdio.h>
//   29 #include <stdlib.h>
//   30 #include <string.h>
//   31 
//   32 /************************************************************************************
//   33 *************************************************************************************
//   34 * Private prototypes 
//   35 *************************************************************************************
//   36 ************************************************************************************/
//   37 static void InitProject(void);
//   38 void InitSmac(void);
//   39 static void PrintTestParameters(bool_t bEraseLine);
//   40 static void SerialUIStateMachine(void);
//   41 static bool_t SerialContinuousTxRxTest(void);
//   42 static bool_t PacketErrorRateTx(void);
//   43 static bool_t PacketErrorRateRx(void);
//   44 static void SetRadioRxOnTimeOut15ms(void);
//   45 static void SetRadioRxOnNoTimeOut(void);
//   46 static void PrintPerRxFinalLine(uint16_t u16Received, uint16_t u16Total);
//   47 static bool_t RangeTx(void);
//   48 static bool_t RangeRx(void);
//   49 
//   50 static bool_t EditRegisters(void);
//   51 static bool_t OverrideDirectRegisters(void);
//   52 static bool_t OverrideIndirectRegisters(void);
//   53 static bool_t ReadDirectRegisters(void);
//   54 static bool_t ReadIndirectRegisters(void);
//   55 
//   56 void MLMEScanConfirm(channels_t ClearestChann);
//   57 void MLMEResetIndication(void);
//   58 void MLMEWakeConfirm(void);
//   59 void CommRxCallback();
//   60 void ShortCutsParser(uint8_t u8CommData);
//   61 void CommTxCallback(void);
//   62 void MCPSDataConfirm(txStatus_t TransmissionResult);
//   63 void MCPSDataIndication(rxPacket_t *gsRxPacket);
//   64 void GlobalDataInit(void);
//   65 /* Place your callbacks prototypes declarations here */
//   66 void InitPacket();
//   67 smacErrors_t SendASCIIPacket();
//   68 smacErrors_t SendBinaryPacket();
//   69 void ReceivePacket();
//   70 void PrintPacketID(uint16_t packetID);
//   71 void CopyBinaryPacketToSMAC();
//   72 void SndSwapEndianness();
//   73 void PngSwapEndianness();
//   74 void OptSwapEndianness(tOptions* opt);
//   75 void GetFactoryOptions(tOptions *pOptions);
//   76 void FlashSaveOptions();
//   77 void ChangeOptions(tOptions* pOptions);
//   78 int ValidateOptions(tOptions *pOptions);
//   79 smacErrors_t SendCurrentOptions();
//   80 void CopyOptPacketToSMAC();
//   81 void CopyOptionsFromRecvPacket(tOptions* pOptions);
//   82 void CopyPngPacketToSMAC();
//   83 uint8_t ChooseBestChannel();
//   84 uint8_t GetRandomNibble();
//   85 int8_t GetLinkQdBm();
//   86 /************************************************************************************
//   87 *************************************************************************************
//   88 * Module Constants
//   89 *************************************************************************************
//   90 ************************************************************************************/
//   91 /*initilize the functions to turn on and off the power to the Accel Module*/
//   92 #define AccellPowerOn()         (gLED_PortDataSetReg_c |= gAccelPower);
//   93 #define AccellEnableOn()         (gLED_PortDataSetReg_c |= gAccelEnable);
//   94 
//   95 /*initilize the functions that will turn on the power to teh accell module */
//   96 #define AccellPowerOff()        (gLED_PortDataClearReg_c |= gAccelPower);
//   97 #define AccellEnableOff()          (gLED_PortDataClearReg_c |= gAccelEnable);
//   98 
//   99 /************************************************************************************
//  100 *************************************************************************************
//  101 * Public memory declarations
//  102 *************************************************************************************
//  103 ************************************************************************************/
//  104 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  105 static uint8_t gau8RxDataBuffer[130]; 
gau8RxDataBuffer:
        DS8 132

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  106 static uint8_t gau8TxDataBuffer[128]; 
gau8TxDataBuffer:
        DS8 128
//  107 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  108 static txPacket_t * gAppTxPacket;
gAppTxPacket:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  109 static rxPacket_t * gAppRxPacket;
gAppRxPacket:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  110 static tSnd        gSnd;
gSnd:
        DS8 72

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  111 tOptions    gOptions;
gOptions:
        DS8 24

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  112 tOpt        gOpt;
gOpt:
        DS8 32

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  113 tPng        gPng;
gPng:
        DS8 8

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  114 tRawSnd     gRawSnd;      
gRawSnd:
        DS8 96
//  115 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  116 volatile int8_t appState;
appState:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  117 uint8_t       gIsAck;
gIsAck:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  118 uint8_t       gIsMyAck;
gIsMyAck:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  119 uint32_t      gRxTimeout;
gRxTimeout:
        DS8 4

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
?_0:
        DATA
        DC8 "\014\015\012 Running PER Tx, Sending "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
?_1:
        DATA
        DC8 " Packets"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
?_2:
        DATA
        DC8 53H, 4EH, 44H, 9, 25H, 75H, 9, 25H
        DC8 75H, 9, 25H, 75H, 9, 25H, 75H, 9
        DC8 25H, 75H, 9, 25H, 75H, 9, 25H, 75H
        DC8 9, 25H, 75H, 9, 25H, 75H, 9, 25H
        DC8 75H, 9, 25H, 75H, 9, 25H, 75H, 9
        DC8 25H, 75H, 9, 25H, 64H, 9, 25H, 75H
        DC8 9, 25H, 64H, 9, 25H, 75H, 9, 25H
        DC8 75H, 9, 25H, 75H, 9, 25H, 75H, 9
        DC8 25H, 75H, 0DH, 0AH, 0
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
?_3:
        DATA
        DC32 1073872896, 0, 524288, 0, 0, 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
?_4:
        DATA
        DC32 1073872896, 0, 524288, 0, 0, 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
//  120 const uint32_t g_DEAD_BEEF = 0xDEADBEEF;  // unlikely-to-exist bit pattern
g_DEAD_BEEF:
        DATA
        DC32 3735928559

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
//  121 const uint32_t settingsAddress = 0x0007F800;
settingsAddress:
        DATA
        DC32 522240
//  122 //uint32_t      gFlashDeadBeef  @0x0007F800;

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  123 uint32_t      gFlashDeadBeef;
gFlashDeadBeef:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  124 tOptions    gFlashOptions;    // Note: on same FLASH memory page as "gFlashDeadBeef"
gFlashOptions:
        DS8 24

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
//  125 uint16_t sensorID;
sensorID:
        DS8 2
//  126 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  127 bool_t bTxDone;
bTxDone:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  128 bool_t bRxDone;
bRxDone:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  129 bool_t bScanDone;
bScanDone:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  130 channels_t bestChannel;
bestChannel:
        DS8 1
//  131 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  132 bool_t  bCommTxDone;  
bCommTxDone:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  133 uint8_t gu8CommData;
gu8CommData:
        DS8 1
//  134 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  135 operationModes_t testOpMode;
testOpMode:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  136 operationModes_t prevOpMode;
prevOpMode:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  137 channels_t       testChannel;
testChannel:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  138 uint8_t          testPower;
testPower:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  139 uint8_t          testTrimmValue;
testTrimmValue:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  140 uint8_t          testPayloadLen;
testPayloadLen:
        DS8 1
//  141 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  142 smacTestMode_t contTestRunning;
contTestRunning:
        DS8 1
//  143 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  144 bool_t evDataFromCOMM;
evDataFromCOMM:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  145 bool_t evTestParameters;
evTestParameters:
        DS8 1
//  146 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  147 bool_t shortCutsEnabled;
shortCutsEnabled:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  148 ConnectivityStates_t       connState;
connState:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  149 ContinuousTxRxTestStates_t cTxRxState;
cTxRxState:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  150 PerTxStates_t              perTxState;
perTxState:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  151 PerRxStates_t              perRxState;
perRxState:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  152 RangeTxStates_t            rangeTxState;
rangeTxState:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  153 RangeRxStates_t            rangeRxState;
rangeRxState:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  154 EditRegsStates_t    eRState; 
eRState:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  155 ODRStates_t         oDRState;
oDRState:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  156 OIRStates_t         oIRState;
oIRState:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  157 RDRStates_t         rDRState;
rDRState:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  158 RIRStates_t         rIRState;
rIRState:
        DS8 1
//  159 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  160 int     PIT_ITTERATIONS;
PIT_ITTERATIONS:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  161 int     AXIS ;
AXIS:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  162 uint32_t  TempSumx ;
TempSumx:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  163 uint32_t  TempSumy ;
TempSumy:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  164 uint32_t  TempSumz ;
TempSumz:
        DS8 4
//  165 
//  166 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  167 uint8_t au8ScanResults[16];
au8ScanResults:
        DS8 16
//  168 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  169 txTests_t txTestIndex;
txTestIndex:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  170 RxTests_t rxTestIndex;
rxTestIndex:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
//  171 uint16_t sentPackets;
sentPackets:
        DS8 2
//  172 #define MMCAU_TEST  FALSE    
//  173 
//  174 #if TRUE == MMCAU_TEST
//  175   #define AES192                    192
//  176   unsigned char key_expansion[60*4];
//  177   /*24 bytes key: "UltraMegaSecretPassword1"*/
//  178   unsigned char   key192[AES192/8] = { 0x55, 0x6c, 0x74, 0x72, 0x61, 0x4d, 0x65, 0x67, 
//  179                                        0x61, 0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x50, 
//  180 	                               0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x31 };
//  181 #endif
//  182 
//  183 
//  184 /************************************************************************************
//  185 *************************************************************************************
//  186 * Main application functions
//  187 *************************************************************************************
//  188 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  189 void main(void)
//  190 {
main:
        PUSH     {R4-R11,LR}
        SUB      SP,SP,#+28
//  191   int XDiff;
//  192   int YDiff;
//  193   int ZDiff;
//  194   
//  195   int threshHold = 120;
        MOVS     R7,#+120
//  196   sensorID=6543; 
        MOVW     R0,#+6543
        LDR.W    R1,??DataTable15
        STRH     R0,[R1, #+0]
//  197   TempSumx = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable15_1
        STR      R0,[R1, #+0]
//  198   TempSumy = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable15_2
        STR      R0,[R1, #+0]
//  199   TempSumz = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable15_3
        STR      R0,[R1, #+0]
//  200   AXIS = 0; 
        MOVS     R0,#+0
        LDR.W    R1,??DataTable15_4
        STR      R0,[R1, #+0]
//  201   PIT_ITTERATIONS =0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable15_5
        STR      R0,[R1, #+0]
//  202   
//  203   InitProject(); 
        BL       InitProject
//  204   /* SMAC Initialization */
//  205   InitSmac(); 
        BL       InitSmac
//  206   
//  207   //initalize the accelerometter
//  208   InitAccelControlls();
        BL       InitAccelControlls
//  209   ADCInit();
        BL       ADCInit
//  210   
//  211  //right now this should be equal to a pit running every .000125 seconds so it will run 8000 itterations in 1 second
//  212   INIT_PIT((uint32_t) 5999);        //((50,000,000)/(1/TIME)) -1 = TimeForInitFucntion Here Time is equal to  intot initthis can be changed for different sample times if the number is increased the sample time is increased
        MOVW     R0,#+5999
        BL       INIT_PIT
//  213   /*this time is for 8000Hz */
//  214   
//  215   //blink the leds
//  216   RedStatLedOn();
        LDR.W    R0,??DataTable15_6  ;; 0x400ff0c8
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x10
        LDR.W    R1,??DataTable15_6  ;; 0x400ff0c8
        STR      R0,[R1, #+0]
//  217   GreenStatLedOn();
        LDR.W    R0,??DataTable15_6  ;; 0x400ff0c8
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x8
        LDR.W    R1,??DataTable15_6  ;; 0x400ff0c8
        STR      R0,[R1, #+0]
//  218   
//  219 #if defined(gCDCInterface_d)    //Wait for user to open the VirtualCom
//  220   while(!Comm_Open());
//  221 #endif
//  222   /*Prints the Welcome screens in the COMM*/  
//  223   //PrintMenu(cu8FreescaleLogo, gDefaultCommPort_c);
//  224   
//  225   #if TRUE == MMCAU_TEST
//  226    cau_aes_set_key(key192, AES192, key_expansion);
//  227   #endif
//  228   
//  229   /*Waits until de user selects press Enter*/    
//  230  // while(!(evDataFromCOMM && ('\r' == gu8CommData))); 
//  231   connState = gConnIdleState_c; 
        MOVS     R0,#+1
        LDR.W    R1,??DataTable15_7
        STRB     R0,[R1, #+0]
//  232   int32_t cin[30];
//  233   int in;
//  234   
//  235   gSnd.channel=gChannel11_c;
        MOVS     R0,#+11
        LDR.W    R1,??DataTable16
        STRB     R0,[R1, #+67]
//  236   uint16_t flashCount=0;
        MOVS     R8,#+0
//  237   (void)MLMESetChannelRequest(gSnd.channel);
        LDR.W    R0,??DataTable16
        LDRB     R0,[R0, #+67]
        BL       MLMESetChannelRequest
        MOV      R9,R0
//  238   (void)MLMEPAOutputAdjust(gMaxOutputPower_c);
        MOVS     R0,#+31
        BL       MLMEPAOutputAdjust
        MOV      R10,R0
//  239   (void)MLMEXtalAdjust(testTrimmValue);
        LDR.W    R0,??DataTable15_8
        LDRB     R0,[R0, #+0]
        BL       MLMEXtalAdjust
        MOV      R11,R0
//  240   //MLMESetPromiscuousMode(TRUE);
//  241   sentPackets=0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable15_9
        STRH     R0,[R1, #+0]
//  242 
//  243   (void)ChooseBestChannel();
        BL       ChooseBestChannel
//  244   appState=TRANSMIT_MODE;
        MOVS     R1,#+0
        LDR.W    R2,??DataTable15_10
        STRB     R1,[R2, #+0]
//  245   
//  246     RedStatLedOff();
        LDR.W    R1,??DataTable15_11  ;; 0x400ff0c4
        LDR      R1,[R1, #+0]
        ORRS     R1,R1,#0x10
        LDR.W    R2,??DataTable15_11  ;; 0x400ff0c4
        STR      R1,[R2, #+0]
//  247   GreenStatLedOff();
        LDR.W    R1,??DataTable15_11  ;; 0x400ff0c4
        LDR      R1,[R1, #+0]
        ORRS     R1,R1,#0x8
        LDR.W    R2,??DataTable15_11  ;; 0x400ff0c4
        STR      R1,[R2, #+0]
//  248   
//  249   PIT_ITTERATIONS =0;
        MOVS     R1,#+0
        LDR.W    R2,??DataTable15_5
        STR      R1,[R2, #+0]
//  250   
//  251   AccellEnableOn();
        LDR.W    R1,??DataTable15_11  ;; 0x400ff0c4
        LDR      R1,[R1, #+0]
        ORRS     R1,R1,#0x2
        LDR.W    R2,??DataTable15_11  ;; 0x400ff0c4
        STR      R1,[R2, #+0]
//  252   AccellPowerOn();
        LDR.W    R1,??DataTable15_11  ;; 0x400ff0c4
        LDR      R1,[R1, #+0]
        ORRS     R1,R1,#0x20
        LDR.W    R2,??DataTable15_11  ;; 0x400ff0c4
        STR      R1,[R2, #+0]
//  253   
//  254   
//  255   
//  256   for(;;){
//  257     
//  258    TempSumx = 0;
??main_0:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable15_1
        STR      R0,[R1, #+0]
//  259    TempSumy = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable15_2
        STR      R0,[R1, #+0]
//  260    TempSumz = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable15_3
        STR      R0,[R1, #+0]
//  261    gSnd.xmax =0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable16
        STRH     R0,[R1, #+10]
//  262    gSnd.ymax =0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable16
        STRH     R0,[R1, #+26]
//  263    gSnd.zmax =0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable16
        STRH     R0,[R1, #+42]
//  264    gSnd.xmin = 4000;
        MOV      R0,#+4000
        LDR.W    R1,??DataTable16
        STRH     R0,[R1, #+8]
//  265    gSnd.ymin = 4000;
        MOV      R0,#+4000
        LDR.W    R1,??DataTable16
        STRH     R0,[R1, #+24]
//  266    gSnd.zmin = 4000;
        MOV      R0,#+4000
        LDR.W    R1,??DataTable16
        STRH     R0,[R1, #+40]
//  267     
//  268     
//  269     uint16_t sleepTime = 1000*gOptions.u16SleepAfterAck;
        LDR.W    R0,??DataTable15_12
        LDRH     R0,[R0, #+22]
        MOV      R1,#+1000
        SMULBB   R9,R0,R1
//  270     
//  271      
//  272      // Prepare the usual stats SND packet
//  273      // get temp and vibration data, put in packet
//  274      GetDeviceData();
        BL       GetDeviceData
//  275     
//  276     
//  277     //delayMs(3000);
//  278     XDiff = gSnd.xmax - gSnd.xmin;
        LDR.W    R0,??DataTable16
        LDRH     R0,[R0, #+10]
        LDR.W    R1,??DataTable16
        LDRH     R1,[R1, #+8]
        SUBS     R0,R0,R1
        MOVS     R4,R0
//  279     YDiff = gSnd.ymax - gSnd.ymin;
        LDR.W    R0,??DataTable16
        LDRH     R0,[R0, #+26]
        LDR.W    R1,??DataTable16
        LDRH     R1,[R1, #+24]
        SUBS     R0,R0,R1
        MOVS     R5,R0
//  280     ZDiff = gSnd.zmax - gSnd.zmin;
        LDR.W    R0,??DataTable16
        LDRH     R0,[R0, #+42]
        LDR.W    R1,??DataTable16
        LDRH     R1,[R1, #+40]
        SUBS     R0,R0,R1
        MOVS     R6,R0
//  281     
//  282     
//  283     if( (XDiff > threshHold || XDiff < -threshHold) || (YDiff > threshHold || YDiff < -threshHold) || (ZDiff > threshHold || ZDiff < -threshHold))
        CMP      R7,R4
        BLT.N    ??main_1
        CMN      R4,R7
        BLT.N    ??main_1
        CMP      R7,R5
        BLT.N    ??main_1
        CMN      R5,R7
        BLT.N    ??main_1
        CMP      R7,R6
        BLT.N    ??main_1
        CMN      R6,R7
        BGE.N    ??main_2
//  284     {
//  285       sentPackets++;
??main_1:
        LDR.W    R0,??DataTable15_9
        LDRH     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR.W    R1,??DataTable15_9
        STRH     R0,[R1, #+0]
//  286       flashCount=0;
        MOVS     R0,#+0
        MOV      R8,R0
//  287       //LED_SetLed(LED2, gLedOn_c);
//  288       
//  289       smacErrors_t status=SendBinaryPacket();
        BL       SendBinaryPacket
        MOV      R10,R0
//  290       if(status==gErrorNoError_c){
        UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
        CMP      R10,#+0
        BNE.N    ??main_3
//  291         ReceivePacket();
        BL       ReceivePacket
//  292       }
//  293       while(--flashCount);
??main_3:
        SUBS     R8,R8,#+1
        UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
        CMP      R8,#+0
        BNE.N    ??main_3
//  294       
//  295       evDataFromCOMM=FALSE;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable15_13
        STRB     R0,[R1, #+0]
//  296       //PrintPacketID(sentPackets);
//  297       tOptions pOptions;
//  298       if(appState==RECEIVE_FINISHED && gIsAck) {
        LDR.W    R0,??DataTable15_10
        LDRSB    R0,[R0, #+0]
        CMP      R0,#+2
        BNE.N    ??main_2
        LDR.W    R0,??DataTable16_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??main_2
//  299         if(gAppRxPacket->u8DataLength>ACK_HEADER_SIZE){
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+0]
        LDRB     R0,[R0, #+2]
        CMP      R0,#+6
        BLT.N    ??main_2
//  300           if(gAppRxPacket->u8DataLength==ACK_OPT_SIZE){
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+0]
        LDRB     R0,[R0, #+2]
        CMP      R0,#+24
        BNE.N    ??main_4
//  301             CopyOptionsFromRecvPacket(&pOptions);
        ADD      R0,SP,#+0
        BL       CopyOptionsFromRecvPacket
//  302             
//  303             OptSwapEndianness(&pOptions);
        ADD      R0,SP,#+0
        BL       OptSwapEndianness
//  304             if (!ValidateOptions(&pOptions)) continue;
        ADD      R0,SP,#+0
        BL       ValidateOptions
        CMP      R0,#+0
        BNE.N    ??main_2
        B.N      ??main_0
//  305           }
//  306           else {
//  307             GetFactoryOptions(&pOptions);
??main_4:
        ADD      R0,SP,#+0
        BL       GetFactoryOptions
//  308           }
//  309           //ChangeOptions(&pOptions);
//  310         }
//  311         
//  312       }
//  313     }
//  314     /*this needs to be here to reset the packet ID every time*/
//  315     InitPacket(); 
??main_2:
        BL       InitPacket
        B.N      ??main_0
//  316     
//  317   }/* For(;;)*/
//  318   
//  319 }/*Main*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  320 int ValidateOptions(tOptions *pOptions){
ValidateOptions:
        MOVS     R1,R0
//  321   if((pOptions->u8RawSpinCount!=0) && (pOptions->u8RawSpinCount > 64 || pOptions->u8RawSpinCount < 5)) return 0;   // updated *** 06/08/11 *** (formerly "u8Reserved1")
        LDRB     R0,[R1, #+0]
        CMP      R0,#+0
        BEQ.N    ??ValidateOptions_0
        LDRB     R0,[R1, #+0]
        CMP      R0,#+65
        BGE.N    ??ValidateOptions_1
        LDRB     R0,[R1, #+0]
        CMP      R0,#+5
        BGE.N    ??ValidateOptions_0
??ValidateOptions_1:
        MOVS     R0,#+0
        B.N      ??ValidateOptions_2
//  322   if(pOptions->u16TimeoutsToKill > 3600 || pOptions->u16TimeoutsToKill < 1) return 0;
??ValidateOptions_0:
        LDRH     R0,[R1, #+2]
        CMP      R0,#+3600
        BGT.N    ??ValidateOptions_3
        LDRH     R0,[R1, #+2]
        CMP      R0,#+0
        BNE.N    ??ValidateOptions_4
??ValidateOptions_3:
        MOVS     R0,#+0
        B.N      ??ValidateOptions_2
//  323   if(pOptions->u16SampleSize != ACCEL_SAMPLE_SIZE) return 0;
??ValidateOptions_4:
        LDRH     R0,[R1, #+4]
        CMP      R0,#+8000
        BEQ.N    ??ValidateOptions_5
        MOVS     R0,#+0
        B.N      ??ValidateOptions_2
//  324   if(pOptions->bAsciiMode > 1) return 0;
??ValidateOptions_5:
        LDRB     R0,[R1, #+6]
        CMP      R0,#+2
        BLT.N    ??ValidateOptions_6
        MOVS     R0,#+0
        B.N      ??ValidateOptions_2
//  325   if(pOptions->bBlinkingLEDs > 1) return 0;
??ValidateOptions_6:
        LDRB     R0,[R1, #+7]
        CMP      R0,#+2
        BLT.N    ??ValidateOptions_7
        MOVS     R0,#+0
        B.N      ??ValidateOptions_2
//  326   if(pOptions->u8OutputPower != OUTPUT_POWER) return 0;
??ValidateOptions_7:
        LDRB     R0,[R1, #+8]
        CMP      R0,#+100
        BEQ.N    ??ValidateOptions_8
        MOVS     R0,#+0
        B.N      ??ValidateOptions_2
//  327   if(pOptions->u32PngTimeout != PNG_TIMEOUT) return 0;
??ValidateOptions_8:
        LDR      R0,[R1, #+12]
        MOVW     R2,#+33000
        CMP      R0,R2
        BEQ.N    ??ValidateOptions_9
        MOVS     R0,#+0
        B.N      ??ValidateOptions_2
//  328   if(pOptions->u32SndTimeout != SND_TIMEOUT) return 0;
??ValidateOptions_9:
        LDR      R0,[R1, #+16]
        LDR.W    R2,??DataTable18  ;; 0x28488
        CMP      R0,R2
        BEQ.N    ??ValidateOptions_10
        MOVS     R0,#+0
        B.N      ??ValidateOptions_2
//  329   if(pOptions->bLNAHighGainMode != 1) return 0; // i.e. Low Noise Amplifier - updated *** 10/26/10 *** (formerly "u8Reserved2")
??ValidateOptions_10:
        LDRB     R0,[R1, #+20]
        CMP      R0,#+1
        BEQ.N    ??ValidateOptions_11
        MOVS     R0,#+0
        B.N      ??ValidateOptions_2
//  330   if(pOptions->u16SleepAfterAck > 3000|| pOptions->u16SleepAfterAck < 3) return 0;
??ValidateOptions_11:
        LDRH     R0,[R1, #+22]
        MOVW     R2,#+3001
        CMP      R0,R2
        BGE.N    ??ValidateOptions_12
        LDRH     R0,[R1, #+22]
        CMP      R0,#+3
        BGE.N    ??ValidateOptions_13
??ValidateOptions_12:
        MOVS     R0,#+0
        B.N      ??ValidateOptions_2
//  331   return 1;
??ValidateOptions_13:
        MOVS     R0,#+1
??ValidateOptions_2:
        BX       LR               ;; return
//  332 }/*ValidateOptions*/
//  333 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  334 void ChangeOptions(tOptions* pOptions)
//  335 {
ChangeOptions:
        PUSH     {R4,LR}
        MOVS     R4,R0
//  336     
//  337   // Are the new options different from the old/current options?
//  338   if (memcmp(pOptions, &gOptions, sizeof(tOptions)) != 0)
        MOVS     R2,#+24
        LDR.W    R1,??DataTable15_12
        MOVS     R0,R4
        BL       memcmp
        CMP      R0,#+0
        BEQ.N    ??ChangeOptions_0
//  339     {
//  340 //        TRACE("\r\nConfiguration OPTIONS will be changed\r\n");
//  341         
//  342         // Save the new options
//  343         gOptions = *pOptions;
        LDR.W    R0,??DataTable15_12
        MOVS     R1,R4
        MOVS     R2,#+24
        BL       __aeabi_memcpy4
//  344         
//  345         // Save new options to FLASH memory
//  346         FlashSaveOptions();
        BL       FlashSaveOptions
//  347         
//  348         // Make sure all of the options changes will be in effect
//  349 //        RadioInitNew(); // added *** 10/27/10 ***
//  350 //        (void)MLMEMC13192PAOutputAdjust(gOptions.u8OutputPower);
//  351         gRxTimeout = gOptions.u32SndTimeout;    // usual timeout value, i.e., timeout for SND packets
        LDR.W    R0,??DataTable15_12
        LDR      R0,[R0, #+16]
        LDR.W    R1,??DataTable19
        STR      R0,[R1, #+0]
//  352         
//  353         // Updated *** 06/20/11 ***
//  354         // Whenever options change, flush the sending of raw data packets
//  355  /*
//  356         gRawSnd.rawSpinCount = gOptions.u8RawSpinCount;
//  357         gRawSnd.axis = 3;     // Note: 1 = X-axis, 2 = Y-axis, 3 = Z-axis
//  358         gRawSnd.blockNo = 16; // Note: raw data is sent in blocks numbered 1 thru 16 (0 means not ready)
//  359 */        
//  360     }
//  361     
//  362     // Inform pan coordinator of our new configuration options
//  363     SendCurrentOptions();
??ChangeOptions_0:
        BL       SendCurrentOptions
//  364 
//  365     return;
        POP      {R4,PC}          ;; return
//  366 }//ChangeOptions
//  367 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  368 smacErrors_t SendCurrentOptions(){
SendCurrentOptions:
        PUSH     {R7,LR}
//  369     
//  370     gOpt.options = gOptions;
        LDR.W    R0,??DataTable16_2
        LDR.W    R1,??DataTable15_12
        MOVS     R2,#+24
        BL       __aeabi_memcpy4
//  371     OptSwapEndianness(&gOpt.options);
        LDR.W    R0,??DataTable16_2
        BL       OptSwapEndianness
//  372     gOpt.hdr.u16SensorID = gOpt.hdr.u16SensorID << 8 | gOpt.hdr.u16SensorID>>8;
        LDR.W    R0,??DataTable18_1
        LDRH     R0,[R0, #+4]
        LDR.W    R1,??DataTable18_1
        LDRH     R1,[R1, #+4]
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        LSRS     R1,R1,#+8
        ORRS     R0,R1,R0, LSL #+8
        LDR.W    R1,??DataTable18_1
        STRH     R0,[R1, #+4]
//  373     
//  374     CopyOptPacketToSMAC();
        BL       CopyOptPacketToSMAC
//  375     // Get ready to send the configuration options SND packet
//  376  //   gAppTxPacket->u8DataLength = sizeof(gOpt);
//  377 //    gAppTxPacket->smacPdu.u8Data = (uint8_t*)&gOpt;
//  378     return MCPSDataRequest(gAppTxPacket); // transmit data
        LDR.W    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        BL       MCPSDataRequest
        POP      {R1,PC}          ;; return
//  379     
//  380     // Note: even though the pan coordinator may acknowledge this message,
//  381     // we don't need to wait for it, because the sensor data SND messages
//  382     // are sent much more frequently, so we'll ignore any ACK here.
//  383   
//  384     
//  385 }//SendCurrentOptions
//  386 
//  387 
//  388 
//  389 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  390 void InitAccelControlls(){
//  391  /*
//  392 Initilizes the GPIO's that controll the  power in the Accelerommeter.
//  393 This initilizes PTD1 and PTD 5 as GPIO's with output functionality and active low performance.
//  394 */
//  395         //enable the clock gating to the module.
//  396         gLED_ClkGatingReg_c |= gLED_ClkGatingBit_c; 
InitAccelControlls:
        LDR.W    R0,??DataTable16_3  ;; 0x40048038
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x1000
        LDR.W    R1,??DataTable16_3  ;; 0x40048038
        STR      R0,[R1, #+0]
//  397         //enable the conenctions, and enable the clock to the PTD output
//  398         gAccelEnableControlReg_c &= ~PORT_PCR_MUX_MASK;
        LDR.W    R0,??DataTable16_4  ;; 0x4004c004
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0x700
        LDR.W    R1,??DataTable16_4  ;; 0x4004c004
        STR      R0,[R1, #+0]
//  399         gAccelEnableControlReg_c |= PORT_PCR_MUX(gLED_PinCtrlAltFunc_c);
        LDR.W    R0,??DataTable16_4  ;; 0x4004c004
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x100
        LDR.W    R1,??DataTable16_4  ;; 0x4004c004
        STR      R0,[R1, #+0]
//  400         gAccelPowerControlReg_c &= ~PORT_PCR_MUX_MASK;
        LDR.W    R0,??DataTable16_5  ;; 0x4004c014
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0x700
        LDR.W    R1,??DataTable16_5  ;; 0x4004c014
        STR      R0,[R1, #+0]
//  401         gAccelPowerControlReg_c |= PORT_PCR_MUX(gLED_PinCtrlAltFunc_c);
        LDR.W    R0,??DataTable16_5  ;; 0x4004c014
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x100
        LDR.W    R1,??DataTable16_5  ;; 0x4004c014
        STR      R0,[R1, #+0]
//  402         
//  403         
//  404         /*Pins direction -> output */
//  405         gLED_PortDataDirReg_c |= (gAccelPower | gAccelEnable);
        LDR.W    R0,??DataTable16_6  ;; 0x400ff0d4
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x22
        LDR.W    R1,??DataTable16_6  ;; 0x400ff0d4
        STR      R0,[R1, #+0]
//  406         /*turn off all outputs */
//  407         gLED_PortDataOutReg_c |= (gAccelPower | gAccelEnable);
        LDR.W    R0,??DataTable19_2  ;; 0x400ff0c0
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x22
        LDR.W    R1,??DataTable19_2  ;; 0x400ff0c0
        STR      R0,[R1, #+0]
//  408   
//  409 }/*void InitAccelControlls()*/
        BX       LR               ;; return
//  410 
//  411 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  412 void GetDeviceData()
//  413 {
GetDeviceData:
        PUSH     {R3-R5,LR}
//  414   
//  415   int TempTempVal =0;
        MOVS     R4,#+0
//  416   int TempBat =0;
        MOVS     R5,#+0
//  417   //filteringCode  =0;
//  418   
//  419     /*for the regular data smapling we might want to make the change so that it will sample at the rate in gOptions.sampleRate
//  420       the filtering code below needs to run at 20Khz at all times though that will not change*/
//  421   
//  422     AXIS =1 ;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable15_4
        STR      R0,[R1, #+0]
//  423    /*first want to get the max average and other values at 8KHz and then teansition into 20KHz*/
//  424     INIT_PIT((uint32_t) 5999);        /*this is the 8K Hz*/
        MOVW     R0,#+5999
        BL       INIT_PIT
//  425     NVIC_EnableIRQ(48);
        MOVS     R0,#+48
        BL       NVIC_EnableIRQ
//  426     
//  427     
//  428     AXIS = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable15_4
        STR      R0,[R1, #+0]
//  429     PIT_ITTERATIONS =0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable15_5
        STR      R0,[R1, #+0]
//  430     
//  431     while(PIT_ITTERATIONS < ACCEL_SAMPLE_SIZE)
??GetDeviceData_0:
        LDR.W    R0,??DataTable15_5
        LDR      R0,[R0, #+0]
        CMP      R0,#+8000
        BLT.N    ??GetDeviceData_0
//  432     {
//  433       // X Y and Z to complete wait for the conversions to finish before continuing
//  434     }
//  435     AXIS =0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable15_4
        STR      R0,[R1, #+0]
//  436     gSnd.xmean = (uint16_t)((TempSumx + (ACCEL_SAMPLE_SIZE >>1))/ ACCEL_SAMPLE_SIZE);
        LDR.W    R0,??DataTable15_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+4000
        MOV      R1,#+8000
        UDIV     R0,R0,R1
        LDR.W    R1,??DataTable16
        STRH     R0,[R1, #+12]
//  437     
//  438     
//  439     gSnd.ymean = (uint16_t)((TempSumy + (ACCEL_SAMPLE_SIZE >>1))/ ACCEL_SAMPLE_SIZE);
        LDR.W    R0,??DataTable15_2
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+4000
        MOV      R1,#+8000
        UDIV     R0,R0,R1
        LDR.W    R1,??DataTable16
        STRH     R0,[R1, #+28]
//  440     
//  441     
//  442     gSnd.zmean = (uint16_t)((TempSumz + (ACCEL_SAMPLE_SIZE >>1))/ ACCEL_SAMPLE_SIZE);
        LDR.W    R0,??DataTable15_3
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+4000
        MOV      R1,#+8000
        UDIV     R0,R0,R1
        LDR.W    R1,??DataTable16
        STRH     R0,[R1, #+44]
//  443     
//  444    /*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  445     *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  446     *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  447     *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  448     *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  449     *
//  450     *This is where the filtering code needs to be enetered when we want to implement filtering again.
//  451     *
//  452     *
//  453     *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  454     *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  455     *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  456     *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  457     *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  458     *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  459     */
//  460     
//  461     /*stop the timer and finish the temp and battery conversion and then send the data that was packed*/
//  462     NVIC_DisableIRQ(48);
        MOVS     R0,#+48
        BL       NVIC_DisableIRQ
//  463       
//  464       
//  465     
//  466     StartTempConversion();
        BL       StartTempConversion
//  467     
//  468     while(ConversionAComplete()==0){
??GetDeviceData_1:
        BL       ConversionAComplete
        CMP      R0,#+0
        BEQ.N    ??GetDeviceData_1
//  469     }
//  470     TempTempVal = GetConversionValue();
        BL       GetConversionValue
        MOVS     R4,R0
//  471     gSnd.temperature = 373 - (int16_t)((uint32_t)(TempTempVal) * 37800/84909)  ;
        MOVW     R0,#+373
        MOVW     R1,#+37800
        MUL      R1,R1,R4
        LDR.W    R2,??DataTable17_1  ;; 0x14bad
        UDIV     R1,R1,R2
        SUBS     R0,R0,R1
        LDR.W    R1,??DataTable16
        STRH     R0,[R1, #+56]
//  472     
//  473     /*now that the conversions are finished measure the voltage over the battery using adc 7 */
//  474     StartBattConversion();
        BL       StartBattConversion
//  475     while(ConversionAComplete()==0){
??GetDeviceData_2:
        BL       ConversionAComplete
        CMP      R0,#+0
        BEQ.N    ??GetDeviceData_2
//  476     }
//  477     TempBat = GetConversionValue();
        BL       GetConversionValue
        MOVS     R5,R0
//  478     gSnd.battery_mV = (uint16_t)((uint32_t)(TempBat) * 4200 / 1023);
        MOVW     R0,#+4200
        MUL      R0,R0,R5
        MOVW     R1,#+1023
        UDIV     R0,R0,R1
        LDR.W    R1,??DataTable16
        STRH     R0,[R1, #+58]
//  479 
//  480     
//  481     
//  482     
//  483 }/*void GetDeviceData()*/
        POP      {R0,R4,R5,PC}    ;; return
//  484 
//  485 /*
//  486 
//  487 inits the pit timmer
//  488 */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  489 void INIT_PIT(uint32_t SampleSpeed)
//  490 {
INIT_PIT:
        PUSH     {R4,LR}
        MOVS     R4,R0
//  491   NVIC_DisableIRQ(48);
        MOVS     R0,#+48
        BL       NVIC_DisableIRQ
//  492   
//  493   //set bit 24 in scgc6
//  494   SIM_SCGC6 |= (uint32_t)(1<<23);
        LDR.W    R0,??DataTable17_2  ;; 0x4004803c
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x800000
        LDR.W    R1,??DataTable17_2  ;; 0x4004803c
        STR      R0,[R1, #+0]
//  495   
//  496   
//  497   PIT_MCR = (uint32_t)0x1;                  //enable the freexe bit and enable the clock for standard pit timer
        MOVS     R0,#+1
        LDR.W    R1,??DataTable17_3  ;; 0x40037000
        STR      R0,[R1, #+0]
//  498   PIT_LDVAL0 = SampleSpeed;
        LDR.W    R0,??DataTable17_4  ;; 0x40037100
        STR      R4,[R0, #+0]
//  499   PIT_TCTRL0 = (uint32_t)0x3;                   //enable the timer and inable the timer interupt diable the cahin mode
        MOVS     R0,#+3
        LDR.W    R1,??DataTable18_2  ;; 0x40037108
        STR      R0,[R1, #+0]
//  500   
//  501   
//  502   
//  503   PIT_TFLG0  = (uint32_t)0x1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable22  ;; 0x4003710c
        STR      R0,[R1, #+0]
//  504   NVIC_SetPriority(48, 0);
        MOVS     R1,#+0
        MOVS     R0,#+48
        BL       NVIC_SetPriority
//  505   NVIC_EnableIRQ(48);
        MOVS     R0,#+48
        BL       NVIC_EnableIRQ
//  506 }
        POP      {R4,PC}          ;; return
//  507 
//  508 
//  509 
//  510 /*This is the Pit ISR, It will take samples of the ADC 8000 times in 1 second these two values will eventually 
//  511 be modifiable using vibe.
//  512 
//  513 There will be a Golbal boolean that needs to be set when the value is at 8000 itterations, it needs to be reset when the program starts up
//  514 
//  515 */
//  516 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  517 void PIT_ISR()
//  518 {
PIT_ISR:
        PUSH     {R4-R6,LR}
//  519   int TempXVal =0;
        MOVS     R4,#+0
//  520   int TempYVal =0;
        MOVS     R5,#+0
//  521   int TempZVal =0;  
        MOVS     R6,#+0
//  522   
//  523   
//  524   /*GreenStatLedOn();*/
//  525 
//  526 /*this is just set to do the 8 k samples it will not run the filtering code.
//  527   */
//  528   
//  529         /*need to take the sampling at 8KHz and find the min and max values here*/
//  530         /*need take 10,000 samples for the x conversion and save the raw values into the q15_t temp value thing */
//  531       if(PIT_ITTERATIONS <= ACCEL_SAMPLE_SIZE && AXIS==1)
        LDR.W    R0,??DataTable15_5
        LDR      R0,[R0, #+0]
        CMP      R0,#+8000
        BGT.N    ??PIT_ISR_0
        LDR.W    R0,??DataTable15_4
        LDR      R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??PIT_ISR_0
//  532       {
//  533       //take the converstion values forom the a to d converter an then increment the number of ittereantion
//  534           StartXConversion();
        BL       StartXConversion
//  535           while(ConversionAComplete()==0){
??PIT_ISR_1:
        BL       ConversionAComplete
        CMP      R0,#+0
        BEQ.N    ??PIT_ISR_1
//  536           }
//  537           TempXVal = GetConversionValue();
        BL       GetConversionValue
        MOVS     R4,R0
//  538            
//  539           
//  540           if(TempXVal > gSnd.xmax)
        LDR.W    R0,??DataTable16
        LDRH     R0,[R0, #+10]
        CMP      R0,R4
        BGE.N    ??PIT_ISR_2
//  541           {
//  542             gSnd.xmax = TempXVal;
        LDR.W    R0,??DataTable16
        STRH     R4,[R0, #+10]
//  543           }
//  544           if(TempXVal < gSnd.xmin)
??PIT_ISR_2:
        LDR.W    R0,??DataTable16
        LDRH     R0,[R0, #+8]
        CMP      R4,R0
        BGE.N    ??PIT_ISR_3
//  545           {
//  546             gSnd.xmin = TempXVal;
        LDR.W    R0,??DataTable16
        STRH     R4,[R0, #+8]
//  547           }
//  548           TempSumx += TempXVal;  
??PIT_ISR_3:
        LDR.W    R0,??DataTable15_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R4,R0
        LDR.W    R1,??DataTable15_1
        STR      R0,[R1, #+0]
//  549       
//  550       
//  551           StartYConversion();
        BL       StartYConversion
//  552           while(ConversionAComplete()==0){
??PIT_ISR_4:
        BL       ConversionAComplete
        CMP      R0,#+0
        BEQ.N    ??PIT_ISR_4
//  553           }   
//  554           TempYVal = GetConversionValue();
        BL       GetConversionValue
        MOVS     R5,R0
//  555                
//  556           /*check th eY max and the Y Min */
//  557           if(TempYVal > gSnd.ymax)
        LDR.W    R0,??DataTable16
        LDRH     R0,[R0, #+26]
        CMP      R0,R5
        BGE.N    ??PIT_ISR_5
//  558           {
//  559             gSnd.ymax = TempYVal;
        LDR.W    R0,??DataTable16
        STRH     R5,[R0, #+26]
//  560           }
//  561           if(TempYVal < gSnd.ymin)
??PIT_ISR_5:
        LDR.W    R0,??DataTable16
        LDRH     R0,[R0, #+24]
        CMP      R5,R0
        BGE.N    ??PIT_ISR_6
//  562           {
//  563             gSnd.ymin = TempYVal;
        LDR.W    R0,??DataTable16
        STRH     R5,[R0, #+24]
//  564           }
//  565           TempSumy += TempYVal;
??PIT_ISR_6:
        LDR.W    R0,??DataTable15_2
        LDR      R0,[R0, #+0]
        ADDS     R0,R5,R0
        LDR.W    R1,??DataTable15_2
        STR      R0,[R1, #+0]
//  566       
//  567       
//  568           StartZConversion();
        BL       StartZConversion
//  569           while(ConversionAComplete()==0){
??PIT_ISR_7:
        BL       ConversionAComplete
        CMP      R0,#+0
        BEQ.N    ??PIT_ISR_7
//  570           }
//  571           TempZVal = GetConversionValue();
        BL       GetConversionValue
        MOVS     R6,R0
//  572           /*Check the Z max and the Z min*/
//  573           if(TempZVal > gSnd.zmax)
        LDR.W    R0,??DataTable16
        LDRH     R0,[R0, #+42]
        CMP      R0,R6
        BGE.N    ??PIT_ISR_8
//  574           {
//  575             gSnd.zmax = TempZVal;
        LDR.W    R0,??DataTable16
        STRH     R6,[R0, #+42]
//  576           }
//  577           if(TempZVal < gSnd.zmin)
??PIT_ISR_8:
        LDR.W    R0,??DataTable16
        LDRH     R0,[R0, #+40]
        CMP      R6,R0
        BGE.N    ??PIT_ISR_9
//  578           {
//  579             gSnd.zmin = TempZVal;
        LDR.W    R0,??DataTable16
        STRH     R6,[R0, #+40]
//  580           }
//  581           TempSumz += TempZVal; 
??PIT_ISR_9:
        LDR.W    R0,??DataTable15_3
        LDR      R0,[R0, #+0]
        ADDS     R0,R6,R0
        LDR.W    R1,??DataTable15_3
        STR      R0,[R1, #+0]
//  582       
//  583       
//  584       
//  585       
//  586       PIT_ITTERATIONS ++;
        LDR.W    R0,??DataTable15_5
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR.W    R1,??DataTable15_5
        STR      R0,[R1, #+0]
//  587       }
//  588         
//  589    
//  590 
//  591 
//  592   
//  593   /* THIS MIGHT BE AN ISSUE
//  594       
//  595       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  596       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  597       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  598       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  599       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  600       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  601       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  602       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  603      */
//  604   
//  605   
//  606   /*the changing of axis will be handled in the main code. this needs to be done there since I need to calculate other tings there using the filter as well. */
//  607   PIT_TFLG0  = (uint32_t)0x1;           //clears the interupt flag and will start a new 
??PIT_ISR_0:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable22  ;; 0x4003710c
        STR      R0,[R1, #+0]
//  608   /*GreenStatLedOff();*/
//  609 }
        POP      {R4-R6,PC}       ;; return
//  610 
//  611 
//  612 //return random number 0-15

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  613 uint8_t GetRandomNibble()
//  614 {
//  615     static uint8_t b=0;
//  616     uint8_t* p = (uint8_t*) 0x1fff9200;
GetRandomNibble:
        LDR.W    R1,??DataTable19_3  ;; 0x1fff9200
//  617    
//  618     while (p> (uint8_t*) 0x1fff80f0)
??GetRandomNibble_0:
        LDR.W    R0,??DataTable19_4  ;; 0x1fff80f1
        CMP      R1,R0
        BCC.N    ??GetRandomNibble_1
//  619     {
//  620       --p;
        SUBS     R1,R1,#+1
//  621       
//  622         b ^= *p;    // xor "b" with next byte of memory
        LDR.W    R0,??DataTable23
        LDRB     R0,[R0, #+0]
        LDRB     R2,[R1, #+0]
        EORS     R0,R2,R0
        LDR.W    R2,??DataTable23
        STRB     R0,[R2, #+0]
        B.N      ??GetRandomNibble_0
//  623     }
//  624     return (b >> 4) ^ (b & 15); // return left-nibble xor'ed with right-nibble (4 random bits)
??GetRandomNibble_1:
        LDR.W    R0,??DataTable23
        LDRB     R0,[R0, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDR.W    R2,??DataTable23
        LDRB     R2,[R2, #+0]
        ANDS     R2,R2,#0xF
        EORS     R0,R2,R0, LSR #+4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BX       LR               ;; return
//  625 }

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
??b:
        DS8 1

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  626 int8_t GetLinkQdBm()
//  627 {
GetLinkQdBm:
        PUSH     {R7,LR}
//  628     // Get link quality (dBm) from last successful RX packet
//  629   uint8_t quality;
//  630  //   return (int8_t)((-(int16_t)MLMELinkQuality()) >> 1); // Note: "floor", not truncation
//  631   MLMELinkQuality(&quality);
        ADD      R0,SP,#+0
        BL       MLMELinkQuality
//  632   return quality;
        LDRSB    R0,[SP, #+0]
        SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
        POP      {R1,PC}          ;; return
//  633 }

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  634 uint8_t getRandomNumberInRange(uint8_t low,uint8_t high){
//  635   if(high <= low) return low;
getRandomNumberInRange:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R0,R1
        BCC.N    ??getRandomNumberInRange_0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        B.N      ??getRandomNumberInRange_1
//  636   uint32_t random;
//  637 //  RNG_GetRandomNo(&random);
//  638 //  CR[INTM]=1;
//  639   return low + (uint8_t)(random % (high - low + 1));    
??getRandomNumberInRange_0:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        SUBS     R1,R1,R0
        ADDS     R1,R1,#+1
        MOVS     R2,#+0
        UDIV     R2,R2,R1
        MLS      R0,R1,R2,R0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
??getRandomNumberInRange_1:
        BX       LR               ;; return
//  640 }
//  641 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  642 uint8_t ChooseBestChannel()
//  643 {
ChooseBestChannel:
        PUSH     {R4-R10,LR}
//  644   //RNG_Init();  
//  645     uint8_t   channelStatus = INITIAL_VALUE;   // something other than SUCCESS
        MOVS     R4,#+0
//  646     uint8_t   channel = 0;
        MOVS     R5,#+0
//  647     uint8_t   iter;
//  648     channels_t iChannel;
//  649     //
//  650     // Updated *** 10/26/10 ***
//  651     // Note: all calls now go thru "GetLinkQdBm"
//  652     //
//  653     int8_t    maxLinkQdBm;
//  654     
//  655     
//  656     // Get ready to send the PNG packet
//  657     gAppTxPacket->u8DataLength = PNG_SIZE;
        MOVS     R0,#+5
        LDR.W    R1,??DataTable19_1
        LDR      R1,[R1, #+0]
        STRB     R0,[R1, #+0]
//  658     PngSwapEndianness();
        BL       PngSwapEndianness
//  659     CopyPngPacketToSMAC();
        BL       CopyPngPacketToSMAC
//  660     
//  661     // Note: we don't want to wait very long between testing each channel,
//  662     // so temporarily change the timeout to a low value
//  663     gRxTimeout = gOptions.u32PngTimeout;
        LDR.W    R0,??DataTable15_12
        LDR      R0,[R0, #+12]
        LDR.W    R1,??DataTable19
        STR      R0,[R1, #+0]
//  664     
//  665     // Find channel with the best link quality
//  666     maxLinkQdBm = -128;
        MVNS     R0,#+127
        MOV      R8,R0
//  667     channel=GetRandomNibble();
        BL       GetRandomNibble
        MOVS     R5,R0
//  668     smacErrors_t smacStatus;
//  669     for (iter = 0; iter < 64; iter++) {
        MOVS     R0,#+0
        MOVS     R6,R0
??ChooseBestChannel_0:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+64
        BGE.N    ??ChooseBestChannel_1
//  670         smacStatus=gErrorBusy_c;
        MOVS     R0,#+1
        MOV      R9,R0
//  671         channel = (channel + 1) & 15;
        ADDS     R0,R5,#+1
        ANDS     R5,R0,#0xF
//  672  //       channel=0;
//  673         iChannel=channel+gChannel11_c;
        ADDS     R0,R5,#+11
        MOVS     R7,R0
//  674         
//  675         while(smacStatus!=gErrorNoError_c){
??ChooseBestChannel_2:
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R9,#+0
        BEQ.N    ??ChooseBestChannel_3
//  676           smacStatus=MLMESetChannelRequest(iChannel);
        MOVS     R0,R7
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       MLMESetChannelRequest
        MOV      R9,R0
        B.N      ??ChooseBestChannel_2
//  677         }
//  678         smacStatus=gErrorBusy_c;
??ChooseBestChannel_3:
        MOVS     R0,#+1
        MOV      R9,R0
//  679         //while(smacStatus!=gErrorNoError_c){
//  680           smacStatus=MCPSDataRequest(gAppTxPacket); // transmit data
        LDR.W    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        BL       MCPSDataRequest
        MOV      R9,R0
//  681         //}
//  682         // NOTE: we have to keep looping here, because our PNG packets may be sent back
//  683         // to us by a REPEATER, but we should ignore them (only intereseted in ACK packets)
//  684         if(smacStatus==gErrorNoError_c){
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R9,#+0
        BNE.N    ??ChooseBestChannel_4
//  685         
//  686         do 
//  687         {
//  688             ReceivePacket();
??ChooseBestChannel_5:
        BL       ReceivePacket
//  689             if (gIsMyAck) 
        LDR.W    R0,??DataTable29
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??ChooseBestChannel_6
//  690             {
//  691                 int8_t linkQdBm = GetLinkQdBm();
        BL       GetLinkQdBm
//  692                 if (linkQdBm > maxLinkQdBm)
        SXTB     R8,R8            ;; SignExt  R8,R8,#+24,#+24
        SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
        CMP      R8,R0
        BGE.N    ??ChooseBestChannel_6
//  693                 {
//  694                     maxLinkQdBm = linkQdBm;
        MOV      R8,R0
//  695                     gSnd.channel = iChannel;
        LDR.W    R1,??DataTable16
        STRB     R7,[R1, #+67]
//  696                     channelStatus = SUCCESS;
        MOVS     R1,#+119
        MOVS     R4,R1
//  697                 }
//  698                 //printf("Channel %d Link Quality %d",iChannel,linkQdBm);
//  699             }
//  700         }
//  701         while (gAppRxPacket->rxStatus != rxTimeOutStatus_c);
??ChooseBestChannel_6:
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+0]
        LDRB     R0,[R0, #+1]
        CMP      R0,#+3
        BNE.N    ??ChooseBestChannel_5
//  702         }
//  703     }
??ChooseBestChannel_4:
        ADDS     R6,R6,#+1
        B.N      ??ChooseBestChannel_0
//  704     
//  705     // Remember to restore the usual timeout value, i.e., the timeout for SND packets
//  706     gRxTimeout = gOptions.u32SndTimeout;
??ChooseBestChannel_1:
        LDR.W    R0,??DataTable15_12
        LDR      R0,[R0, #+16]
        LDR.W    R1,??DataTable19
        STR      R0,[R1, #+0]
//  707     
//  708     // Reset channel (even if none were successful, since then it's original gChannelNumber)
//  709     if (MLMESetChannelRequest(gSnd.channel) != SUCCESS) // select channel here (0-15)
        LDR.W    R0,??DataTable16
        LDRB     R0,[R0, #+67]
        BL       MLMESetChannelRequest
        MOV      R10,R0
//  710     { 
//  711         //printf("can't set channel %d",gSnd.channel);
//  712     }
//  713     
//  714   	// Added *** 10/27/10 ***
//  715     // NOTE: the most meaningful "linkQdBm" value in the first SND packet after
//  716     // channel scan is "maxLinkQdBm" - see also "ReceivePacket".
//  717     gSnd.linkQdBm = maxLinkQdBm;
        LDR.W    R0,??DataTable16
        STRB     R8,[R0, #+60]
//  718 
//  719     // Finally, send our current options to the pan coordinator
//  720     SendCurrentOptions();
        BL       SendCurrentOptions
//  721     
//  722     return channelStatus;  // return SUCCESS if selected channel is good
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R4-R10,PC}      ;; return
//  723 }
//  724 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  725 void ReceivePacket(){
ReceivePacket:
        PUSH     {R4,LR}
//  726   appState = WAIT_FOR_ACK;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable15_10
        STRB     R0,[R1, #+0]
//  727   gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
        MOVS     R0,#+123
        LDR.W    R1,??DataTable17
        LDR      R1,[R1, #+0]
        STRB     R0,[R1, #+0]
//  728   smacErrors_t status = MLMERXEnableRequest(gAppRxPacket, gRxTimeout);
        LDR.W    R0,??DataTable19
        LDR      R1,[R0, #+0]
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+0]
        BL       MLMERXEnableRequest
        MOVS     R4,R0
//  729   while(status!=gErrorNoError_c){
??ReceivePacket_0:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+0
        BEQ.N    ??ReceivePacket_1
//  730     status = MLMERXEnableRequest(gAppRxPacket, gRxTimeout);
        LDR.W    R0,??DataTable19
        LDR      R1,[R0, #+0]
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+0]
        BL       MLMERXEnableRequest
        MOVS     R4,R0
        B.N      ??ReceivePacket_0
//  731   }
//  732   
//  733   while(appState == WAIT_FOR_ACK);
??ReceivePacket_1:
        LDR.W    R0,??DataTable15_10
        LDRSB    R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.N    ??ReceivePacket_1
//  734   if(gAppRxPacket->rxStatus==rxSuccessStatus_c) {
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+0]
        LDRB     R0,[R0, #+1]
        CMP      R0,#+2
        BNE.N    ??ReceivePacket_2
//  735     //LED_SetLed(LED3, gLedOn_c);
//  736     if (gAppRxPacket->smacPdu.u8Data[0] == 'A' &&
//  737         gAppRxPacket->smacPdu.u8Data[1] == 'C' && 
//  738         gAppRxPacket->smacPdu.u8Data[2] == 'K' &&
//  739         gAppRxPacket->u8DataLength >= ACK_HEADER_SIZE)
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+0]
        LDRB     R0,[R0, #+5]
        CMP      R0,#+65
        BNE.N    ??ReceivePacket_3
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+0]
        LDRB     R0,[R0, #+6]
        CMP      R0,#+67
        BNE.N    ??ReceivePacket_3
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+0]
        LDRB     R0,[R0, #+7]
        CMP      R0,#+75
        BNE.N    ??ReceivePacket_3
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+0]
        LDRB     R0,[R0, #+2]
        CMP      R0,#+5
        BLT.N    ??ReceivePacket_3
//  740     {
//  741         gIsAck = TRUE;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable16_1
        STRB     R0,[R1, #+0]
//  742         uint16_t ackID = (*(uint16_t*)&gAppRxPacket->smacPdu.u8Data[3]);
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+0]
        LDRH     R0,[R0, #+8]
//  743         ackID = (ackID << 8) | (ackID >> 8);
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        LSRS     R1,R0,#+8
        ORRS     R0,R1,R0, LSL #+8
//  744         gIsMyAck = (ackID == sensorID);
        LDR.W    R1,??DataTable15
        LDRH     R1,[R1, #+0]
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        CMP      R0,R1
        BNE.N    ??ReceivePacket_4
        MOVS     R0,#+1
        LDR.W    R1,??DataTable29
        STRB     R0,[R1, #+0]
        B.N      ??ReceivePacket_2
??ReceivePacket_4:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable29
        STRB     R0,[R1, #+0]
        B.N      ??ReceivePacket_2
//  745         //if(gIsMyAck) LED_SetLed(LED1, gLedOn_c);
//  746        
//  747     }
//  748     else
//  749     {
//  750         gIsAck = FALSE;
??ReceivePacket_3:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable16_1
        STRB     R0,[R1, #+0]
//  751         gIsMyAck = FALSE;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable29
        STRB     R0,[R1, #+0]
//  752     }
//  753   }
//  754   if(gAppRxPacket->rxStatus==rxTimeOutStatus_c) {
//  755     //LED_SetLed(LED4, gLedOn_c); 
//  756   }
//  757   
//  758 }
??ReceivePacket_2:
        POP      {R4,PC}          ;; return

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  759 void PrintPacketID(uint16_t packetID){
PrintPacketID:
        PUSH     {R4,LR}
        MOVS     R4,R0
//  760   CommUtil_Print("\f\r\n Running PER Tx, Sending ", gAllowToBlock_d);
        MOVS     R1,#+1
        LDR.W    R0,??DataTable22_1
        BL       CommUtil_Print
//  761   PrintWordOnDecimalFormatBlocking(packetID, 0, FALSE, gDefaultCommPort_c);
        MOVS     R3,#+1
        MOVS     R2,#+0
        MOVS     R1,#+0
        MOVS     R0,R4
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        BL       PrintWordOnDecimalFormatBlocking
//  762   CommUtil_Print(" Packets", gAllowToBlock_d);
        MOVS     R1,#+1
        LDR.W    R0,??DataTable30
        BL       CommUtil_Print
//  763     
//  764 }
        POP      {R4,PC}          ;; return
//  765 
//  766 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  767 void SndSwapEndianness(){
//  768   //uint16
//  769   gSnd.hdr.u16SensorID  = (gSnd.hdr.u16SensorID << 8) | (gSnd.hdr.u16SensorID >> 8 );
SndSwapEndianness:
        LDR.W    R0,??DataTable19_5
        LDRH     R0,[R0, #+4]
        LDR.W    R1,??DataTable19_5
        LDRH     R1,[R1, #+4]
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        LSRS     R1,R1,#+8
        ORRS     R0,R1,R0, LSL #+8
        LDR.W    R1,??DataTable19_5
        STRH     R0,[R1, #+4]
//  770   gSnd.packetID         = (gSnd.packetID        << 8) | (gSnd.packetID       >> 8 );
        LDR.W    R0,??DataTable19_5
        LDRH     R0,[R0, #+6]
        LDR.W    R1,??DataTable19_5
        LDRH     R1,[R1, #+6]
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        LSRS     R1,R1,#+8
        ORRS     R0,R1,R0, LSL #+8
        LDR.W    R1,??DataTable19_5
        STRH     R0,[R1, #+6]
//  771   gSnd.xmin             = (gSnd.xmin            << 8) | (gSnd.xmin           >> 8 );
        LDR.W    R0,??DataTable19_5
        LDRH     R0,[R0, #+8]
        LDR.W    R1,??DataTable19_5
        LDRH     R1,[R1, #+8]
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        LSRS     R1,R1,#+8
        ORRS     R0,R1,R0, LSL #+8
        LDR.W    R1,??DataTable19_5
        STRH     R0,[R1, #+8]
//  772   gSnd.xmax             = (gSnd.xmax            << 8) | (gSnd.xmax           >> 8 );
        LDR.W    R0,??DataTable19_5
        LDRH     R0,[R0, #+10]
        LDR.W    R1,??DataTable19_5
        LDRH     R1,[R1, #+10]
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        LSRS     R1,R1,#+8
        ORRS     R0,R1,R0, LSL #+8
        LDR.W    R1,??DataTable19_5
        STRH     R0,[R1, #+10]
//  773   gSnd.xmean            = (gSnd.xmean           << 8) | (gSnd.xmean          >> 8 );
        LDR.W    R0,??DataTable19_5
        LDRH     R0,[R0, #+12]
        LDR.W    R1,??DataTable19_5
        LDRH     R1,[R1, #+12]
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        LSRS     R1,R1,#+8
        ORRS     R0,R1,R0, LSL #+8
        LDR.W    R1,??DataTable19_5
        STRH     R0,[R1, #+12]
//  774   gSnd.ymin             = (gSnd.ymin            << 8) | (gSnd.ymin           >> 8 );
        LDR.W    R0,??DataTable19_5
        LDRH     R0,[R0, #+24]
        LDR.W    R1,??DataTable19_5
        LDRH     R1,[R1, #+24]
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        LSRS     R1,R1,#+8
        ORRS     R0,R1,R0, LSL #+8
        LDR.W    R1,??DataTable19_5
        STRH     R0,[R1, #+24]
//  775   gSnd.ymax             = (gSnd.ymax            << 8) | (gSnd.ymax           >> 8 );
        LDR.W    R0,??DataTable19_5
        LDRH     R0,[R0, #+26]
        LDR.W    R1,??DataTable19_5
        LDRH     R1,[R1, #+26]
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        LSRS     R1,R1,#+8
        ORRS     R0,R1,R0, LSL #+8
        LDR.W    R1,??DataTable19_5
        STRH     R0,[R1, #+26]
//  776   gSnd.ymean            = (gSnd.ymean           << 8) | (gSnd.ymean          >> 8 );
        LDR.W    R0,??DataTable19_5
        LDRH     R0,[R0, #+28]
        LDR.W    R1,??DataTable19_5
        LDRH     R1,[R1, #+28]
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        LSRS     R1,R1,#+8
        ORRS     R0,R1,R0, LSL #+8
        LDR.W    R1,??DataTable19_5
        STRH     R0,[R1, #+28]
//  777   gSnd.zmin             = (gSnd.zmin            << 8) | (gSnd.zmin           >> 8 );
        LDR.W    R0,??DataTable19_5
        LDRH     R0,[R0, #+40]
        LDR.W    R1,??DataTable19_5
        LDRH     R1,[R1, #+40]
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        LSRS     R1,R1,#+8
        ORRS     R0,R1,R0, LSL #+8
        LDR.W    R1,??DataTable19_5
        STRH     R0,[R1, #+40]
//  778   gSnd.zmax             = (gSnd.zmax            << 8) | (gSnd.zmax           >> 8 );
        LDR.W    R0,??DataTable19_5
        LDRH     R0,[R0, #+42]
        LDR.W    R1,??DataTable19_5
        LDRH     R1,[R1, #+42]
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        LSRS     R1,R1,#+8
        ORRS     R0,R1,R0, LSL #+8
        LDR.W    R1,??DataTable19_5
        STRH     R0,[R1, #+42]
//  779   gSnd.zmean            = (gSnd.zmean           << 8) | (gSnd.zmean          >> 8 );
        LDR.W    R0,??DataTable19_5
        LDRH     R0,[R0, #+44]
        LDR.W    R1,??DataTable19_5
        LDRH     R1,[R1, #+44]
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        LSRS     R1,R1,#+8
        ORRS     R0,R1,R0, LSL #+8
        LDR.W    R1,??DataTable19_5
        STRH     R0,[R1, #+44]
//  780   gSnd.battery_mV       = (gSnd.battery_mV      << 8) | (gSnd.battery_mV     >> 8 );
        LDR.W    R0,??DataTable19_5
        LDRH     R0,[R0, #+58]
        LDR.W    R1,??DataTable19_5
        LDRH     R1,[R1, #+58]
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        LSRS     R1,R1,#+8
        ORRS     R0,R1,R0, LSL #+8
        LDR.W    R1,??DataTable19_5
        STRH     R0,[R1, #+58]
//  781   gSnd.totalTimeouts    = (gSnd.totalTimeouts   << 8) | (gSnd.totalTimeouts  >> 8 );
        LDR.W    R0,??DataTable19_5
        LDRH     R0,[R0, #+62]
        LDR.W    R1,??DataTable19_5
        LDRH     R1,[R1, #+62]
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        LSRS     R1,R1,#+8
        ORRS     R0,R1,R0, LSL #+8
        LDR.W    R1,??DataTable19_5
        STRH     R0,[R1, #+62]
//  782   gSnd.maxMissedCount   = (gSnd.maxMissedCount  << 8) | (gSnd.maxMissedCount >> 8 );
        LDR.W    R0,??DataTable19_5
        LDRH     R0,[R0, #+64]
        LDR.W    R1,??DataTable19_5
        LDRH     R1,[R1, #+64]
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        LSRS     R1,R1,#+8
        ORRS     R0,R1,R0, LSL #+8
        LDR.W    R1,??DataTable19_5
        STRH     R0,[R1, #+64]
//  783   
//  784   //int16
//  785   gSnd.temperature      = (gSnd.temperature << 8) | ((gSnd.temperature >> 8) & 0xFF);
        LDR.W    R0,??DataTable19_5
        LDRH     R0,[R0, #+56]
        LDR.W    R1,??DataTable19_5
        LDRSH    R1,[R1, #+56]
        UBFX     R1,R1,#+8,#+8
        ORRS     R0,R1,R0, LSL #+8
        LDR.W    R1,??DataTable19_5
        STRH     R0,[R1, #+56]
//  786   
//  787   //uint32
//  788   gSnd.xsum0 = ((gSnd.xsum0 << 8) & 0xFF00FF00 ) | ((gSnd.xsum0 >> 8) & 0xFF00FF ); 
        LDR.W    R0,??DataTable19_5
        LDR      R0,[R0, #+16]
        LSLS     R0,R0,#+8
        BICS     R0,R0,#0xFF00FF
        LDR.W    R1,??DataTable19_5
        LDR      R1,[R1, #+16]
        LSRS     R1,R1,#+8
        ANDS     R1,R1,#0xFF00FF
        ORRS     R0,R1,R0
        LDR.W    R1,??DataTable19_5
        STR      R0,[R1, #+16]
//  789   gSnd.xsum0 = (gSnd.xsum0 << 16) | (gSnd.xsum0 >> 16);
        LDR.W    R0,??DataTable19_5
        LDR      R0,[R0, #+16]
        LDR.W    R1,??DataTable19_5
        LDR      R1,[R1, #+16]
        RORS     R0,R1,#+16
        LDR.W    R1,??DataTable19_5
        STR      R0,[R1, #+16]
//  790   gSnd.xsum1 = ((gSnd.xsum1 << 8) & 0xFF00FF00 ) | ((gSnd.xsum1 >> 8) & 0xFF00FF ); 
        LDR.W    R0,??DataTable19_5
        LDR      R0,[R0, #+20]
        LSLS     R0,R0,#+8
        BICS     R0,R0,#0xFF00FF
        LDR.W    R1,??DataTable19_5
        LDR      R1,[R1, #+20]
        LSRS     R1,R1,#+8
        ANDS     R1,R1,#0xFF00FF
        ORRS     R0,R1,R0
        LDR.W    R1,??DataTable19_5
        STR      R0,[R1, #+20]
//  791   gSnd.xsum1 =  (gSnd.xsum1 << 16) | (gSnd.xsum1 >> 16);
        LDR.W    R0,??DataTable19_5
        LDR      R0,[R0, #+20]
        LDR.W    R1,??DataTable19_5
        LDR      R1,[R1, #+20]
        RORS     R0,R1,#+16
        LDR.W    R1,??DataTable19_5
        STR      R0,[R1, #+20]
//  792   gSnd.ysum0 = ((gSnd.ysum0 << 8) & 0xFF00FF00 ) | ((gSnd.ysum0 >> 8) & 0xFF00FF ); 
        LDR.W    R0,??DataTable19_5
        LDR      R0,[R0, #+32]
        LSLS     R0,R0,#+8
        BICS     R0,R0,#0xFF00FF
        LDR.W    R1,??DataTable19_5
        LDR      R1,[R1, #+32]
        LSRS     R1,R1,#+8
        ANDS     R1,R1,#0xFF00FF
        ORRS     R0,R1,R0
        LDR.W    R1,??DataTable19_5
        STR      R0,[R1, #+32]
//  793   gSnd.ysum0 = (gSnd.ysum0 << 16) | (gSnd.ysum0 >> 16);
        LDR.W    R0,??DataTable19_5
        LDR      R0,[R0, #+32]
        LDR.W    R1,??DataTable19_5
        LDR      R1,[R1, #+32]
        RORS     R0,R1,#+16
        LDR.W    R1,??DataTable19_5
        STR      R0,[R1, #+32]
//  794   gSnd.ysum1 = ((gSnd.ysum1 << 8) & 0xFF00FF00 ) | ((gSnd.ysum1 >> 8) & 0xFF00FF ); 
        LDR.W    R0,??DataTable19_5
        LDR      R0,[R0, #+36]
        LSLS     R0,R0,#+8
        BICS     R0,R0,#0xFF00FF
        LDR.W    R1,??DataTable19_5
        LDR      R1,[R1, #+36]
        LSRS     R1,R1,#+8
        ANDS     R1,R1,#0xFF00FF
        ORRS     R0,R1,R0
        LDR.W    R1,??DataTable19_5
        STR      R0,[R1, #+36]
//  795   gSnd.ysum1 =  (gSnd.ysum1 << 16) | (gSnd.ysum1 >> 16);  
        LDR.W    R0,??DataTable19_5
        LDR      R0,[R0, #+36]
        LDR.W    R1,??DataTable19_5
        LDR      R1,[R1, #+36]
        RORS     R0,R1,#+16
        LDR.W    R1,??DataTable19_5
        STR      R0,[R1, #+36]
//  796   gSnd.zsum0 = ((gSnd.zsum0 << 8) & 0xFF00FF00 ) | ((gSnd.zsum0 >> 8) & 0xFF00FF ); 
        LDR.W    R0,??DataTable19_5
        LDR      R0,[R0, #+48]
        LSLS     R0,R0,#+8
        BICS     R0,R0,#0xFF00FF
        LDR.W    R1,??DataTable19_5
        LDR      R1,[R1, #+48]
        LSRS     R1,R1,#+8
        ANDS     R1,R1,#0xFF00FF
        ORRS     R0,R1,R0
        LDR.W    R1,??DataTable19_5
        STR      R0,[R1, #+48]
//  797   gSnd.zsum0 = (gSnd.zsum0 << 16) | (gSnd.zsum0 >> 16);
        LDR.W    R0,??DataTable19_5
        LDR      R0,[R0, #+48]
        LDR.W    R1,??DataTable19_5
        LDR      R1,[R1, #+48]
        RORS     R0,R1,#+16
        LDR.W    R1,??DataTable19_5
        STR      R0,[R1, #+48]
//  798   gSnd.zsum1 = ((gSnd.zsum1 << 8) & 0xFF00FF00 ) | ((gSnd.zsum1 >> 8) & 0xFF00FF ); 
        LDR.W    R0,??DataTable19_5
        LDR      R0,[R0, #+52]
        LSLS     R0,R0,#+8
        BICS     R0,R0,#0xFF00FF
        LDR.W    R1,??DataTable19_5
        LDR      R1,[R1, #+52]
        LSRS     R1,R1,#+8
        ANDS     R1,R1,#0xFF00FF
        ORRS     R0,R1,R0
        LDR.W    R1,??DataTable19_5
        STR      R0,[R1, #+52]
//  799   gSnd.zsum1 =  (gSnd.zsum1 << 16) | (gSnd.zsum1 >> 16);
        LDR.W    R0,??DataTable19_5
        LDR      R0,[R0, #+52]
        LDR.W    R1,??DataTable19_5
        LDR      R1,[R1, #+52]
        RORS     R0,R1,#+16
        LDR.W    R1,??DataTable19_5
        STR      R0,[R1, #+52]
//  800   
//  801 }
        BX       LR               ;; return

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  802 void CopyOptionsFromRecvPacket(tOptions* pOptions){
CopyOptionsFromRecvPacket:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
//  803 
//  804   uint32_t offset = ACK_HEADER_SIZE;      
        MOVS     R5,#+5
//  805   MemoryCpy(&pOptions->u8RawSpinCount, &gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->u8RawSpinCount));  
        MOVS     R2,#+1
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+0]
        ADDS     R0,R5,R0
        ADDS     R1,R0,#+5
        MOVS     R0,R4
        BL       MemoryCpy
//  806   offset += sizeof(uint8_t);
        ADDS     R5,R5,#+1
//  807   MemoryCpy(&pOptions->u16TimeoutsToKill, &gAppRxPacket->smacPdu.u8Data[offset],sizeof(pOptions->u16TimeoutsToKill));
        MOVS     R2,#+2
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+0]
        ADDS     R0,R5,R0
        ADDS     R1,R0,#+5
        ADDS     R0,R4,#+2
        BL       MemoryCpy
//  808   offset += sizeof(uint16_t);
        ADDS     R5,R5,#+2
//  809   MemoryCpy(&pOptions->u16SampleSize, &gAppRxPacket->smacPdu.u8Data[offset],sizeof(pOptions->u16SampleSize));
        MOVS     R2,#+2
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+0]
        ADDS     R0,R5,R0
        ADDS     R1,R0,#+5
        ADDS     R0,R4,#+4
        BL       MemoryCpy
//  810   offset += sizeof(uint16_t);
        ADDS     R5,R5,#+2
//  811   MemoryCpy(&pOptions->bAsciiMode, &gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->bAsciiMode));
        MOVS     R2,#+1
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+0]
        ADDS     R0,R5,R0
        ADDS     R1,R0,#+5
        ADDS     R0,R4,#+6
        BL       MemoryCpy
//  812   offset += sizeof(uint8_t);
        ADDS     R5,R5,#+1
//  813   MemoryCpy(&pOptions->bBlinkingLEDs, &gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->bBlinkingLEDs));
        MOVS     R2,#+1
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+0]
        ADDS     R0,R5,R0
        ADDS     R1,R0,#+5
        ADDS     R0,R4,#+7
        BL       MemoryCpy
//  814   offset += sizeof(uint8_t);                                           
        ADDS     R5,R5,#+1
//  815   MemoryCpy(&pOptions->u8OutputPower, &gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->u8OutputPower));
        MOVS     R2,#+1
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+0]
        ADDS     R0,R5,R0
        ADDS     R1,R0,#+5
        ADDS     R0,R4,#+8
        BL       MemoryCpy
//  816   offset += sizeof(uint8_t);                                        
        ADDS     R5,R5,#+1
//  817   MemoryCpy(&pOptions->u32PngTimeout, &gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->u32PngTimeout));
        MOVS     R2,#+4
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+0]
        ADDS     R0,R5,R0
        ADDS     R1,R0,#+5
        ADDS     R0,R4,#+12
        BL       MemoryCpy
//  818   offset += sizeof(uint32_t);                                        
        ADDS     R5,R5,#+4
//  819   MemoryCpy(&pOptions->u32SndTimeout, &gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->u32SndTimeout));
        MOVS     R2,#+4
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+0]
        ADDS     R0,R5,R0
        ADDS     R1,R0,#+5
        ADDS     R0,R4,#+16
        BL       MemoryCpy
//  820   offset += sizeof(uint32_t);
        ADDS     R5,R5,#+4
//  821   MemoryCpy(&pOptions->bLNAHighGainMode,&gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->bLNAHighGainMode)); // i.e. Low Noise Amplifier - updated *** 10/26/10 *** (formerly "u8Reserved2")
        MOVS     R2,#+1
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+0]
        ADDS     R0,R5,R0
        ADDS     R1,R0,#+5
        ADDS     R0,R4,#+20
        BL       MemoryCpy
//  822   offset += sizeof(uint8_t);
        ADDS     R5,R5,#+1
//  823   MemoryCpy(&pOptions->u16SleepAfterAck,&gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->u16SleepAfterAck));
        MOVS     R2,#+2
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+0]
        ADDS     R0,R5,R0
        ADDS     R1,R0,#+5
        ADDS     R0,R4,#+22
        BL       MemoryCpy
//  824   
//  825 
//  826 }
        POP      {R0,R4,R5,PC}    ;; return

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  827 void OptSwapEndianness(tOptions* pOptions){
//  828   
//  829   
//  830   
//  831   pOptions->u16TimeoutsToKill   = ((pOptions->u16TimeoutsToKill)       << 8) | ((pOptions->u16TimeoutsToKill) >> 8);
OptSwapEndianness:
        LDRH     R1,[R0, #+2]
        LDRH     R2,[R0, #+2]
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        LSRS     R2,R2,#+8
        ORRS     R1,R2,R1, LSL #+8
        STRH     R1,[R0, #+2]
//  832   pOptions->u16SampleSize       = ((pOptions->u16SampleSize)           << 8) | ((pOptions->u16SampleSize)     >> 8);
        LDRH     R1,[R0, #+4]
        LDRH     R2,[R0, #+4]
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        LSRS     R2,R2,#+8
        ORRS     R1,R2,R1, LSL #+8
        STRH     R1,[R0, #+4]
//  833   pOptions->u16SleepAfterAck    = ((pOptions->u16SleepAfterAck)        << 8) | ((pOptions->u16SleepAfterAck)  >> 8);
        LDRH     R1,[R0, #+22]
        LDRH     R2,[R0, #+22]
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        LSRS     R2,R2,#+8
        ORRS     R1,R2,R1, LSL #+8
        STRH     R1,[R0, #+22]
//  834   
//  835   pOptions->u32PngTimeout = (((pOptions->u32PngTimeout) << 8) & 0xFF00FF00 ) | (((pOptions->u32PngTimeout) >> 8) & 0xFF00FF );
        LDR      R1,[R0, #+12]
        LSLS     R1,R1,#+8
        BICS     R1,R1,#0xFF00FF
        LDR      R2,[R0, #+12]
        LSRS     R2,R2,#+8
        ANDS     R2,R2,#0xFF00FF
        ORRS     R1,R2,R1
        STR      R1,[R0, #+12]
//  836   pOptions->u32PngTimeout = (pOptions->u32PngTimeout << 16) | (pOptions->u32PngTimeout >> 16);
        LDR      R1,[R0, #+12]
        LDR      R2,[R0, #+12]
        RORS     R1,R2,#+16
        STR      R1,[R0, #+12]
//  837   
//  838   pOptions->u32SndTimeout = (((pOptions->u32SndTimeout) << 8) & 0xFF00FF00 ) | (((pOptions->u32SndTimeout) >> 8) & 0xFF00FF );
        LDR      R1,[R0, #+16]
        LSLS     R1,R1,#+8
        BICS     R1,R1,#0xFF00FF
        LDR      R2,[R0, #+16]
        LSRS     R2,R2,#+8
        ANDS     R2,R2,#0xFF00FF
        ORRS     R1,R2,R1
        STR      R1,[R0, #+16]
//  839   pOptions->u32SndTimeout = (pOptions->u32SndTimeout << 16) | (pOptions->u32SndTimeout >> 16);
        LDR      R1,[R0, #+16]
        LDR      R2,[R0, #+16]
        RORS     R1,R2,#+16
        STR      R1,[R0, #+16]
//  840   
//  841   
//  842   
//  843 }
        BX       LR               ;; return
//  844 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  845 void PngSwapEndianness(){
//  846   gPng.u16SensorID = (gPng.u16SensorID << 8) | (gPng.u16SensorID >> 8);
PngSwapEndianness:
        LDR.W    R0,??DataTable31
        LDRH     R0,[R0, #+4]
        LDR.W    R1,??DataTable31
        LDRH     R1,[R1, #+4]
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        LSRS     R1,R1,#+8
        ORRS     R0,R1,R0, LSL #+8
        LDR.W    R1,??DataTable31
        STRH     R0,[R1, #+4]
//  847 }
        BX       LR               ;; return

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  848 void CopyPngPacketToSMAC(){
CopyPngPacketToSMAC:
        PUSH     {R7,LR}
//  849   MemoryCpy(&gAppTxPacket->smacPdu.u8Data[0],       (uint8_t*)&gPng.u8Prefix[0],       sizeof(gPng.u8Prefix[0]));
        MOVS     R2,#+1
        LDR.W    R1,??DataTable31
        LDR.W    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+3
        BL       MemoryCpy
//  850   MemoryCpy(&gAppTxPacket->smacPdu.u8Data[1],       (uint8_t*)&gPng.u8Prefix[1],       sizeof(gPng.u8Prefix[1]));
        MOVS     R2,#+1
        LDR.W    R1,??DataTable31_1
        LDR.W    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+4
        BL       MemoryCpy
//  851   MemoryCpy(&gAppTxPacket->smacPdu.u8Data[2],       (uint8_t*)&gPng.u8Prefix[2],       sizeof(gPng.u8Prefix[2]));
        MOVS     R2,#+1
        LDR.W    R1,??DataTable31_2
        LDR.W    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+5
        BL       MemoryCpy
//  852   MemoryCpy(&gAppTxPacket->smacPdu.u8Data[3],       (uint8_t*)&gPng.u16SensorID,       sizeof(gPng.u16SensorID));
        MOVS     R2,#+2
        LDR.W    R1,??DataTable31_3
        LDR.W    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+6
        BL       MemoryCpy
//  853            
//  854 }
        POP      {R0,PC}          ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15:
        DC32     sensorID

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_1:
        DC32     TempSumx

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_2:
        DC32     TempSumy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_3:
        DC32     TempSumz

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_4:
        DC32     AXIS

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_5:
        DC32     PIT_ITTERATIONS

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_6:
        DC32     0x400ff0c8

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_7:
        DC32     connState

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_8:
        DC32     testTrimmValue

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_9:
        DC32     sentPackets

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_10:
        DC32     appState

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_11:
        DC32     0x400ff0c4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_12:
        DC32     gOptions

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_13:
        DC32     evDataFromCOMM

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  855 void CopyBinaryPacketToSMAC(){
CopyBinaryPacketToSMAC:
        PUSH     {R7,LR}
//  856   
//  857   
//  858   
//  859     
//  860   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[0]),  (uint8_t*)&gSnd.hdr.u8Prefix[0]        ,sizeof(gSnd.hdr.u8Prefix[0]));
        MOVS     R2,#+1
        LDR.N    R1,??DataTable16
        LDR.W    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+3
        BL       MemoryCpy
//  861   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[1]),  (uint8_t*)&gSnd.hdr.u8Prefix[1]        ,sizeof(gSnd.hdr.u8Prefix[1]));
        MOVS     R2,#+1
        LDR.W    R1,??DataTable31_4
        LDR.W    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+4
        BL       MemoryCpy
//  862   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[2]),  (uint8_t*)&gSnd.hdr.u8Prefix[2]        ,sizeof(gSnd.hdr.u8Prefix[2]));
        MOVS     R2,#+1
        LDR.W    R1,??DataTable31_5
        LDR.W    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+5
        BL       MemoryCpy
//  863   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[3]),  (uint8_t*)&gSnd.hdr.u8Length           ,sizeof(gSnd.hdr.u8Length   ));
        MOVS     R2,#+1
        LDR.W    R1,??DataTable31_6
        LDR.W    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+6
        BL       MemoryCpy
//  864   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[4]),  (uint8_t*)&gSnd.hdr.u16SensorID        ,sizeof(gSnd.hdr.u16SensorID));
        MOVS     R2,#+2
        LDR.W    R1,??DataTable31_7
        LDR.W    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+7
        BL       MemoryCpy
//  865   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[6]),  (uint8_t*)&gSnd.packetID               ,sizeof(gSnd.packetID       ));
        MOVS     R2,#+2
        LDR.W    R1,??DataTable31_8
        LDR.W    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+9
        BL       MemoryCpy
//  866   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[8]),  (uint8_t*)&gSnd.xmin                   ,sizeof(gSnd.xmin           ));
        MOVS     R2,#+2
        LDR.W    R1,??DataTable31_9
        LDR.W    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+11
        BL       MemoryCpy
//  867   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[10]), (uint8_t*)&gSnd.xmax                   ,sizeof(gSnd.xmax           ));
        MOVS     R2,#+2
        LDR.W    R1,??DataTable31_10
        LDR.W    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+13
        BL       MemoryCpy
//  868   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[12]), (uint8_t*)&gSnd.xmean                  ,sizeof(gSnd.xmean          ));
        MOVS     R2,#+2
        LDR.W    R1,??DataTable31_11
        LDR.W    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+15
        BL       MemoryCpy
//  869   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[14]), (uint8_t*)&gSnd.xsum0                  ,sizeof(gSnd.xsum0          ));
        MOVS     R2,#+4
        LDR.W    R1,??DataTable31_12
        LDR.W    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+17
        BL       MemoryCpy
//  870   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[18]), (uint8_t*)&gSnd.xsum1                  ,sizeof(gSnd.xsum1          ));
        MOVS     R2,#+4
        LDR.W    R1,??DataTable31_13
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+21
        BL       MemoryCpy
//  871   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[22]), (uint8_t*)&gSnd.ymin                   ,sizeof(gSnd.ymin           ));
        MOVS     R2,#+2
        LDR.W    R1,??DataTable31_14
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+25
        BL       MemoryCpy
//  872   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[24]), (uint8_t*)&gSnd.ymax                   ,sizeof(gSnd.ymax           ));
        MOVS     R2,#+2
        LDR.W    R1,??DataTable31_15
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+27
        BL       MemoryCpy
//  873   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[26]), (uint8_t*)&gSnd.ymean                  ,sizeof(gSnd.ymean          ));
        MOVS     R2,#+2
        LDR.W    R1,??DataTable31_16
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+29
        BL       MemoryCpy
//  874   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[28]), (uint8_t*)&gSnd.ysum0                  ,sizeof(gSnd.ysum0          ));
        MOVS     R2,#+4
        LDR.W    R1,??DataTable31_17
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+31
        BL       MemoryCpy
//  875   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[32]), (uint8_t*)&gSnd.ysum1                  ,sizeof(gSnd.ysum1          ));
        MOVS     R2,#+4
        LDR.W    R1,??DataTable31_18
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+35
        BL       MemoryCpy
//  876   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[36]), (uint8_t*)&gSnd.zmin                   ,sizeof(gSnd.zmin           ));
        MOVS     R2,#+2
        LDR.W    R1,??DataTable31_19
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+39
        BL       MemoryCpy
//  877   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[38]), (uint8_t*)&gSnd.zmax                   ,sizeof(gSnd.zmax           ));
        MOVS     R2,#+2
        LDR.W    R1,??DataTable31_20
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+41
        BL       MemoryCpy
//  878   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[40]), (uint8_t*)&gSnd.zmean                  ,sizeof(gSnd.zmean          ));
        MOVS     R2,#+2
        LDR.W    R1,??DataTable31_21
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+43
        BL       MemoryCpy
//  879   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[42]), (uint8_t*)&gSnd.zsum0                  ,sizeof(gSnd.zsum0          ));
        MOVS     R2,#+4
        LDR.W    R1,??DataTable31_22
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+45
        BL       MemoryCpy
//  880   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[46]), (uint8_t*)&gSnd.zsum1                  ,sizeof(gSnd.zsum1          ));
        MOVS     R2,#+4
        LDR.W    R1,??DataTable31_23
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+49
        BL       MemoryCpy
//  881   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[50]), (uint8_t*)&gSnd.temperature            ,sizeof(gSnd.temperature    ));
        MOVS     R2,#+2
        LDR.W    R1,??DataTable31_24
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+53
        BL       MemoryCpy
//  882   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[52]), (uint8_t*)&gSnd.battery_mV             ,sizeof(gSnd.battery_mV     ));
        MOVS     R2,#+2
        LDR.W    R1,??DataTable31_25
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+55
        BL       MemoryCpy
//  883   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[54]), (uint8_t*)&gSnd.linkQdBm               ,sizeof(gSnd.linkQdBm       ));
        MOVS     R2,#+1
        LDR.W    R1,??DataTable31_26
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+57
        BL       MemoryCpy
//  884   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[55]), (uint8_t*)&gSnd.totalTimeouts          ,sizeof(gSnd.totalTimeouts  ));
        MOVS     R2,#+2
        LDR.W    R1,??DataTable31_27
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+58
        BL       MemoryCpy
//  885   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[57]), (uint8_t*)&gSnd.maxMissedCount         ,sizeof(gSnd.maxMissedCount ));
        MOVS     R2,#+2
        LDR.W    R1,??DataTable31_28
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+60
        BL       MemoryCpy
//  886   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[59]), (uint8_t*)&gSnd.voltageWarning         ,sizeof(gSnd.voltageWarning ));
        MOVS     R2,#+1
        LDR.W    R1,??DataTable31_29
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+62
        BL       MemoryCpy
//  887   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[60]), (uint8_t*)&gSnd.channel                ,sizeof(gSnd.channel        ));
        MOVS     R2,#+1
        LDR.W    R1,??DataTable31_30
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+63
        BL       MemoryCpy
//  888   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[61]), (uint8_t*)&gSnd.version                ,sizeof(gSnd.version        ));
        MOVS     R2,#+1
        LDR.W    R1,??DataTable31_31
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+64
        BL       MemoryCpy
//  889    
//  890   gAppTxPacket->u8DataLength = SND_SIZE;
        MOVS     R0,#+62
        LDR.N    R1,??DataTable19_1
        LDR      R1,[R1, #+0]
        STRB     R0,[R1, #+0]
//  891 }
        POP      {R0,PC}          ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16:
        DC32     gSnd

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_1:
        DC32     gIsAck

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_2:
        DC32     gOpt+0x8

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_3:
        DC32     0x40048038

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_4:
        DC32     0x4004c004

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_5:
        DC32     0x4004c014

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_6:
        DC32     0x400ff0d4

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  892 void CopyOptPacketToSMAC(){
CopyOptPacketToSMAC:
        PUSH     {R7,LR}
//  893   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[0]),   (uint8_t*)&gOpt.hdr.u8Prefix[0]        ,sizeof(gOpt.hdr.u8Prefix[0]));
        MOVS     R2,#+1
        LDR.N    R1,??DataTable18_1
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+3
        BL       MemoryCpy
//  894   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[1]),   (uint8_t*)&gOpt.hdr.u8Prefix[1]        ,sizeof(gOpt.hdr.u8Prefix[1]));
        MOVS     R2,#+1
        LDR.W    R1,??DataTable31_32
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+4
        BL       MemoryCpy
//  895   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[2]),   (uint8_t*)&gOpt.hdr.u8Prefix[2]        ,sizeof(gOpt.hdr.u8Prefix[2]));
        MOVS     R2,#+1
        LDR.W    R1,??DataTable31_33
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+5
        BL       MemoryCpy
//  896   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[3]),   (uint8_t*)&gOpt.hdr.u8Length           ,sizeof(gOpt.hdr.u8Length   ));
        MOVS     R2,#+1
        LDR.W    R1,??DataTable31_34
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+6
        BL       MemoryCpy
//  897   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[4]),   (uint8_t*)&gOpt.hdr.u16SensorID        ,sizeof(gOpt.hdr.u16SensorID));
        MOVS     R2,#+2
        LDR.W    R1,??DataTable31_35
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+7
        BL       MemoryCpy
//  898   
//  899   
//  900   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[6]),   (uint8_t*)&gOpt.options.u8RawSpinCount        ,sizeof(gOpt.options.u8RawSpinCount    ));   // updated *** 06/08/11 *** (formerly "u8Reserved1")
        MOVS     R2,#+1
        LDR.W    R1,??DataTable31_36
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+9
        BL       MemoryCpy
//  901   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[7]),   (uint8_t*)&gOpt.options.u16TimeoutsToKill     ,sizeof(gOpt.options.u16TimeoutsToKill ));
        MOVS     R2,#+2
        LDR.W    R1,??DataTable31_37
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+10
        BL       MemoryCpy
//  902   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[9]),   (uint8_t*)&gOpt.options.u16SampleSize         ,sizeof(gOpt.options.u16SampleSize     ));
        MOVS     R2,#+2
        LDR.W    R1,??DataTable31_38
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+12
        BL       MemoryCpy
//  903   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[11]),   (uint8_t*)&gOpt.options.bAsciiMode            ,sizeof(gOpt.options.bAsciiMode        ));
        MOVS     R2,#+1
        LDR.W    R1,??DataTable31_39
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+14
        BL       MemoryCpy
//  904   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[12]),   (uint8_t*)&gOpt.options.bBlinkingLEDs         ,sizeof(gOpt.options.bBlinkingLEDs     ));
        MOVS     R2,#+1
        LDR.W    R1,??DataTable31_40
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+15
        BL       MemoryCpy
//  905   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[13]),  (uint8_t*)&gOpt.options.u8OutputPower         ,sizeof(gOpt.options.u8OutputPower     ));
        MOVS     R2,#+1
        LDR.W    R1,??DataTable31_41
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+16
        BL       MemoryCpy
//  906   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[14]),  (uint8_t*)&gOpt.options.u32PngTimeout         ,sizeof(gOpt.options.u32PngTimeout     ));
        MOVS     R2,#+4
        LDR.W    R1,??DataTable31_42
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+17
        BL       MemoryCpy
//  907   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[18]),  (uint8_t*)&gOpt.options.u32SndTimeout         ,sizeof(gOpt.options.u32SndTimeout     ));
        MOVS     R2,#+4
        LDR.W    R1,??DataTable31_43
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+21
        BL       MemoryCpy
//  908   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[22]),  (uint8_t*)&gOpt.options.bLNAHighGainMode      ,sizeof(gOpt.options.bLNAHighGainMode  )); // i.e. Low Noise Amplifier - updated *** 10/26/10 *** (formerly "u8Reserved2")
        MOVS     R2,#+1
        LDR.W    R1,??DataTable31_44
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+25
        BL       MemoryCpy
//  909   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[23]),  (uint8_t*)&gOpt.options.u16SleepAfterAck      ,sizeof(gOpt.options.u16SleepAfterAck  ));
        MOVS     R2,#+2
        LDR.W    R1,??DataTable31_45
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+26
        BL       MemoryCpy
//  910   gAppTxPacket->u8DataLength = OPT_SIZE;
        MOVS     R0,#+25
        LDR.N    R1,??DataTable19_1
        LDR      R1,[R1, #+0]
        STRB     R0,[R1, #+0]
//  911   
//  912 }
        POP      {R0,PC}          ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17:
        DC32     gAppRxPacket

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_1:
        DC32     0x14bad

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_2:
        DC32     0x4004803c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_3:
        DC32     0x40037000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_4:
        DC32     0x40037100

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  913 smacErrors_t SendASCIIPacket(){
SendASCIIPacket:
        PUSH     {R4,LR}
        SUB      SP,SP,#+80
//  914   InitPacket();
        BL       InitPacket
//  915   gSnd.packetID=sentPackets;
        LDR.W    R0,??DataTable31_46
        LDRH     R0,[R0, #+0]
        LDR.N    R1,??DataTable19_5
        STRH     R0,[R1, #+6]
//  916   int len = sprintf(&gAppTxPacket->smacPdu.u8Data[0],
//  917             "SND\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%d\t%u\t%d\t%u\t%u\t%u\t%u\t%u\r\n",
//  918             gSnd.hdr.u16SensorID, gSnd.packetID,
//  919             gSnd.xmin, gSnd.xmax, gSnd.xmean,
//  920             gSnd.ymin, gSnd.ymax, gSnd.ymean, 
//  921             gSnd.ysum0, gSnd.ysum1,
//  922             gSnd.zmin, gSnd.zmax, gSnd.zmean,
//  923             gSnd.temperature, gSnd.battery_mV, gSnd.linkQdBm,
//  924             gSnd.totalTimeouts, gSnd.maxMissedCount,
//  925             gSnd.voltageWarning, gSnd.channel, gSnd.version);
        LDR.N    R0,??DataTable19_5
        LDRB     R0,[R0, #+68]
        STR      R0,[SP, #+72]
        LDR.N    R0,??DataTable19_5
        LDRB     R0,[R0, #+67]
        STR      R0,[SP, #+68]
        LDR.N    R0,??DataTable19_5
        LDRB     R0,[R0, #+66]
        STR      R0,[SP, #+64]
        LDR.N    R0,??DataTable19_5
        LDRH     R0,[R0, #+64]
        STR      R0,[SP, #+60]
        LDR.N    R0,??DataTable19_5
        LDRH     R0,[R0, #+62]
        STR      R0,[SP, #+56]
        LDR.N    R0,??DataTable19_5
        LDRSB    R0,[R0, #+60]
        STR      R0,[SP, #+52]
        LDR.N    R0,??DataTable19_5
        LDRH     R0,[R0, #+58]
        STR      R0,[SP, #+48]
        LDR.N    R0,??DataTable19_5
        LDRSH    R0,[R0, #+56]
        STR      R0,[SP, #+44]
        LDR.N    R0,??DataTable19_5
        LDRH     R0,[R0, #+44]
        STR      R0,[SP, #+40]
        LDR.N    R0,??DataTable19_5
        LDRH     R0,[R0, #+42]
        STR      R0,[SP, #+36]
        LDR.N    R0,??DataTable19_5
        LDRH     R0,[R0, #+40]
        STR      R0,[SP, #+32]
        LDR.N    R0,??DataTable19_5
        LDR      R0,[R0, #+36]
        STR      R0,[SP, #+28]
        LDR.N    R0,??DataTable19_5
        LDR      R0,[R0, #+32]
        STR      R0,[SP, #+24]
        LDR.N    R0,??DataTable19_5
        LDRH     R0,[R0, #+28]
        STR      R0,[SP, #+20]
        LDR.N    R0,??DataTable19_5
        LDRH     R0,[R0, #+26]
        STR      R0,[SP, #+16]
        LDR.N    R0,??DataTable19_5
        LDRH     R0,[R0, #+24]
        STR      R0,[SP, #+12]
        LDR.N    R0,??DataTable19_5
        LDRH     R0,[R0, #+12]
        STR      R0,[SP, #+8]
        LDR.N    R0,??DataTable19_5
        LDRH     R0,[R0, #+10]
        STR      R0,[SP, #+4]
        LDR.N    R0,??DataTable19_5
        LDRH     R0,[R0, #+8]
        STR      R0,[SP, #+0]
        LDR.N    R0,??DataTable19_5
        LDRH     R3,[R0, #+6]
        LDR.N    R0,??DataTable19_5
        LDRH     R2,[R0, #+4]
        LDR.W    R1,??DataTable31_47
        LDR.W    R0,??DataTable31_48
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+3
        BL       sprintf
        MOVS     R4,R0
//  926   gAppTxPacket->u8DataLength = len;
        LDR.W    R0,??DataTable31_48
        LDR      R0,[R0, #+0]
        STRB     R4,[R0, #+0]
//  927   smacErrors_t status=MCPSDataRequest(gAppTxPacket);    
        LDR.W    R0,??DataTable31_48
        LDR      R0,[R0, #+0]
        BL       MCPSDataRequest
//  928   return status;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADD      SP,SP,#+80
        POP      {R4,PC}          ;; return
//  929     
//  930 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable18:
        DC32     0x28488

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable18_1:
        DC32     gOpt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable18_2:
        DC32     0x40037108

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  931 smacErrors_t SendBinaryPacket(){
SendBinaryPacket:
        PUSH     {R7,LR}
//  932   //InitPacket();
//  933   gSnd.packetID=sentPackets;
        LDR.W    R0,??DataTable31_46
        LDRH     R0,[R0, #+0]
        LDR.N    R1,??DataTable19_5
        STRH     R0,[R1, #+6]
//  934   gSnd.linkQdBm=GetLinkQdBm();
        BL       GetLinkQdBm
        LDR.N    R1,??DataTable19_5
        STRB     R0,[R1, #+60]
//  935   SndSwapEndianness();
        BL       SndSwapEndianness
//  936   CopyBinaryPacketToSMAC();  
        BL       CopyBinaryPacketToSMAC
//  937   smacErrors_t status=MCPSDataRequest(gAppTxPacket);    
        LDR.N    R0,??DataTable19_1
        LDR      R0,[R0, #+0]
        BL       MCPSDataRequest
//  938   appState = WAIT_FOR_ACK;
        MOVS     R1,#+1
        LDR.W    R2,??DataTable31_49
        STRB     R1,[R2, #+0]
//  939   return status;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R1,PC}          ;; return
//  940 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable19:
        DC32     gRxTimeout

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable19_1:
        DC32     gAppTxPacket

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable19_2:
        DC32     0x400ff0c0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable19_3:
        DC32     0x1fff9200

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable19_4:
        DC32     0x1fff80f1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable19_5:
        DC32     gSnd
//  941 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  942 void InitPacket(){
//  943   gSnd.hdr.u8Prefix[0] = 'S';
InitPacket:
        MOVS     R0,#+83
        LDR.W    R1,??DataTable31_50
        STRB     R0,[R1, #+0]
//  944   gSnd.hdr.u8Prefix[1] = 'N';
        MOVS     R0,#+78
        LDR.W    R1,??DataTable31_50
        STRB     R0,[R1, #+1]
//  945   gSnd.hdr.u8Prefix[2] = 'D';       
        MOVS     R0,#+68
        LDR.W    R1,??DataTable31_50
        STRB     R0,[R1, #+2]
//  946   gSnd.hdr.u8Length = SND_SIZE;
        MOVS     R0,#+62
        LDR.W    R1,??DataTable31_50
        STRB     R0,[R1, #+3]
//  947   gSnd.hdr.u16SensorID = sensorID;  
        LDR.W    R0,??DataTable31_51
        LDRH     R0,[R0, #+0]
        LDR.W    R1,??DataTable31_50
        STRH     R0,[R1, #+4]
//  948   
//  949   gSnd.xsum0 = 1111111;
        LDR.W    R0,??DataTable31_52  ;; 0x10f447
        LDR.W    R1,??DataTable31_50
        STR      R0,[R1, #+16]
//  950   gSnd.ysum0 = 2222222;
        LDR.W    R0,??DataTable31_53  ;; 0x21e88e
        LDR.W    R1,??DataTable31_50
        STR      R0,[R1, #+32]
//  951   gSnd.zsum0 = 3333333;
        LDR.W    R0,??DataTable31_54  ;; 0x32dcd5
        LDR.W    R1,??DataTable31_50
        STR      R0,[R1, #+48]
//  952   gSnd.xsum1 = 111111111;
        LDR.W    R0,??DataTable31_55  ;; 0x69f6bc7
        LDR.W    R1,??DataTable31_50
        STR      R0,[R1, #+20]
//  953   gSnd.ysum1 = 222222222;
        LDR.W    R0,??DataTable31_56  ;; 0xd3ed78e
        LDR.W    R1,??DataTable31_50
        STR      R0,[R1, #+36]
//  954   gSnd.zsum1 = 333333333;
        LDR.W    R0,??DataTable31_57  ;; 0x13de4355
        LDR.W    R1,??DataTable31_50
        STR      R0,[R1, #+52]
//  955   gSnd.xmin = 1000;
        MOV      R0,#+1000
        LDR.W    R1,??DataTable31_50
        STRH     R0,[R1, #+8]
//  956   gSnd.ymin = 2000;
        MOV      R0,#+2000
        LDR.W    R1,??DataTable31_50
        STRH     R0,[R1, #+24]
//  957   gSnd.zmin = 3000;
        MOVW     R0,#+3000
        LDR.W    R1,??DataTable31_50
        STRH     R0,[R1, #+40]
//  958   gSnd.xmax = 9991;
        MOVW     R0,#+9991
        LDR.W    R1,??DataTable31_50
        STRH     R0,[R1, #+10]
//  959   gSnd.ymax = 9992;
        MOVW     R0,#+9992
        LDR.W    R1,??DataTable31_50
        STRH     R0,[R1, #+26]
//  960   gSnd.zmax = 9993;
        MOVW     R0,#+9993
        LDR.W    R1,??DataTable31_50
        STRH     R0,[R1, #+42]
//  961   gSnd.xmean = 111;
        MOVS     R0,#+111
        LDR.W    R1,??DataTable31_50
        STRH     R0,[R1, #+12]
//  962   gSnd.ymean = 222;
        MOVS     R0,#+222
        LDR.W    R1,??DataTable31_50
        STRH     R0,[R1, #+28]
//  963   gSnd.zmean = 333;
        MOVW     R0,#+333
        LDR.W    R1,??DataTable31_50
        STRH     R0,[R1, #+44]
//  964   gSnd.packetID=666;
        MOVW     R0,#+666
        LDR.W    R1,??DataTable31_50
        STRH     R0,[R1, #+6]
//  965   gSnd.temperature=375;
        MOVW     R0,#+375
        LDR.W    R1,??DataTable31_50
        STRH     R0,[R1, #+56]
//  966   gSnd.battery_mV=3000;
        MOVW     R0,#+3000
        LDR.W    R1,??DataTable31_50
        STRH     R0,[R1, #+58]
//  967  // gSnd.linkQdBm=-75;
//  968   gSnd.totalTimeouts=3;
        MOVS     R0,#+3
        LDR.W    R1,??DataTable31_50
        STRH     R0,[R1, #+62]
//  969   gSnd.maxMissedCount=3;
        MOVS     R0,#+3
        LDR.W    R1,??DataTable31_50
        STRH     R0,[R1, #+64]
//  970   gSnd.voltageWarning=2;
        MOVS     R0,#+2
        LDR.W    R1,??DataTable31_50
        STRB     R0,[R1, #+66]
//  971   gSnd.channel=gChannel11_c - 11;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable31_50
        STRB     R0,[R1, #+67]
//  972   gSnd.version=9;
        MOVS     R0,#+9
        LDR.W    R1,??DataTable31_50
        STRB     R0,[R1, #+68]
//  973   
//  974   evDataFromCOMM = FALSE;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable31_58
        STRB     R0,[R1, #+0]
//  975 }
        BX       LR               ;; return

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  976 void FlashSaveOptions(){
FlashSaveOptions:
        PUSH     {R4-R6,LR}
        SUB      SP,SP,#+32
//  977   
//  978   uint32_t statErase, statRead, statWrite;
//  979   NvConfig_t mNvConfig = {
//  980    gNV_FTFX_REG_BASE_c,
//  981    gNV_PFLASH_BLOCK_BASE_c,
//  982    gNV_PFLASH_BLOCK_SIZE_c,
//  983    gNV_DFLASH_BLOCK_BASE_c,
//  984    gNV_DFLASH_BLOCK_SIZE_c,
//  985    gNV_EERAM_BLOCK_BASE_c,
//  986    gNV_EERAM_BLOCK_SIZE_c,
//  987    gNV_EEE_BLOCK_SIZE_c
//  988   };
        ADD      R0,SP,#+0
        LDR.W    R1,??DataTable31_59
        MOVS     R2,#+32
        BL       __aeabi_memcpy4
//  989   gFlashDeadBeef=g_DEAD_BEEF;
        LDR.W    R0,??DataTable31_60
        LDR      R0,[R0, #+0]
        LDR.W    R1,??DataTable31_61
        STR      R0,[R1, #+0]
//  990   statErase = NV_FlashEraseSector(&mNvConfig, settingsAddress,0x800);
        MOV      R2,#+2048
        LDR.W    R0,??DataTable31_62
        LDR      R1,[R0, #+0]
        ADD      R0,SP,#+0
        BL       NV_FlashEraseSector
        MOVS     R4,R0
//  991   uint32_t address = settingsAddress;
        LDR.W    R0,??DataTable31_62
        LDR      R6,[R0, #+0]
//  992   statWrite = NV_FlashProgramLongword(&mNvConfig,settingsAddress,sizeof(gFlashDeadBeef),(uint32_t)&gFlashDeadBeef);
        LDR.W    R3,??DataTable31_61
        MOVS     R2,#+4
        LDR.W    R0,??DataTable31_62
        LDR      R1,[R0, #+0]
        ADD      R0,SP,#+0
        BL       NV_FlashProgramLongword
        MOVS     R5,R0
//  993   address = address + sizeof(gFlashDeadBeef);
        ADDS     R6,R6,#+4
//  994   if(statWrite ==gNV_OK_c) NV_FlashProgramUnalignedLongword(&mNvConfig,address,sizeof(gOptions),(uint32_t)&gOptions);
        CMP      R5,#+0
        BNE.N    ??FlashSaveOptions_0
        LDR.W    R3,??DataTable31_63
        MOVS     R2,#+24
        MOVS     R1,R6
        ADD      R0,SP,#+0
        BL       NV_FlashProgramUnalignedLongword
//  995 //  NV_FlashRead(address, (uint8_t*)&gFlashOptions,sizeof(gFlashOptions));
//  996   
//  997 }
??FlashSaveOptions_0:
        ADD      SP,SP,#+32
        POP      {R4-R6,PC}       ;; return

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  998 void GetFactoryOptions(tOptions* pOptions)
//  999 {
// 1000     // Load the factory default configuration options
// 1001     pOptions->u8RawSpinCount = 0; // i.e., don't send raw accelerometer data - updated *** 06/08/11 ***
GetFactoryOptions:
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
// 1002     pOptions->u16TimeoutsToKill = TIMEOUTS_TO_KILL;
        MOV      R1,#+360
        STRH     R1,[R0, #+2]
// 1003     pOptions->u16SampleSize = ACCEL_SAMPLE_SIZE;
        MOV      R1,#+8000
        STRH     R1,[R0, #+4]
// 1004     pOptions->bAsciiMode = TRUE;
        MOVS     R1,#+1
        STRB     R1,[R0, #+6]
// 1005     pOptions->bBlinkingLEDs = TRUE;
        MOVS     R1,#+1
        STRB     R1,[R0, #+7]
// 1006     pOptions->u8OutputPower = OUTPUT_POWER;
        MOVS     R1,#+100
        STRB     R1,[R0, #+8]
// 1007     pOptions->u32PngTimeout = PNG_TIMEOUT;
        MOVW     R1,#+33000
        STR      R1,[R0, #+12]
// 1008     pOptions->u32SndTimeout = SND_TIMEOUT;
        LDR.W    R1,??DataTable31_64  ;; 0x28488
        STR      R1,[R0, #+16]
// 1009 
// 1010 // Updated *** 10/26/10 ***    
// 1011 #if defined (PANASONIC_REVB)
// 1012     pOptions->bLNAHighGainMode = TRUE;
// 1013 #elif defined (PANASONIC_YES)
// 1014     pOptions->bLNAHighGainMode = TRUE;
// 1015 #else
// 1016     pOptions->bLNAHighGainMode = FALSE; // Note: LNA isn't even available for PANASONIC_NO
        MOVS     R1,#+0
        STRB     R1,[R0, #+20]
// 1017 #endif
// 1018 
// 1019     pOptions->u16SleepAfterAck = SLEEP_AFTER_ACK;
        MOVS     R1,#+3
        STRH     R1,[R0, #+22]
// 1020     
// 1021     return;
        BX       LR               ;; return
// 1022 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable22:
        DC32     0x4003710c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable22_1:
        DC32     ?_0
// 1023 
// 1024 
// 1025 
// 1026 /************************************************************************************
// 1027 * InitProject
// 1028 * 
// 1029 * Hardware and Global data initialization
// 1030 *
// 1031 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(2)
        THUMB
// 1032 void InitProject(void)
// 1033 {
InitProject:
        PUSH     {R4-R8,LR}
        SUB      SP,SP,#+32
// 1034     DisableInterrupts();
        CPSID i
// 1035    
// 1036    gOpt.hdr.u8Prefix[0] = 'O';
        MOVS     R0,#+79
        LDR.W    R1,??DataTable31_65
        STRB     R0,[R1, #+0]
// 1037    gOpt.hdr.u8Prefix[1] = 'P';
        MOVS     R0,#+80
        LDR.W    R1,??DataTable31_65
        STRB     R0,[R1, #+1]
// 1038    gOpt.hdr.u8Prefix[2] = 'T';
        MOVS     R0,#+84
        LDR.W    R1,??DataTable31_65
        STRB     R0,[R1, #+2]
// 1039    gOpt.hdr.u16SensorID = sensorID;
        LDR.W    R0,??DataTable31_51
        LDRH     R0,[R0, #+0]
        LDR.W    R1,??DataTable31_65
        STRH     R0,[R1, #+4]
// 1040    gOpt.hdr.u8Length = OPT_SIZE;
        MOVS     R0,#+25
        LDR.W    R1,??DataTable31_65
        STRB     R0,[R1, #+3]
// 1041    
// 1042    gPng.u8Prefix[0] = 'P';
        MOVS     R0,#+80
        LDR.W    R1,??DataTable31
        STRB     R0,[R1, #+0]
// 1043    gPng.u8Prefix[1] = 'N';
        MOVS     R0,#+78
        LDR.W    R1,??DataTable31
        STRB     R0,[R1, #+1]
// 1044    gPng.u8Prefix[2] = 'G';
        MOVS     R0,#+71
        LDR.N    R1,??DataTable31
        STRB     R0,[R1, #+2]
// 1045    gPng.u16SensorID = sensorID;        // initialized via compiler settings (1 - 65534)
        LDR.W    R0,??DataTable31_51
        LDRH     R0,[R0, #+0]
        LDR.N    R1,??DataTable31
        STRH     R0,[R1, #+4]
// 1046     
// 1047     
// 1048   // Bob's code
// 1049    uint8_t u8Status;
// 1050    uint8_t u8BlinkOnFirstAck = 1;
        MOVS     R4,#+1
// 1051    uint16_t sleepCount;
// 1052    uint16_t missedCount = 0;
        MOVS     R5,#+0
// 1053   // Detect if we need a factory reset
// 1054    uint32_t statErase, statWrite;
// 1055    NvConfig_t mNvConfig = {
// 1056    gNV_FTFX_REG_BASE_c,
// 1057    gNV_PFLASH_BLOCK_BASE_c,
// 1058    gNV_PFLASH_BLOCK_SIZE_c,
// 1059    gNV_DFLASH_BLOCK_BASE_c,
// 1060    gNV_DFLASH_BLOCK_SIZE_c,
// 1061    gNV_EERAM_BLOCK_BASE_c,
// 1062    gNV_EERAM_BLOCK_SIZE_c,
// 1063    gNV_EEE_BLOCK_SIZE_c
// 1064   };
        ADD      R0,SP,#+0
        LDR.W    R1,??DataTable31_66
        MOVS     R2,#+32
        BL       __aeabi_memcpy4
// 1065   NV_FlashInit(&mNvConfig);
        ADD      R0,SP,#+0
        BL       NV_FlashInit
// 1066   static uint32_t sDeadBeef;
// 1067 //   
// 1068 //   statErase = NV_FlashEraseSector(&mNvConfig, settingsAddress,0x800);
// 1069 //   statWrite = NV_FlashProgramLongword(&mNvConfig,settingsAddress,sizeof(sDeadBeef),(uint32_t)&sDeadBeef);
// 1070    NV_FlashRead(settingsAddress,(uint8_t*)&gFlashDeadBeef,sizeof(gFlashDeadBeef));
        MOVS     R2,#+4
        LDR.W    R1,??DataTable31_61
        LDR.W    R0,??DataTable31_62
        LDR      R0,[R0, #+0]
        BL       NV_FlashRead
// 1071    uint8_t bFactoryReset = (sDeadBeef == g_DEAD_BEEF) || (gFlashDeadBeef != g_DEAD_BEEF);
        LDR.W    R0,??DataTable31_67
        LDR      R0,[R0, #+0]
        LDR.W    R1,??DataTable31_60
        LDR      R1,[R1, #+0]
        CMP      R0,R1
        BEQ.N    ??InitProject_0
        LDR.W    R0,??DataTable31_61
        LDR      R0,[R0, #+0]
        LDR.W    R1,??DataTable31_60
        LDR      R1,[R1, #+0]
        CMP      R0,R1
        BEQ.N    ??InitProject_1
??InitProject_0:
        MOVS     R6,#+1
        B.N      ??InitProject_2
??InitProject_1:
        MOVS     R6,#+0
// 1072    sDeadBeef = g_DEAD_BEEF;
??InitProject_2:
        LDR.W    R0,??DataTable31_60
        LDR      R0,[R0, #+0]
        LDR.W    R1,??DataTable31_67
        STR      R0,[R1, #+0]
// 1073    if (bFactoryReset)
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BEQ.N    ??InitProject_3
// 1074    {
// 1075        GetFactoryOptions(&gOptions);
        LDR.W    R0,??DataTable31_63
        BL       GetFactoryOptions
        B.N      ??InitProject_4
// 1076    }
// 1077    else
// 1078    {
// 1079  //      gOptions = gFlashOptions;      
// 1080       NV_FlashRead(settingsAddress+sizeof(gFlashDeadBeef),(uint8_t*)&gOptions,sizeof(gOptions));
??InitProject_3:
        MOVS     R2,#+24
        LDR.W    R1,??DataTable31_63
        LDR.W    R0,??DataTable31_62
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+4
        BL       NV_FlashRead
// 1081    }
// 1082   InitPacket(); 
??InitProject_4:
        BL       InitPacket
// 1083  
// 1084   /* SPI Initialization */ 
// 1085   MC1324xDrv_SPIInit(); 
        BL       MC1324xDrv_SPIInit
// 1086   (void)MLMERadioInit();
        BL       MLMERadioInit
        MOV      R8,R0
// 1087   /* TMR Initialization */
// 1088   TMR_Init(); 
        BL       TMR_Init
// 1089   MM_Init((uint8_t*)maMacHeap, poolInfo, maMmPools);
        LDR.W    R2,??DataTable31_68
        LDR.W    R1,??DataTable31_69
        LDR.W    R0,??DataTable31_70
        BL       MM_Init
// 1090   /*LED configuration*/
// 1091   LED_Init();
        BL       LED_Init
// 1092 #if defined(gCDCInterface_d)
// 1093   USB_Init();
// 1094   (void)CDC_ModuleInit();
// 1095 #elif defined (gUARTInterface_d)
// 1096   /* UART Initialization */
// 1097   Uart_ModuleInit();
        BL       Uart_ModuleInit
// 1098 #endif
// 1099   Comm_SetBaud(Comm_DefaultBaud);
        MOVS     R0,#+115200
        BL       Uart1_SetBaud
// 1100   Comm_SetRxCallBack(CommRxCallback);
        ADR.W    R0,CommRxCallback
        BL       Uart1_SetRxCallBack
// 1101 
// 1102   /* Keyboard Initialization */
// 1103   KeyboardInit();
        BL       KeyboardInit
// 1104   GlobalDataInit();  
        BL       GlobalDataInit
// 1105   
// 1106 
// 1107 //  evDataFromCOMM = FALSE;
// 1108   
// 1109   EnableInterrupts();
        CPSIE i
// 1110   int count = 10;
        MOVS     R7,#+10
// 1111   while (count--)
??InitProject_5:
        MOVS     R0,R7
        SUBS     R7,R0,#+1
        CMP      R0,#+0
        BEQ.N    ??InitProject_6
// 1112   {
// 1113       uint16_t innerCount = 0;        
        MOVS     R0,#+0
// 1114       while (--innerCount);
??InitProject_7:
        SUBS     R0,R0,#+1
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        CMP      R0,#+0
        BNE.N    ??InitProject_7
        B.N      ??InitProject_5
// 1115   }
// 1116   FlashSaveOptions();
??InitProject_6:
        BL       FlashSaveOptions
// 1117   sDeadBeef = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable31_67
        STR      R0,[R1, #+0]
// 1118  //  
// 1119  //  // Initialize options.
// 1120  //  // NOTE: we can't write to FLASH memory yet ("AppInit" not called yet, clock, etc),
// 1121  //  // so we don't call "FlashSaveOptions" yet.
// 1122    
// 1123    
// 1124    
// 1125    
// 1126 }
        ADD      SP,SP,#+32
        POP      {R4-R8,PC}       ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable23:
        DC32     ??b

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
??sDeadBeef:
        DS8 4

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1127 void GlobalDataInit(void)
// 1128 {
// 1129   /*Global Data init*/
// 1130   testOpMode     = gDefaultMode_c;
GlobalDataInit:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable31_71
        STRB     R0,[R1, #+0]
// 1131   testChannel    = gDefaultChannelNumber_c;
        MOVS     R0,#+15
        LDR.W    R1,??DataTable31_72
        STRB     R0,[R1, #+0]
// 1132   testPower      = gDefaultOutputPower_c;
        MOVS     R0,#+23
        LDR.N    R1,??DataTable31_73
        STRB     R0,[R1, #+0]
// 1133   testTrimmValue = gDefaultCrysTrim_c;
        MOVS     R0,#+115
        LDR.N    R1,??DataTable31_74
        STRB     R0,[R1, #+0]
// 1134   testPayloadLen = gDefaultPayload_c;
        MOVS     R0,#+20
        LDR.N    R1,??DataTable31_75
        STRB     R0,[R1, #+0]
// 1135   contTestRunning = gTestModeForceIdle_c;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable31_76
        STRB     R0,[R1, #+0]
// 1136   shortCutsEnabled = FALSE; 
        MOVS     R0,#+0
        LDR.N    R1,??DataTable31_77
        STRB     R0,[R1, #+0]
// 1137   connState      = gConnInitState_c;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable31_78
        STRB     R0,[R1, #+0]
// 1138   cTxRxState     = gCTxRxStateInit_c;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable31_79
        STRB     R0,[R1, #+0]
// 1139   perTxState     = gPerTxStateInit_c;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable31_80
        STRB     R0,[R1, #+0]
// 1140   perRxState     = gPerRxStateInit_c;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable31_81
        STRB     R0,[R1, #+0]
// 1141   rangeTxState   = gRangeTxStateInit_c;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable31_82
        STRB     R0,[R1, #+0]
// 1142   rangeRxState   = gRangeRxStateInit_c;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable31_83
        STRB     R0,[R1, #+0]
// 1143   prevOpMode      = gDefaultMode_c;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable31_84
        STRB     R0,[R1, #+0]
// 1144   txTestIndex    = gPacketErrorRateTx_c;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable31_85
        STRB     R0,[R1, #+0]
// 1145   rxTestIndex    = gPacketErrorRateRx_c;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable31_86
        STRB     R0,[R1, #+0]
// 1146 }
        BX       LR               ;; return
// 1147 /**************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1148 void InitSmac(void)
// 1149 {
InitSmac:
        PUSH     {R3-R5,LR}
// 1150   gAppTxPacket = (txPacket_t*)gau8TxDataBuffer;
        LDR.N    R0,??DataTable31_87
        LDR.N    R1,??DataTable25
        STR      R0,[R1, #+0]
// 1151   gAppRxPacket = (rxPacket_t*)gau8RxDataBuffer; 
        LDR.N    R0,??DataTable31_88
        LDR.N    R1,??DataTable31_89
        STR      R0,[R1, #+0]
// 1152   gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
        MOVS     R0,#+123
        LDR.N    R1,??DataTable31_89
        LDR      R1,[R1, #+0]
        STRB     R0,[R1, #+0]
// 1153   
// 1154   MLMESetPromiscuousMode(gPromiscuousMode_d); 
        MOVS     R0,#+0
        BL       MLMESetPromiscuousMode
// 1155   (void)MLMESetChannelRequest(testChannel);
        LDR.N    R0,??DataTable31_72
        LDRB     R0,[R0, #+0]
        BL       MLMESetChannelRequest
        MOVS     R4,R0
// 1156   (void)MLMEPAOutputAdjust(testPower);
        LDR.N    R0,??DataTable31_73
        LDRB     R0,[R0, #+0]
        BL       MLMEPAOutputAdjust
        MOVS     R5,R0
// 1157   (void)MLMEXtalAdjust(testTrimmValue); 
        LDR.N    R0,??DataTable31_74
        LDRB     R0,[R0, #+0]
        BL       MLMEXtalAdjust
// 1158 }
        POP      {R0,R4,R5,PC}    ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25:
        DC32     gAppTxPacket
// 1159 
// 1160 /**************************************************************************************/
// 1161 void SerialUIStateMachine(void)
// 1162 {
// 1163   if((gConnSelectTest_c == connState) && evTestParameters)
// 1164   {
// 1165     (void)MLMESetChannelRequest(testChannel);
// 1166     (void)MLMEPAOutputAdjust(testPower);
// 1167     (void)MLMEXtalAdjust(testTrimmValue);
// 1168     PrintTestParameters(TRUE);
// 1169     evTestParameters = FALSE;
// 1170   }
// 1171   switch(connState){
// 1172     case gConnIdleState_c:
// 1173        PrintMenu(cu8MainMenu, gDefaultCommPort_c);
// 1174        PrintTestParameters(FALSE);
// 1175        shortCutsEnabled = TRUE;           
// 1176        connState = gConnSelectTest_c;
// 1177     break;
// 1178     case gConnSelectTest_c:
// 1179      if(evDataFromCOMM){
// 1180        if('1' == gu8CommData){
// 1181          cTxRxState = gCTxRxStateInit_c;
// 1182          connState = gConnContinuousTxRxState_c;
// 1183        }else if('2' == gu8CommData){
// 1184          perTxState = gPerTxStateInit_c;
// 1185          perRxState = gPerRxStateInit_c;
// 1186          connState = gConnPerState_c;
// 1187        }else if('3' == gu8CommData){
// 1188          rangeTxState = gRangeTxStateInit_c;
// 1189          rangeRxState = gRangeRxStateInit_c;
// 1190          connState = gConnRangeState_c;
// 1191        }else if('4' == gu8CommData){
// 1192          eRState = gERStateInit_c;
// 1193          connState = gConnRegEditState_c;
// 1194        }
// 1195        evDataFromCOMM = FALSE;
// 1196      }
// 1197     break;
// 1198     case gConnContinuousTxRxState_c:
// 1199        if(SerialContinuousTxRxTest()) {
// 1200            connState = gConnIdleState_c;
// 1201        }
// 1202     break;
// 1203     case gConnPerState_c:
// 1204        if(mTxOperation_c == testOpMode){
// 1205          if(PacketErrorRateTx()){
// 1206            connState = gConnIdleState_c;
// 1207          }
// 1208        }else{
// 1209          if(PacketErrorRateRx()){
// 1210            connState = gConnIdleState_c;
// 1211          }
// 1212        }
// 1213     break;
// 1214     case gConnRangeState_c:
// 1215        if(mTxOperation_c == testOpMode){
// 1216          if(RangeTx()){
// 1217            connState = gConnIdleState_c;
// 1218          }
// 1219        }else{
// 1220          if(RangeRx()){
// 1221            connState = gConnIdleState_c;
// 1222          }
// 1223        }
// 1224     break;
// 1225     case gConnRegEditState_c:
// 1226        if(EditRegisters()) {
// 1227            connState = gConnIdleState_c;
// 1228        }
// 1229     break;
// 1230     default:
// 1231     break;
// 1232     
// 1233   }
// 1234   if(prevOpMode != testOpMode){
// 1235     perTxState = gPerTxStateInit_c;
// 1236     perRxState = gPerRxStateInit_c;
// 1237     rangeTxState = gRangeTxStateInit_c;
// 1238     rangeRxState = gRangeRxStateInit_c;
// 1239     prevOpMode = testOpMode;
// 1240   }
// 1241 }
// 1242 
// 1243 
// 1244 /**************************************************************************************/
// 1245 bool_t SerialContinuousTxRxTest(void)
// 1246 {
// 1247   bool_t bBackFlag = FALSE;
// 1248   smacErrors_t smacResult;
// 1249   uint8_t u8Index, u8TempEnergyValue;
// 1250   
// 1251   if(evTestParameters)
// 1252   {
// 1253     (void)MLMERXDisableRequest();
// 1254     (void)MLMETestMode(gTestModeForceIdle_c);
// 1255     (void)MLMESetChannelRequest(testChannel);
// 1256     (void)MLMEPAOutputAdjust(testPower);
// 1257     (void)MLMEXtalAdjust(testTrimmValue);
// 1258     
// 1259     if(gCTxRxStateSelectTest_c == cTxRxState){
// 1260       PrintTestParameters(TRUE);
// 1261     }else{
// 1262       PrintTestParameters(FALSE);
// 1263       CommUtil_Print("\r\n", gAllowToBlock_d);     
// 1264     }
// 1265     
// 1266     if(gTestModePRBS9_c == contTestRunning){
// 1267       (void)MLMETestMode(gTestModePRBS9_c);
// 1268     }else if(gTestModeContinuousTxModulated_c == contTestRunning){
// 1269       (void)MLMETestMode(gTestModeContinuousTxModulated_c);
// 1270     }else if(gTestModeContinuousTxUnmodulated_c == contTestRunning){
// 1271       (void)MLMETestMode(gTestModeContinuousTxUnmodulated_c);
// 1272     }
// 1273     
// 1274     if(gCTxRxStateRunnigRxTest_c == cTxRxState){
// 1275       bRxDone = FALSE;
// 1276       gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
// 1277       (void)MLMERXEnableRequest(gAppRxPacket, 0);
// 1278     }
// 1279     evTestParameters = FALSE;
// 1280   }
// 1281   
// 1282   switch(cTxRxState)
// 1283   {
// 1284     case gCTxRxStateIdle_c:
// 1285          if((evDataFromCOMM) && ('\r' == gu8CommData))
// 1286          {
// 1287            cTxRxState = gCTxRxStateInit_c;
// 1288            evDataFromCOMM = FALSE;  
// 1289          }
// 1290     break;
// 1291     case gCTxRxStateInit_c:
// 1292          PrintMenu(cu8ShortCutsBar, gDefaultCommPort_c);
// 1293          PrintMenu(cu8ContinuousTestMenu, gDefaultCommPort_c);
// 1294          
// 1295          (void)MLMETestMode(gTestModeForceIdle_c);  
// 1296          
// 1297          while(MLMESetChannelRequest(testChannel)); 
// 1298          
// 1299          (void)MLMETestMode(contTestRunning);
// 1300          CommUtil_Print(cu8ContinuousTestTags[contTestRunning], gAllowToBlock_d);
// 1301          CommUtil_Print("\r\n\r\n", gAllowToBlock_d);       
// 1302          PrintTestParameters(FALSE);
// 1303          shortCutsEnabled = TRUE;           
// 1304          cTxRxState = gCTxRxStateSelectTest_c; 
// 1305     break;
// 1306     case gCTxRxStateSelectTest_c:
// 1307          if(evDataFromCOMM)
// 1308          {           
// 1309            if('1' == gu8CommData){
// 1310              contTestRunning = gTestModeForceIdle_c;              
// 1311              cTxRxState = gCTxRxStateInit_c;
// 1312            }else if('2' == gu8CommData){
// 1313              contTestRunning = gTestModePRBS9_c;               
// 1314              cTxRxState = gCTxRxStateInit_c;
// 1315            }else if('3' == gu8CommData){
// 1316              contTestRunning = gTestModeContinuousTxModulated_c;               
// 1317              cTxRxState = gCTxRxStateInit_c;
// 1318            }else if('4' == gu8CommData){
// 1319              if(gTestModeContinuousTxUnmodulated_c != contTestRunning) 
// 1320              { 
// 1321               contTestRunning = gTestModeContinuousTxUnmodulated_c;               
// 1322               cTxRxState = gCTxRxStateInit_c;
// 1323              }
// 1324            }else if('5' == gu8CommData)
// 1325            {
// 1326              (void)MLMETestMode(gTestModeForceIdle_c);     
// 1327              contTestRunning = gTestModeForceIdle_c;
// 1328              CommUtil_Print("\f\r\nPress [p] to stop receiving promiscuous packets \r\n", gAllowToBlock_d);
// 1329                     
// 1330              MLMESetPromiscuousMode(TRUE);    
// 1331              
// 1332              bRxDone = FALSE;
// 1333              gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
// 1334              (void)MLMERXEnableRequest(gAppRxPacket, 0);
// 1335              cTxRxState = gCTxRxStateRunnigRxTest_c;
// 1336            }else if('6' == gu8CommData){
// 1337              (void)MLMETestMode(gTestModeForceIdle_c);
// 1338              contTestRunning = gTestModeForceIdle_c;
// 1339              CommUtil_Print("\f\r\nPress [p] to stop the Continuous ED test\r\n", gAllowToBlock_d);
// 1340              contTestRunning = gTestModeForceIdle_c;                
// 1341              cTxRxState = gCTxRxStateRunnigEdTest_c;
// 1342            }else if('7' == gu8CommData){
// 1343              (void)MLMETestMode(gTestModeForceIdle_c);
// 1344              contTestRunning = gTestModeForceIdle_c;
// 1345              CommUtil_Print("\f\r\nPress [p] to stop the Continuous SCAN test\r\n", gAllowToBlock_d);
// 1346              bScanDone = FALSE;
// 1347              smacResult = MLMEScanRequest(0xFFFF, gScanModeED_c, au8ScanResults);
// 1348              (void)smacResult;
// 1349              contTestRunning = gTestModeForceIdle_c;                
// 1350              cTxRxState = gCTxRxStateRunnigScanTest_c;
// 1351            }else if('p' == gu8CommData){ 
// 1352              (void)MLMETestMode(gTestModeForceIdle_c);
// 1353              (void)MLMESetChannelRequest(testChannel);
// 1354              bBackFlag = TRUE;
// 1355            }
// 1356            evDataFromCOMM = FALSE;
// 1357          }
// 1358     break;
// 1359     case gCTxRxStateRunnigRxTest_c:
// 1360          if(bRxDone){
// 1361            if (gAppRxPacket->rxStatus == rxSuccessStatus_c){
// 1362              CommUtil_Print("New Packet: ", gAllowToBlock_d);
// 1363              for(u8Index = 0; u8Index < (gAppRxPacket->u8DataLength); u8Index++){
// 1364                PrintByteOnHexFormatBlocking(gAppRxPacket->smacPdu.u8Data[u8Index], TRUE, gAllowToBlock_d);
// 1365              }
// 1366              CommUtil_Print("\b \r\n", gAllowToBlock_d);
// 1367            }
// 1368            bRxDone = FALSE;
// 1369            gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
// 1370            (void)MLMERXEnableRequest(gAppRxPacket, 0);
// 1371          }
// 1372          if((evDataFromCOMM) && ('p' == gu8CommData)){
// 1373            (void)MLMERXDisableRequest();
// 1374            (void)MLMETestMode(gTestModeForceIdle_c);
// 1375            MLMESetPromiscuousMode(FALSE);
// 1376            CommUtil_Print("\r\n\r\n Press [enter] to go back to the Continuous test menu ", gAllowToBlock_d);
// 1377            cTxRxState = gCTxRxStateIdle_c;
// 1378            evDataFromCOMM = FALSE;
// 1379          }
// 1380     break;
// 1381     case gCTxRxStateRunnigEdTest_c:
// 1382          delayMs(100);delayMs(100);
// 1383          CommUtil_Print("Energy on the Channel ", gAllowToBlock_d);
// 1384          PrintWordOnDecimalFormatBlocking((uint16_t)testChannel, 0, FALSE, gDefaultCommPort_c);
// 1385          CommUtil_Print(" : ", gAllowToBlock_d);
// 1386          (void)MLMEEnergyDetect(&u8TempEnergyValue);
// 1387          PrintWordOnDecimalFormatBlocking(u8TempEnergyValue,0,TRUE, gDefaultCommPort_c);
// 1388          CommUtil_Print("dBm\r\n", gAllowToBlock_d);
// 1389          if((evDataFromCOMM) && ('p' == gu8CommData)){
// 1390            CommUtil_Print("\r\n\r\n Press [enter] to go back to the Continuous test menu ", gAllowToBlock_d);
// 1391            cTxRxState = gCTxRxStateIdle_c;
// 1392            evDataFromCOMM = FALSE;
// 1393          }
// 1394     break;
// 1395     case gCTxRxStateRunnigScanTest_c:
// 1396          if(bScanDone){
// 1397            CommUtil_Print("Results : ", gAllowToBlock_d);
// 1398            for(u8Index = 0; u8Index < 16 ; u8Index++){
// 1399              PrintWordOnDecimalFormatBlocking((uint16_t)(au8ScanResults[u8Index]),0,TRUE, gDefaultCommPort_c);
// 1400              CommUtil_Print(",", gAllowToBlock_d);   
// 1401            }
// 1402            CommUtil_Print("\b \r\n", gAllowToBlock_d);
// 1403            if((evDataFromCOMM) && ('p' == gu8CommData)){
// 1404              CommUtil_Print("\r\n\r\n Press [enter] to go back to the Continuous test menu ", gAllowToBlock_d);
// 1405              cTxRxState = gCTxRxStateIdle_c;
// 1406              evDataFromCOMM = FALSE;
// 1407            }else{
// 1408              delayMs(100);delayMs(100);delayMs(50);
// 1409              bScanDone = FALSE;
// 1410              smacResult = MLMEScanRequest(0xFFFF, gScanModeED_c, au8ScanResults);
// 1411            }
// 1412          }
// 1413     break;
// 1414     default:
// 1415     break;
// 1416   }
// 1417   return bBackFlag;
// 1418 }
// 1419 
// 1420 /**************************************************************************************/
// 1421 bool_t PacketErrorRateTx(void)
// 1422 {
// 1423   const uint16_t u16TotalPacketsOptions[] = {1,25,100,500,1000,2000,5000,10000,65535};
// 1424   static uint16_t u16TotalPackets;
// 1425   static uint16_t u16SentPackets;
// 1426   uint8_t u8Index;
// 1427   bool_t bBackFlag = FALSE;
// 1428   
// 1429   if(evTestParameters)
// 1430   {
// 1431     (void)MLMERXDisableRequest();
// 1432     (void)MLMESetChannelRequest(testChannel);
// 1433     (void)MLMEPAOutputAdjust(testPower);
// 1434     (void)MLMEXtalAdjust(testTrimmValue);
// 1435     PrintTestParameters(TRUE);
// 1436     evTestParameters = FALSE;
// 1437   }
// 1438   
// 1439   switch(perTxState)
// 1440   {
// 1441     case gPerTxStateInit_c:
// 1442            PrintMenu(cu8ShortCutsBar, gDefaultCommPort_c);
// 1443            PrintMenu(cu8PerTxTestMenu, gDefaultCommPort_c);
// 1444            PrintTestParameters(FALSE);
// 1445            shortCutsEnabled = TRUE;           
// 1446            perTxState = gPerTxStateSelectPacketNum_c;        
// 1447     break;
// 1448     case gPerTxStateSelectPacketNum_c:
// 1449          if(evDataFromCOMM){
// 1450            if((gu8CommData >= '0') && (gu8CommData <= '8')){
// 1451              u16TotalPackets = u16TotalPacketsOptions[gu8CommData - '0'];
// 1452              shortCutsEnabled = FALSE;  
// 1453              perTxState = gPerTxStateStartTest_c;
// 1454         }else if('p' == gu8CommData){ 
// 1455              bBackFlag = TRUE;
// 1456            }
// 1457 			 evDataFromCOMM = FALSE;
// 1458          }
// 1459     break;
// 1460     case gPerTxStateStartTest_c:
// 1461          gAppTxPacket->u8DataLength = testPayloadLen;
// 1462          u16SentPackets = 0;
// 1463          gAppTxPacket->smacPdu.u8Data[0] = (u16TotalPackets >> 8);
// 1464          gAppTxPacket->smacPdu.u8Data[1] = (uint8_t)u16TotalPackets;
// 1465          gAppTxPacket->smacPdu.u8Data[2] = ((u16SentPackets+1) >> 8);
// 1466          gAppTxPacket->smacPdu.u8Data[3] = (uint8_t)(u16SentPackets+1);
// 1467          MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[4]), "SMAC PER Demo",13);
// 1468          if(17 < testPayloadLen){
// 1469            for(u8Index=17;u8Index<testPayloadLen;u8Index++){
// 1470              gAppTxPacket->smacPdu.u8Data[u8Index] = (u8Index%10)+'0';            
// 1471            }
// 1472          }
// 1473          bTxDone = FALSE;
// 1474 
// 1475          (void)MCPSDataRequest(gAppTxPacket);
// 1476          u16SentPackets++;
// 1477          CommUtil_Print("\f\r\n Running PER Tx, Sending ", gAllowToBlock_d);
// 1478          PrintWordOnDecimalFormatBlocking(u16TotalPackets, 0, FALSE, gDefaultCommPort_c);
// 1479          CommUtil_Print(" Packets", gAllowToBlock_d);
// 1480          perTxState = gPerTxStateRunningTest_c;
// 1481     break;
// 1482     case gPerTxStateRunningTest_c:
// 1483          if(bTxDone){
// 1484            if(u16SentPackets == u16TotalPackets)
// 1485            {
// 1486              MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[4]), "DONE",4);
// 1487              gAppTxPacket->u8DataLength = 8;
// 1488              u16SentPackets = 0;
// 1489              u16TotalPackets = mTotalFinalFrames_c;
// 1490              gAppTxPacket->u8DataLength = 8;
// 1491              perTxState = gPerTxStateSendingLastFrames_c;
// 1492            }else
// 1493            {
// 1494             gAppTxPacket->smacPdu.u8Data[2] = ((u16SentPackets+1) >> 8);
// 1495             gAppTxPacket->smacPdu.u8Data[3] = (uint8_t)(u16SentPackets+1);
// 1496             gAppTxPacket->u8DataLength = testPayloadLen;
// 1497            }
// 1498             bTxDone = FALSE;
// 1499            delayMs(10);
// 1500             (void)MCPSDataRequest(gAppTxPacket);
// 1501             u16SentPackets++;
// 1502           }
// 1503     break;
// 1504     case gPerTxStateSendingLastFrames_c:
// 1505          if(bTxDone)
// 1506          {
// 1507            bTxDone = FALSE;
// 1508            if(u16SentPackets == u16TotalPackets)
// 1509            {
// 1510                CommUtil_Print("\r\n PER Tx DONE \r\n", gAllowToBlock_d);
// 1511                CommUtil_Print("\r\n\r\n Press [enter] to go back to the PER Tx test menu ", gAllowToBlock_d);
// 1512                perTxState = gPerTxStateIdle_c;
// 1513            }else
// 1514            {
// 1515              gAppTxPacket->u8DataLength = 8;
// 1516              delayMs(10);
// 1517              (void)MCPSDataRequest(gAppTxPacket);
// 1518              u16SentPackets++;
// 1519               } 
// 1520           }	 
// 1521     break;	
// 1522     case gPerTxStateIdle_c:
// 1523          if((evDataFromCOMM) && ('\r' == gu8CommData))
// 1524          {
// 1525            perTxState = gPerTxStateInit_c;
// 1526            evDataFromCOMM = FALSE;
// 1527          }
// 1528     break;
// 1529    default:
// 1530     break;
// 1531   }
// 1532 
// 1533   return bBackFlag;
// 1534 }
// 1535 
// 1536 /**************************************************************************************/
// 1537 bool_t PacketErrorRateRx(void)
// 1538 {
// 1539   static uint16_t u16ReceivedPackets;
// 1540   static uint16_t u16PacketsIndex;  
// 1541   static uint16_t u16TotalPackets;
// 1542   static uint16_t u16FinalPacketsCount;
// 1543   static uint32_t u32LQISum;
// 1544   uint8_t  u8AverageLQI, u8TempLQIvalue;
// 1545 
// 1546   bool_t bBackFlag = FALSE;
// 1547   if(evTestParameters){
// 1548     (void)MLMESetChannelRequest(testChannel);
// 1549     (void)MLMEPAOutputAdjust(testPower);
// 1550     (void)MLMEXtalAdjust(testTrimmValue);
// 1551     PrintTestParameters(TRUE);
// 1552     evTestParameters = FALSE;
// 1553   }
// 1554 
// 1555   switch(perRxState)
// 1556   {
// 1557     case gPerRxStateInit_c:
// 1558         u16TotalPackets = 0;
// 1559         u16ReceivedPackets = 0;
// 1560         u16PacketsIndex = 0;
// 1561         u32LQISum = 0;
// 1562         PrintMenu(cu8ShortCutsBar, gDefaultCommPort_c);
// 1563         PrintMenu(cu8PerRxTestMenu, gDefaultCommPort_c);
// 1564         PrintTestParameters(FALSE);
// 1565         shortCutsEnabled = TRUE;           
// 1566         perRxState = gPerRxWaitStartTest_c;
// 1567     break;
// 1568     case gPerRxWaitStartTest_c:
// 1569          if(evDataFromCOMM){
// 1570            if(' ' == gu8CommData){
// 1571                  CommUtil_Print("\f\n\rPER Test Rx Running\r\n\r\n", gAllowToBlock_d);
// 1572                  SetRadioRxOnTimeOut15ms();
// 1573                  shortCutsEnabled = FALSE;  
// 1574                  perRxState = gPerRxStateStartTest_c;
// 1575               }else if('p' == gu8CommData){ 
// 1576               bBackFlag = TRUE;
// 1577            }
// 1578            evDataFromCOMM = FALSE;
// 1579          }
// 1580     break;
// 1581     case gPerRxStateStartTest_c:
// 1582          if(bRxDone){
// 1583            if (gAppRxPacket->rxStatus == rxSuccessStatus_c){
// 1584              if(stringComp("SMAC PER Demo",&gAppRxPacket->smacPdu.u8Data[4],13)){
// 1585                u16TotalPackets = ((uint16_t)gAppRxPacket->smacPdu.u8Data[0] <<8) + gAppRxPacket->smacPdu.u8Data[1];
// 1586                u16PacketsIndex = ((uint16_t)gAppRxPacket->smacPdu.u8Data[2] <<8) + gAppRxPacket->smacPdu.u8Data[3];
// 1587                u16ReceivedPackets++;
// 1588                (void)MLMELinkQuality(&u8TempLQIvalue);
// 1589                u32LQISum += u8TempLQIvalue;
// 1590                u8AverageLQI = (uint8_t)(u32LQISum/u16ReceivedPackets);
// 1591                (void)u8AverageLQI;
// 1592                  CommUtil_Print("Packet ", gAllowToBlock_d);
// 1593                PrintWordOnDecimalFormatBlocking(u16ReceivedPackets, 2, FALSE, gDefaultCommPort_c);
// 1594                CommUtil_Print("\r\n", gAllowToBlock_d);
// 1595                if(u16PacketsIndex == u16TotalPackets){
// 1596                  u16FinalPacketsCount = 0; 
// 1597                  perRxState = gPerRxStateReceivingLastFrames_c;
// 1598            }
// 1599              }else if(stringComp("DONE",&gAppRxPacket->smacPdu.u8Data[4],4)){
// 1600                u16FinalPacketsCount = 0; 
// 1601                perRxState = gPerRxStateReceivingLastFrames_c;
// 1602              }
// 1603            }else{ 
// 1604              if(u16TotalPackets){
// 1605                u16PacketsIndex++;
// 1606                if(u16PacketsIndex == u16TotalPackets){
// 1607                  u16FinalPacketsCount = 0; 
// 1608              perRxState = gPerRxStateReceivingLastFrames_c;
// 1609             }
// 1610              }
// 1611            }
// 1612            SetRadioRxOnTimeOut15ms();
// 1613          }
// 1614          if(evDataFromCOMM){
// 1615            if(' ' == gu8CommData){
// 1616              (void)MLMERXDisableRequest();
// 1617              CommUtil_Print("\n\rPER Test Rx Stopped\r\n\r\n", gAllowToBlock_d);
// 1618              PrintPerRxFinalLine(u16ReceivedPackets,u16TotalPackets);
// 1619              perRxState = gPerRxStateIdle_c;
// 1620            } 
// 1621            evDataFromCOMM = FALSE;
// 1622          }         
// 1623     break;
// 1624     case gPerRxStateReceivingLastFrames_c:
// 1625          if(bRxDone){
// 1626            u16FinalPacketsCount++; 
// 1627            if(mTotalFinalFrames_c == u16FinalPacketsCount){
// 1628            CommUtil_Print("\n\rPER Test Finished\r\n\r\n", gAllowToBlock_d);
// 1629            PrintPerRxFinalLine(u16ReceivedPackets,u16TotalPackets);              
// 1630            perRxState = gPerRxStateIdle_c;
// 1631            }else{  
// 1632              SetRadioRxOnTimeOut15ms();
// 1633            }
// 1634          }
// 1635     break;
// 1636     case gPerRxStateIdle_c:
// 1637          if((evDataFromCOMM) && ('\r' == gu8CommData)){
// 1638            perRxState = gPerRxStateInit_c;
// 1639          }
// 1640          evDataFromCOMM = FALSE;
// 1641     break;
// 1642     default:
// 1643     break;
// 1644   }
// 1645   return bBackFlag;
// 1646 }
// 1647 
// 1648 /**************************************************************************************/
// 1649 bool_t RangeTx(void)
// 1650 {
// 1651   bool_t bBackFlag = FALSE;
// 1652   static uint32_t u32LQISum;
// 1653   static uint16_t u16ReceivedPackets;
// 1654   static uint16_t u16PacketsDropped;
// 1655   uint8_t  u8AverageLQI;
// 1656   uint8_t  u8CurrentLQI;
// 1657   
// 1658   if(evTestParameters){
// 1659     (void)MLMESetChannelRequest(testChannel);
// 1660     (void)MLMEPAOutputAdjust(testPower);
// 1661     (void)MLMEXtalAdjust(testTrimmValue);
// 1662     PrintTestParameters(TRUE);
// 1663     evTestParameters = FALSE;
// 1664   }
// 1665   
// 1666   switch(rangeTxState)
// 1667   {
// 1668     case gRangeTxStateInit_c:
// 1669          u32LQISum = 0;
// 1670          u16ReceivedPackets = 0;
// 1671          u16PacketsDropped = 0;
// 1672            PrintMenu(cu8ShortCutsBar, gDefaultCommPort_c);
// 1673            PrintMenu(cu8RangeTxTestMenu, gDefaultCommPort_c);
// 1674            PrintTestParameters(FALSE);
// 1675            shortCutsEnabled = TRUE;           
// 1676            rangeTxState = gRangeTxWaitStartTest_c;
// 1677     break;
// 1678     case gRangeTxWaitStartTest_c:
// 1679          if(evDataFromCOMM){
// 1680            if(' ' == gu8CommData){
// 1681              shortCutsEnabled = FALSE; 
// 1682              CommUtil_Print("\f\r\nRange Test Tx Running\r\n", gAllowToBlock_d);
// 1683              rangeTxState = gRangeTxStateStartTest_c;
// 1684            }else if('p' == gu8CommData){ 
// 1685              bBackFlag = TRUE;
// 1686            }
// 1687            evDataFromCOMM = FALSE;
// 1688          }
// 1689     break;
// 1690     case gRangeTxStateStartTest_c:
// 1691          delayMs(100);
// 1692          delayMs(100);
// 1693          bTxDone = FALSE;
// 1694          gAppTxPacket->u8DataLength = 16;
// 1695          gAppTxPacket->smacPdu.u8Data[0]  = 0;
// 1696          MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[1]), "SMAC Range Demo",15);
// 1697          (void)MCPSDataRequest(gAppTxPacket);
// 1698          rangeTxState = gRangeTxStateRunningTest_c;
// 1699     break;
// 1700     case gRangeTxStateRunningTest_c:
// 1701          if(bTxDone){
// 1702            SetRadioRxOnTimeOut15ms();
// 1703            rangeTxState = gRangeTxStatePrintTestResults_c;
// 1704          }
// 1705     break;
// 1706     case gRangeTxStatePrintTestResults_c:
// 1707          if(bRxDone){
// 1708            if(gAppRxPacket->rxStatus == rxSuccessStatus_c){ 
// 1709              if(stringComp("SMAC Range Demo",&gAppRxPacket->smacPdu.u8Data[1],15)){
// 1710                u8CurrentLQI = (gAppRxPacket->smacPdu.u8Data[0]); 
// 1711                u32LQISum += u8CurrentLQI;  
// 1712                u16ReceivedPackets++;
// 1713                u8AverageLQI = (uint8_t)(u32LQISum/u16ReceivedPackets);
// 1714                  CommUtil_Print("\r\n LQI = ", gAllowToBlock_d);
// 1715                  PrintWordOnDecimalFormatBlocking((uint16_t)u8CurrentLQI,1,FALSE, gDefaultCommPort_c);               
// 1716              }else{
// 1717                SetRadioRxOnTimeOut15ms();
// 1718              }
// 1719            }else{
// 1720                u16PacketsDropped++;
// 1721                CommUtil_Print("\r\nPacket Dropped", gAllowToBlock_d);
// 1722            }
// 1723            if(evDataFromCOMM && (' ' == gu8CommData)){
// 1724              CommUtil_Print("\n\r\n\rRange Test Tx Stopped\r\n\r\n", gAllowToBlock_d);
// 1725              u8AverageLQI = (uint8_t)(u32LQISum/u16ReceivedPackets);
// 1726              CommUtil_Print("Average LQI     ", gAllowToBlock_d);
// 1727              PrintWordOnDecimalFormatBlocking((uint16_t)u8AverageLQI,1,FALSE, gDefaultCommPort_c);  
// 1728              CommUtil_Print("\r\nPackets dropped ", gAllowToBlock_d);
// 1729              PrintWordOnDecimalFormatBlocking(u16PacketsDropped,1,FALSE, gDefaultCommPort_c);  
// 1730              CommUtil_Print("\r\n\r\n Press [enter] to go back to the Range Tx test menu", gAllowToBlock_d);
// 1731              rangeTxState = gRangeTxStateIdle_c;
// 1732            }else{
// 1733              rangeTxState = gRangeTxStateStartTest_c;
// 1734            }
// 1735            evDataFromCOMM = FALSE;
// 1736          }
// 1737     break;
// 1738     case gRangeTxStateIdle_c:
// 1739          if((evDataFromCOMM) && ('\r' == gu8CommData))
// 1740          {
// 1741            rangeTxState = gRangeTxStateInit_c;
// 1742          }
// 1743          evDataFromCOMM = FALSE;
// 1744     break;
// 1745     default:
// 1746     break;
// 1747   }
// 1748   return bBackFlag;
// 1749 }
// 1750 
// 1751 /**************************************************************************************/
// 1752 bool_t RangeRx(void)
// 1753 {
// 1754   bool_t bBackFlag = FALSE;
// 1755   static uint32_t u32LQISum;
// 1756   static uint16_t u16ReceivedPackets;
// 1757   uint8_t  u8AverageLQI, u8TempLQIvalue;
// 1758   uint8_t  u8CurrentLQI;
// 1759 
// 1760   if(evTestParameters){
// 1761     (void)MLMESetChannelRequest(testChannel);
// 1762     (void)MLMEPAOutputAdjust(testPower);
// 1763     (void)MLMEXtalAdjust(testTrimmValue);
// 1764     PrintTestParameters(TRUE);
// 1765     evTestParameters = FALSE;
// 1766   }
// 1767 
// 1768   switch(rangeRxState)
// 1769   {
// 1770     case gRangeRxStateInit_c:
// 1771          u32LQISum = 0;
// 1772          u16ReceivedPackets = 0;
// 1773            PrintMenu(cu8ShortCutsBar, gDefaultCommPort_c);
// 1774            PrintMenu(cu8RangeRxTestMenu, gDefaultCommPort_c);
// 1775            PrintTestParameters(FALSE);
// 1776            shortCutsEnabled = TRUE;           
// 1777            rangeRxState = gRangeRxWaitStartTest_c;
// 1778     break;
// 1779     case gRangeRxWaitStartTest_c:
// 1780          if(evDataFromCOMM){
// 1781            if(' ' == gu8CommData){
// 1782              shortCutsEnabled = FALSE; 
// 1783              CommUtil_Print("\f\r\nRange Test Rx Running\r\n", gAllowToBlock_d);
// 1784              rangeRxState = gRangeRxStateStartTest_c;
// 1785            }else if('p' == gu8CommData){ 
// 1786              bBackFlag = TRUE;
// 1787            }
// 1788            evDataFromCOMM = FALSE;
// 1789          }
// 1790     break;
// 1791     case gRangeRxStateStartTest_c:
// 1792          SetRadioRxOnNoTimeOut();
// 1793          rangeRxState = gRangeRxStateRunningTest_c;
// 1794     break;
// 1795     case gRangeRxStateRunningTest_c:
// 1796          if(evDataFromCOMM && (' ' == gu8CommData))
// 1797          {             
// 1798            (void)MLMERXDisableRequest();
// 1799            CommUtil_Print("\n\r\n\rRange Test Rx Stopped\r\n\r\n", gAllowToBlock_d);
// 1800            u8AverageLQI = (uint8_t)(u32LQISum/u16ReceivedPackets);
// 1801            CommUtil_Print("Average LQI     ", gAllowToBlock_d);
// 1802            PrintWordOnDecimalFormatBlocking((uint16_t)u8AverageLQI,1,FALSE, gDefaultCommPort_c);  
// 1803            CommUtil_Print("\r\n\r\n Press [enter] to go back to the Range Rx test menu", gAllowToBlock_d);
// 1804            rangeRxState = gRangeRxStateIdle_c;
// 1805          }
// 1806          evDataFromCOMM = FALSE;
// 1807          if(bRxDone){
// 1808            if(gAppRxPacket->rxStatus == rxSuccessStatus_c){ 
// 1809              if(stringComp("SMAC Range Demo",&gAppRxPacket->smacPdu.u8Data[1],15)){
// 1810                bTxDone = FALSE;
// 1811 			   delayMs(2);
// 1812                (void)MLMELinkQuality(&u8TempLQIvalue);
// 1813                gAppTxPacket->smacPdu.u8Data[0] = u8TempLQIvalue;
// 1814                MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[1]), "SMAC Range Demo",15);
// 1815                gAppTxPacket->u8DataLength = 16;
// 1816                (void)MCPSDataRequest(gAppTxPacket);
// 1817                rangeRxState = gRangeRxStatePrintTestResults_c;
// 1818              }else{
// 1819                SetRadioRxOnNoTimeOut();
// 1820              }
// 1821            }else{
// 1822              SetRadioRxOnNoTimeOut();
// 1823            }
// 1824          }
// 1825     break;
// 1826     case gRangeRxStatePrintTestResults_c:
// 1827          if(bTxDone)
// 1828          {
// 1829            (void)MLMELinkQuality(&u8CurrentLQI); 
// 1830            u32LQISum += u8CurrentLQI;
// 1831            u16ReceivedPackets++;
// 1832            u8AverageLQI = (uint8_t)(u32LQISum/u16ReceivedPackets);
// 1833              CommUtil_Print("\r\n LQI = ", gAllowToBlock_d);
// 1834              PrintWordOnDecimalFormatBlocking((uint16_t)u8CurrentLQI,1,FALSE, gDefaultCommPort_c);               
// 1835            rangeRxState = gRangeRxStateStartTest_c;
// 1836          }
// 1837     break;
// 1838     case gRangeRxStateIdle_c:
// 1839          if((evDataFromCOMM) && ('\r' == gu8CommData))
// 1840          {
// 1841            rangeRxState = gRangeRxStateInit_c;
// 1842          }
// 1843          evDataFromCOMM = FALSE;
// 1844     break;
// 1845     default:
// 1846     break;
// 1847   }
// 1848   return bBackFlag;
// 1849 }
// 1850 
// 1851 /**************************************************************************************/
// 1852 /**************************************************************************************/
// 1853 bool_t EditRegisters(void)
// 1854 {
// 1855   bool_t bBackFlag = FALSE;
// 1856   if(evTestParameters){
// 1857     (void)MLMESetChannelRequest(testChannel);
// 1858     (void)MLMEPAOutputAdjust(testPower);
// 1859     (void)MLMEXtalAdjust(testTrimmValue);
// 1860     PrintTestParameters(TRUE);
// 1861     evTestParameters = FALSE;
// 1862   }
// 1863 
// 1864   switch(eRState)
// 1865   {
// 1866     case gERStateInit_c:
// 1867          PrintMenu(cu8ShortCutsBar, gDefaultCommPort_c);
// 1868          PrintMenu(cu8RadioRegistersEditMenu, gDefaultCommPort_c);
// 1869          PrintTestParameters(FALSE);
// 1870          shortCutsEnabled = TRUE;           
// 1871          eRState = gERWaitSelection_c;
// 1872     break;
// 1873     case gERWaitSelection_c:
// 1874          if(evDataFromCOMM){
// 1875            if('1' == gu8CommData){
// 1876              oDRState = gODRStateInit_c;
// 1877              eRState = gERStateOverrideDirectReg_c;
// 1878            }else if('2' == gu8CommData){
// 1879              rDRState = gRDRStateInit_c;
// 1880              eRState = gERStateReadDirectReg_c;
// 1881            }else if('3' == gu8CommData){
// 1882              oIRState = gOIRStateInit_c;
// 1883              eRState = gERStateOverrideIndirectReg_c;
// 1884            }else if('4' == gu8CommData){
// 1885              rIRState = gRIRStateInit_c;
// 1886              eRState = gERStateReadIndirectReg_c;
// 1887            }else if('p' == gu8CommData){ 
// 1888              bBackFlag = TRUE;
// 1889            }
// 1890            evDataFromCOMM = FALSE;
// 1891          }
// 1892     break;
// 1893     case gERStateOverrideDirectReg_c:
// 1894          if(OverrideDirectRegisters()) {
// 1895              eRState = gERStateInit_c;
// 1896          }    
// 1897     break;
// 1898     case gERStateOverrideIndirectReg_c:
// 1899          if(OverrideIndirectRegisters()) {
// 1900              eRState = gERStateInit_c;
// 1901          }    
// 1902     break;
// 1903     case gERStateReadDirectReg_c:
// 1904          if(ReadDirectRegisters()) {
// 1905              eRState = gERStateInit_c;
// 1906          }    
// 1907     break;
// 1908     case gERStateReadIndirectReg_c:
// 1909          if(ReadIndirectRegisters()) {
// 1910              eRState = gERStateInit_c;
// 1911          }    
// 1912     break;
// 1913     default:
// 1914     break;
// 1915   }
// 1916   return bBackFlag;
// 1917 }
// 1918 
// 1919 
// 1920 /**************************************************************************************/
// 1921 bool_t OverrideDirectRegisters(void)
// 1922 {
// 1923   bool_t bBackFlag = FALSE;
// 1924   static uint8_t au8RxString[5];
// 1925   static uint8_t u8Index;
// 1926   static uint8_t u8RegAddress;
// 1927   static uint8_t u8RegValue;
// 1928   
// 1929   
// 1930   switch(oDRState)
// 1931   {
// 1932     case gODRStateInit_c:
// 1933          CommUtil_Print("\f\r\nOverride Direct Registers\r\n", gAllowToBlock_d);
// 1934          CommUtil_Print("\r\n-Press [p] Previous Menu\r\n", gAllowToBlock_d);
// 1935          shortCutsEnabled = FALSE;   
// 1936          oDRState = gODRStateStart_c;
// 1937     break;
// 1938     case gODRStateStart_c:
// 1939          CommUtil_Print("\r\n -write the Register address in Hex and [enter]: 0x", gAllowToBlock_d);
// 1940          u8Index = 0;
// 1941          oDRState = gODRWaitForTheAddress_c; 
// 1942     break;
// 1943     case gODRWaitForTheAddress_c:
// 1944          if(evDataFromCOMM){
// 1945            if((!isAsciiHex(gu8CommData)) && ('\r' != gu8CommData)){
// 1946              if('p' == gu8CommData){ 
// 1947                bBackFlag = TRUE;
// 1948              }else{
// 1949                CommUtil_Print("\r\n -Invalid Character!! ", gAllowToBlock_d);
// 1950                oDRState = gODRStateStart_c;              
// 1951              }
// 1952            }else if((2 == u8Index) && ('\r' != gu8CommData)){ 
// 1953              CommUtil_Print("\r\n -Value out of Range!! ", gAllowToBlock_d);
// 1954              oDRState = gODRStateStart_c;
// 1955            }else if(isAsciiHex(gu8CommData)){
// 1956              au8RxString[u8Index++] = gu8CommData;
// 1957            }else{
// 1958              au8RxString[u8Index] = 0;
// 1959              u8RegAddress = HexString2Dec16(au8RxString);
// 1960              CommUtil_Print("\r\n -write the Register value to override in Hex and [enter]: 0x", gAllowToBlock_d);
// 1961              u8Index = 0;
// 1962              oDRState = gODRWaitForTheValue_c; 
// 1963            }
// 1964            evDataFromCOMM = FALSE;
// 1965          }
// 1966     break;
// 1967     case gODRWaitForTheValue_c:
// 1968          if(evDataFromCOMM){
// 1969            if((!isAsciiHex(gu8CommData)) && ('\r' != gu8CommData)){
// 1970              if('p' == gu8CommData){ 
// 1971                bBackFlag = TRUE;
// 1972              }else{
// 1973                CommUtil_Print("\r\n -Invalid Character!! ", gAllowToBlock_d);
// 1974                oDRState = gODRStateStart_c;              
// 1975              }
// 1976            }else if((2 == u8Index) && ('\r' != gu8CommData)){ 
// 1977              CommUtil_Print("\r\n -Value out of Range!! ", gAllowToBlock_d);
// 1978              oDRState = gODRStateStart_c;              
// 1979            }else if(isAsciiHex(gu8CommData)){
// 1980              au8RxString[u8Index++] = gu8CommData;
// 1981            }else{
// 1982              au8RxString[u8Index] = 0;
// 1983              u8RegValue = (uint8_t)(HexString2Dec16(au8RxString) & 0x00FF);
// 1984              MC1324xDrv_DirectAccessSPIWrite(u8RegAddress,u8RegValue);
// 1985              
// 1986              CommUtil_Print("\r\n Register overridden \r\n", gAllowToBlock_d);
// 1987              u8Index = 0;
// 1988              oDRState = gODRStateStart_c; 
// 1989            }
// 1990            evDataFromCOMM = FALSE;
// 1991          }
// 1992     break;
// 1993     default:
// 1994     break;
// 1995   }
// 1996   return bBackFlag;  
// 1997 }
// 1998 
// 1999 /**************************************************************************************/
// 2000 bool_t OverrideIndirectRegisters(void)
// 2001 {
// 2002   bool_t bBackFlag = FALSE;
// 2003   static uint8_t au8RxString[3];
// 2004   static uint8_t u8Index;
// 2005   static uint8_t u8RegAddress;
// 2006   static uint8_t u8RegValue;
// 2007   
// 2008   
// 2009   switch(oIRState)
// 2010   {
// 2011     case gOIRStateInit_c:
// 2012          CommUtil_Print("\f\r\nOverride Indirect Registers\r\n", gAllowToBlock_d);
// 2013          CommUtil_Print("\r\n-Press [p] Previous Menu\r\n", gAllowToBlock_d);
// 2014          shortCutsEnabled = FALSE;   
// 2015          oIRState = gOIRStateStart_c;
// 2016     break;
// 2017     case gOIRStateStart_c:
// 2018          CommUtil_Print("\r\n -write the Register address in Hex and [enter]: 0x", gAllowToBlock_d);
// 2019          u8Index = 0;
// 2020          oIRState = gOIRWaitForTheAddress_c; 
// 2021     break;
// 2022     case gOIRWaitForTheAddress_c:
// 2023          if(evDataFromCOMM){
// 2024            if((!isAsciiHex(gu8CommData)) && ('\r' != gu8CommData)){
// 2025              if('p' == gu8CommData){ 
// 2026                bBackFlag = TRUE;
// 2027              }else{
// 2028                CommUtil_Print("\r\n -Invalid Character!! ", gAllowToBlock_d);
// 2029                oIRState = gOIRStateStart_c;              
// 2030              }
// 2031            }else if((2 == u8Index) && ('\r' != gu8CommData)){ 
// 2032              CommUtil_Print("\r\n -Value out of Range!! ", gAllowToBlock_d);
// 2033              oIRState = gOIRStateStart_c;   
// 2034            }else if(isAsciiHex(gu8CommData)){
// 2035              au8RxString[u8Index++] = gu8CommData;
// 2036            }else{
// 2037              au8RxString[u8Index] = 0;
// 2038              u8RegAddress = (uint8_t)(HexString2Dec16(au8RxString) & 0x00FF);
// 2039              CommUtil_Print("\r\n -write the Register value to override in Hex and [enter]: 0x", gAllowToBlock_d);
// 2040              u8Index = 0;
// 2041              oIRState = gOIRWaitForTheValue_c; 
// 2042            }
// 2043            evDataFromCOMM = FALSE;
// 2044          }
// 2045     break;
// 2046     case gOIRWaitForTheValue_c:
// 2047          if(evDataFromCOMM)
// 2048          {
// 2049            if((!isAsciiHex(gu8CommData)) && ('\r' != gu8CommData)){
// 2050              if('p' == gu8CommData){ 
// 2051                bBackFlag = TRUE;
// 2052              }else{
// 2053                CommUtil_Print("\r\n -Invalid Character!! ", gAllowToBlock_d);
// 2054                oIRState = gOIRStateStart_c;              
// 2055              }
// 2056            }else if((2 == u8Index) && ('\r' != gu8CommData)){ 
// 2057              CommUtil_Print("\r\n -Value out of Range!! ", gAllowToBlock_d);
// 2058              bBackFlag = TRUE;
// 2059            }else if(isAsciiHex(gu8CommData)){
// 2060              au8RxString[u8Index++] = gu8CommData;
// 2061            }else{
// 2062              au8RxString[u8Index] = 0;
// 2063              u8RegValue = (uint8_t)(HexString2Dec16(au8RxString) & 0x00FF);
// 2064              MC1324xDrv_IndirectAccessSPIWrite(u8RegAddress, u8RegValue);
// 2065              CommUtil_Print("\r\n Register overridden \r\n", gAllowToBlock_d);
// 2066              u8Index = 0;
// 2067              oIRState = gOIRStateStart_c; 
// 2068            }
// 2069            evDataFromCOMM = FALSE;
// 2070          }
// 2071     break;
// 2072     default:
// 2073     break;
// 2074   }
// 2075   return bBackFlag;  
// 2076 }
// 2077 
// 2078 
// 2079 /**************************************************************************************/
// 2080 bool_t ReadDirectRegisters(void)
// 2081 {
// 2082   bool_t bBackFlag = FALSE;
// 2083   static uint8_t au8RxString[5];
// 2084   static uint8_t u8Index;
// 2085   static uint8_t u8RegAddress;
// 2086   static uint8_t u8RegValue;
// 2087   
// 2088   switch(rDRState)
// 2089   {
// 2090     case gRDRStateInit_c:
// 2091          CommUtil_Print("\f\r\rRead Direct Registers\r\n", gAllowToBlock_d);
// 2092          CommUtil_Print("\r\n-Press [p] Previous Menu\r\n", gAllowToBlock_d);
// 2093          shortCutsEnabled = FALSE;   
// 2094          rDRState = gRDRStateStart_c;
// 2095     break;
// 2096     case gRDRStateStart_c:
// 2097          CommUtil_Print("\r\n -write the Register address in Hex and [enter]: 0x", gAllowToBlock_d);
// 2098          u8Index = 0;
// 2099          rDRState = gRDRWaitForTheAddress_c; 
// 2100     break;
// 2101     case gRDRWaitForTheAddress_c:
// 2102          if(evDataFromCOMM){
// 2103            if((!isAsciiHex(gu8CommData)) && ('\r' != gu8CommData)){
// 2104              if('p' == gu8CommData){ 
// 2105                bBackFlag = TRUE;
// 2106              }else{
// 2107                CommUtil_Print("\r\n -Invalid Character!! ", gAllowToBlock_d);
// 2108                rDRState = gRDRStateStart_c;              
// 2109              }
// 2110            }else if((2 == u8Index) && ('\r' != gu8CommData)){ 
// 2111              CommUtil_Print("\r\n -Value out of Range!! ", gAllowToBlock_d);
// 2112              rDRState = gRDRStateStart_c;
// 2113            }else if(isAsciiHex(gu8CommData)){
// 2114              au8RxString[u8Index++] = gu8CommData;
// 2115            }else{
// 2116              au8RxString[u8Index] = 0;
// 2117              u8RegAddress = HexString2Dec16(au8RxString);
// 2118              u8RegValue = MC1324xDrv_DirectAccessSPIRead(u8RegAddress);
// 2119              
// 2120              CommUtil_Print("\r\n -Register value : 0x", gAllowToBlock_d);
// 2121              PrintByteOnHexFormatBlocking(u8RegValue,FALSE, gDefaultCommPort_c);
// 2122              CommUtil_Print("\r\n", gAllowToBlock_d);
// 2123              
// 2124              rDRState = gRDRStateStart_c; 
// 2125            }
// 2126            evDataFromCOMM = FALSE;
// 2127          }
// 2128     break;
// 2129     default:
// 2130     break;
// 2131   }
// 2132   return bBackFlag;  
// 2133 }
// 2134 
// 2135 /**************************************************************************************/
// 2136 bool_t ReadIndirectRegisters(void)
// 2137 {
// 2138   bool_t bBackFlag = FALSE;
// 2139   static uint8_t au8RxString[5];
// 2140   static uint8_t u8Index;
// 2141   static uint8_t u8RegAddress;
// 2142   static uint8_t u8RegValue;
// 2143   
// 2144   switch(rIRState)
// 2145   {
// 2146     case gRIRStateInit_c:
// 2147          CommUtil_Print("\f\r\rRead Indirect Registers\r\n", gAllowToBlock_d);
// 2148          CommUtil_Print("\r\n-Press [p] Previous Menu\r\n", gAllowToBlock_d);
// 2149          shortCutsEnabled = FALSE;   
// 2150          rIRState = gRIRStateStart_c;
// 2151     break;
// 2152     case gRIRStateStart_c:
// 2153          CommUtil_Print("\r\n -write the Register address in Hex and [enter]: 0x", gAllowToBlock_d);
// 2154          u8Index = 0;
// 2155          rIRState = gRIRWaitForTheAddress_c; 
// 2156     break;
// 2157     case gRIRWaitForTheAddress_c:
// 2158          if(evDataFromCOMM){
// 2159            if((!isAsciiHex(gu8CommData)) && ('\r' != gu8CommData))
// 2160            {
// 2161              if('p' == gu8CommData){ 
// 2162                bBackFlag = TRUE;
// 2163              }else{
// 2164                CommUtil_Print("\r\n -Invalid Character!! ", gAllowToBlock_d);
// 2165                rIRState = gRIRStateStart_c;              
// 2166              }
// 2167            }else if((2 == u8Index) && ('\r' != gu8CommData)){ 
// 2168              CommUtil_Print("\r\n -Value out of Range!! ", gAllowToBlock_d);
// 2169              rIRState = gRIRStateStart_c; 
// 2170            }else if(isAsciiHex(gu8CommData)){
// 2171              au8RxString[u8Index++] = gu8CommData;
// 2172            }else{
// 2173              au8RxString[u8Index] = 0;
// 2174              u8RegAddress = (uint8_t)(HexString2Dec16(au8RxString) & 0x00FF);
// 2175              u8RegValue = MC1324xDrv_IndirectAccessSPIRead(u8RegAddress);
// 2176              
// 2177              CommUtil_Print("\r\n -Register value : 0x", gAllowToBlock_d);
// 2178              PrintByteOnHexFormatBlocking(u8RegValue, FALSE, gDefaultCommPort_c);
// 2179              CommUtil_Print("\r\n", gAllowToBlock_d);
// 2180              rIRState = gRIRStateStart_c; 
// 2181            }
// 2182            evDataFromCOMM = FALSE;
// 2183          }
// 2184     break;
// 2185     default:
// 2186     break;
// 2187   }
// 2188   return bBackFlag;  
// 2189 } 
// 2190 
// 2191 /**************************************************************************************/
// 2192 void PrintTestParameters(bool_t bEraseLine)
// 2193 {
// 2194   uint8_t u8lineLen = 63;
// 2195   uint8_t u8Index;
// 2196  
// 2197   if(bEraseLine)
// 2198   {
// 2199     for(u8Index = 0;u8Index<u8lineLen;u8Index++)
// 2200     {
// 2201       CommUtil_Print("\b", gAllowToBlock_d);
// 2202     }
// 2203   }
// 2204   
// 2205   CommUtil_Print("Mode ", gAllowToBlock_d);
// 2206   if(mTxOperation_c == testOpMode){
// 2207     CommUtil_Print("Tx", gAllowToBlock_d);
// 2208   }else{
// 2209     CommUtil_Print("Rx", gAllowToBlock_d);
// 2210   }
// 2211   CommUtil_Print(", Channel ", gAllowToBlock_d);
// 2212   PrintWordOnDecimalFormatBlocking((uint16_t)testChannel,2, FALSE, gDefaultCommPort_c);
// 2213   CommUtil_Print(", Power ", gAllowToBlock_d);
// 2214   PrintWordOnDecimalFormatBlocking((uint16_t)testPower,2, FALSE, gDefaultCommPort_c);
// 2215   CommUtil_Print(", Crystal Trim ", gAllowToBlock_d);
// 2216   PrintWordOnDecimalFormatBlocking((uint16_t)testTrimmValue,3, FALSE, gDefaultCommPort_c);
// 2217   CommUtil_Print(", Payload ", gAllowToBlock_d);
// 2218   PrintWordOnDecimalFormatBlocking((uint16_t)testPayloadLen,3, FALSE, gDefaultCommPort_c);
// 2219   CommUtil_Print(" >", gAllowToBlock_d);
// 2220 }
// 2221 
// 2222 /**************************************************************************************/
// 2223 void SetRadioRxOnTimeOut15ms(void)
// 2224 {
// 2225   bRxDone = FALSE;
// 2226   gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
// 2227   smacErrors_t status = MLMERXEnableRequest(gAppRxPacket, 45000);
// 2228   while(status!=gErrorNoError_c){
// 2229     status = MLMERXEnableRequest(gAppRxPacket, 45000);
// 2230   }
// 2231 }
// 2232 
// 2233 /**************************************************************************************/
// 2234 void SetRadioRxOnNoTimeOut(void)
// 2235 {
// 2236   bRxDone = FALSE;
// 2237   gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
// 2238   (void)MLMERXEnableRequest(gAppRxPacket, 0);
// 2239 }
// 2240 
// 2241 /**************************************************************************************/
// 2242 void PrintPerRxFinalLine(uint16_t u16Received, uint16_t u16Total)
// 2243 {
// 2244   CommUtil_Print("Received ", gAllowToBlock_d);
// 2245   PrintWordOnDecimalFormatBlocking(u16Received, 2, FALSE, gDefaultCommPort_c);
// 2246   CommUtil_Print(" of ", gAllowToBlock_d);
// 2247   PrintWordOnDecimalFormatBlocking(u16Total, 2, FALSE, gDefaultCommPort_c);
// 2248   CommUtil_Print(" packets transmitted \r\n", gAllowToBlock_d);
// 2249   CommUtil_Print("\r\n Press [enter] to go back to the Per Rx test menu", gAllowToBlock_d);
// 2250 }
// 2251 
// 2252 
// 2253 /************************************************************************************
// 2254 * User's Callbacks
// 2255 ************************************************************************************/
// 2256 
// 2257 /* Place your callbacks here */
// 2258 
// 2259 
// 2260 /************************************************************************************
// 2261 * CommTxCallback
// 2262 * 
// 2263 *
// 2264 *
// 2265 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2266 void CommTxCallback(void)
// 2267 {
// 2268     bCommTxDone = TRUE;  
CommTxCallback:
        MOVS     R0,#+1
        LDR.N    R1,??DataTable31_90
        STRB     R0,[R1, #+0]
// 2269 }
        BX       LR               ;; return
// 2270 
// 2271 /************************************************************************************
// 2272 * CommRxCallback
// 2273 * 
// 2274 *
// 2275 *
// 2276 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(2)
        THUMB
// 2277 void CommRxCallback()
// 2278 {
CommRxCallback:
        PUSH     {R7,LR}
// 2279     Comm_GetByteFromRxBuffer(&gu8CommData);
        LDR.N    R0,??DataTable31_91
        BL       Uart1_GetByteFromRxBuffer
// 2280     if(shortCutsEnabled){
        LDR.N    R0,??DataTable31_77
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??CommRxCallback_0
// 2281       ShortCutsParser(gu8CommData);  
        LDR.N    R0,??DataTable31_91
        LDRB     R0,[R0, #+0]
        BL       ShortCutsParser
        B.N      ??CommRxCallback_1
// 2282     }else{
// 2283       evDataFromCOMM = TRUE;
??CommRxCallback_0:
        MOVS     R0,#+1
        LDR.N    R1,??DataTable31_58
        STRB     R0,[R1, #+0]
// 2284     }
// 2285 }
??CommRxCallback_1:
        POP      {R0,PC}          ;; return
// 2286 
// 2287 
// 2288 /************************************************************************************
// 2289 * SMAC Callbacks
// 2290 ************************************************************************************/
// 2291 
// 2292 /************************************************************************************
// 2293 * MCPSDataConfirm
// 2294 * 
// 2295 *
// 2296 *
// 2297 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2298 void MCPSDataConfirm(txStatus_t TransmissionResult)
// 2299 {  
// 2300     bTxDone = TRUE;
MCPSDataConfirm:
        MOVS     R1,#+1
        LDR.N    R2,??DataTable31_92
        STRB     R1,[R2, #+0]
// 2301 }
        BX       LR               ;; return
// 2302  
// 2303 
// 2304 /************************************************************************************
// 2305 * MCPSDataIndication
// 2306 * 
// 2307 *
// 2308 *
// 2309 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2310 void MCPSDataIndication(rxPacket_t *gsRxPacket)
// 2311 {  
// 2312   bRxDone = TRUE;
MCPSDataIndication:
        MOVS     R1,#+1
        LDR.N    R2,??DataTable31_93
        STRB     R1,[R2, #+0]
// 2313   appState=RECEIVE_FINISHED;
        MOVS     R1,#+2
        LDR.N    R2,??DataTable31_49
        STRB     R1,[R2, #+0]
// 2314 }
        BX       LR               ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29:
        DC32     gIsMyAck
// 2315 
// 2316 
// 2317 /************************************************************************************
// 2318 * MLMEScanConfirm
// 2319 * 
// 2320 *
// 2321 *
// 2322 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2323 void MLMEScanConfirm(channels_t ClearestChann)
// 2324 {
// 2325   bestChannel = ClearestChann; 
MLMEScanConfirm:
        LDR.N    R1,??DataTable31_94
        STRB     R0,[R1, #+0]
// 2326   bScanDone = TRUE;
        MOVS     R1,#+1
        LDR.N    R2,??DataTable31_95
        STRB     R1,[R2, #+0]
// 2327 }
        BX       LR               ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable30:
        DC32     ?_1
// 2328 
// 2329 /************************************************************************************
// 2330 * MLMEResetIndication
// 2331 * 
// 2332 *
// 2333 *
// 2334 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2335 void MLMEResetIndication(void)
// 2336 {
// 2337   
// 2338 }
MLMEResetIndication:
        BX       LR               ;; return
// 2339 
// 2340 /************************************************************************************
// 2341 * MLMEWakeConfirm
// 2342 * 
// 2343 *
// 2344 *
// 2345 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2346 void MLMEWakeConfirm(void)
// 2347 {
// 2348   
// 2349 }
MLMEWakeConfirm:
        BX       LR               ;; return
// 2350 
// 2351 /**************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2352 void ShortCutsParser(uint8_t u8CommData)
// 2353 {
// 2354   evTestParameters = TRUE;
ShortCutsParser:
        MOVS     R1,#+1
        LDR.N    R2,??DataTable31_96
        STRB     R1,[R2, #+0]
// 2355   evDataFromCOMM = FALSE;
        MOVS     R1,#+0
        LDR.N    R2,??DataTable31_58
        STRB     R1,[R2, #+0]
// 2356   switch(u8CommData){
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R1,R0
        CMP      R1,#+97
        BEQ.N    ??ShortCutsParser_0
        CMP      R1,#+109
        BEQ.N    ??ShortCutsParser_1
        CMP      R1,#+110
        BEQ.N    ??ShortCutsParser_2
        CMP      R1,#+113
        BEQ.N    ??ShortCutsParser_3
        CMP      R1,#+114
        BEQ.N    ??ShortCutsParser_4
        CMP      R1,#+115
        BEQ.N    ??ShortCutsParser_5
        CMP      R1,#+116
        BEQ.N    ??ShortCutsParser_6
        CMP      R1,#+119
        BEQ.N    ??ShortCutsParser_7
        CMP      R1,#+120
        BEQ.N    ??ShortCutsParser_8
        CMP      R1,#+122
        BEQ.N    ??ShortCutsParser_9
        B.N      ??ShortCutsParser_10
// 2357     case 't':
// 2358       testOpMode = mTxOperation_c;
??ShortCutsParser_6:
        MOVS     R1,#+0
        LDR.N    R2,??DataTable31_71
        STRB     R1,[R2, #+0]
// 2359     break;
        B.N      ??ShortCutsParser_11
// 2360     case 'r':
// 2361       testOpMode = mRxOperation_c;
??ShortCutsParser_4:
        MOVS     R1,#+1
        LDR.N    R2,??DataTable31_71
        STRB     R1,[R2, #+0]
// 2362     break;
        B.N      ??ShortCutsParser_11
// 2363     case 'q': 
// 2364       testChannel++;
??ShortCutsParser_3:
        LDR.N    R1,??DataTable31_72
        LDRB     R1,[R1, #+0]
        ADDS     R1,R1,#+1
        LDR.N    R2,??DataTable31_72
        STRB     R1,[R2, #+0]
// 2365       if(gChannel26_c < testChannel){
        LDR.N    R1,??DataTable31_72
        LDRB     R1,[R1, #+0]
        CMP      R1,#+27
        BLT.N    ??ShortCutsParser_12
// 2366         testChannel = gChannel11_c;
        MOVS     R1,#+11
        LDR.N    R2,??DataTable31_72
        STRB     R1,[R2, #+0]
// 2367       }
// 2368     break;
??ShortCutsParser_12:
        B.N      ??ShortCutsParser_11
// 2369     case 'w':
// 2370       testChannel--;
??ShortCutsParser_7:
        LDR.N    R1,??DataTable31_72
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+1
        LDR.N    R2,??DataTable31_72
        STRB     R1,[R2, #+0]
// 2371       if(gChannel11_c > testChannel){
        LDR.N    R1,??DataTable31_72
        LDRB     R1,[R1, #+0]
        CMP      R1,#+11
        BGE.N    ??ShortCutsParser_13
// 2372         testChannel = gChannel26_c;
        MOVS     R1,#+26
        LDR.N    R2,??DataTable31_72
        STRB     R1,[R2, #+0]
// 2373       }
// 2374     break;
??ShortCutsParser_13:
        B.N      ??ShortCutsParser_11
// 2375     case 'a':
// 2376       testPower++;
??ShortCutsParser_0:
        LDR.N    R1,??DataTable31_73
        LDRB     R1,[R1, #+0]
        ADDS     R1,R1,#+1
        LDR.N    R2,??DataTable31_73
        STRB     R1,[R2, #+0]
// 2377       if(gMaxOutputPower_c < testPower){
        LDR.N    R1,??DataTable31_73
        LDRB     R1,[R1, #+0]
        CMP      R1,#+32
        BLT.N    ??ShortCutsParser_14
// 2378         testPower = gMinOutputPower_c;
        MOVS     R1,#+3
        LDR.N    R2,??DataTable31_73
        STRB     R1,[R2, #+0]
// 2379       }
// 2380     break;
??ShortCutsParser_14:
        B.N      ??ShortCutsParser_11
// 2381     case 's':
// 2382       testPower--;
??ShortCutsParser_5:
        LDR.N    R1,??DataTable31_73
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+1
        LDR.N    R2,??DataTable31_73
        STRB     R1,[R2, #+0]
// 2383       if(gMinOutputPower_c > testPower){
        LDR.N    R1,??DataTable31_73
        LDRB     R1,[R1, #+0]
        CMP      R1,#+3
        BGE.N    ??ShortCutsParser_15
// 2384         testPower = gMaxOutputPower_c;
        MOVS     R1,#+31
        LDR.N    R2,??DataTable31_73
        STRB     R1,[R2, #+0]
// 2385       }
// 2386     break;
??ShortCutsParser_15:
        B.N      ??ShortCutsParser_11
// 2387     case 'z':
// 2388       testTrimmValue++;
??ShortCutsParser_9:
        LDR.N    R1,??DataTable31_74
        LDRB     R1,[R1, #+0]
        ADDS     R1,R1,#+1
        LDR.N    R2,??DataTable31_74
        STRB     R1,[R2, #+0]
// 2389     break;
        B.N      ??ShortCutsParser_11
// 2390     case 'x':
// 2391       testTrimmValue--;
??ShortCutsParser_8:
        LDR.N    R1,??DataTable31_74
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+1
        LDR.N    R2,??DataTable31_74
        STRB     R1,[R2, #+0]
// 2392     break;
        B.N      ??ShortCutsParser_11
// 2393     case 'n':
// 2394       testPayloadLen++;
??ShortCutsParser_2:
        LDR.N    R1,??DataTable31_75
        LDRB     R1,[R1, #+0]
        ADDS     R1,R1,#+1
        LDR.N    R2,??DataTable31_75
        STRB     R1,[R2, #+0]
// 2395       if(gMaxSmacSDULength_c < testPayloadLen){
        LDR.N    R1,??DataTable31_75
        LDRB     R1,[R1, #+0]
        CMP      R1,#+124
        BLT.N    ??ShortCutsParser_16
// 2396         testPayloadLen = 1;
        MOVS     R1,#+1
        LDR.N    R2,??DataTable31_75
        STRB     R1,[R2, #+0]
// 2397       }    
// 2398     break;
??ShortCutsParser_16:
        B.N      ??ShortCutsParser_11
// 2399     case 'm':
// 2400       testPayloadLen--;
??ShortCutsParser_1:
        LDR.N    R1,??DataTable31_75
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+1
        LDR.N    R2,??DataTable31_75
        STRB     R1,[R2, #+0]
// 2401       if(1 > testPayloadLen){
        LDR.N    R1,??DataTable31_75
        LDRB     R1,[R1, #+0]
        CMP      R1,#+0
        BNE.N    ??ShortCutsParser_17
// 2402         testPayloadLen = gMaxSmacSDULength_c;
        MOVS     R1,#+123
        LDR.N    R2,??DataTable31_75
        STRB     R1,[R2, #+0]
// 2403       }    
// 2404     break;
??ShortCutsParser_17:
        B.N      ??ShortCutsParser_11
// 2405     default:
// 2406       evDataFromCOMM = TRUE;
??ShortCutsParser_10:
        MOVS     R1,#+1
        LDR.N    R2,??DataTable31_58
        STRB     R1,[R2, #+0]
// 2407       evTestParameters = FALSE;
        MOVS     R1,#+0
        LDR.N    R2,??DataTable31_96
        STRB     R1,[R2, #+0]
// 2408     break;
// 2409   }
// 2410 }
??ShortCutsParser_11:
        BX       LR               ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31:
        DC32     gPng

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_1:
        DC32     gPng+0x1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_2:
        DC32     gPng+0x2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_3:
        DC32     gPng+0x4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_4:
        DC32     gSnd+0x1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_5:
        DC32     gSnd+0x2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_6:
        DC32     gSnd+0x3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_7:
        DC32     gSnd+0x4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_8:
        DC32     gSnd+0x6

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_9:
        DC32     gSnd+0x8

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_10:
        DC32     gSnd+0xA

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_11:
        DC32     gSnd+0xC

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_12:
        DC32     gSnd+0x10

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_13:
        DC32     gSnd+0x14

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_14:
        DC32     gSnd+0x18

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_15:
        DC32     gSnd+0x1A

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_16:
        DC32     gSnd+0x1C

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_17:
        DC32     gSnd+0x20

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_18:
        DC32     gSnd+0x24

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_19:
        DC32     gSnd+0x28

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_20:
        DC32     gSnd+0x2A

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_21:
        DC32     gSnd+0x2C

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_22:
        DC32     gSnd+0x30

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_23:
        DC32     gSnd+0x34

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_24:
        DC32     gSnd+0x38

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_25:
        DC32     gSnd+0x3A

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_26:
        DC32     gSnd+0x3C

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_27:
        DC32     gSnd+0x3E

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_28:
        DC32     gSnd+0x40

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_29:
        DC32     gSnd+0x42

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_30:
        DC32     gSnd+0x43

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_31:
        DC32     gSnd+0x44

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_32:
        DC32     gOpt+0x1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_33:
        DC32     gOpt+0x2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_34:
        DC32     gOpt+0x3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_35:
        DC32     gOpt+0x4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_36:
        DC32     gOpt+0x8

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_37:
        DC32     gOpt+0xA

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_38:
        DC32     gOpt+0xC

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_39:
        DC32     gOpt+0xE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_40:
        DC32     gOpt+0xF

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_41:
        DC32     gOpt+0x10

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_42:
        DC32     gOpt+0x14

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_43:
        DC32     gOpt+0x18

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_44:
        DC32     gOpt+0x1C

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_45:
        DC32     gOpt+0x1E

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_46:
        DC32     sentPackets

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_47:
        DC32     ?_2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_48:
        DC32     gAppTxPacket

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_49:
        DC32     appState

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_50:
        DC32     gSnd

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_51:
        DC32     sensorID

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_52:
        DC32     0x10f447

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_53:
        DC32     0x21e88e

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_54:
        DC32     0x32dcd5

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_55:
        DC32     0x69f6bc7

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_56:
        DC32     0xd3ed78e

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_57:
        DC32     0x13de4355

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_58:
        DC32     evDataFromCOMM

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_59:
        DC32     ?_3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_60:
        DC32     g_DEAD_BEEF

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_61:
        DC32     gFlashDeadBeef

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_62:
        DC32     settingsAddress

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_63:
        DC32     gOptions

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_64:
        DC32     0x28488

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_65:
        DC32     gOpt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_66:
        DC32     ?_4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_67:
        DC32     ??sDeadBeef

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_68:
        DC32     maMmPools

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_69:
        DC32     poolInfo

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_70:
        DC32     maMacHeap

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_71:
        DC32     testOpMode

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_72:
        DC32     testChannel

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_73:
        DC32     testPower

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_74:
        DC32     testTrimmValue

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_75:
        DC32     testPayloadLen

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_76:
        DC32     contTestRunning

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_77:
        DC32     shortCutsEnabled

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_78:
        DC32     connState

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_79:
        DC32     cTxRxState

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_80:
        DC32     perTxState

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_81:
        DC32     perRxState

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_82:
        DC32     rangeTxState

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_83:
        DC32     rangeRxState

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_84:
        DC32     prevOpMode

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_85:
        DC32     txTestIndex

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_86:
        DC32     rxTestIndex

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_87:
        DC32     gau8TxDataBuffer

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_88:
        DC32     gau8RxDataBuffer

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_89:
        DC32     gAppRxPacket

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_90:
        DC32     bCommTxDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_91:
        DC32     gu8CommData

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_92:
        DC32     bTxDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_93:
        DC32     bRxDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_94:
        DC32     bestChannel

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_95:
        DC32     bScanDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_96:
        DC32     evTestParameters

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        END
// 2411 
// 2412 
// 
//   609 bytes in section .bss
//   188 bytes in section .rodata
// 6 020 bytes in section .text
// 
// 6 020 bytes of CODE  memory
//   188 bytes of CONST memory
//   609 bytes of DATA  memory
//
//Errors: none
//Warnings: 4
