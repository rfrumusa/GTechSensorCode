///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM       02/Sep/2018  14:19:38
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\AD1.c
//    Command line =  
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\AD1.c"
//        -D IAR --preprocess "F:\Guardrail Work\Sensor Code\Git Repo\Sensor
//        Code Sequential ADC Reads\Shanit Origional Code\Connectivity
//        Test\Debug\List\" -lC "F:\Guardrail Work\Sensor Code\Git Repo\Sensor
//        Code Sequential ADC Reads\Shanit Origional Code\Connectivity
//        Test\Debug\List\" -lB "F:\Guardrail Work\Sensor Code\Git Repo\Sensor
//        Code Sequential ADC Reads\Shanit Origional Code\Connectivity
//        Test\Debug\List\" --diag_suppress
//        Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\Obj\" --no_cse --no_unroll
//        --no_inline --no_code_motion --no_tbaa --no_clustering
//        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\APP\CDC\" -I "F:\Guardrail Work\Sensor Code\Git
//        Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\USB\APP\Descriptor\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Class\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Sys Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
//    List file    =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\AD1.s
//
///////////////////////////////////////////////////////////////////////////////

        #define SHT_PROGBITS 0x1

        PUBLIC ADCInit
        PUBLIC CheckConversionActive
        PUBLIC ClearADCContents
        PUBLIC ConversionAComplete
        PUBLIC ConversionBComplete
        PUBLIC DisableADC
        PUBLIC GetConversionValue
        PUBLIC GetConversionValueXYZ
        PUBLIC PDBinit
        PUBLIC StartBattConversion
        PUBLIC StartTempConversion
        PUBLIC StartXConversion
        PUBLIC StartYConversion
        PUBLIC StartZConversion
        PUBLIC startOutputChanel1Timmer
        PUBLIC startOutputChanel2Timmer
        PUBLIC startOutputChanel3Timmer

// F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\AD1.c
//    1    
//    2 
//    3 /* MODULE AD1. */
//    4 
//    5 #include "AD1.h"
//    6 /* {Default RTOS Adapter} No RTOS includes */
//    7 #define CHECK_BIT(var,pos) ((var) & (1<<(pos)))
//    8 
//    9    /** !!!!! IMPORTANT NOTE THE TWO FOLLOWING LINES ARE USED FOR TAKING THE BATTERY MEASURMENTS 
//   10    FOR THE MEASURMENTS ON THE SENSOR THE ADCCFG1 MAY NEED TO BE 39, f9 or something for a faster sample rate
//   11    */
//   12 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//   13 bool_t ADCInit()
//   14 /*
//   15 initilize the ADC modules that connect tothe accelerometer and the temperature sensor.
//   16 */
//   17 {
ADCInit:
        PUSH     {R4-R6,LR}
//   18   uint16_t PlusSideConv;
//   19   uint16_t MinusSideConv;
//   20   
//   21   // enable the clock to the ADC0 Module
//   22   SIM_SCGC6 |= (uint32_t)(1<<27);
        LDR.N    R0,??DataTable16  ;; 0x4004803c
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x8000000
        LDR.N    R1,??DataTable16  ;; 0x4004803c
        STR      R0,[R1, #+0]
//   23   //enable the clock gating to PTE
//   24   SIM_SCGC5 |= (uint32_t)(1<<13);
        LDR.N    R0,??DataTable16_1  ;; 0x40048038
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x2000
        LDR.N    R1,??DataTable16_1  ;; 0x40048038
        STR      R0,[R1, #+0]
//   25  //set all of the values to a known state
//   26   ClearADCContents();
        BL       ClearADCContents
//   27   //set the correct pin muxing for the 4 pins
//   28   PORTD_PCR6 = PORT_PCR_MUX(0x0);
        MOVS     R0,#+0
        LDR.N    R1,??DataTable16_2  ;; 0x4004c018
        STR      R0,[R1, #+0]
//   29   PORTD_PCR7 = PORT_PCR_MUX(0x0);
        MOVS     R0,#+0
        LDR.N    R1,??DataTable16_3  ;; 0x4004c01c
        STR      R0,[R1, #+0]
//   30   
//   31   
//   32   //set the correct colck gating to the three pins for the ADC module
//   33   PORTE_PCR16 = PORT_PCR_MUX(0x0);              //ADCA 4
        MOVS     R0,#+0
        LDR.N    R1,??DataTable16_4  ;; 0x4004d040
        STR      R0,[R1, #+0]
//   34   PORTE_PCR17 = PORT_PCR_MUX(0x0);              //ADCA 5
        MOVS     R0,#+0
        LDR.N    R1,??DataTable16_5  ;; 0x4004d044
        STR      R0,[R1, #+0]
//   35   PORTE_PCR18 = PORT_PCR_MUX(0x0);              //ADCA 6
        MOVS     R0,#+0
        LDR.N    R1,??DataTable16_6  ;; 0x4004d048
        STR      R0,[R1, #+0]
//   36   PORTE_PCR19 = PORT_PCR_MUX(0x0);              //ADCA 7
        MOVS     R0,#+0
        LDR.N    R1,??DataTable16_7  ;; 0x4004d04c
        STR      R0,[R1, #+0]
//   37   
//   38    ADC0_SC1A |= (uint32_t)0x16; 
        LDR.N    R0,??DataTable16_8  ;; 0x4003b000
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x16
        LDR.N    R1,??DataTable16_8  ;; 0x4003b000
        STR      R0,[R1, #+0]
//   39    
//   40   
//   41   ADC0_CFG1 |= (uint32_t)0x1F9;
        LDR.N    R0,??DataTable16_9  ;; 0x4003b008
        LDR      R0,[R0, #+0]
        MOVW     R1,#+505
        ORRS     R0,R1,R0
        LDR.N    R1,??DataTable16_9  ;; 0x4003b008
        STR      R0,[R1, #+0]
//   42   
//   43   ADC0_SC3 = (uint32_t)0xf;
        MOVS     R0,#+15
        LDR.N    R1,??DataTable16_10  ;; 0x4003b024
        STR      R0,[R1, #+0]
//   44   
//   45   //start the calibrtion
//   46   ADC0_SC3 |= (uint32_t)(1<<6);
        LDR.N    R0,??DataTable16_10  ;; 0x4003b024
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x40
        LDR.N    R1,??DataTable16_10  ;; 0x4003b024
        STR      R0,[R1, #+0]
//   47   
//   48  while(ADC0_SC1A & ADC_SC1_COCO_MASK)
??ADCInit_0:
        LDR.N    R0,??DataTable16_8  ;; 0x4003b000
        LDR      R0,[R0, #+0]
        LSLS     R0,R0,#+24
        BMI.N    ??ADCInit_0
//   49    {
//   50     //calibration is not completed
//   51   }
//   52   //calibration is now complete
//   53   if(ADC0_SC3 & ADC_SC3_CALF_MASK)
        LDR.N    R0,??DataTable16_10  ;; 0x4003b024
        LDR      R0,[R0, #+0]
        LSLS     R0,R0,#+25
        BPL.N    ??ADCInit_1
//   54   {
//   55     //calibration failed need to retry
//   56     return 0;
        MOVS     R0,#+0
        B.N      ??ADCInit_2
//   57   }
//   58   
//   59   //calibration passed
//   60   //need to set the plus side gain and the minus side gain registers
//   61   
//   62   PlusSideConv= ADC0_CLP0 + ADC0_CLP1 + ADC0_CLP2 + ADC0_CLP3 + ADC0_CLP4 + ADC0_CLPS;
??ADCInit_1:
        LDR.N    R0,??DataTable16_11  ;; 0x4003b04c
        LDR      R0,[R0, #+0]
        LDR.N    R1,??DataTable16_12  ;; 0x4003b048
        LDR      R1,[R1, #+0]
        LDR.N    R2,??DataTable16_13  ;; 0x4003b044
        LDR      R2,[R2, #+0]
        LDR.N    R3,??DataTable16_14  ;; 0x4003b040
        LDR      R3,[R3, #+0]
        LDR.N    R6,??DataTable16_15  ;; 0x4003b03c
        LDR      R6,[R6, #+0]
        ADDS     R0,R1,R0
        ADDS     R0,R2,R0
        ADDS     R0,R3,R0
        ADDS     R0,R6,R0
        LDR.N    R1,??DataTable16_16  ;; 0x4003b038
        LDR      R1,[R1, #+0]
        ADDS     R0,R1,R0
        MOVS     R5,R0
//   63   PlusSideConv = PlusSideConv /2;
        UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
        MOVS     R0,#+2
        SDIV     R5,R5,R0
//   64   //ADC0_CLPD = PlusSideConv | 0x8000;
//   65   ADC0_PG = PlusSideConv | 0x8000;
        UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
        ORRS     R0,R5,#0x8000
        LDR.N    R1,??DataTable16_17  ;; 0x4003b02c
        STR      R0,[R1, #+0]
//   66   
//   67   MinusSideConv= ADC0_CLM0 + ADC0_CLM1 + ADC0_CLM2 + ADC0_CLM3 + ADC0_CLM4 + ADC0_CLMS;
        LDR.N    R0,??DataTable16_18  ;; 0x4003b06c
        LDR      R0,[R0, #+0]
        LDR.N    R1,??DataTable16_19  ;; 0x4003b068
        LDR      R1,[R1, #+0]
        LDR.N    R2,??DataTable16_20  ;; 0x4003b064
        LDR      R2,[R2, #+0]
        LDR.N    R3,??DataTable16_21  ;; 0x4003b060
        LDR      R3,[R3, #+0]
        LDR.N    R6,??DataTable16_22  ;; 0x4003b05c
        LDR      R6,[R6, #+0]
        ADDS     R0,R1,R0
        ADDS     R0,R2,R0
        ADDS     R0,R3,R0
        ADDS     R0,R6,R0
        LDR.N    R1,??DataTable16_23  ;; 0x4003b058
        LDR      R1,[R1, #+0]
        ADDS     R0,R1,R0
        MOVS     R4,R0
//   68   MinusSideConv = MinusSideConv /2;
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        MOVS     R0,#+2
        SDIV     R4,R4,R0
//   69   //ADC0_CLMD = MinusSideConv | 0x8000;
//   70   ADC0_MG = MinusSideConv | 0x8000;
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        ORRS     R0,R4,#0x8000
        LDR.N    R1,??DataTable16_24  ;; 0x4003b030
        STR      R0,[R1, #+0]
//   71   
//   72   ADC0_SC2 = (uint32_t)0x0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable16_25  ;; 0x4003b020
        STR      R0,[R1, #+0]
//   73   
//   74   
//   75   /* set the time back to faster sample rates. from the conversion times */
//   76    ADC0_CFG1 = (uint32_t)0x19;
        MOVS     R0,#+25
        LDR.N    R1,??DataTable16_9  ;; 0x4003b008
        STR      R0,[R1, #+0]
//   77    ADC0_SC3 = (uint32_t)0x0;              //this well set the ADC for continous conversion, 32 samples and hardware average is enabled
        MOVS     R0,#+0
        LDR.N    R1,??DataTable16_10  ;; 0x4003b024
        STR      R0,[R1, #+0]
//   78   
//   79   
//   80   return 1;
        MOVS     R0,#+1
??ADCInit_2:
        POP      {R4-R6,PC}       ;; return
//   81 }
//   82 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//   83 void ClearADCContents()
//   84 /*
//   85 Set all of the contents from the ADC registers to a known value so there are no issues with the set up of the ADC registers
//   86 */
//   87 {
//   88     ADC0_CFG1 = (uint32_t)0x0;
ClearADCContents:
        MOVS     R0,#+0
        LDR.N    R1,??DataTable16_9  ;; 0x4003b008
        STR      R0,[R1, #+0]
//   89     ADC0_CFG2 = (uint32_t)0x0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable16_26  ;; 0x4003b00c
        STR      R0,[R1, #+0]
//   90     ADC0_CV1 = (uint32_t)0x0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable16_27  ;; 0x4003b018
        STR      R0,[R1, #+0]
//   91     ADC0_CV2 = (uint32_t)0x0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable16_28  ;; 0x4003b01c
        STR      R0,[R1, #+0]
//   92     ADC0_SC2 = (uint32_t)0x0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable16_25  ;; 0x4003b020
        STR      R0,[R1, #+0]
//   93     ADC0_SC3 = (uint32_t)0x0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable16_10  ;; 0x4003b024
        STR      R0,[R1, #+0]
//   94 }
        BX       LR               ;; return
//   95 
//   96 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//   97 bool_t CheckConversionActive()
//   98 {
//   99   if(ADC0_SC2 & ADC_SC2_ADACT_MASK)
CheckConversionActive:
        LDR.N    R0,??DataTable16_25  ;; 0x4003b020
        LDR      R0,[R0, #+0]
        LSLS     R0,R0,#+24
        BPL.N    ??CheckConversionActive_0
//  100   {
//  101     return 1;
        MOVS     R0,#+1
        B.N      ??CheckConversionActive_1
//  102   }
//  103   return 0;
??CheckConversionActive_0:
        MOVS     R0,#+0
??CheckConversionActive_1:
        BX       LR               ;; return
//  104 }
//  105 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  106 bool_t ConversionAComplete()
//  107 /*
//  108 Checks to see if the conversion is complete
//  109 */
//  110 {
//  111   //check if 1 conversion is complete bit 7
//  112   if(ADC0_SC1A & ADC_SC1_COCO_MASK)
ConversionAComplete:
        LDR.N    R0,??DataTable16_8  ;; 0x4003b000
        LDR      R0,[R0, #+0]
        LSLS     R0,R0,#+24
        BPL.N    ??ConversionAComplete_0
//  113   {
//  114     return 1;
        MOVS     R0,#+1
        B.N      ??ConversionAComplete_1
//  115   }
//  116   
//  117   return 0;
??ConversionAComplete_0:
        MOVS     R0,#+0
??ConversionAComplete_1:
        BX       LR               ;; return
//  118 }
//  119 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  120 bool_t ConversionBComplete()
//  121 /*
//  122 Checks to see if the conversion is complete for the B ADC
//  123 */
//  124 {
//  125   //check if 1 conversion is complete bit 7
//  126   if(ADC0_SC1B & ADC_SC1_COCO_MASK)
ConversionBComplete:
        LDR.N    R0,??DataTable16_29  ;; 0x4003b004
        LDR      R0,[R0, #+0]
        LSLS     R0,R0,#+24
        BPL.N    ??ConversionBComplete_0
//  127   {
//  128     return 1;
        MOVS     R0,#+1
        B.N      ??ConversionBComplete_1
//  129   }
//  130   
//  131   return 0;
??ConversionBComplete_0:
        MOVS     R0,#+0
??ConversionBComplete_1:
        BX       LR               ;; return
//  132 }
//  133 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  134 void StartBattConversion()
//  135 /*
//  136 selects the correct chanel to start the conversion and starts the conversion
//  137 */
//  138 {
//  139   /* Old way to try and start the conversion in channel B
//  140   //need to connect to the B chanel
//  141   ADC0_CFG2 = (uint32_t)0x10;
//  142   //set the conversionchanel in the B channel
//  143   ADC0_SC1B = (uint32_t)0x5;
//  144   */
//  145   
//  146   //need to connect to the A chanel
//  147   ADC0_CFG2 = (uint32_t)0x0;             
StartBattConversion:
        MOVS     R0,#+0
        LDR.N    R1,??DataTable16_26  ;; 0x4003b00c
        STR      R0,[R1, #+0]
//  148   
//  149   ADC0_SC1A =  (uint32_t)0x7 ;
        MOVS     R0,#+7
        LDR.N    R1,??DataTable16_8  ;; 0x4003b000
        STR      R0,[R1, #+0]
//  150  
//  151   //set the first 5 bits equal to the correct location 
//  152 
//  153   
//  154 }
        BX       LR               ;; return
//  155 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  156 void StartXConversion()
//  157 /*
//  158 selects the correct chanel to start the conversion and starts the conversion
//  159 */
//  160 {
//  161   /* Old way to try and start the conversion in channel B
//  162   //need to connect to the B chanel
//  163   ADC0_CFG2 = (uint32_t)0x10;
//  164   //set the conversionchanel in the B channel
//  165   ADC0_SC1B = (uint32_t)0x5;
//  166   */
//  167   
//  168   //need to connect to the A chanel
//  169   ADC0_CFG2 = (uint32_t)0x0;             
StartXConversion:
        MOVS     R0,#+0
        LDR.N    R1,??DataTable16_26  ;; 0x4003b00c
        STR      R0,[R1, #+0]
//  170   
//  171   ADC0_SC1A =  (uint32_t)0x4 ;
        MOVS     R0,#+4
        LDR.N    R1,??DataTable16_8  ;; 0x4003b000
        STR      R0,[R1, #+0]
//  172  
//  173   //set the first 5 bits equal to the correct location 
//  174 
//  175   
//  176 }
        BX       LR               ;; return
//  177 
//  178 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  179 void StartYConversion()
//  180 /*
//  181 selects the correct chanel to start the conversion and starts the conversion
//  182 */
//  183 {
//  184   
//  185   /*Code that was used for old conversion techquine when Was connected to the B channel
//  186   ADC0_CFG2 = (uint32_t)0x10;
//  187   //dissable differential mode set the first 5 bits equal to the correct location 
//  188   //this shoud start the conversion
//  189   ADC0_SC1B = (uint32_t)0x6;
//  190   */
//  191   
//  192   //need to connect to the A chanel
//  193   ADC0_CFG2 = (uint32_t)0x0;             
StartYConversion:
        MOVS     R0,#+0
        LDR.N    R1,??DataTable16_26  ;; 0x4003b00c
        STR      R0,[R1, #+0]
//  194   
//  195   ADC0_SC1A =  (uint32_t)0x5 ;
        MOVS     R0,#+5
        LDR.N    R1,??DataTable16_8  ;; 0x4003b000
        STR      R0,[R1, #+0]
//  196  
//  197   //set the first 5 bits equal to the correct location 
//  198 }
        BX       LR               ;; return
//  199 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  200 void StartZConversion()
//  201 /*
//  202 selects the correct chanel to start the conversion and starts the conversion
//  203 */
//  204 {
//  205   /*  this is old code for when it was connected to channel 
//  206   ADC0_SC2 = (uint32_t)0x40;
//  207   
//  208   ADC0_SC3 = (uint32_t)0xc;
//  209   //need to connect to the B chanel
//  210   ADC0_CFG2 = (uint32_t)0x10;
//  211   //dissable differential mode
//  212   //this shoud start the conversion
//  213   ADC0_SC1B = (uint32_t)0x7;
//  214   */
//  215   
//  216   //need to connect to the A chanel
//  217   ADC0_CFG2 = (uint32_t)0x0;             
StartZConversion:
        MOVS     R0,#+0
        LDR.N    R1,??DataTable16_26  ;; 0x4003b00c
        STR      R0,[R1, #+0]
//  218   
//  219   ADC0_SC1A =  (uint32_t)0x6 ;
        MOVS     R0,#+6
        LDR.N    R1,??DataTable16_8  ;; 0x4003b000
        STR      R0,[R1, #+0]
//  220   //set the first 5 bits equal to the correct location 
//  221   
//  222 }
        BX       LR               ;; return
//  223 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  224 void StartTempConversion()
//  225 /*
//  226 selects the correct chanel to start the conversion and starts the conversion
//  227 */
//  228 {
//  229   //need to connect to the A chanel
//  230   ADC0_CFG2 = (uint32_t)0x0;             
StartTempConversion:
        MOVS     R0,#+0
        LDR.N    R1,??DataTable16_26  ;; 0x4003b00c
        STR      R0,[R1, #+0]
//  231   
//  232   ADC0_SC1A =  (uint32_t)0x16 ;
        MOVS     R0,#+22
        LDR.N    R1,??DataTable16_8  ;; 0x4003b000
        STR      R0,[R1, #+0]
//  233  
//  234   //set the first 5 bits equal to the correct location 
//  235 }
        BX       LR               ;; return
//  236 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  237 uint32_t GetConversionValueXYZ()
//  238 /*
//  239 returns the value of the converstion
//  240 */
//  241 {
//  242   return ADC0_RB;
GetConversionValueXYZ:
        LDR.N    R0,??DataTable16_30  ;; 0x4003b014
        LDR      R0,[R0, #+0]
        BX       LR               ;; return
//  243 }
//  244 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  245 uint32_t GetConversionValue()
//  246 /*
//  247 returns the value of the converstion
//  248 */
//  249 {
//  250   return ADC0_RA;
GetConversionValue:
        LDR.N    R0,??DataTable16_31  ;; 0x4003b010
        LDR      R0,[R0, #+0]
        BX       LR               ;; return
//  251 }
//  252 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  253 void DisableADC()
//  254 {
//  255   ADC0_SC1A = 0x1F;
DisableADC:
        MOVS     R0,#+31
        LDR.N    R1,??DataTable16_8  ;; 0x4003b000
        STR      R0,[R1, #+0]
//  256   ADC0_SC1B = 0x1F;
        MOVS     R0,#+31
        LDR.N    R1,??DataTable16_29  ;; 0x4003b004
        STR      R0,[R1, #+0]
//  257 }
        BX       LR               ;; return
//  258 
//  259 
//  260 
//  261 
//  262 
//  263 
//  264 
//  265 
//  266 
//  267 /*this method initilizes the PDB module
//  268 Params- NONE
//  269 return - VOID
//  270 Function
//  271   sets things to the values to use the PDB to start the ADC conversions
//  272 PDB0_SC -> LDMOD 00 -> PDBEIE 0 -> SWTRIG 0(this will be set periodically to reset the counter) -> DMAEN 0 -> PRESCALER 010 -> TRGSEL 0000(this will be cahnging with SWTRIG to change the channel
//  273         ->PDBEN 0 -> PDBIF 0 -> PDBIE 0 -> reserved 0 -> CONT 0 -> LDOK 0( this needs to change with PDBEN being set to 1) 0x800
//  274 
//  275 PDB0_MOD -> this is the resgister that will be the comnparitor, when the internal counter reaches this value it will acitvate a conversion. 0x1
//  276 
//  277 PDB0_CNT -> contains the value of the counter
//  278 
//  279 PDB0_CH0C1 -> BB 00000000(dont want back to back operations) -> TOS 00000001 (this will be changing from this to 00000010 and 00000100 for other chanels) -> EN 1 -> 0x3
//  280 
//  281 PDB0_CH0DLY0 -> DLY 0 -> 0x0
//  282 PDB0_CH0DLY1 -> DLY 0 -> 0x0
//  283 PDB0_POEN -> POEN 0 -> 0x0
//  284 
//  285 NEED TO SET UP THE INTERUPT FOR THE ADC SO IT WILL READ THE VALUE WHEN IT IS FINISHED WITH THE CONVERSION
//  286 
//  287 */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  288 void PDBinit()
//  289 {
//  290   //need to enable this in the sistem registers
//  291   SIM_SCGC6 |= (uint32_t) (1<<22);
PDBinit:
        LDR.N    R0,??DataTable16  ;; 0x4004803c
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x400000
        LDR.N    R1,??DataTable16  ;; 0x4004803c
        STR      R0,[R1, #+0]
//  292   PDB0_SC = (uint32_t)0x800;
        MOV      R0,#+2048
        LDR.N    R1,??DataTable16_32  ;; 0x40036000
        STR      R0,[R1, #+0]
//  293   
//  294   PDB0_MOD = (uint32_t)0x1;
        MOVS     R0,#+1
        LDR.N    R1,??DataTable16_33  ;; 0x40036004
        STR      R0,[R1, #+0]
//  295   
//  296   PDB0_CH0C1 = (uint32_t)0x1;
        MOVS     R0,#+1
        LDR.N    R1,??DataTable16_34  ;; 0x40036010
        STR      R0,[R1, #+0]
//  297   
//  298   PDB0_CH0DLY0 = (uint32_t)0x0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable16_35  ;; 0x40036018
        STR      R0,[R1, #+0]
//  299   PDB0_CH1DLY0 = (uint32_t)0x0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable16_36  ;; 0x40036040
        STR      R0,[R1, #+0]
//  300   PDB0_POEN = (uint32_t)0x0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable16_37  ;; 0x40036190
        STR      R0,[R1, #+0]
//  301   
//  302   
//  303 }
        BX       LR               ;; return
//  304 /*
//  305 Params -None
//  306 returns - void
//  307  starts the timmer and enables the chanel 0 from CH0C1 register 
//  308 */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  309 void startOutputChanel1Timmer()
//  310 {
//  311   //enable PBEN and LDOK and set chanel 0 trigger
//  312   PDB0_SC = (uint32_t)0x821;
startOutputChanel1Timmer:
        MOVW     R0,#+2081
        LDR.N    R1,??DataTable16_32  ;; 0x40036000
        STR      R0,[R1, #+0]
//  313   //enable the output for the first ADC channel
//  314   PDB0_CH0C1 = (uint32_t)0x3;
        MOVS     R0,#+3
        LDR.N    R1,??DataTable16_34  ;; 0x40036010
        STR      R0,[R1, #+0]
//  315   //this may want to be a different channel, channel 0 should be for ADC0 A and channel 2 should be for ADC0 B
//  316   
//  317 }
        BX       LR               ;; return
//  318                                                                                                                                            /*(
//  319 void startOutputChanel1Timmer()
//  320 {
//  321   //enable PBEN and LDOK and set chanel 0 trigger
//  322   PDB0_SC = (uint32_t)0x821;
//  323   //enable the output for the first ADC channel
//  324   PDB0_CH0C1 = (uint32_t)0x3;
//  325   //this may want to be a different channel, channel 0 should be for ADC0 A and channel 2 should be for ADC0 B
//  326   
//  327 }
//  328                                                                                                                                            */
//  329 /*
//  330 
//  331 
//  332 The next two functions may not be correct may only want to use the first one to set up the starting of the conversion and then change it to the
//  333 correct ADC channel
//  334 
//  335 
//  336 */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  337 void startOutputChanel2Timmer()
//  338 {
//  339   //enable PBEN and LDOK and set chanel 0 trigger
//  340   PDB0_SC = (uint32_t)0x821;
startOutputChanel2Timmer:
        MOVW     R0,#+2081
        LDR.N    R1,??DataTable16_32  ;; 0x40036000
        STR      R0,[R1, #+0]
//  341   //enable the output for the first ADC channel
//  342   PDB0_CH0C1 = (uint32_t)0xB;
        MOVS     R0,#+11
        LDR.N    R1,??DataTable16_34  ;; 0x40036010
        STR      R0,[R1, #+0]
//  343   //this may want to be a different channel, channel 0 should be for ADC0 A and channel 2 should be for ADC0 B
//  344   
//  345 }
        BX       LR               ;; return
//  346 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  347 void startOutputChanel3Timmer()
//  348 {
//  349   //enable PBEN and LDOK and set chanel 0 trigger
//  350   PDB0_SC = (uint32_t)0x821;
startOutputChanel3Timmer:
        MOVW     R0,#+2081
        LDR.N    R1,??DataTable16_32  ;; 0x40036000
        STR      R0,[R1, #+0]
//  351   //enable the output for the first ADC channel
//  352   PDB0_CH0C1 = (uint32_t)0xB;
        MOVS     R0,#+11
        LDR.N    R1,??DataTable16_34  ;; 0x40036010
        STR      R0,[R1, #+0]
//  353   //this may want to be a different channel, channel 0 should be for ADC0 A and channel 2 should be for ADC0 B
//  354   
//  355 }
        BX       LR               ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16:
        DC32     0x4004803c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_1:
        DC32     0x40048038

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_2:
        DC32     0x4004c018

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_3:
        DC32     0x4004c01c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_4:
        DC32     0x4004d040

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_5:
        DC32     0x4004d044

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_6:
        DC32     0x4004d048

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_7:
        DC32     0x4004d04c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_8:
        DC32     0x4003b000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_9:
        DC32     0x4003b008

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_10:
        DC32     0x4003b024

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_11:
        DC32     0x4003b04c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_12:
        DC32     0x4003b048

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_13:
        DC32     0x4003b044

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_14:
        DC32     0x4003b040

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_15:
        DC32     0x4003b03c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_16:
        DC32     0x4003b038

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_17:
        DC32     0x4003b02c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_18:
        DC32     0x4003b06c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_19:
        DC32     0x4003b068

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_20:
        DC32     0x4003b064

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_21:
        DC32     0x4003b060

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_22:
        DC32     0x4003b05c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_23:
        DC32     0x4003b058

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_24:
        DC32     0x4003b030

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_25:
        DC32     0x4003b020

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_26:
        DC32     0x4003b00c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_27:
        DC32     0x4003b018

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_28:
        DC32     0x4003b01c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_29:
        DC32     0x4003b004

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_30:
        DC32     0x4003b014

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_31:
        DC32     0x4003b010

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_32:
        DC32     0x40036000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_33:
        DC32     0x40036004

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_34:
        DC32     0x40036010

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_35:
        DC32     0x40036018

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_36:
        DC32     0x40036040

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_37:
        DC32     0x40036190

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        END
//  356 
//  357 
//  358 
// 
// 694 bytes in section .text
// 
// 694 bytes of CODE memory
//
//Errors: none
//Warnings: none
