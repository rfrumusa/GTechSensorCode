///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM       02/Sep/2018  14:19:39
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Generic
//        Services\Source\MsgSystem.c
//    Command line =  
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Generic
//        Services\Source\MsgSystem.c" -D IAR --preprocess "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\List\" -lC "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\List\" -lB "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\List\" --diag_suppress
//        Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\Obj\" --no_cse --no_unroll
//        --no_inline --no_code_motion --no_tbaa --no_clustering
//        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\APP\CDC\" -I "F:\Guardrail Work\Sensor Code\Git
//        Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\USB\APP\Descriptor\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Class\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Sys Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
//    List file    =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\MsgSystem.s
//
///////////////////////////////////////////////////////////////////////////////

        #define SHT_PROGBITS 0x1

        EXTERN IntDisableAll
        EXTERN IntRestoreAll

        PUBLIC List_AddHead
        PUBLIC List_AddTail
        PUBLIC List_ClearAnchor
        PUBLIC List_GetFirst
        PUBLIC List_GetNext
        PUBLIC List_Remove
        PUBLIC List_RemoveHead
        PUBLIC MM_AddMsgToTrackingArray
        PUBLIC MM_AddToPool
        PUBLIC MM_Alloc
        PUBLIC MM_AllocFast
        PUBLIC MM_AllocPool
        PUBLIC MM_Free
        PUBLIC MM_GetMsgIndex
        PUBLIC MM_GetPool
        PUBLIC MM_Init
        PUBLIC MM_InitMsgTracking
        PUBLIC MM_UpdateMsgTracking
        PUBLIC gFreeMessagesCount
        PUBLIC maMacHeap
        PUBLIC maMmPools
        PUBLIC pMacPool
        PUBLIC poolInfo

// F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\Generic Services\Source\MsgSystem.c
//    1 /************************************************************************************
//    2 * This module implements the memory allocation, list, and message modules. The memory
//    3 * allocation is build around N (1-3) pools with various memory allocation unit (block)
//    4 * sizes. Each pool consists of an anchor with head and tail pointers. The memory blocks
//    5 * are all linked to the anchor using a single chained list. Thus each block has a next
//    6 * pointer. The user of the functions in this module never has to be concerned with the
//    7 * list overhead since this is handled transparently. The block pointer which the user
//    8 * receives when allocating memory is pointing to the address after the next-pointer.
//    9 *
//   10 * FIFO Queues are implemented using the same list functions as used by the memory
//   11 * (de)allocation functions. The queue data object is simply an anchor (anchor_t).
//   12 * List_AddTail is used for putting allocated blocks on the queue, and List_RemoveHead
//   13 * will detach the block from the queue. Before using a queue anchor it must have been
//   14 * initialized with List_ClearAnchor. No extra header is required in order to put a
//   15 * block in a queue. However, messages should contain type information beside the
//   16 * message data so that the message handler at the receiver can reckognize the message.
//   17 *
//   18 * Messages are sent by allocating a block using MM_Alloc, and using the MSG_Send macro
//   19 * to call the Service Access Point (SAP) of the receiver. If the SAP handles specific
//   20 * messages synchronously (returns with result immideately) then the block may be
//   21 * allocated on the stack of the calling function. The message types which allows this
//   22 * are specified in the design documents.
//   23 *
//   24 * (c) Copyright 2012, Freescale, Inc.  All rights reserved.
//   25 *
//   26 * No part of this document may be reproduced in any form - including copied,
//   27 * transcribed, printed or by any electronic means - without specific written
//   28 * permission from Freescale Semiconductor.
//   29 *
//   30 ************************************************************************************/
//   31 
//   32 #include "MsgSystem.h"
//   33 #include "Interrupt.h"
//   34 
//   35 #if MsgTracking_d
//   36 #include "FunctionLib.h"
//   37 #endif
//   38 
//   39 /************************************************************************************
//   40 *************************************************************************************
//   41 * Private macros
//   42 *************************************************************************************
//   43 ************************************************************************************/
//   44   #define MmAssert(condition)
//   45   #define MmDebug_InitPool(pool)
//   46   #define MmDebug_InitBlock(block)
//   47   #define MM_DEBUG_LOG(fName)
//   48 
//   49 /************************************************************************************
//   50 *************************************************************************************
//   51 * Private type definitions
//   52 *************************************************************************************
//   53 ************************************************************************************/
//   54 
//   55 /************************************************************************************
//   56 *************************************************************************************
//   57 * Public memory declarations
//   58 *************************************************************************************
//   59 ************************************************************************************/
//   60 // The heap for MAC, NWK and application memory blocks.

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   61 uint8_t maMacHeap[mMmTotalPoolSize_c];
maMacHeap:
        DS8 2940
//   62 
//   63 // Memory pool info and anchors.

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   64 pools_t maMmPools[gMmNumPools_c];
maMmPools:
        DS8 36
//   65 
//   66 // Const array used during initialization. Describes the memory layout.
//   67 // Pools must occur in the table in ascending order according to their size.

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
//   68 const poolInfo_t poolInfo[gMmNumPools_c] = {
poolInfo:
        DATA
        DC8 5, 48, 180, 0, 10, 180, 252, 0, 3, 252, 0, 0
//   69   {gMmPoolSize0_c, mMmBlockSize0_c, mMmBlockSize1_c, 0},
//   70 #if gMmNumPools_c > 1
//   71   {gMmPoolSize1_c, mMmBlockSize1_c, mMmBlockSize2_c, 0},
//   72 #if gMmNumPools_c > 2
//   73   {gMmPoolSize2_c, mMmBlockSize2_c, 0, 0}
//   74 #endif // gMmNumPools_c > 2
//   75 #endif // gMmNumPools_c > 1
//   76 };
//   77 
//   78 
//   79 /************************************************************************************
//   80 *************************************************************************************
//   81 * Private memory declarations
//   82 *************************************************************************************
//   83 ************************************************************************************/
//   84 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   85 const pools_t *pMacPool = NULL;
pMacPool:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   86 uint8_t gFreeMessagesCount;
gFreeMessagesCount:
        DS8 1
//   87 
//   88 #if MsgTracking_d
//   89 uint8_t NoOfWrongAddrs = 0;
//   90 uint32_t mLinkRegister; /* Used by Message Tracking feature*/
//   91 const uint8_t TotalNoOfMsgs_c = (gTotalBigMsgs_d + gTotalSmallMsgs_d + gTotalExtendedBigMsgs_d);
//   92 MsgTracking_t MsgTrackingArray [(gTotalBigMsgs_d + gTotalSmallMsgs_d + gTotalExtendedBigMsgs_d)] = {0};
//   93 #endif
//   94 
//   95 /************************************************************************************
//   96 *************************************************************************************
//   97 * Private prototypes
//   98 *************************************************************************************
//   99 ************************************************************************************/
//  100   #define MmDebug_Alloc(pPool, numBytes)
//  101   #define MmDebug_AllocFail(pPool, numBytes)
//  102   #define MmDebug_Free(pPool)
//  103 
//  104 int8_t MM_GetMsgIndex(const uint32_t BufferAddr);
//  105 bool_t MM_UpdateMsgTracking(const void *pBlock, const bool_t Alloc);
//  106 void   MM_InitMsgTracking(void);
//  107 void   MM_AddMsgToTrackingArray(uint8_t Index, uint32_t Addr);
//  108 
//  109 
//  110 /************************************************************************************
//  111 *************************************************************************************
//  112 * Public functions
//  113 *************************************************************************************
//  114 ************************************************************************************/
//  115 
//  116 /************************************************************************************
//  117 * This function initializes the message module private variables. Must be
//  118 * called at boot time, or if device is reset. Currently the module supports
//  119 * up to 3 memory pools.
//  120 *
//  121 * The gMmPoolSize*_c constants determine the number of blocks in a pool, and
//  122 * gMmBlockSize*_c is the number of bytes in each block for the corresponding pool.
//  123 * The number of bytes is rounded up to a value so that each block is aligned to
//  124 * a machine dependant boundary in order to avoid bus errors during pool access.
//  125 *
//  126 * The total amount of heap required is given by the constant mMmTotalPoolSize_c.
//  127 *
//  128 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  129 void MM_Init
//  130   (
//  131   uint8_t *pHeap,               // IN: Memory heap. Caller must be sure to make this big enough
//  132   const poolInfo_t *pPoolInfo,  // IN: Memory layout information
//  133   pools_t *pPools               // OUT: Will be initialized with requested memory pools.
//  134   )
//  135 {
MM_Init:
        PUSH     {R4-R8,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
//  136   uintn8_t poolN;
//  137   uint8_t nBuffer = 0;
        MOVS     R8,#+0
//  138   gFreeMessagesCount = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable5
        STRB     R0,[R1, #+0]
//  139 
//  140   MM_DEBUG_LOG(MM_Init);
//  141   MM_InitMsgTracking();
        BL       MM_InitMsgTracking
//  142 
//  143   pMacPool = &maMmPools[mMmBigMsgPoolIdx_c];
        LDR.N    R0,??DataTable5_1
        LDR.N    R1,??DataTable5_2
        STR      R0,[R1, #+0]
//  144 
//  145 
//  146   for(;;) {
//  147     poolN = pPoolInfo->poolSize;
??MM_Init_0:
        LDRB     R0,[R5, #+0]
        MOVS     R7,R0
//  148 
//  149     List_ClearAnchor(&pPools->anchor);
        MOVS     R0,R6
        BL       List_ClearAnchor
//  150 
//  151     MmDebug_InitPool(pPools);
//  152 
//  153     while(poolN) {
??MM_Init_1:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+0
        BEQ.N    ??MM_Init_2
//  154       MmDebug_InitBlock(pHeap);
//  155         // Add block to list of free memory.
//  156       ((listHeader_t *)pHeap)->pParentPool = pPools;
        STR      R6,[R4, #+4]
//  157       MM_AddToPool(pPools, pHeap);
        MOVS     R1,R4
        MOVS     R0,R6
        BL       MM_AddToPool
//  158 
//  159       gFreeMessagesCount++;
        LDR.N    R0,??DataTable5
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR.N    R1,??DataTable5
        STRB     R0,[R1, #+0]
//  160 
//  161       MM_AddMsgToTrackingArray(nBuffer, (uint32_t) pHeap  + 8);
        ADDS     R1,R4,#+8
        MOV      R0,R8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       MM_AddMsgToTrackingArray
//  162       nBuffer++;
        ADDS     R8,R8,#+1
//  163 
//  164         // Add block size (without list header)
//  165       pHeap += pPoolInfo->blockSize + sizeof(listHeader_t);
        LDRB     R0,[R5, #+1]
        ADDS     R0,R0,R4
        ADDS     R4,R0,#+8
//  166       poolN--;
        SUBS     R7,R7,#+1
        B.N      ??MM_Init_1
//  167     }
//  168 
//  169     pPools->blockSize = pPoolInfo->blockSize;
??MM_Init_2:
        LDRB     R0,[R5, #+1]
        STRB     R0,[R6, #+9]
//  170 
//  171     pPools->nextBlockSize = pPoolInfo->nextBlockSize;
        LDRB     R0,[R5, #+2]
        STRB     R0,[R6, #+8]
//  172     if(pPools->nextBlockSize == 0)
        LDRB     R0,[R6, #+8]
        CMP      R0,#+0
        BEQ.N    ??MM_Init_3
//  173       break;
//  174 
//  175     pPools++;
//  176     pPoolInfo++;
//  177   }
//  178 }
??MM_Init_4:
        ADDS     R6,R6,#+12
        ADDS     R5,R5,#+4
        B.N      ??MM_Init_0
??MM_Init_3:
        POP      {R4-R8,PC}       ;; return
//  179 
//  180 
//  181 /************************************************************************************
//  182 * Initialize a list anchor with a NULL list header. Used for preparing an anchor for
//  183 * first time use
//  184 *
//  185 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  186 void List_ClearAnchor
//  187   (
//  188   anchor_t *pAnchor // IN: Anchor of list to reset
//  189   )
//  190 {
//  191   pAnchor->pHead = NULL;
List_ClearAnchor:
        MOVS     R1,#+0
        STR      R1,[R0, #+0]
//  192 }
        BX       LR               ;; return
//  193 
//  194 /************************************************************************************
//  195 * Links a list element to the tail of the list given by the anchor argument.
//  196 * This function is amongst other useful for FIFO queues if combined with
//  197 * List_RemoveHead.
//  198 *
//  199 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  200 void List_AddTail
//  201   (
//  202   anchor_t *pAnchor, //IN: Anchor of list to add element to
//  203   void *pBlock       //IN: Element to add to tail of list
//  204   )
//  205 {
List_AddTail:
        PUSH     {R4-R6,LR}
        MOVS     R4,R0
        MOVS     R5,R1
//  206   uint32_t saveInt;
//  207 
//  208   MmAssert(pAnchor && pBlock);
//  209 
//  210   MM_DEBUG_LOG(List_AddTail);
//  211   if ((NULL == pBlock) || (NULL == pAnchor))
        CMP      R5,#+0
        BEQ.N    ??List_AddTail_0
        CMP      R4,#+0
        BNE.N    ??List_AddTail_1
//  212     return;
??List_AddTail_0:
        B.N      ??List_AddTail_2
//  213 
//  214     // Get pointer to header portion of the list element
//  215   pBlock = ((listHeader_t *)pBlock)-1;
??List_AddTail_1:
        SUBS     R5,R5,#+8
//  216     // The new element must terminate the list.
//  217   ((listHeader_t *)pBlock)->pNext = NULL;
        MOVS     R0,#+0
        STR      R0,[R5, #+0]
//  218 
//  219   saveInt = IntDisableAll();
        BL       IntDisableAll
        MOVS     R6,R0
//  220 
//  221     // Update current tail element with pointer to new element
//  222   if(pAnchor->pHead) {
        LDR      R0,[R4, #+0]
        CMP      R0,#+0
        BEQ.N    ??List_AddTail_3
//  223       // Make old tail point to new element.
//  224     pAnchor->pTail->pNext = pBlock;
        LDR      R0,[R4, #+4]
        STR      R5,[R0, #+0]
        B.N      ??List_AddTail_4
//  225   }
//  226   else {
//  227       // Nothing in list yet, so initialize head pointer.
//  228     pAnchor->pHead = pBlock;
??List_AddTail_3:
        STR      R5,[R4, #+0]
//  229   }
//  230     // Let new element be the tail.
//  231   pAnchor->pTail = pBlock;
??List_AddTail_4:
        STR      R5,[R4, #+4]
//  232 
//  233   IntRestoreAll(saveInt);
        MOVS     R0,R6
        BL       IntRestoreAll
//  234 }
??List_AddTail_2:
        POP      {R4-R6,PC}       ;; return
//  235 
//  236 
//  237 /************************************************************************************
//  238 *
//  239 * Links a list element to the head of the list given by the anchor argument.
//  240 * Useful for FILO buffers (push/pop stacks).
//  241 *
//  242 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  243 void List_AddHead
//  244   (
//  245   anchor_t *pAnchor, //IN: Anchor of list to add element to
//  246   void *pBlock       //IN: Element to add to head of list
//  247   )
//  248 {
List_AddHead:
        PUSH     {R3-R7,LR}
        MOVS     R4,R0
        MOVS     R5,R1
//  249   listHeader_t *pNewBlock;
//  250   uint32_t saveInt;
//  251 
//  252   MmAssert(pAnchor && pBlock);
//  253   MM_DEBUG_LOG(List_AddHead);
//  254 
//  255   if (NULL == pBlock || NULL == pAnchor)
        CMP      R5,#+0
        BEQ.N    ??List_AddHead_0
        CMP      R4,#+0
        BNE.N    ??List_AddHead_1
//  256 	return;
??List_AddHead_0:
        B.N      ??List_AddHead_2
//  257 
//  258     // Get pointer to header portion of the list element
//  259   pNewBlock = ((listHeader_t *)pBlock)-1;
??List_AddHead_1:
        SUBS     R0,R5,#+8
        MOVS     R6,R0
//  260 
//  261   saveInt = IntDisableAll();
        BL       IntDisableAll
        MOVS     R7,R0
//  262 
//  263    // If list is empty, then the element will also be the tail of the list.
//  264   if(pAnchor->pHead == NULL) {
        LDR      R0,[R4, #+0]
        CMP      R0,#+0
        BNE.N    ??List_AddHead_3
//  265     pAnchor->pTail = pNewBlock;
        STR      R6,[R4, #+4]
//  266   }
//  267     // Let the new element point to the old head element (NULL if list is empty).
//  268   pNewBlock->pNext = pAnchor->pHead;
??List_AddHead_3:
        LDR      R0,[R4, #+0]
        STR      R0,[R6, #+0]
//  269     // The new element becomes the new list header.
//  270   pAnchor->pHead = pNewBlock;
        STR      R6,[R4, #+0]
//  271 
//  272   IntRestoreAll(saveInt);
        MOVS     R0,R7
        BL       IntRestoreAll
//  273 }
??List_AddHead_2:
        POP      {R0,R4-R7,PC}    ;; return
//  274 
//  275 
//  276 /************************************************************************************
//  277 * Unlinks a list element from the head of the list given by the anchor argument.
//  278 *
//  279 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  280 void *List_RemoveHead
//  281   (
//  282   anchor_t *pAnchor  //IN: Anchor of list to remove head from
//  283   )
//  284 {
List_RemoveHead:
        PUSH     {R4-R6,LR}
        MOVS     R4,R0
//  285   listHeader_t *pBlock;
//  286   uint32_t saveInt;
//  287 
//  288   MmAssert(pAnchor);
//  289   MM_DEBUG_LOG(List_RemoveHead);
//  290   if (NULL == pAnchor)
        CMP      R4,#+0
        BNE.N    ??List_RemoveHead_0
//  291 	return NULL;
        MOVS     R0,#+0
        B.N      ??List_RemoveHead_1
//  292 
//  293   saveInt = IntDisableAll();
??List_RemoveHead_0:
        BL       IntDisableAll
        MOVS     R6,R0
//  294 
//  295     // If any head element, then remove it by setting
//  296     // the head to the next element in the list.
//  297     // If we just removed the last element, then the
//  298     // tail ponter must be set to 0.
//  299   pBlock = pAnchor->pHead;
        LDR      R0,[R4, #+0]
        MOVS     R5,R0
//  300   if(pBlock) {
        CMP      R5,#+0
        BEQ.N    ??List_RemoveHead_2
//  301     pAnchor->pHead = pBlock->pNext;
        LDR      R0,[R5, #+0]
        STR      R0,[R4, #+0]
//  302   }
//  303 
//  304   IntRestoreAll(saveInt);
??List_RemoveHead_2:
        MOVS     R0,R6
        BL       IntRestoreAll
//  305 
//  306     // Skip header, and return pointer to data area if pointer is not NULL.
//  307   return pBlock ? pBlock+1 : pBlock;
        CMP      R5,#+0
        BEQ.N    ??List_RemoveHead_3
        ADDS     R5,R5,#+8
        B.N      ??List_RemoveHead_4
??List_RemoveHead_3:
??List_RemoveHead_4:
        MOVS     R0,R5
??List_RemoveHead_1:
        POP      {R4-R6,PC}       ;; return
//  308 }
//  309 
//  310 
//  311 /************************************************************************************
//  312 * Removes a list element from anywhere in the list.
//  313 *
//  314 * This function should be used somewhat like in the following example since it
//  315 * requires a pointer to the previous block relative to the current block:
//  316 *
//  317 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  318 void List_Remove
//  319   (
//  320   anchor_t *pAnchor, //IN: List to remove block from
//  321   void *pPrevBlock,  //IN: Previous List element used to fix the list after modification.
//  322   void *pBlock       //IN: List element used to reference the next element in the list.
//  323   )
//  324 {
List_Remove:
        PUSH     {R4-R8,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
//  325   uint32_t saveInt;
//  326 
//  327 #define prevBlock (((listHeader_t *)pPrevBlock)-1)
//  328 
//  329   listHeader_t *nextBlock =  (listHeader_t *)pBlock;
        MOV      R8,R6
//  330 
//  331   if (NULL == pBlock || NULL == pAnchor)
        CMP      R6,#+0
        BEQ.N    ??List_Remove_0
        CMP      R4,#+0
        BNE.N    ??List_Remove_1
//  332 	return;
??List_Remove_0:
        B.N      ??List_Remove_2
//  333   MM_DEBUG_LOG(List_Remove);
//  334 
//  335   saveInt = IntDisableAll();
??List_Remove_1:
        BL       IntDisableAll
        MOVS     R7,R0
//  336 
//  337     // Use current element as temp var to point at next element.
//  338   nextBlock = ((nextBlock)-1)->pNext;
        LDR      R8,[R8, #-8]
//  339 
//  340   if(pPrevBlock) {
        CMP      R5,#+0
        BEQ.N    ??List_Remove_3
//  341       // Let previous block point to next block.
//  342     prevBlock->pNext = nextBlock;
        STR      R8,[R5, #-8]
//  343       // Adjust tail pointer if pBlock was the last element in the list.
//  344     if(prevBlock->pNext == 0) {
        LDR      R0,[R5, #-8]
        CMP      R0,#+0
        BNE.N    ??List_Remove_4
//  345       pAnchor->pTail = prevBlock;
        SUBS     R0,R5,#+8
        STR      R0,[R4, #+4]
        B.N      ??List_Remove_4
//  346     }
//  347   }
//  348   else {
//  349       // No previous element => remove from head.
//  350       // Set head to point at second element to remove pBlock from list.
//  351     pAnchor->pHead = nextBlock;
??List_Remove_3:
        STR      R8,[R4, #+0]
//  352   }
//  353 
//  354   IntRestoreAll(saveInt);
??List_Remove_4:
        MOVS     R0,R7
        BL       IntRestoreAll
//  355 
//  356 #undef prevBlock
//  357 }
??List_Remove_2:
        POP      {R4-R8,PC}       ;; return
//  358 
//  359 
//  360 /************************************************************************************
//  361 * Returns a pointer to the first element in the list.
//  362 *
//  363 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  364 void *List_GetFirst
//  365   (
//  366   anchor_t *pAnchor  //IN: The list where the first element will be returned from.
//  367   )
//  368 {
List_GetFirst:
        PUSH     {R4-R6,LR}
        MOVS     R4,R0
//  369   listHeader_t *pBlock;
//  370   uint32_t saveInt;
//  371 
//  372   MmAssert(pAnchor);
//  373 
//  374   if (NULL == pAnchor)
        CMP      R4,#+0
        BNE.N    ??List_GetFirst_0
//  375     return NULL;
        MOVS     R0,#+0
        B.N      ??List_GetFirst_1
//  376 
//  377   saveInt = IntDisableAll();
??List_GetFirst_0:
        BL       IntDisableAll
        MOVS     R6,R0
//  378 
//  379   pBlock = pAnchor->pHead;
        LDR      R0,[R4, #+0]
        MOVS     R5,R0
//  380 
//  381   IntRestoreAll(saveInt);
        MOVS     R0,R6
        BL       IntRestoreAll
//  382 
//  383     // Skip header, and return pointer to data area if pointer is not NULL.
//  384   return pBlock ? pBlock+1 : pBlock;
        CMP      R5,#+0
        BEQ.N    ??List_GetFirst_2
        ADDS     R5,R5,#+8
        B.N      ??List_GetFirst_3
??List_GetFirst_2:
??List_GetFirst_3:
        MOVS     R0,R5
??List_GetFirst_1:
        POP      {R4-R6,PC}       ;; return
//  385 }
//  386 
//  387 /************************************************************************************
//  388 * Returns a pointer to the next list element in the list.
//  389 *
//  390 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  391 void *List_GetNext
//  392   (
//  393   void *pBlock  //IN: List element used to reference the next element in the list.
//  394   )
//  395 {
List_GetNext:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
//  396   uint32_t saveInt;
//  397 
//  398   MmAssert(pBlock);
//  399 
//  400   if (NULL == pBlock)
        CMP      R4,#+0
        BNE.N    ??List_GetNext_0
//  401     return NULL;
        MOVS     R0,#+0
        B.N      ??List_GetNext_1
//  402 
//  403   saveInt = IntDisableAll();
??List_GetNext_0:
        BL       IntDisableAll
        MOVS     R5,R0
//  404 
//  405   pBlock = (((listHeader_t *)pBlock)-1)->pNext;
        LDR      R4,[R4, #-8]
//  406 
//  407   IntRestoreAll(saveInt);
        MOVS     R0,R5
        BL       IntRestoreAll
//  408 
//  409     // Skip header, and return pointer to data area if pointer is not NULL.
//  410   return pBlock ? ((listHeader_t *)pBlock)+1 : pBlock;
        CMP      R4,#+0
        BEQ.N    ??List_GetNext_2
        ADDS     R4,R4,#+8
        B.N      ??List_GetNext_3
??List_GetNext_2:
??List_GetNext_3:
        MOVS     R0,R4
??List_GetNext_1:
        POP      {R1,R4,R5,PC}    ;; return
//  411 }
//  412 
//  413 
//  414 /************************************************************************************
//  415 * This function can be used to add a memory block to the specified pool during
//  416 * runtime.
//  417 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  418 void MM_AddToPool(pools_t *pPool, void *pBlock)
//  419 {
MM_AddToPool:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
        MOVS     R5,R1
//  420   ((listHeader_t *)pBlock)->pParentPool = pPool;
        STR      R4,[R5, #+4]
//  421   pBlock = ((listHeader_t *)pBlock) + 1;
        ADDS     R5,R5,#+8
//  422   List_AddTail(&pPool->anchor, ((listHeader_t *)pBlock));
        MOVS     R1,R5
        MOVS     R0,R4
        BL       List_AddTail
//  423 }
        POP      {R0,R4,R5,PC}    ;; return
//  424 
//  425 
//  426 /************************************************************************************
//  427 * This function returns a pointer to the buffer pool which corresponds exactly to
//  428 * the size argument. This is used with the MM_AddToPool() function to add buffers
//  429 * to the buffer pool.
//  430 *
//  431 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  432 pools_t *MM_GetPool(uint8_t size)
//  433 {
MM_GetPool:
        MOVS     R1,R0
//  434   pools_t *pPools = maMmPools;
        LDR.N    R2,??DataTable5_3
//  435 
//  436   while(size) {
??MM_GetPool_0:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BEQ.N    ??MM_GetPool_1
//  437     if(size == pPools->blockSize)
        LDRB     R0,[R2, #+9]
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,R0
        BNE.N    ??MM_GetPool_2
//  438       return pPools;
        MOVS     R0,R2
        B.N      ??MM_GetPool_3
//  439     if(pPools->nextBlockSize == 0)
??MM_GetPool_2:
        LDRB     R0,[R2, #+8]
        CMP      R0,#+0
        BNE.N    ??MM_GetPool_4
//  440       return NULL;
        MOVS     R0,#+0
        B.N      ??MM_GetPool_3
//  441     pPools++;
??MM_GetPool_4:
        ADDS     R2,R2,#+12
        B.N      ??MM_GetPool_0
//  442   }
//  443   return NULL;
??MM_GetPool_1:
        MOVS     R0,#+0
??MM_GetPool_3:
        BX       LR               ;; return
//  444 }
//  445 
//  446 /************************************************************************************
//  447 * Allocate a block from the specified memory pool. The function uses the size
//  448 * argument to look up a pool with adequate block sizes.
//  449 *
//  450 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  451 void *MM_AllocPool
//  452   (
//  453   pools_t *pPools, // IN: Pool to allocate from
//  454   uint8_t numBytes // IN: Minimum number of bytes to allocate
//  455   )
//  456 {
MM_AllocPool:
        PUSH     {R4-R6,LR}
        MOVS     R4,R0
        MOVS     R5,R1
//  457   listHeader_t *pBlock;
//  458 
//  459   while(numBytes)
??MM_AllocPool_0:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BEQ.N    ??MM_AllocPool_1
//  460   {
//  461     if(numBytes <= pPools->blockSize)
        LDRB     R0,[R4, #+9]
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R0,R5
        BCC.N    ??MM_AllocPool_2
//  462     {
//  463       /* Do not allow to allocate the last message from the MAC Big Message Pool.
//  464          The last message is only accessible via MM_AllocFast() */
//  465       if ((pPools == pMacPool) && (pPools->anchor.pHead == pPools->anchor.pTail))
        LDR.N    R0,??DataTable5_2
        LDR      R0,[R0, #+0]
        CMP      R4,R0
        BNE.N    ??MM_AllocPool_3
        LDR      R0,[R4, #+0]
        LDR      R1,[R4, #+4]
        CMP      R0,R1
        BNE.N    ??MM_AllocPool_3
//  466         pBlock = NULL;
        MOVS     R0,#+0
        MOVS     R6,R0
        B.N      ??MM_AllocPool_4
//  467       else
//  468         pBlock = List_RemoveHead(&pPools->anchor);
??MM_AllocPool_3:
        MOVS     R0,R4
        BL       List_RemoveHead
        MOVS     R6,R0
//  469 
//  470       if(NULL != pBlock)
??MM_AllocPool_4:
        CMP      R6,#+0
        BEQ.N    ??MM_AllocPool_5
//  471       {
//  472 
//  473         gFreeMessagesCount--;
        LDR.N    R0,??DataTable5
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        LDR.N    R1,??DataTable5
        STRB     R0,[R1, #+0]
//  474 
//  475         (void)MM_UpdateMsgTracking(pBlock, TRUE);
        MOVS     R1,#+1
        MOVS     R0,R6
        BL       MM_UpdateMsgTracking
        MOVS     R1,R0
//  476 
//  477         return pBlock;
        MOVS     R0,R6
        B.N      ??MM_AllocPool_6
//  478       }
//  479       else
//  480           // No more blocks of that size, try next size.
//  481         numBytes = pPools->nextBlockSize;
??MM_AllocPool_5:
        LDRB     R0,[R4, #+8]
        MOVS     R5,R0
//  482     }
//  483       // Try next pool
//  484     if(pPools->nextBlockSize)
??MM_AllocPool_2:
        LDRB     R0,[R4, #+8]
        CMP      R0,#+0
        BEQ.N    ??MM_AllocPool_7
//  485       pPools++;
        ADDS     R4,R4,#+12
        B.N      ??MM_AllocPool_0
//  486     else
//  487       break;
//  488   }
//  489 
//  490   MmDebug_AllocFail(pPools, numBytes);
//  491 
//  492   return NULL;
??MM_AllocPool_7:
??MM_AllocPool_1:
        MOVS     R0,#+0
??MM_AllocPool_6:
        POP      {R4-R6,PC}       ;; return
//  493 }
//  494 
//  495 
//  496 /************************************************************************************
//  497 * Allocate a block from the MAC memory pool. The function uses the size argument to
//  498 * look up a pool with adequate block sizes.
//  499 *
//  500 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  501 void *MM_Alloc
//  502   (
//  503   uint8_t numBytes // IN: Minimum number of bytes to allocate
//  504   )
//  505 {
MM_Alloc:
        PUSH     {R4,LR}
        MOVS     R4,R0
//  506 #if MsgTracking_d
//  507   /* Save the Link Register */
//  508   volatile uint32_t savedLR;
//  509 
//  510   __asm("push {r1}  ");
//  511   __asm("push {r14} ");
//  512   __asm("pop  {r1} ");
//  513   __asm("str  r1, [SP, #4]");
//  514   __asm("pop {r1}");
//  515   mLinkRegister = savedLR;
//  516 #endif
//  517   return MM_AllocPool(maMmPools, numBytes);
        MOVS     R1,R4
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR.N    R0,??DataTable5_3
        BL       MM_AllocPool
        POP      {R4,PC}          ;; return
//  518 }
//  519 
//  520 
//  521 /************************************************************************************
//  522 * Deallocate a memory block by putting it in the corresponding pool of free blocks.
//  523 *
//  524 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  525 void MM_Free
//  526   (
//  527   void *pBlock // IN: Block of memory to free
//  528   )
//  529 {
MM_Free:
        PUSH     {R4-R6,LR}
        MOVS     R4,R0
//  530 #if MsgTracking_d
//  531   /* Save the Link Register */
//  532   volatile uint32_t savedLR;
//  533 
//  534   __asm("push {r1}  ");
//  535   __asm("push {r14} ");
//  536   __asm("pop  {r1} ");
//  537   __asm("str  r1, [SP, #4]");
//  538   __asm("pop {r1}");
//  539   mLinkRegister = savedLR;
//  540 #endif
//  541   MM_DEBUG_LOG(MM_Free);
//  542 
//  543     // Freeing a NULL pointer will be ignored.
//  544   if(pBlock) {
        CMP      R4,#+0
        BEQ.N    ??MM_Free_0
//  545     pools_t *pParentPool = (((listHeader_t *)pBlock)-1)->pParentPool;
        LDR      R5,[R4, #-4]
//  546 
//  547     gFreeMessagesCount++;
        LDR.N    R0,??DataTable5
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR.N    R1,??DataTable5
        STRB     R0,[R1, #+0]
//  548 
//  549     (void)MM_UpdateMsgTracking(pBlock, FALSE);
        MOVS     R1,#+0
        MOVS     R0,R4
        BL       MM_UpdateMsgTracking
        MOVS     R6,R0
//  550     List_AddTail(&pParentPool->anchor, pBlock);
        MOVS     R1,R4
        MOVS     R0,R5
        BL       List_AddTail
//  551   }
//  552 }
??MM_Free_0:
        POP      {R4-R6,PC}       ;; return
//  553 
//  554 
//  555 /************************************************************************************
//  556 * Allocate a block from the largest memory pool. This function should only be called
//  557 * from interrupt context since it is not protected. First the function tries to
//  558 * allocate from the MAC private pool. If it fails it tries to allocate from the
//  559 * public buffer pool.
//  560 *
//  561 ************************************************************************************/
//  562 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  563 void *MM_AllocFast(void)
//  564 {
MM_AllocFast:
        PUSH     {R3-R5,LR}
//  565 #if MsgTracking_d
//  566   volatile uint32_t savedLR;
//  567 #endif
//  568   anchor_t *pAnchor;
//  569   listHeader_t *pBlock;
//  570 
//  571 #if MsgTracking_d
//  572   /* Save the Link Register */
//  573   __asm("push {r1}  ");
//  574   __asm("push {r14} ");
//  575   __asm("pop  {r1}  ");
//  576   __asm("str  r1, [SP, #4]");
//  577   __asm("pop  {r1}  ");
//  578   mLinkRegister = savedLR;
//  579 #endif
//  580   pAnchor = (anchor_t *)&(pMacPool->anchor);
        LDR.N    R0,??DataTable5_2
        LDR      R0,[R0, #+0]
        MOVS     R4,R0
//  581   pBlock = pAnchor->pHead;
        LDR      R0,[R4, #+0]
        MOVS     R5,R0
//  582 
//  583   if (NULL == pBlock)
        CMP      R5,#+0
        BNE.N    ??MM_AllocFast_0
//  584     return pBlock;
        MOVS     R0,R5
        B.N      ??MM_AllocFast_1
//  585 
//  586 
//  587   pAnchor->pHead = pBlock->pNext;
??MM_AllocFast_0:
        LDR      R0,[R5, #+0]
        STR      R0,[R4, #+0]
//  588 
//  589   MmDebug_Alloc(((listHeader_t *)pBlock)->pParentPool, 0);
//  590 
//  591   gFreeMessagesCount--;
        LDR.N    R0,??DataTable5
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        LDR.N    R1,??DataTable5
        STRB     R0,[R1, #+0]
//  592 
//  593   (void)MM_UpdateMsgTracking(pBlock + 1, TRUE);
        MOVS     R1,#+1
        ADDS     R0,R5,#+8
        BL       MM_UpdateMsgTracking
        MOVS     R1,R0
//  594 
//  595   return pBlock + 1;
        ADDS     R0,R5,#+8
??MM_AllocFast_1:
        POP      {R1,R4,R5,PC}    ;; return
//  596 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5:
        DC32     gFreeMessagesCount

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_1:
        DC32     maMmPools+0xC

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_2:
        DC32     pMacPool

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_3:
        DC32     maMmPools
//  597 
//  598 /************************************************************************************
//  599 * Initialize Msg tracking array. It is called by the Msg system when the MAC is reset
//  600 *
//  601 * Interface assumptions:
//  602 *   None
//  603 *
//  604 * Return value:
//  605 *   None.
//  606 *
//  607 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  608 void MM_InitMsgTracking(void) {
//  609 #if MsgTracking_d
//  610    FLib_MemSet16((uint8_t* )&MsgTrackingArray[0],0,(sizeof(MsgTrackingArray[0]) * TotalNoOfMsgs_c));
//  611    NoOfWrongAddrs = 0;
//  612 #endif
//  613 }
MM_InitMsgTracking:
        BX       LR               ;; return
//  614 /************************************************************************************
//  615 * Initialize Msg tracking array a current index with a Msg address.
//  616 * This functions is called for once for every Msg when the MAC is reset.
//  617 *
//  618 * Interface assumptions:
//  619 *   None
//  620 *
//  621 * Return value:
//  622 *   None.
//  623 *
//  624 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  625 void   MM_AddMsgToTrackingArray(uint8_t Index, uint32_t Addr) {
//  626 #if MsgTracking_d
//  627       MsgTrackingArray[Index].MsgAddr = Addr;
//  628 #else
//  629   /*To prevent compiler warinngs:*/
//  630   (void) Index;
//  631   (void) Addr;
//  632 #endif
//  633 }
MM_AddMsgToTrackingArray:
        BX       LR               ;; return
//  634 /************************************************************************************
//  635 * This function finds the index of a Msg in the Tracking array
//  636 * -1 is returned if Msg not found and the NoOfWrongAddrs is incremented.
//  637 *
//  638 * Interface assumptions:
//  639 *   None
//  640 *
//  641 * Return value:
//  642 *   Index of message in tracking array
//  643 *
//  644 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  645 int8_t MM_GetMsgIndex(const uint32_t MsgAddr)
//  646 {
MM_GetMsgIndex:
        MOVS     R1,R0
//  647 #if MsgTracking_d
//  648   uint8_t i;
//  649   /*Search through the Tracking array*/
//  650   for (i = 0; i < TotalNoOfMsgs_c; i++)
//  651   {
//  652     /*If Msg Addr found then exit with Index*/
//  653     if (MsgAddr == MsgTrackingArray[i].MsgAddr)
//  654       return i;
//  655   }
//  656   /*Msg addr not found, increment error counter and return*/
//  657   NoOfWrongAddrs++;
//  658   return -1;
//  659 #else
//  660   /*To prevent compiler warinngs:*/
//  661  (void) MsgAddr;
//  662  return -1;
        MOVS     R0,#-1
        BX       LR               ;; return
//  663 #endif
//  664 }
//  665 
//  666 /************************************************************************************
//  667 * Provide the mLinkRegister value to Message Tracking module
//  668 ************************************************************************************/
//  669 #if MsgTracking_d
//  670 uint32_t MM_GetLinkRegister(void)
//  671 {
//  672   return mLinkRegister;
//  673 }
//  674 #endif
//  675 
//  676 /************************************************************************************
//  677 * This function is called when ever a Msg is freed or allocated and updates
//  678 * the tracking information for that particular Msg
//  679 *
//  680 *
//  681 * Interface assumptions:
//  682 *   None
//  683 *
//  684 * Return value:
//  685 *   Success status
//  686 *
//  687 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  688 bool_t MM_UpdateMsgTracking(const void *pBlock, const bool_t Alloc)
//  689 {
MM_UpdateMsgTracking:
        MOVS     R2,R0
//  690 #if MsgTracking_d
//  691   int8_t index = MM_GetMsgIndex((uint32_t)pBlock);
//  692   if (index >= 0)
//  693   {
//  694     if (MsgTrackingArray[index].AllocStatus == Alloc)
//  695     {
//  696      return FALSE;
//  697     }
//  698 
//  699     MsgTrackingArray[index].AllocStatus = Alloc;
//  700 
//  701     /*Update MsgTracking array counters and return address of alloc or free */
//  702     if (Alloc) {
//  703       MsgTrackingArray[index].AllocCounter++;
//  704       MsgTrackingArray[index].AllocAddr = MM_GetLinkRegister();
//  705     }
//  706     else {
//  707       MsgTrackingArray[index].FreeCounter++;
//  708       MsgTrackingArray[index].FreeAddr = MM_GetLinkRegister();
//  709     }
//  710     return TRUE;
//  711 
//  712   }
//  713   else
//  714     return FALSE;
//  715 #else
//  716   /*To prevent compiler warinngs:*/
//  717   (void) pBlock;
//  718   (void) Alloc;
//  719   return TRUE;
        MOVS     R0,#+1
        BX       LR               ;; return
//  720 #endif
//  721 }

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        END
//  722 
//  723 /************************************************************************************
//  724 *************************************************************************************
//  725 * Private functions
//  726 *************************************************************************************
//  727 ************************************************************************************/
// 
// 2 981 bytes in section .bss
//    12 bytes in section .rodata
//   724 bytes in section .text
// 
//   724 bytes of CODE  memory
//    12 bytes of CONST memory
// 2 981 bytes of DATA  memory
//
//Errors: none
//Warnings: none
