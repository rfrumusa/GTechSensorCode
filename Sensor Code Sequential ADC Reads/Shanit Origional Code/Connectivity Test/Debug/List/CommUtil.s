///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM       02/Sep/2018  14:19:38
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Generic
//        Services\Source\CommUtil.c
//    Command line =  
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Generic
//        Services\Source\CommUtil.c" -D IAR --preprocess "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\List\" -lC "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\List\" -lB "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\List\" --diag_suppress
//        Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\Obj\" --no_cse --no_unroll
//        --no_inline --no_code_motion --no_tbaa --no_clustering
//        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\APP\CDC\" -I "F:\Guardrail Work\Sensor Code\Git
//        Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\USB\APP\Descriptor\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Class\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Sys Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
//    List file    =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\CommUtil.s
//
///////////////////////////////////////////////////////////////////////////////

        #define SHT_PROGBITS 0x1

        EXTERN HexToAscii
        EXTERN MM_Alloc
        EXTERN MM_Free
        EXTERN MemoryCpy
        EXTERN Uart1_IsTxActive
        EXTERN Uart1_Transmit
        EXTERN __region_ROM_end__
        EXTERN __region_ROM_start__

        PUBLIC CommUtil_Print
        PUBLIC CommUtil_PrintDec
        PUBLIC CommUtil_PrintHex
        PUBLIC CommUtil_Tx
        PUBLIC CommUtil_TxCallback

// F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\Generic Services\Source\CommUtil.c
//    1 /************************************************************************************
//    2 * Includes the Comm Utils.
//    3 *
//    4 * (c) Copyright 2012, Freescale, Inc. All rights reserved.
//    5 *
//    6 * No part of this document may be reproduced in any form - including copied,
//    7 * transcribed, printed or by any electronic means - without specific written
//    8 * permission from Freescale Semiconductor.
//    9 *
//   10 *
//   11 ************************************************************************************/
//   12 #include "EmbeddedTypes.h"
//   13 #include "CommUtil.h"
//   14 #include "Utilities_Interface.h"
//   15 #include "MsgSystem.h"
//   16 /******************************************************************************/
//   17 /******************************************************************************/
//   18 
//   19 /************************************************************************************
//   20 *************************************************************************************
//   21 * Private macros
//   22 *************************************************************************************
//   23 ************************************************************************************/
//   24 
//   25 /************************************************************************************
//   26 *************************************************************************************
//   27 * Private prototypes
//   28 *************************************************************************************/
//   29 
//   30 /************************************************************************************
//   31 *************************************************************************************
//   32 * Private type definitions
//   33 *************************************************************************************
//   34 ************************************************************************************/
//   35 
//   36 /************************************************************************************
//   37 *************************************************************************************
//   38 * Public memory declarations
//   39 *************************************************************************************
//   40 ************************************************************************************/
//   41 
//   42 /************************************************************************************
//   43 *************************************************************************************
//   44 * Private memory declarations
//   45 *************************************************************************************
//   46 ************************************************************************************/
//   47 extern uint32_t __region_ROM_start__[];
//   48 extern uint32_t __region_ROM_end__[];
//   49 /************************************************************************************
//   50 *************************************************************************************
//   51 * Public functions
//   52 *************************************************************************************
//   53 ************************************************************************************/
//   54 
//   55 #if (gComm_Type_d != gNoComm_c)
//   56 /************************************************************************************/
//   57 #ifndef gUartDefaultBaud_c
//   58 #define gUartDefaultBaud_c UartX_DefaultBaud
//   59 #endif
//   60 
//   61 /************************************************************************************/
//   62 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//   63 void CommUtil_TxCallback(unsigned char const *pBuf)
//   64 {
CommUtil_TxCallback:
        PUSH     {R4,LR}
        MOVS     R4,R0
//   65   if(pBuf != NULL)
        CMP      R4,#+0
        BEQ.N    ??CommUtil_TxCallback_0
//   66   {
//   67     MM_Free((void*)pBuf);
        MOVS     R0,R4
        BL       MM_Free
//   68   }
//   69   
//   70 }
??CommUtil_TxCallback_0:
        POP      {R4,PC}          ;; return
//   71 
//   72 /************************************************************************************/
//   73 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//   74 void CommUtil_Tx(uint8_t * pData, uint8_t length)
//   75 {
CommUtil_Tx:
        PUSH     {R4-R6,LR}
        MOVS     R4,R0
        MOVS     R5,R1
//   76   /* wait until module can insert message into Comm buffers */
//   77   if ( ((uint32_t)pData > (uint32_t)__region_ROM_start__) &&
//   78             ((uint32_t)pData < (uint32_t)__region_ROM_end__))
        LDR.N    R0,??DataTable1
        CMP      R0,R4
        BCS.N    ??CommUtil_Tx_0
        LDR.N    R0,??DataTable1_1
        CMP      R4,R0
        BCS.N    ??CommUtil_Tx_0
//   79   {
//   80     uint8_t* pRam = MM_Alloc(length);
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       MM_Alloc
        MOVS     R6,R0
//   81     if(pRam == NULL)
        CMP      R6,#+0
        BEQ.N    ??CommUtil_Tx_1
//   82     {
//   83       return;
//   84     }
//   85     MemoryCpy( pRam, pData, length );
??CommUtil_Tx_2:
        MOVS     R2,R5
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,R4
        MOVS     R0,R6
        BL       MemoryCpy
//   86     while(!Comm_Transmit(pRam,(index_t)length,CommUtil_TxCallback));
??CommUtil_Tx_3:
        LDR.N    R2,??DataTable1_2
        MOVS     R1,R5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R6
        BL       Uart1_Transmit
        CMP      R0,#+0
        BNE.N    ??CommUtil_Tx_4
        B.N      ??CommUtil_Tx_3
//   87   }
//   88 
//   89   else
//   90   {
//   91     while(!Comm_Transmit(pData,(index_t)length,NULL));
??CommUtil_Tx_0:
        MOVS     R2,#+0
        MOVS     R1,R5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R4
        BL       Uart1_Transmit
        CMP      R0,#+0
        BEQ.N    ??CommUtil_Tx_0
//   92   }
//   93   
//   94   /* wait until tx complete */
//   95   while (Comm_IsTxActive());
??CommUtil_Tx_4:
        BL       Uart1_IsTxActive
        CMP      R0,#+0
        BNE.N    ??CommUtil_Tx_4
//   96 }
??CommUtil_Tx_1:
        POP      {R4-R6,PC}       ;; return
//   97 
//   98 /************************************************************************************/
//   99 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  100 void CommUtil_Print(char* pString, commUtilBlock_t allowToBlock)
//  101 {
CommUtil_Print:
        PUSH     {R4-R8,LR}
        MOVS     R4,R0
        MOVS     R5,R1
//  102   uint16_t i = 0;
        MOVS     R7,#+0
//  103   char *  pTmpString = pString ;
        MOVS     R6,R4
//  104 
//  105   while (*pTmpString != '\0')
??CommUtil_Print_0:
        LDRB     R0,[R6, #+0]
        CMP      R0,#+0
        BEQ.N    ??CommUtil_Print_1
//  106   {
//  107     pTmpString++;
        ADDS     R6,R6,#+1
//  108     i++;
        ADDS     R7,R7,#+1
        B.N      ??CommUtil_Print_0
//  109   }
//  110   if(allowToBlock)
??CommUtil_Print_1:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BEQ.N    ??CommUtil_Print_2
//  111   {
//  112     /* wait until module can insert message into Comm buffers and until tx completes */
//  113 	CommUtil_Tx((uint8_t *)pString,(uint8_t)i);
        MOVS     R1,R7
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R4
        BL       CommUtil_Tx
        B.N      ??CommUtil_Print_3
//  114   }
//  115   else
//  116   {
//  117     if ( ((uint32_t)pString > (uint32_t)__region_ROM_start__) &&
//  118             ((uint32_t)pString < (uint32_t)__region_ROM_end__))
??CommUtil_Print_2:
        LDR.N    R0,??DataTable1
        CMP      R0,R4
        BCS.N    ??CommUtil_Print_4
        LDR.N    R0,??DataTable1_1
        CMP      R4,R0
        BCS.N    ??CommUtil_Print_4
//  119     {
//  120       uint8_t* pRam = MM_Alloc((uint8_t)i);
        MOVS     R0,R7
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       MM_Alloc
        MOV      R8,R0
//  121       if(pRam == NULL)
        CMP      R8,#+0
        BEQ.N    ??CommUtil_Print_5
//  122       {
//  123         return;
//  124       }
//  125       MemoryCpy( pRam, pString, (uint8_t)i );
??CommUtil_Print_6:
        MOVS     R2,R7
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,R4
        MOV      R0,R8
        BL       MemoryCpy
//  126       (void)Comm_Transmit((unsigned char const*)pRam,(index_t)i,CommUtil_TxCallback);
        LDR.N    R2,??DataTable1_2
        MOVS     R1,R7
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOV      R0,R8
        BL       Uart1_Transmit
        B.N      ??CommUtil_Print_3
//  127     }
//  128     else
//  129     {
//  130       (void)Comm_Transmit((unsigned char const*)pString,(index_t)i,NULL);      
??CommUtil_Print_4:
        MOVS     R2,#+0
        MOVS     R1,R7
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R4
        BL       Uart1_Transmit
//  131     }    
//  132 
//  133   }
//  134 }
??CommUtil_Print_3:
??CommUtil_Print_5:
        POP      {R4-R8,PC}       ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable1:
        DC32     __region_ROM_start__

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable1_1:
        DC32     __region_ROM_end__

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable1_2:
        DC32     CommUtil_TxCallback
//  135 
//  136 /************************************************************************************/
//  137 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  138 void CommUtil_PrintHex(uint8_t *hex, uint8_t len, uint8_t flags)
//  139 {
CommUtil_PrintHex:
        PUSH     {R4-R7,LR}
        SUB      SP,SP,#+12
        MOVS     R7,R0
        MOVS     R4,R1
        MOVS     R5,R2
//  140   uint8_t i=0;
        MOVS     R6,#+0
//  141   uint8_t hexString[6]; /* 2 bytes  - hexadecimal display
//  142                            1 byte   - separator ( comma)
//  143 						   1 byte   - separator ( space)
//  144                            2 bytes  - new line (\n\r)  */
//  145 
//  146   if(! (flags & gPrtHexBigEndian_c))
        LSLS     R0,R5,#+31
        BMI.N    ??CommUtil_PrintHex_0
//  147    {
//  148     hex = hex + (len-1);
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        ADDS     R0,R4,R7
        SUBS     R7,R0,#+1
//  149    }
//  150 
//  151   while(len)
??CommUtil_PrintHex_0:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+0
        BEQ.N    ??CommUtil_PrintHex_1
//  152   {
//  153     /* wait until previous hex print transmission is over */
//  154     while (Comm_IsTxActive());
??CommUtil_PrintHex_2:
        BL       Uart1_IsTxActive
        CMP      R0,#+0
        BNE.N    ??CommUtil_PrintHex_2
//  155 
//  156     /* start preparing the print of a new byte */
//  157     i=0;
        MOVS     R0,#+0
        MOVS     R6,R0
//  158     hexString[i++] = HexToAscii((*hex)>>4);
        LDRB     R0,[R7, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LSRS     R0,R0,#+4
        BL       HexToAscii
        ADD      R1,SP,#+0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        STRB     R0,[R6, R1]
        ADDS     R6,R6,#+1
//  159     hexString[i++] = HexToAscii( *hex);
        LDRB     R0,[R7, #+0]
        BL       HexToAscii
        ADD      R1,SP,#+0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        STRB     R0,[R6, R1]
        ADDS     R6,R6,#+1
//  160 
//  161     if(flags & gPrtHexCommas_c)
        LSLS     R0,R5,#+29
        BPL.N    ??CommUtil_PrintHex_3
//  162      {
//  163       hexString[i++] = ',';
        MOVS     R0,#+44
        ADD      R1,SP,#+0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        STRB     R0,[R6, R1]
        ADDS     R6,R6,#+1
//  164      }
//  165     if(flags & gPrtHexSpaces_c)
??CommUtil_PrintHex_3:
        LSLS     R0,R5,#+28
        BPL.N    ??CommUtil_PrintHex_4
//  166      {
//  167       hexString[i++] = ' ';
        MOVS     R0,#+32
        ADD      R1,SP,#+0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        STRB     R0,[R6, R1]
        ADDS     R6,R6,#+1
//  168      }
//  169     hex = hex + (flags & gPrtHexBigEndian_c ? 1 : -1);
??CommUtil_PrintHex_4:
        LSLS     R0,R5,#+31
        BPL.N    ??CommUtil_PrintHex_5
        MOVS     R0,#+1
        B.N      ??CommUtil_PrintHex_6
??CommUtil_PrintHex_5:
        MOVS     R0,#-1
??CommUtil_PrintHex_6:
        ADDS     R7,R0,R7
//  170     len--;
        SUBS     R4,R4,#+1
//  171 
//  172     if((len == 0) && (flags & gPrtHexNewLine_c))
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+0
        BNE.N    ??CommUtil_PrintHex_7
        LSLS     R0,R5,#+30
        BPL.N    ??CommUtil_PrintHex_7
//  173      {
//  174       hexString[i++] = '\n';
        MOVS     R0,#+10
        ADD      R1,SP,#+0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        STRB     R0,[R6, R1]
        ADDS     R6,R6,#+1
//  175       hexString[i++] = '\r';
        MOVS     R0,#+13
        ADD      R1,SP,#+0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        STRB     R0,[R6, R1]
        ADDS     R6,R6,#+1
//  176      }
//  177      /* transmit formatted byte */
//  178     (void)Comm_Transmit((unsigned char const*)hexString,(index_t)i,NULL);
??CommUtil_PrintHex_7:
        MOVS     R2,#+0
        MOVS     R1,R6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        ADD      R0,SP,#+0
        BL       Uart1_Transmit
        B.N      ??CommUtil_PrintHex_0
//  179   }
//  180   /* wait to complete the last transmission */
//  181   while (Comm_IsTxActive());
??CommUtil_PrintHex_1:
        BL       Uart1_IsTxActive
        CMP      R0,#+0
        BNE.N    ??CommUtil_PrintHex_1
//  182   (void)hexString;
        ADD      R0,SP,#+0
//  183 }
        POP      {R0-R2,R4-R7,PC}  ;; return
//  184 
//  185 /************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  186 void CommUtil_PrintDec(uint32_t nr)
//  187 {
CommUtil_PrintDec:
        PUSH     {R1-R5,LR}
        MOVS     R4,R0
//  188   uint8_t i = gDecStringLen_d-1;
        MOVS     R5,#+11
//  189   uint8_t decString[gDecStringLen_d];
//  190 
//  191   if (nr == 0)
        CMP      R4,#+0
        BNE.N    ??CommUtil_PrintDec_0
//  192   {
//  193     decString[i] = '0';
        MOVS     R0,#+48
        ADD      R1,SP,#+0
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        STRB     R0,[R5, R1]
        B.N      ??CommUtil_PrintDec_1
//  194   }
//  195   else
//  196   {
//  197     while (nr)
??CommUtil_PrintDec_0:
        CMP      R4,#+0
        BEQ.N    ??CommUtil_PrintDec_2
//  198     {
//  199       decString[i] = '0' + (uint8_t)(nr % 10);
        MOVS     R0,#+10
        UDIV     R1,R4,R0
        MLS      R0,R0,R1,R4
        ADDS     R0,R0,#+48
        ADD      R1,SP,#+0
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        STRB     R0,[R5, R1]
//  200       nr = nr / 10;
        MOVS     R0,#+10
        UDIV     R4,R4,R0
//  201       i--;
        SUBS     R5,R5,#+1
        B.N      ??CommUtil_PrintDec_0
//  202     }
//  203     i++;
??CommUtil_PrintDec_2:
        ADDS     R5,R5,#+1
//  204   }
//  205 
//  206   /* wait to complete the last transmission */
//  207   while (Comm_IsTxActive());
??CommUtil_PrintDec_1:
        BL       Uart1_IsTxActive
        CMP      R0,#+0
        BNE.N    ??CommUtil_PrintDec_1
//  208 
//  209    /* transmit formatted byte */
//  210   (void)Comm_Transmit((uint8_t*)&decString[i], gDecStringLen_d-i, NULL);
        MOVS     R2,#+0
        RSBS     R1,R5,#+12
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        ADD      R0,SP,#+0
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        ADDS     R0,R5,R0
        BL       Uart1_Transmit
//  211 
//  212   /* wait to complete the last transmission */
//  213   while (Comm_IsTxActive());
??CommUtil_PrintDec_3:
        BL       Uart1_IsTxActive
        CMP      R0,#+0
        BNE.N    ??CommUtil_PrintDec_3
//  214   (void)decString;
        ADD      R0,SP,#+0
//  215 }
        POP      {R0-R2,R4,R5,PC}  ;; return

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        END
//  216 
//  217 /************************************************************************************/
//  218 
//  219 #else /* (gComm_Type_d != gNoComm_c) */
//  220 
//  221 /************************************************************************************/
//  222 /* Create  dummy functions  */
//  223 /************************************************************************************/
//  224 void CommUtil_Init(pCommRxCallBack_t pCommRxCallBack)
//  225 {
//  226   (void)pCommRxCallBack;
//  227 }
//  228 
//  229 void CommUtil_Print(uint8_t * pString, commUtilBlock_t allowToBlock)
//  230 {
//  231   /* Avoid compiler warning */
//  232   (void)pString;
//  233   (void)allowToBlock;
//  234 }
//  235 
//  236 /************************************************************************************/
//  237 
//  238 void CommUtil_PrintHex(uint8_t *hex, uint8_t len, uint8_t flags)
//  239 {
//  240   /* Avoid compiler warning */
//  241   (void)hex;
//  242   (void)len;
//  243   (void)flags;
//  244 }
//  245 
//  246 /************************************************************************************/
//  247 
//  248 void CommUtil_Tx(uint8_t * pData, uint8_t length){
//  249   /* Avoid compiler warning */
//  250   (void)pData;
//  251   (void)length;
//  252 }
//  253 
//  254 /************************************************************************************/
//  255 #endif  /* (gComm_Type_d != gNoComm_c) */
// 
// 492 bytes in section .text
// 
// 492 bytes of CODE memory
//
//Errors: none
//Warnings: none
