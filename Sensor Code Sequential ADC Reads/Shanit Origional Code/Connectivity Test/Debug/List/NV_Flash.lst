###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        02/Sep/2018  14:19:40
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\NVM\NV_Flash.c
#    Command line =  
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\NVM\NV_Flash.c" -D IAR --preprocess "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\List\" -lC "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\List\" -lB "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\List\" --diag_suppress
#        Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\Obj\" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\CDC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\Descriptor\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\USB\Class\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Sys Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
#    List file    =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\List\NV_Flash.lst
#    Object file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\Obj\NV_Flash.o
#
###############################################################################

F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\NV_Flash.c
      1          /******************************************************************************
      2          * Filename: NV_Flash.c
      3          *
      4          * Description: Implementation of the non-volatile storage module 
      5          *              for CORTEX-M4 processor     
      6          *
      7          *
      8          * Copyright (c) 2014, Freescale Semiconductor, Inc.
      9          * All rights reserved.
     10          *
     11          * Redistribution and use in source and binary forms, with or without modification,
     12          * are permitted provided that the following conditions are met:
     13          *
     14          * o Redistributions of source code must retain the above copyright notice, this list
     15          *   of conditions and the following disclaimer.
     16          *
     17          * o Redistributions in binary form must reproduce the above copyright notice, this
     18          *   list of conditions and the following disclaimer in the documentation and/or
     19          *   other materials provided with the distribution.
     20          *
     21          * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     22          *   contributors may be used to endorse or promote products derived from this
     23          *   software without specific prior written permission.
     24          *
     25          * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     26          * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     27          * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     28          * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     29          * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     30          * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     31          * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     32          * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     33          * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     34          * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     35          *
     36          ***************************************************************************/
     37          
     38          #include "EmbeddedTypes.h"
     39          #include "NV_Flash.h"
     40          #include "NV_FlashHAL.h"
     41          #include "TMR_Interface.h"
     42          #include "RNG_Interface.h"
     43          
     44          #if (gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c != 0) /* FlexNVM */
     45          #include "FunctionLib.h"
     46          #endif
     47          
     48          /*****************************************************************************
     49           *****************************************************************************
     50           * Private macros
     51           *****************************************************************************
     52           *****************************************************************************/
     53          #if gNvStorageIncluded_d
     54          
     55          /*
     56           * Name: gNvVirtualPagesCount_c
     57           * Description: the count of virtual pages used
     58           */
     59          #define gNvVirtualPagesCount_c         2 /* DO NOT MODIFY */
     60          
     61          
     62          #endif /* gNvStorageIncluded_d */
     63          
     64          /*****************************************************************************
     65           *****************************************************************************
     66           * Private type definitions
     67           *****************************************************************************
     68           *****************************************************************************/
     69          
     70          /*****************************************************************************
     71           *****************************************************************************
     72           * Private prototypes
     73           *****************************************************************************
     74           *****************************************************************************/
     75          
     76          #if gNvStorageIncluded_d
     77          
     78          /******************************************************************************
     79           * Name: NvInitPendingSavesQueue
     80           * Description: Initialize the pending saves queue
     81           * Parameters: [IN] pQueue - pointer to queue
     82           * Return: TRUE if the pointer is valid, FALSE otherwise
     83           ******************************************************************************/
     84          static bool_t NvInitPendingSavesQueue
     85          (
     86            NVM_SaveQueue_t *pQueue
     87          );
     88          
     89          
     90          /******************************************************************************
     91           * Name: NvPushPendingSave
     92           * Description: Add a new pending save to the queue
     93           * Parameters: [IN] pQueue - pointer to queue
     94           *             [IN] data - data to be saved
     95           * Return: TRUE if the push operation succeeded, FALSE otherwise
     96           ******************************************************************************/
     97          static bool_t NvPushPendingSave
     98          (
     99            NVM_SaveQueue_t *pQueue, 
    100            NVM_TableEntryInfo_t data    
    101          );
    102          
    103          
    104          /******************************************************************************
    105           * Name: NvPopPendingSave
    106           * Description: Retrieves the head element from the pending saves queue
    107           * Parameters: [IN] pQueue - pointer to queue
    108           *             [OUT] pData - pointer to the location where data will be placed
    109           * Return: TRUE if the pop operation succeeded, FALSE otherwise
    110           ******************************************************************************/
    111          static bool_t NvPopPendingSave
    112          (
    113            NVM_SaveQueue_t *pQueue, 
    114            NVM_TableEntryInfo_t *pData
    115          );
    116          
    117          /******************************************************************************
    118           * Name: NvGetPendingSavesCount
    119           * Description: self explanatory
    120           * Parameters: [IN] pQueue - pointer to queue
    121           * Return: Number of pending saves
    122           ******************************************************************************/
    123          static uint8_t NvGetPendingSavesCount
    124          (
    125            NVM_SaveQueue_t *pQueue 
    126          );
    127          
    128          /*****************************************************************
    129           * The below functions are compiled only if FlexNVM is NOT used 
    130           *****************************************************************/
    131          
    132          #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */
    133          
    134          /******************************************************************************
    135           * Name: NvEraseVirtualPage
    136           * Description: erase the specified page
    137           * Parameter(s): [IN] pageID - the ID of the page to be erased
    138           * Return: gNVM_InvalidPageID_c - if the page ID is not valid
    139           *         gNVM_SectorEraseFail_c - if the page cannot be erased
    140           *         gNVM_OK_c - if operation completed successfully
    141           *****************************************************************************/
    142          static NVM_Status_t NvEraseVirtualPage
    143          (
    144            NVM_VirtualPageID_t pageID
    145          );
    146          
    147          
    148          /******************************************************************************
    149           * Name: NvInitStorageSystem
    150           * Description: Initialize the storage system, retrieve the active page and
    151           *              the page counter. Called once by NvModuleInit() function.
    152           * Parameter(s): - 
    153           * Return: -
    154           *****************************************************************************/
    155          static void NvInitStorageSystem
    156          (
    157            void
    158          );
    159          
    160          
    161          /******************************************************************************
    162           * Name: NvVirtualPageBlankCheck
    163           * Description: checks if the specified page is blank (erased) 
    164           * Parameter(s): [IN] pageID - the ID of the page to be checked
    165           * Return: gNVM_InvalidPageID_c - if the page ID is not valid 
    166           *         gNVM_PageIsNotBlank_c - if the page is not blank
    167           *         gNVM_OK_c - if the page is blank (erased)
    168           *****************************************************************************/
    169          static NVM_Status_t NvVirtualPageBlankCheck
    170          (
    171            NVM_VirtualPageID_t pageID
    172          );
    173          
    174          
    175          /******************************************************************************
    176           * Name: NvGetLastMetaInfoAddress
    177           * Description: retrieve and store (update) the last meta information address 
    178           * Parameter(s): -
    179           * Return: gNVM_MetaNotFound_c - if no meta information has been found
    180           *         gNVM_OK_c - if the meta was found and stored (updated)
    181           *****************************************************************************/
    182          static NVM_Status_t NvGetLastMetaInfoAddress
    183          (    
    184            void
    185          );
    186          
    187          
    188          /******************************************************************************
    189           * Name: NvGetMetaInfo
    190           * Description: get meta information based on the meta information address
    191           * Parameter(s): [IN] pageID - the ID of the page
    192           *               [IN] metaInfoAddress - meta information address
    193           *               [OUT] pMetaInfo - a pointer to a memory location where the 
    194           *                                 requested meta information will be stored
    195           * Return: gNVM_InvalidPageID_c - if the active page is not valid
    196           *         gNVM_NullPointer_c - if the provided pointer is NULL
    197           *         gNVM_AddressOutOfRange_c - if the provided address is out of range
    198           *         gNVM_OK_c - if the operation completed successfully
    199           *****************************************************************************/
    200          static NVM_Status_t NvGetMetaInfo
    201          (
    202            NVM_VirtualPageID_t pageId,
    203            uint32_t metaInfoAddress,
    204            NVM_RecordMetaInfo_t* pMetaInfo
    205          );
    206          
    207          
    208          /******************************************************************************
    209           * Name: NvGetPageFreeSpace
    210           * Description: return the page free space, in bytes
    211           * Parameter(s): [OUT] ptrFreeSpace - a pointer to a memory location where the
    212           *                                    page free space will be stored
    213           * Return: gNVM_InvalidPageID_c - if the active page is not valid
    214           *         gNVM_NullPointer_c - if the provided pointer is NULL
    215           *         gNVM_PageIsEmpty_c - if the page is empty
    216           *         gNVM_OK_c - if the operation completed successfully
    217           *****************************************************************************/
    218          static NVM_Status_t NvGetPageFreeSpace
    219          (    
    220            uint32_t* ptrFreeSpace
    221          );
    222          
    223          
    224          /******************************************************************************
    225           * Name: NvIsMemoryAreaAvailable
    226           * Description: checks if the specified memory area is blank (erased)
    227           * Parameter(s): [IN] address - start address
    228           *               [IN] len - length to be verified
    229           * Return: TRUE if the area is available (blank), FALSE otherwise
    230           *****************************************************************************/
    231          static bool_t NvIsMemoryAreaAvailable
    232          (
    233            uint32_t address,
    234            uint32_t len
    235          );
    236          
    237          
    238          /******************************************************************************
    239           * Name: NvIsRecordCopied
    240           * Description: Checks if a record or an entire table entry is already copied. 
    241           *              Called by page copy function.
    242           * Parameter(s): [IN] pageId - the ID of the page where to perform the check
    243           *               [IN] metaInf - a pointer to source page meta information tag
    244           * Return: TRUE if the element is already copied, FALSE otherwise
    245           *****************************************************************************/
    246          static bool_t NvIsRecordCopied
    247          (
    248            NVM_VirtualPageID_t pageId,
    249            NVM_RecordMetaInfo_t* metaInf
    250          );
    251          
    252          
    253          /******************************************************************************
    254           * Name: NvInternalCopy
    255           * Description: Performs a copy of an record / entire table entry
    256           * Parameter(s): [IN] dstAddress - destination record address
    257           *               [IN] dstMetaAddress - destination meta address
    258           *               [IN] srcMetaInfo - source meta information
    259           *               [IN] srcTblEntryIdx - source table entry index
    260           *               [IN] size - bytes to copy
    261           * Return: gNVM_InvalidPageID_c - if the source or destination page is not 
    262           *                                valid
    263           *         gNVM_MetaInfoWriteError_c - if the meta information couldn't be 
    264           *                                     written
    265           *         gNVM_RecordWriteError_c - if the record couldn't be written
    266           *         gNVM_Error_c - in case of error(s)
    267           *         gNVM_OK_c - page copy completed successfully
    268           *****************************************************************************/
    269          static NVM_Status_t NvInternalCopy
    270          (
    271            uint32_t dstAddress,
    272            uint32_t dstMetaAddress,
    273            NVM_RecordMetaInfo_t* srcMetaInfo,
    274            uint16_t srcTblEntryIdx,
    275            uint16_t size
    276          );
    277          
    278          
    279          /******************************************************************************
    280           * Name: NvGetRecordFullSize
    281           * Description: Computes the size of the specified table entry that will 
    282           *              be written on FLASH memory
    283           * Parameter(s): [IN] tableEntryIndex - table entry index               
    284           * Return: the computed size
    285           *****************************************************************************/
    286          static uint32_t NvGetRecordFullSize
    287          (    
    288            NvTableEntryId_t tableEntryIndex    
    289          );
    290          
    291          
    292          /******************************************************************************
    293           * Name: NvGetTblEntryMetaAddrFromId
    294           * Description: Gets the table entry meta address based on table entry ID
    295           * Parameter(s): [IN] searchStartAddress - the search start address
    296           *               [IN] dataEntryId - table entry ID
    297           * Return: the value of the meta address
    298           *****************************************************************************/
    299          #if gNvFragmentation_Enabled_d
    300          static uint32_t NvGetTblEntryMetaAddrFromId
    301          (
    302            uint32_t searchStartAddress,
    303            uint16_t dataEntryId
    304          );
    305          #endif /* gNvFragmentation_Enabled_d */
    306          
    307          
    308          /******************************************************************************
    309           * Name: NvInternalDefragmentedCopy
    310           * Description: Performs defragmentation and copy from the source page to 
    311           *              the destination one
    312           * Parameter(s): [IN] srcMetaAddr - source page meta address
    313           *               [IN] pSrcMetaInf - pointer to source page meta information
    314           *               [IN] srcTblEntryIdx - source page table entry index
    315           *               [IN] dstMetaAddr - destination meta address
    316           *               [IN] dstRecordAddr - destination record address (to copy to)
    317           * Return: the status of the operation
    318           *****************************************************************************/
    319          #if gNvFragmentation_Enabled_d
    320          static NVM_Status_t NvInternalDefragmentedCopy
    321          (
    322            uint32_t srcMetaAddr,  
    323            NVM_RecordMetaInfo_t* pSrcMetaInf,
    324            uint16_t srcTblEntryIdx,
    325            uint32_t dstMetaAddr,
    326            uint32_t dstRecordAddr
    327          );
    328          #endif /* #if gNvFragmentation_Enabled_d */
    329          
    330          
    331          /******************************************************************************
    332           * Name: NvCopyPage
    333           * Description: Copy the active page content to the mirror page. Only the 
    334           *              latest table entries / elements are copied. A merge operation
    335           *              is performed before copy if an entry has single elements 
    336           *              saved priori and newer than the table entry. If one or more
    337           *              elements were singular saved and the NV page doesn't has a
    338           *              full table entry saved, then the elements are copied as they
    339           *              are.  
    340           * Parameter(s): [IN] skipEntryId - the entry ID to be skipped when page
    341           *                                  copy is performed
    342           * Return: gNVM_InvalidPageID_c - if the source or destination page is not 
    343           *                                valid
    344           *         gNVM_MetaInfoWriteError_c - if the meta information couldn't be 
    345           *                                     written
    346           *         gNVM_RecordWriteError_c - if the record couldn't be written
    347           *         gNVM_Error_c - in case of error(s)
    348           *         gNVM_OK_c - page copy completed successfully
    349           *****************************************************************************/
    350          static NVM_Status_t NvCopyPage
    351          (    
    352          #if gNvUseExtendedFeatureSet_d		
    353            NvTableEntryId_t skipEntryId
    354          #else
    355            void
    356          #endif
    357          );
    358          
    359          
    360          /******************************************************************************
    361           * Name: NvWritePageCounter
    362           * Description: Write the page counter value              
    363           * Parameter(s): [IN] pageId - the ID of the page 
    364           *               [IN] value - the page counter value that will written to 
    365           *                            the specified page
    366           *               
    367           * Return: gNVM_OK_c - if the operation completes successfully
    368           *         gNVM_Error_c - if the format operation fails
    369           *****************************************************************************/
    370          static NVM_Status_t NvWritePageCounter
    371          (
    372            NVM_VirtualPageID_t pageId,
    373            uint32_t value    
    374          );
    375          
    376          
    377          /******************************************************************************
    378           * Name: NvInternalFormat
    379           * Description: Format the NV storage system. The function erases in place both
    380           *              virtual pages and then writes the page counter value to first  
    381           *              virtual page. The provided page counter value is automatically 
    382           *              incremented and then written to first (active) virtual page.              
    383           * Parameter(s): [IN] pageCounterValue - the page counter value that will
    384           *                                       be incremented and then written to
    385           *                                       active page
    386           * Return: gNVM_OK_c - if the operation completes successfully
    387           *         gNVM_FormatFailure_c - if the format operation fails
    388           *****************************************************************************/
    389          static NVM_Status_t NvInternalFormat
    390          (
    391            uint32_t pageCounterValue
    392          );
    393          
    394          
    395          #if gNvUseExtendedFeatureSet_d
    396          
    397          /******************************************************************************
    398           * Name: NvSaveRamTable
    399           * Description: Saves the NV table
    400           * Parameter(s): [IN] pageId - the virtual page ID where the table will be 
    401           *                             saved 
    402           * Return: TRUE if table saved successfully, FALSE otherwise
    403           ******************************************************************************/
    404          static bool_t NvSaveRamTable
    405          (
    406              NVM_VirtualPageID_t pageId
    407          );
    408          
    409          /******************************************************************************
    410           * Name: NvGetTableSize
    411           * Description: Retrieves the size of the NV table
    412           * Parameter(s): [IN] location - specifies if the size shall be the NV FLASH 
    413           *                               table size (gFLASHTable_c) or the NV RAM table 
    414           *                               size (gRAMTable_c) 
    415           * Return: the NV table size
    416           ******************************************************************************/
    417          static uint32_t NvGetTableSize
    418          (
    419            uint8_t location
    420          );
    421          
    422          
    423          /******************************************************************************
    424           * Name: NvIsRamTableUpdated
    425           * Description: Checks if the the NV table from RAM memory has changed since
    426           *              last system reset (e.g. via an OTAP transfer)
    427           * Parameter(s): -
    428           * Return: TRUE if the NV RAM table has been changed / FALSE otherwise
    429           ******************************************************************************/
    430          static bool_t NvIsRamTableUpdated
    431          (
    432            void
    433          );
    434          
    435          /******************************************************************************
    436           * Name: NvGetTableEntry
    437           * Description: get the NV table entry information stored on FLASH memory
    438           * Parameter(s): [IN] tblEntryId - table entry ID
    439           *               [OUT] pDataEntry - a pointer to a memory location where the 
    440           *                                  entry information will be stored
    441           * Return: TRUE if the has been found / FALSE otherwise
    442           ******************************************************************************/
    443          static bool_t NvGetTableEntry
    444          (
    445            uint16_t tblEntryId,
    446            NVM_DataEntry_t* pDataEntry
    447          );
    448          
    449          #endif /* gNvUseExtendedFeatureSet_d */
    450          
    451          #endif /* no FlexNVM */
    452          
    453          
    454          /******************************************************************************
    455           * Name: NvGetEntryFromDataPtr
    456           * Description: get table and element indexes based on a generic pointer address
    457           * Parameter(s): [IN] pData - a pointer to a NVM RAM table
    458           *               [OUT] pIndex - a pointer to a memory location where the 
    459           *                              requested indexed will be stored
    460           * Return: gNVM_NullPointer_c - if the provided pointer is NULL
    461           *         gNVM_PointerOutOfRange_c - if the provided pointer cannot be founded
    462           *                                    within the RAM table
    463           *         gNVM_OK_c - if the operation completed successfully
    464           *****************************************************************************/
    465          static NVM_Status_t NvGetEntryFromDataPtr
    466          (
    467            void* pData,
    468            NVM_TableEntryInfo_t* pIndex
    469          );
    470          
    471          
    472          /******************************************************************************
    473           * Name: NvWriteRecord
    474           * Description: writes a record
    475           * Parameter(s): [IN] tblIndexes - a pointer to table and element indexes
    476           * Return: gNVM_InvalidPageID_c - if the active page is not valid
    477           *         gNVM_NullPointer_c - if the provided pointer is NULL
    478           *         gNVM_MetaInfoWriteError_c - if the meta information couldn't be 
    479           *                                     written
    480           *         gNVM_RecordWriteError_c - if the record couldn't be written
    481           *         gNVM_OK_c - if the operation completed successfully
    482           *****************************************************************************/
    483          static NVM_Status_t NvWriteRecord
    484          (        
    485            NVM_TableEntryInfo_t* tblIndexes
    486          );
    487          
    488          
    489          /******************************************************************************
    490           * Name: NvRestoreData
    491           * Description: restore an element from NVM storage to its original RAM location
    492           * Parameter(s): [IN] tblIdx - pointer to table and element indexes
    493           * Return: gNVM_NullPointer_c - if the provided pointer is NULL
    494           *         gNVM_PageIsEmpty_c - if page is empty
    495           *         gNVM_Error_c - in case of error(s)
    496           *         gNVM_OK_c - if the operation completed successfully
    497           *****************************************************************************/
    498          static NVM_Status_t NvRestoreData
    499          (        
    500            NVM_TableEntryInfo_t* tblIdx
    501          );
    502          
    503          
    504          /******************************************************************************
    505           * Name: NvGetTableEntryIndex
    506           * Description: get the table entry index from the provided ID
    507           * Parameter(s): [IN] entryId - the ID of the table entry
    508           * Return: table entry index of gNvInvalidTableEntryIndex_c
    509           *****************************************************************************/
    510          static uint16_t NvGetTableEntryIndexFromId
    511          (
    512            NvTableEntryId_t entryId 
    513          );
    514          
    515          
    516          /******************************************************************************
    517           * Name: NvAddSaveRequestToQueue
    518           * Description: Add save request to save requests queue; if the request is 
    519           *              already stored, ignore the current request  
    520           * Parameter(s): [IN] ptrTblIdx - pointer to table index
    521           * Return: gNVM_OK_c - if operation completed successfully
    522           *         gNVM_SaveRequestRejected_c - if the request couldn't be queued         
    523           ******************************************************************************/
    524          static NVM_Status_t NvAddSaveRequestToQueue
    525          (
    526            NVM_TableEntryInfo_t* ptrTblIdx
    527          );
    528          
    529          /******************************************************************************
    530           * Name: NvIntervalTimerCallback
    531           * Description: Callback function of the timer used by the NvSaveOnInterval()
    532           * Parameter(s): [IN] timerID - timer ID
    533           * Return: -
    534           ******************************************************************************/
    535          static void NvIntervalTimerCallback
    536          (
    537            tmrTimerID_t timerID
    538          );
    539          
    540          /******************************************************************************
    541           * Name: NvGetRandomRange
    542           * Description: Returns a random number between 'low' and 'high'
    543           * Parameter(s): [IN] low, high - generated number range
    544           * Return: 0..255
    545           ******************************************************************************/
    546          static uint8_t NvGetRandomRange
    547          (
    548            uint8_t low, 
    549            uint8_t high
    550          );
    551          
    552          #if (gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c != 0) /*** FlexNVM ***/
    553          
    554          /******************************************************************************
    555           * Name: NvGetFlexLastMetaInfo
    556           * Description: Get FlexRAM last meta information address 
    557           * Parameter(s): -
    558           * Return: the address of the last valid meta information       
    559           ******************************************************************************/
    560          static uint32_t NvGetFlexLastMetaInfo
    561          (
    562            void
    563          );
    564          
    565          /******************************************************************************
    566           * Name: NvGetFlexMetaInfoFromId
    567           * Description: Get FlexRAM meta information tag from table entry ID 
    568           * Parameter(s): [IN] tblEntryId - table entry ID
    569           *               [OUT] pMetaInfo - a pointer to a memory location where the
    570           *                                 meta information tag will be stored
    571           * Return: -
    572           ******************************************************************************/
    573          static void NvGetFlexMetaInfoFromId
    574          (
    575            NvTableEntryId_t tblEntryId,
    576            NVM_FlexMetaInfo_t* pMetaInfo
    577          );
    578          
    579          /******************************************************************************
    580           * Name: NvCheckNvmTableForFlexRAMUsage
    581           * Description: Check if the existing NVM table fits within the FlexRAM window 
    582           * Parameter(s): -
    583           * Return: gNVM_NvTableExceedFlexRAMSize_c - the table exceed the size of
    584           *                                           FlexRAM window
    585           *         gNVM_OK_c - the table fits within the size of window FlexRAM window                                  
    586           ******************************************************************************/
    587          static NVM_Status_t NvCheckNvmTableForFlexRAMUsage
    588          (
    589            void
    590          );
    591          
    592          #endif /* gNvUseFlexNVM_d */
    593          #endif /* gNvStorageIncluded_d */
    594          
    595          
    596          /*****************************************************************************
    597           *****************************************************************************
    598           * Private memory declarations
    599           *****************************************************************************
    600           *****************************************************************************/
    601          
    602          #if gNvStorageIncluded_d
    603          
    604          #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */
    605          
    606          /*
    607           * Name: mNvActivePageId
    608           * Description: variable that holds the ID of the active page
    609           */

   \                                 In section .bss, align 1
    610          static NVM_VirtualPageID_t mNvActivePageId;
   \                     mNvActivePageId:
   \   00000000                      DS8 1
    611          
    612          /*
    613           * Name: mNvPageCounter
    614           * Description: page counter, used to validate the entire virtual page
    615           *              and also to provide statistical information about
    616           *              how many times the virtual page was erased
    617           */

   \                                 In section .bss, align 4
    618          static uint32_t mNvPageCounter = 0;
   \                     mNvPageCounter:
   \   00000000                      DS8 4
    619          
    620          /*
    621           * Name: mNvVirtualPageProperty
    622           * Description: virtual page properties
    623           */

   \                                 In section .bss, align 4
    624          static NVM_VirtualPageProperties_t mNvVirtualPageProperty[gNvVirtualPagesCount_c];
   \                     mNvVirtualPageProperty:
   \   00000000                      DS8 40
    625          
    626          /*
    627           * Name: mNvCopyOperationIsPending
    628           * Description: a flag that a indicates that a page copy operation is requested
    629           */

   \                                 In section .bss, align 1
    630          static bool_t mNvCopyOperationIsPending = FALSE;
   \                     mNvCopyOperationIsPending:
   \   00000000                      DS8 1
    631          
    632          /*
    633           * Name: mNvSkipTableEntryId
    634           * Description: table entry ID to be skipped when a page copy is requested
    635           */
    636          #if gNvUseExtendedFeatureSet_d
    637          static NvTableEntryId_t mNvSkipTableEntryId;
    638          #endif
    639          
    640          /*
    641           * Name: mNvErasePgCmdStatus
    642           * Description: a data structure used to erase a virtual page. The erase of a 
    643           *              virtual page is performed in idle task, in a sector-by-sector
    644           *              manner. When the idle task runs, if the erase pending flag is 
    645           *              set, only one flash sector will be erased. Therefore, the
    646           *              virtual page will be entirely erased after several runs of 
    647           *              idle task
    648           */

   \                                 In section .bss, align 4
    649          static NVM_ErasePageCmdStatus_t mNvErasePgCmdStatus;
   \                     mNvErasePgCmdStatus:
   \   00000000                      DS8 8
    650          
    651          /*
    652           * Name: maNvRecordsCpyIdx
    653           * Description: An array that stores the indexes of the records already copied; 
    654           *              Used by the defragmentation process.
    655           */
    656          #if gNvFragmentation_Enabled_d
    657          static uint16_t maNvRecordsCpyIdx[gNvRecordsCopiedBufferSize_c];
    658          #endif /* gNvFragmentation_Enabled_d */
    659          
    660          
    661          #if gNvUseExtendedFeatureSet_d
    662          /*
    663           * Name: mNvTableSizeInRAM
    664           * Description: the size of the NV table stored in RAM memory
    665           */
    666          static uint32_t mNvTableSizeInRAM;
    667          
    668          /*
    669           * Name: mNvTableSizeInFlash
    670           * Description: the size of the NV table stored in the FLASH memory
    671           */
    672          static uint32_t mNvTableSizeInFlash;
    673          
    674          /*
    675           * Name: mNvTableMarker 
    676           * Description: FLASH NV table marker, used only for code readability 
    677           *              (when applying the sizeof() operator to it) 
    678           */
    679          static uint32_t mNvTableMarker = gNvTableMarker_c;
    680          
    681          /*
    682           * Name: mNvTableUpdated
    683           * Description: boolean flag used to mark if the NV table from the RAM memory
    684           *              has been changed. Set (or left untouched) only at module initialization,
    685           *              when the existing NV FLASH table (if any) is compared against
    686           *              the NV RAM table.  
    687           */
    688          static bool_t mNvTableUpdated;
    689          
    690          #endif /* gNvUseExtendedFeatureSet_d */
    691          
    692          #endif /* no FlexNVM */
    693          
    694          /*
    695           * Name: mNvModuleInitialized
    696           * Description: variable that holds the NVM initialisation status
    697           */

   \                                 In section .bss, align 1
    698          static bool_t mNvModuleInitialized = FALSE;
   \                     mNvModuleInitialized:
   \   00000000                      DS8 1
    699          
    700          /*
    701           * Name: mNvCriticalSectionFlag
    702           * Description: If this counter is != 0, do not save to NV Storage
    703           */

   \                                 In section .bss, align 1
    704          static uint8_t mNvCriticalSectionFlag = 0;
   \                     mNvCriticalSectionFlag:
   \   00000000                      DS8 1
    705          
    706          /*
    707           * Name: gNvMinimumTicksBetweenSaves
    708           * Description: Minimum number of calls to NvTimerTick() between saves of a given data set 
    709           */

   \                                 In section .data, align 2
    710          static NvSaveInterval_t gNvMinimumTicksBetweenSaves = gNvMinimumTicksBetweenSaves_c;
   \                     gNvMinimumTicksBetweenSaves:
   \   00000000   0x0004             DC16 4
    711          
    712          /*
    713           * Name: gNvCountsBetweenSaves
    714           * Description: Minimum number of calls to NvSaveOnIdle() between saves of a given data set
    715           */

   \                                 In section .data, align 2
    716          static NvSaveCounter_t gNvCountsBetweenSaves = gNvCountsBetweenSaves_c;
   \                     gNvCountsBetweenSaves:
   \   00000000   0x0100             DC16 256
    717          
    718          /*
    719           * Name: mNvPendingSavesQueue
    720           * Description: a queue used for storing information about the pending saves
    721           */

   \                                 In section .bss, align 4
    722          static NVM_SaveQueue_t mNvPendingSavesQueue;
   \                     mNvPendingSavesQueue:
   \   00000000                      DS8 196
    723          
    724          /*
    725           * Name: maDatasetInfo
    726           * Description: Data set info table
    727           */

   \                                 In section .bss, align 4
    728          static NVM_DatasetInfo_t maDatasetInfo[gNvTableEntriesCountMax_c];
   \                     maDatasetInfo:
   \   00000000                      DS8 192
    729          
    730          /*
    731           * Name: mNvSaveOnIntervalEvent
    732           * Description: flag used to signal an 'SaveOnInterval' event
    733           */

   \                                 In section .bss, align 1
    734          static bool_t mNvSaveOnIntervalEvent;
   \                     mNvSaveOnIntervalEvent:
   \   00000000                      DS8 1
    735          
    736          /*
    737           * Name: mNvSaveOnIntervalTimerID
    738           * Description: the ID of timer used by the Save-On-Interval functionality
    739           */

   \                                 In section .bss, align 1
    740          static tmrTimerID_t mNvSaveOnIntervalTimerID;
   \                     mNvSaveOnIntervalTimerID:
   \   00000000                      DS8 1
    741          
    742          #endif /* gNvStorageIncluded_d */
    743          
    744          /*****************************************************************************
    745           *****************************************************************************
    746           * Public memory declarations
    747           *****************************************************************************
    748           *****************************************************************************/
    749          
    750          #if gNvStorageIncluded_d
    751          
    752          #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */
    753          
    754          /*
    755           * Name: NV_STORAGE_END_ADDRESS
    756           * Description: NV_STORAGE_END_ADDRESS from linker command file is used by this code
    757           *              as Raw Sector Start Address. This should not be misleading because 
    758           *              ENVM module writes meta information in address-ascending order 
    759           *              and records in address-descending order.
    760           */
    761          extern uint32_t NV_STORAGE_END_ADDRESS[];
    762          
    763          /*
    764           * Name: NV_STORAGE_SECTOR_SIZE
    765           * Description: external symbol from linker command file, it represents the size
    766           *              of a FLASH sector 
    767           */
    768          extern uint32_t NV_STORAGE_SECTOR_SIZE[];
    769          
    770          /*
    771           * Name:  NV_STORAGE_MAX_SECTORS
    772           * Description: external symbol from linker command file, it represents the sectors
    773           *              count used by the ENVM storage system; it has to be a multiple of 2 
    774           */
    775          extern uint32_t  NV_STORAGE_MAX_SECTORS[];
    776          
    777          #endif /* no FlexNVM */
    778          
    779          /*
    780           * Name: mNvConfig
    781           * Description: configuration variable used to initialize and control the FTFL HAL driver
    782           */

   \                                 In section .data, align 4
    783          NvConfig_t mNvConfig = {
   \                     mNvConfig:
   \   00000000   0x40020000         DC32 1073872896, 0, 524288, 0, 0, 0, 0, 0
   \              0x00000000   
   \              0x00080000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
    784              gNV_FTFX_REG_BASE_c,
    785              gNV_PFLASH_BLOCK_BASE_c,
    786              gNV_PFLASH_BLOCK_SIZE_c,
    787              gNV_DFLASH_BLOCK_BASE_c,
    788              gNV_DFLASH_BLOCK_SIZE_c,
    789              gNV_EERAM_BLOCK_BASE_c,
    790              gNV_EERAM_BLOCK_SIZE_c,
    791              gNV_EEE_BLOCK_SIZE_c
    792          };
    793          
    794          #endif /* gNvStorageIncluded_d */
    795          
    796          
    797          /*****************************************************************************
    798           *****************************************************************************
    799           * Private functions
    800           *****************************************************************************
    801           *****************************************************************************/
    802          
    803          #if gNvStorageIncluded_d
    804          
    805          /******************************************************************************
    806           * Name: NvInitPendingSavesQueue
    807           * Description: Initialize the pending saves queue
    808           * Parameters: [IN] pQueue - pointer to queue
    809           * Return: TRUE if the pointer is valid, FALSE otherwise
    810           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    811          static bool_t NvInitPendingSavesQueue
    812          (
    813            NVM_SaveQueue_t *pQueue
    814          )
    815          {
   \                     NvInitPendingSavesQueue: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    816            if(NULL == pQueue)
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD101             BNE.N    ??NvInitPendingSavesQueue_0
    817            {
    818              return FALSE;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xE009             B.N      ??NvInitPendingSavesQueue_1
    819            }
    820          
    821            pQueue->Head = 0;
   \                     ??NvInitPendingSavesQueue_0: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF881 0x00C0      STRB     R0,[R1, #+192]
    822            pQueue->Tail = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF881 0x00C1      STRB     R0,[R1, #+193]
    823            pQueue->EntriesCount = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF881 0x00C2      STRB     R0,[R1, #+194]
    824          
    825            return TRUE;
   \   0000001C   0x2001             MOVS     R0,#+1
   \                     ??NvInitPendingSavesQueue_1: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
    826          }
    827          
    828          
    829          /******************************************************************************
    830           * Name: NvPushPendingSave
    831           * Description: Add a new pending save to the queue
    832           * Parameters: [IN] pQueue - pointer to queue
    833           *             [IN] data - data to be saved
    834           * Return: TRUE if the push operation succeeded, FALSE otherwise
    835           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    836          static bool_t NvPushPendingSave
    837          (
    838            NVM_SaveQueue_t *pQueue, 
    839            NVM_TableEntryInfo_t data    
    840          )
    841          {
   \                     NvPushPendingSave: (+1)
   \   00000000   0xB516             PUSH     {R1,R2,R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    842            if(NULL == pQueue)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??NvPushPendingSave_0
    843            {
    844              return FALSE;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE028             B.N      ??NvPushPendingSave_1
    845            }
    846          
    847            if((pQueue->Tail == pQueue->Head) && (pQueue->EntriesCount > 0))
   \                     ??NvPushPendingSave_0: (+1)
   \   0000000C   0xF894 0x00C1      LDRB     R0,[R4, #+193]
   \   00000010   0xF894 0x10C0      LDRB     R1,[R4, #+192]
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD105             BNE.N    ??NvPushPendingSave_2
   \   00000018   0xF894 0x00C2      LDRB     R0,[R4, #+194]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD001             BEQ.N    ??NvPushPendingSave_2
    848            {
    849          #if gFifoOverwriteEnabled_c        
    850              /* increment the head (read index) */
    851              pQueue->Head = (pQueue->Head + 1) & ((unsigned char) (gNvPendigSavesQueueSize_c - 1));
    852          #else
    853              return FALSE;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE01C             B.N      ??NvPushPendingSave_1
    854          #endif
    855            }
    856          
    857            /* Add the item to queue */
    858            pQueue->QData[pQueue->Tail] = data;
   \                     ??NvPushPendingSave_2: (+1)
   \   00000024   0xF894 0x00C1      LDRB     R0,[R4, #+193]
   \   00000028   0x2106             MOVS     R1,#+6
   \   0000002A   0xFB01 0x4000      MLA      R0,R1,R0,R4
   \   0000002E   0xA900             ADD      R1,SP,#+0
   \   00000030   0x2206             MOVS     R2,#+6
   \   00000032   0x.... 0x....      BL       __aeabi_memcpy
    859          
    860            /* Reset the tail when it reach gNvPendigSavesQueueSize_c */
    861            pQueue->Tail = (pQueue->Tail + 1) % ((unsigned char) (gNvPendigSavesQueueSize_c));
   \   00000036   0xF894 0x00C1      LDRB     R0,[R4, #+193]
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   \   0000003C   0x2120             MOVS     R1,#+32
   \   0000003E   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   00000042   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   00000046   0xF884 0x20C1      STRB     R2,[R4, #+193]
    862          
    863            /* Increment the entries count */
    864            if(pQueue->EntriesCount < (unsigned char) (gNvPendigSavesQueueSize_c))
   \   0000004A   0xF894 0x00C2      LDRB     R0,[R4, #+194]
   \   0000004E   0x2820             CMP      R0,#+32
   \   00000050   0xDA04             BGE.N    ??NvPushPendingSave_3
    865            {
    866              pQueue->EntriesCount++;
   \   00000052   0xF894 0x00C2      LDRB     R0,[R4, #+194]
   \   00000056   0x1C40             ADDS     R0,R0,#+1
   \   00000058   0xF884 0x00C2      STRB     R0,[R4, #+194]
    867            }
    868          
    869            return TRUE;
   \                     ??NvPushPendingSave_3: (+1)
   \   0000005C   0x2001             MOVS     R0,#+1
   \                     ??NvPushPendingSave_1: (+1)
   \   0000005E   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    870          }
    871          
    872          
    873          /******************************************************************************
    874           * Name: NvPopPendingSave
    875           * Description: Retrieves the head element from the pending saves queue
    876           * Parameters: [IN] pQueue - pointer to queue
    877           *             [OUT] pData - pointer to the location where data will be placed
    878           * Return: TRUE if the pop operation succeeded, FALSE otherwise
    879           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    880          static bool_t NvPopPendingSave
    881          (
    882            NVM_SaveQueue_t *pQueue, 
    883            NVM_TableEntryInfo_t *pData
    884          )
    885          {
   \                     NvPopPendingSave: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    886            if( (NULL == pQueue) || (pQueue->EntriesCount <= 0) || ((NULL == pData)) )
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD005             BEQ.N    ??NvPopPendingSave_0
   \   0000000A   0xF894 0x00C2      LDRB     R0,[R4, #+194]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD001             BEQ.N    ??NvPopPendingSave_0
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD101             BNE.N    ??NvPopPendingSave_1
    887            {
    888              return FALSE;
   \                     ??NvPopPendingSave_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE018             B.N      ??NvPopPendingSave_2
    889            }
    890          
    891            *pData = pQueue->QData[pQueue->Head];
   \                     ??NvPopPendingSave_1: (+1)
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0xF894 0x10C0      LDRB     R1,[R4, #+192]
   \   00000020   0x2206             MOVS     R2,#+6
   \   00000022   0xFB02 0x4101      MLA      R1,R2,R1,R4
   \   00000026   0x2206             MOVS     R2,#+6
   \   00000028   0x.... 0x....      BL       __aeabi_memcpy
    892          
    893            /* Reset the head when it reach gNvPendigSavesQueueSize_c */
    894            pQueue->Head = (pQueue->Head + 1) % ((unsigned char) (gNvPendigSavesQueueSize_c ));
   \   0000002C   0xF894 0x00C0      LDRB     R0,[R4, #+192]
   \   00000030   0x1C40             ADDS     R0,R0,#+1
   \   00000032   0x2120             MOVS     R1,#+32
   \   00000034   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   00000038   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   0000003C   0xF884 0x20C0      STRB     R2,[R4, #+192]
    895          
    896            /* Decrement the entries count */
    897            pQueue->EntriesCount--;
   \   00000040   0xF894 0x00C2      LDRB     R0,[R4, #+194]
   \   00000044   0x1E40             SUBS     R0,R0,#+1
   \   00000046   0xF884 0x00C2      STRB     R0,[R4, #+194]
    898          
    899            return TRUE;
   \   0000004A   0x2001             MOVS     R0,#+1
   \                     ??NvPopPendingSave_2: (+1)
   \   0000004C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    900          }
    901          
    902          /******************************************************************************
    903           * Name: NvGetPendingSavesCount
    904           * Description: self explanatory
    905           * Parameters: [IN] pQueue - pointer to queue
    906           * Return: Number of pending saves
    907           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    908          static uint8_t NvGetPendingSavesCount
    909          (
    910            NVM_SaveQueue_t *pQueue 
    911          )
    912          {
   \                     NvGetPendingSavesCount: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    913            if( NULL == pQueue ) 
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD101             BNE.N    ??NvGetPendingSavesCount_0
    914            {
    915              return 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xE001             B.N      ??NvGetPendingSavesCount_1
    916            }
    917            return pQueue->EntriesCount;
   \                     ??NvGetPendingSavesCount_0: (+1)
   \   0000000A   0xF891 0x00C2      LDRB     R0,[R1, #+194]
   \                     ??NvGetPendingSavesCount_1: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
    918          }
    919          
    920          
    921          /*****************************************************************
    922           * The below functions are compiled only if FlexNVM is NOT used 
    923           *****************************************************************/
    924          
    925          #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */
    926          
    927          /******************************************************************************
    928           * Name: NvEraseVirtualPage
    929           * Description: erase the specified page
    930           * Parameter(s): [IN] pageID - the ID of the page to be erased
    931           * Return: gNVM_InvalidPageID_c - if the page ID is not valid
    932           *         gNVM_SectorEraseFail_c - if the page cannot be erased
    933           *         gNVM_OK_c - if operation completed successfully
    934           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    935          static NVM_Status_t NvEraseVirtualPage
    936          (
    937            NVM_VirtualPageID_t pageID
    938          )
    939          {    
   \                     NvEraseVirtualPage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    940            if(pageID > gSecondVirtualPage_c)
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C02             CMP      R4,#+2
   \   00000008   0xDB01             BLT.N    ??NvEraseVirtualPage_0
    941              return gNVM_InvalidPageID_c;
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE016             B.N      ??NvEraseVirtualPage_1
    942          
    943            /* erase virtual page */
    944            if(gNV_OK_c == NV_FlashEraseSector(&mNvConfig, mNvVirtualPageProperty[pageID].NvRawSectorStartAddress,
    945                mNvVirtualPageProperty[pageID].NvTotalPageSize))
   \                     ??NvEraseVirtualPage_0: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2114             MOVS     R1,#+20
   \   00000016   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000001A   0x68C2             LDR      R2,[R0, #+12]
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x2114             MOVS     R1,#+20
   \   00000024   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000028   0x6801             LDR      R1,[R0, #+0]
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   0000002E   0x.... 0x....      BL       NV_FlashEraseSector
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD101             BNE.N    ??NvEraseVirtualPage_2
    946            {
    947              return gNVM_OK_c;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xE000             B.N      ??NvEraseVirtualPage_1
    948            }
    949          
    950            return gNVM_SectorEraseFail_c;
   \                     ??NvEraseVirtualPage_2: (+1)
   \   0000003A   0x2004             MOVS     R0,#+4
   \                     ??NvEraseVirtualPage_1: (+1)
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
    951          }
    952          
    953          
    954          /******************************************************************************
    955           * Name: NvInitStorageSystem
    956           * Description: Initialize the storage system, retrieve the active page and
    957           *              the page counter. Called once by NvModuleInit() function.
    958           * Parameter(s): - 
    959           * Return: -
    960           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    961          static void NvInitStorageSystem
    962          (
    963            void
    964          )
    965          {
   \                     NvInitStorageSystem: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    966            uint32_t firstPageCounterTopValue;
    967            uint32_t firstPageCounterBottomValue;
    968            uint32_t secondPageCounterTopValue;
    969            uint32_t secondPageCounterBottomValue;
    970          
    971            /* read both pages counter values */
    972            NV_FlashRead(mNvVirtualPageProperty[gFirstVirtualPage_c].NvRawSectorStartAddress, (uint8_t*)&firstPageCounterTopValue, 
    973                sizeof(firstPageCounterTopValue));
   \   00000004   0x2204             MOVS     R2,#+4
   \   00000006   0xA901             ADD      R1,SP,#+4
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x.... 0x....      BL       NV_FlashRead
    974            NV_FlashRead(mNvVirtualPageProperty[gFirstVirtualPage_c].NvRawSectorEndAddress - sizeof(firstPageCounterBottomValue) + 1,  
    975                (uint8_t*)&firstPageCounterBottomValue, sizeof(firstPageCounterBottomValue));
   \   00000012   0x2204             MOVS     R2,#+4
   \   00000014   0xA903             ADD      R1,SP,#+12
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000001A   0x6840             LDR      R0,[R0, #+4]
   \   0000001C   0x1EC0             SUBS     R0,R0,#+3
   \   0000001E   0x.... 0x....      BL       NV_FlashRead
    976            NV_FlashRead(mNvVirtualPageProperty[gSecondVirtualPage_c].NvRawSectorStartAddress, (uint8_t*)&secondPageCounterTopValue, 
    977                sizeof(secondPageCounterTopValue));
   \   00000022   0x2204             MOVS     R2,#+4
   \   00000024   0xA900             ADD      R1,SP,#+0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000002A   0x6940             LDR      R0,[R0, #+20]
   \   0000002C   0x.... 0x....      BL       NV_FlashRead
    978            NV_FlashRead(mNvVirtualPageProperty[gSecondVirtualPage_c].NvRawSectorEndAddress - sizeof(secondPageCounterBottomValue) + 1, 
    979                (uint8_t*)&secondPageCounterBottomValue, sizeof(secondPageCounterBottomValue));
   \   00000030   0x2204             MOVS     R2,#+4
   \   00000032   0xA902             ADD      R1,SP,#+8
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000038   0x6980             LDR      R0,[R0, #+24]
   \   0000003A   0x1EC0             SUBS     R0,R0,#+3
   \   0000003C   0x.... 0x....      BL       NV_FlashRead
    980          
    981            mNvActivePageId = gVirtualPageNone_c;
   \   00000040   0x2002             MOVS     R0,#+2
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000046   0x7008             STRB     R0,[R1, #+0]
    982          
    983          
    984            if((firstPageCounterTopValue == firstPageCounterBottomValue) && (gPageCounterMaxValue_c != firstPageCounterTopValue))
   \   00000048   0x9801             LDR      R0,[SP, #+4]
   \   0000004A   0x9903             LDR      R1,[SP, #+12]
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xD153             BNE.N    ??NvInitStorageSystem_0
   \   00000050   0x9801             LDR      R0,[SP, #+4]
   \   00000052   0xF110 0x0F01      CMN      R0,#+1
   \   00000056   0xD04F             BEQ.N    ??NvInitStorageSystem_0
    985            {
    986              if((secondPageCounterTopValue == secondPageCounterBottomValue) && (gPageCounterMaxValue_c != secondPageCounterTopValue))
   \   00000058   0x9800             LDR      R0,[SP, #+0]
   \   0000005A   0x9902             LDR      R1,[SP, #+8]
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD119             BNE.N    ??NvInitStorageSystem_1
   \   00000060   0x9800             LDR      R0,[SP, #+0]
   \   00000062   0xF110 0x0F01      CMN      R0,#+1
   \   00000066   0xD015             BEQ.N    ??NvInitStorageSystem_1
    987              {
    988                if(firstPageCounterTopValue >= secondPageCounterTopValue)
   \   00000068   0x9801             LDR      R0,[SP, #+4]
   \   0000006A   0x9900             LDR      R1,[SP, #+0]
   \   0000006C   0x4288             CMP      R0,R1
   \   0000006E   0xD308             BCC.N    ??NvInitStorageSystem_2
    989                {
    990                  /* first page is active */
    991                  mNvPageCounter = firstPageCounterTopValue;
   \   00000070   0x9801             LDR      R0,[SP, #+4]
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   00000076   0x6008             STR      R0,[R1, #+0]
    992                  mNvActivePageId = gFirstVirtualPage_c;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000007E   0x7008             STRB     R0,[R1, #+0]
    993                  return;
   \   00000080   0xE0AF             B.N      ??NvInitStorageSystem_3
    994                }
    995          
    996                /* second page is active */
    997                mNvPageCounter = secondPageCounterTopValue;
   \                     ??NvInitStorageSystem_2: (+1)
   \   00000082   0x9800             LDR      R0,[SP, #+0]
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   00000088   0x6008             STR      R0,[R1, #+0]
    998                mNvActivePageId = gSecondVirtualPage_c;
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000090   0x7008             STRB     R0,[R1, #+0]
    999                return;
   \   00000092   0xE0A6             B.N      ??NvInitStorageSystem_3
   1000              }
   1001          
   1002              if(secondPageCounterTopValue != secondPageCounterBottomValue)
   \                     ??NvInitStorageSystem_1: (+1)
   \   00000094   0x9800             LDR      R0,[SP, #+0]
   \   00000096   0x9902             LDR      R1,[SP, #+8]
   \   00000098   0x4288             CMP      R0,R1
   \   0000009A   0xD016             BEQ.N    ??NvInitStorageSystem_4
   1003              {                
   1004                /* first page is active */
   1005                mNvPageCounter = firstPageCounterTopValue;
   \   0000009C   0x9801             LDR      R0,[SP, #+4]
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   000000A2   0x6008             STR      R0,[R1, #+0]
   1006                mNvActivePageId = gFirstVirtualPage_c;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000000AA   0x7008             STRB     R0,[R1, #+0]
   1007                /* request the erase of the second page */
   1008                mNvErasePgCmdStatus.NvPageToErase = gSecondVirtualPage_c;            
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   000000B2   0x7048             STRB     R0,[R1, #+1]
   1009                mNvErasePgCmdStatus.NvSectorAddress = mNvVirtualPageProperty[gSecondVirtualPage_c].NvRawSectorStartAddress;
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable13
   \   000000B8   0x6940             LDR      R0,[R0, #+20]
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   000000BE   0x6048             STR      R0,[R1, #+4]
   1010                mNvErasePgCmdStatus.NvErasePending = TRUE;
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   000000C6   0x7008             STRB     R0,[R1, #+0]
   1011                return;
   \   000000C8   0xE08B             B.N      ??NvInitStorageSystem_3
   1012              }
   1013          
   1014              if(gNVM_PageIsNotBlank_c == NvVirtualPageBlankCheck(gSecondVirtualPage_c))
   \                     ??NvInitStorageSystem_4: (+1)
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0x.... 0x....      BL       NvVirtualPageBlankCheck
   \   000000D0   0x2803             CMP      R0,#+3
   \   000000D2   0xD108             BNE.N    ??NvInitStorageSystem_5
   1015              {            
   1016                /* second page is active */
   1017                mNvPageCounter = secondPageCounterTopValue;
   \   000000D4   0x9800             LDR      R0,[SP, #+0]
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   000000DA   0x6008             STR      R0,[R1, #+0]
   1018                mNvActivePageId = gSecondVirtualPage_c;
   \   000000DC   0x2001             MOVS     R0,#+1
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000000E2   0x7008             STRB     R0,[R1, #+0]
   1019                return;
   \   000000E4   0xE07D             B.N      ??NvInitStorageSystem_3
   1020              }
   1021              else
   1022              {
   1023                /* first page is active */
   1024                mNvPageCounter = firstPageCounterTopValue;
   \                     ??NvInitStorageSystem_5: (+1)
   \   000000E6   0x9801             LDR      R0,[SP, #+4]
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   000000EC   0x6008             STR      R0,[R1, #+0]
   1025                mNvActivePageId = gFirstVirtualPage_c;
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000000F4   0x7008             STRB     R0,[R1, #+0]
   1026                return;
   \   000000F6   0xE074             B.N      ??NvInitStorageSystem_3
   1027              }        
   1028            }
   1029          
   1030            if(firstPageCounterTopValue != firstPageCounterBottomValue)
   \                     ??NvInitStorageSystem_0: (+1)
   \   000000F8   0x9801             LDR      R0,[SP, #+4]
   \   000000FA   0x9903             LDR      R1,[SP, #+12]
   \   000000FC   0x4288             CMP      R0,R1
   \   000000FE   0xD038             BEQ.N    ??NvInitStorageSystem_6
   1031            {
   1032              if((secondPageCounterTopValue == secondPageCounterBottomValue) && (gPageCounterMaxValue_c != secondPageCounterTopValue))
   \   00000100   0x9800             LDR      R0,[SP, #+0]
   \   00000102   0x9902             LDR      R1,[SP, #+8]
   \   00000104   0x4288             CMP      R0,R1
   \   00000106   0xD11A             BNE.N    ??NvInitStorageSystem_7
   \   00000108   0x9800             LDR      R0,[SP, #+0]
   \   0000010A   0xF110 0x0F01      CMN      R0,#+1
   \   0000010E   0xD016             BEQ.N    ??NvInitStorageSystem_7
   1033              {            
   1034                /* second page is active */
   1035                mNvPageCounter = secondPageCounterTopValue;
   \   00000110   0x9800             LDR      R0,[SP, #+0]
   \   00000112   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   00000116   0x6008             STR      R0,[R1, #+0]
   1036                mNvActivePageId = gSecondVirtualPage_c;
   \   00000118   0x2001             MOVS     R0,#+1
   \   0000011A   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000011E   0x7008             STRB     R0,[R1, #+0]
   1037                /* request the erase of the first page */
   1038                mNvErasePgCmdStatus.NvPageToErase = gFirstVirtualPage_c;            
   \   00000120   0x2000             MOVS     R0,#+0
   \   00000122   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   00000126   0x7048             STRB     R0,[R1, #+1]
   1039                mNvErasePgCmdStatus.NvSectorAddress = mNvVirtualPageProperty[gFirstVirtualPage_c].NvRawSectorStartAddress;
   \   00000128   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000012C   0x6800             LDR      R0,[R0, #+0]
   \   0000012E   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   00000132   0x6048             STR      R0,[R1, #+4]
   1040                mNvErasePgCmdStatus.NvErasePending = TRUE;            
   \   00000134   0x2001             MOVS     R0,#+1
   \   00000136   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   0000013A   0x7008             STRB     R0,[R1, #+0]
   1041                return;
   \   0000013C   0xE051             B.N      ??NvInitStorageSystem_3
   1042              }
   1043          
   1044              if(secondPageCounterTopValue != secondPageCounterBottomValue)
   \                     ??NvInitStorageSystem_7: (+1)
   \   0000013E   0x9800             LDR      R0,[SP, #+0]
   \   00000140   0x9902             LDR      R1,[SP, #+8]
   \   00000142   0x4288             CMP      R0,R1
   \   00000144   0xD003             BEQ.N    ??NvInitStorageSystem_8
   1045              {
   1046                /* both pages are invalid, format the NV storage system */            
   1047                (void)NvInternalFormat(0);
   \   00000146   0x2000             MOVS     R0,#+0
   \   00000148   0x.... 0x....      BL       NvInternalFormat
   1048                return;
   \   0000014C   0xE049             B.N      ??NvInitStorageSystem_3
   1049              }
   1050          
   1051              if(gNVM_PageIsNotBlank_c == NvVirtualPageBlankCheck(gSecondVirtualPage_c))
   \                     ??NvInitStorageSystem_8: (+1)
   \   0000014E   0x2001             MOVS     R0,#+1
   \   00000150   0x.... 0x....      BL       NvVirtualPageBlankCheck
   \   00000154   0x2803             CMP      R0,#+3
   \   00000156   0xD108             BNE.N    ??NvInitStorageSystem_9
   1052              {            
   1053                /* second page is active */
   1054                mNvPageCounter = secondPageCounterTopValue;
   \   00000158   0x9800             LDR      R0,[SP, #+0]
   \   0000015A   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   0000015E   0x6008             STR      R0,[R1, #+0]
   1055                mNvActivePageId = gSecondVirtualPage_c;
   \   00000160   0x2001             MOVS     R0,#+1
   \   00000162   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000166   0x7008             STRB     R0,[R1, #+0]
   1056                return;
   \   00000168   0xE03B             B.N      ??NvInitStorageSystem_3
   1057              }
   1058              else
   1059              {
   1060                /* first page is invalid and the second one is blank */
   1061                /* format the NV storage system */            
   1062                (void)NvInternalFormat(0);
   \                     ??NvInitStorageSystem_9: (+1)
   \   0000016A   0x2000             MOVS     R0,#+0
   \   0000016C   0x.... 0x....      BL       NvInternalFormat
   1063                return;
   \   00000170   0xE037             B.N      ??NvInitStorageSystem_3
   1064              }        
   1065            }
   1066          
   1067            if(gNVM_PageIsNotBlank_c == NvVirtualPageBlankCheck(gFirstVirtualPage_c))
   \                     ??NvInitStorageSystem_6: (+1)
   \   00000172   0x2000             MOVS     R0,#+0
   \   00000174   0x.... 0x....      BL       NvVirtualPageBlankCheck
   \   00000178   0x2803             CMP      R0,#+3
   \   0000017A   0xD108             BNE.N    ??NvInitStorageSystem_10
   1068            {
   1069              /* first page is active */
   1070              mNvPageCounter = firstPageCounterTopValue;
   \   0000017C   0x9801             LDR      R0,[SP, #+4]
   \   0000017E   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   00000182   0x6008             STR      R0,[R1, #+0]
   1071              mNvActivePageId = gFirstVirtualPage_c;
   \   00000184   0x2000             MOVS     R0,#+0
   \   00000186   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000018A   0x7008             STRB     R0,[R1, #+0]
   1072              return;
   \   0000018C   0xE029             B.N      ??NvInitStorageSystem_3
   1073            }
   1074            else
   1075            {
   1076              /* first page is blank */        
   1077              if((secondPageCounterTopValue == secondPageCounterBottomValue) && (gPageCounterMaxValue_c != secondPageCounterTopValue))
   \                     ??NvInitStorageSystem_10: (+1)
   \   0000018E   0x9800             LDR      R0,[SP, #+0]
   \   00000190   0x9902             LDR      R1,[SP, #+8]
   \   00000192   0x4288             CMP      R0,R1
   \   00000194   0xD10C             BNE.N    ??NvInitStorageSystem_11
   \   00000196   0x9800             LDR      R0,[SP, #+0]
   \   00000198   0xF110 0x0F01      CMN      R0,#+1
   \   0000019C   0xD008             BEQ.N    ??NvInitStorageSystem_11
   1078              {
   1079                /* second page is active */
   1080                mNvPageCounter = secondPageCounterTopValue;
   \   0000019E   0x9800             LDR      R0,[SP, #+0]
   \   000001A0   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   000001A4   0x6008             STR      R0,[R1, #+0]
   1081                mNvActivePageId = gSecondVirtualPage_c;
   \   000001A6   0x2001             MOVS     R0,#+1
   \   000001A8   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000001AC   0x7008             STRB     R0,[R1, #+0]
   1082                return;
   \   000001AE   0xE018             B.N      ??NvInitStorageSystem_3
   1083              }
   1084          
   1085              if(secondPageCounterTopValue != secondPageCounterBottomValue)
   \                     ??NvInitStorageSystem_11: (+1)
   \   000001B0   0x9800             LDR      R0,[SP, #+0]
   \   000001B2   0x9902             LDR      R1,[SP, #+8]
   \   000001B4   0x4288             CMP      R0,R1
   \   000001B6   0xD003             BEQ.N    ??NvInitStorageSystem_12
   1086              {
   1087                /* first page is blank and the second one is not valid */
   1088                /* format the NV storage system */
   1089                (void)NvInternalFormat(0);
   \   000001B8   0x2000             MOVS     R0,#+0
   \   000001BA   0x.... 0x....      BL       NvInternalFormat
   1090                return;
   \   000001BE   0xE010             B.N      ??NvInitStorageSystem_3
   1091              }
   1092          
   1093              if(gNVM_PageIsNotBlank_c == NvVirtualPageBlankCheck(gSecondVirtualPage_c))
   \                     ??NvInitStorageSystem_12: (+1)
   \   000001C0   0x2001             MOVS     R0,#+1
   \   000001C2   0x.... 0x....      BL       NvVirtualPageBlankCheck
   \   000001C6   0x2803             CMP      R0,#+3
   \   000001C8   0xD108             BNE.N    ??NvInitStorageSystem_13
   1094              {            
   1095                /* second page is active */
   1096                mNvPageCounter = secondPageCounterTopValue;
   \   000001CA   0x9800             LDR      R0,[SP, #+0]
   \   000001CC   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   000001D0   0x6008             STR      R0,[R1, #+0]
   1097                mNvActivePageId = gSecondVirtualPage_c;
   \   000001D2   0x2001             MOVS     R0,#+1
   \   000001D4   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000001D8   0x7008             STRB     R0,[R1, #+0]
   1098                return;
   \   000001DA   0xE002             B.N      ??NvInitStorageSystem_3
   1099              }
   1100              else
   1101              {
   1102                /* both pages are blank */
   1103                /* format the NV storage system */
   1104                (void)NvInternalFormat(0);
   \                     ??NvInitStorageSystem_13: (+1)
   \   000001DC   0x2000             MOVS     R0,#+0
   \   000001DE   0x.... 0x....      BL       NvInternalFormat
   1105                return;
   \                     ??NvInitStorageSystem_3: (+1)
   \   000001E2   0xB005             ADD      SP,SP,#+20
   \   000001E4   0xBD00             POP      {PC}             ;; return
   1106              }            
   1107            }    
   1108          }
   1109          
   1110          /******************************************************************************
   1111           * Name: NvVirtualPageBlankCheck
   1112           * Description: checks if the specified page is blank (erased) 
   1113           * Parameter(s): [IN] pageID - the ID of the page to be checked
   1114           * Return: gNVM_InvalidPageID_c - if the page ID is not valid 
   1115           *         gNVM_PageIsNotBlank_c - if the page is not blank
   1116           *         gNVM_OK_c - if the page is blank (erased)
   1117           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1118          static NVM_Status_t NvVirtualPageBlankCheck
   1119          (
   1120            NVM_VirtualPageID_t pageID
   1121          )
   1122          {
   \                     NvVirtualPageBlankCheck: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1123            if(pageID > gSecondVirtualPage_c)
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C02             CMP      R4,#+2
   \   00000008   0xDB01             BLT.N    ??NvVirtualPageBlankCheck_0
   1124              return gNVM_InvalidPageID_c;
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE018             B.N      ??NvVirtualPageBlankCheck_1
   1125          
   1126            if(gNV_OK_c != NV_FlashVerifySection(&mNvConfig, mNvVirtualPageProperty[pageID].NvRawSectorStartAddress,
   1127                mNvVirtualPageProperty[pageID].NvTotalPageSize, gNV_MARGIN_NORMAL_c))
   \                     ??NvVirtualPageBlankCheck_0: (+1)
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0x2114             MOVS     R1,#+20
   \   00000018   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000001C   0x68C2             LDR      R2,[R0, #+12]
   \   0000001E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x2114             MOVS     R1,#+20
   \   00000028   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000032   0x.... 0x....      BL       NV_FlashVerifySection
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD001             BEQ.N    ??NvVirtualPageBlankCheck_2
   1128            {
   1129              return gNVM_PageIsNotBlank_c;
   \   0000003A   0x2003             MOVS     R0,#+3
   \   0000003C   0xE000             B.N      ??NvVirtualPageBlankCheck_1
   1130            }
   1131          
   1132            return gNVM_OK_c;    
   \                     ??NvVirtualPageBlankCheck_2: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \                     ??NvVirtualPageBlankCheck_1: (+1)
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
   1133          }
   1134          
   1135          
   1136          /******************************************************************************
   1137           * Name: NvGetLastMetaInfoAddress
   1138           * Description: retrieve and store (update) the last meta information address 
   1139           * Parameter(s): -
   1140           * Return: gNVM_MetaNotFound_c - if no meta information has been found
   1141           *         gNVM_OK_c - if the meta was found and stored (updated)
   1142           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1143          static NVM_Status_t NvGetLastMetaInfoAddress
   1144          (    
   1145            void
   1146          )
   1147          {       
   \                     NvGetLastMetaInfoAddress: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   1148            uint32_t readAddress;  
   1149            uint8_t metaFirstByte;
   1150            NVM_RecordMetaInfo_t metaValue;
   1151          
   1152          #if gNvUseExtendedFeatureSet_d  
   1153            readAddress = mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + sizeof(mNvPageCounter) + 
   1154                mNvTableSizeInFlash + (2 * sizeof(mNvTableMarker));
   1155          #else
   1156            readAddress = mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + sizeof(mNvPageCounter);
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000000C   0x7809             LDRB     R1,[R1, #+0]
   \   0000000E   0x2214             MOVS     R2,#+20
   \   00000010   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x1D00             ADDS     R0,R0,#+4
   \   00000018   0x0004             MOVS     R4,R0
   1157          #endif /* gNvUseExtendedFeatureSet_d */
   1158          
   1159            while(readAddress < mNvVirtualPageProperty[mNvActivePageId].NvRawSectorEndAddress)
   \                     ??NvGetLastMetaInfoAddress_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000022   0x7809             LDRB     R1,[R1, #+0]
   \   00000024   0x2214             MOVS     R2,#+20
   \   00000026   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000002A   0x6840             LDR      R0,[R0, #+4]
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD264             BCS.N    ??NvGetLastMetaInfoAddress_1
   1160            {
   1161              NV_FlashRead(readAddress, (uint8_t*)&metaFirstByte, sizeof(metaFirstByte));
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0xA902             ADD      R1,SP,#+8
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       NV_FlashRead
   1162          
   1163              if(gNvErasedFlashCellValue_c == metaFirstByte)
   \   0000003A   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000003E   0x28FF             CMP      R0,#+255
   \   00000040   0xD159             BNE.N    ??NvGetLastMetaInfoAddress_2
   1164              {
   1165                NV_FlashRead(readAddress, (uint8_t*)&metaValue, sizeof(metaValue));
   \   00000042   0x2208             MOVS     R2,#+8
   \   00000044   0xA900             ADD      R1,SP,#+0
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       NV_FlashRead
   1166          
   1167                if(metaValue.rawValue == 0xFFFFFFFFFFFFFFFF)
   \   0000004C   0xA800             ADD      R0,SP,#+0
   \   0000004E   0x6802             LDR      R2,[R0, #+0]
   \   00000050   0x6843             LDR      R3,[R0, #+4]
   \   00000052   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000056   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000005A   0x428B             CMP      R3,R1
   \   0000005C   0xD149             BNE.N    ??NvGetLastMetaInfoAddress_3
   \   0000005E   0x4282             CMP      R2,R0
   \   00000060   0xD147             BNE.N    ??NvGetLastMetaInfoAddress_3
   1168                {
   1169                  if(readAddress == (mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + sizeof(mNvPageCounter)
   1170          #if gNvUseExtendedFeatureSet_d        		
   1171                  		+ mNvTableSizeInFlash + (2 * sizeof(mNvTableMarker))
   1172          #endif /* gNvUseExtendedFeatureSet_d */
   1173                  ))
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000006A   0x7809             LDRB     R1,[R1, #+0]
   \   0000006C   0x2214             MOVS     R2,#+20
   \   0000006E   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x1D00             ADDS     R0,R0,#+4
   \   00000076   0x4284             CMP      R4,R0
   \   00000078   0xD10C             BNE.N    ??NvGetLastMetaInfoAddress_4
   1174                  {
   1175                    mNvVirtualPageProperty[mNvActivePageId].NvLastMetaInfoAddress = gEmptyPageMetaAddress_c;
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable14  ;; 0x3fff0000
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000082   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   00000086   0x7812             LDRB     R2,[R2, #+0]
   \   00000088   0x2314             MOVS     R3,#+20
   \   0000008A   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   0000008E   0x6108             STR      R0,[R1, #+16]
   1176                    return gNVM_OK_c;
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xE033             B.N      ??NvGetLastMetaInfoAddress_5
   1177                  }
   1178          
   1179                  readAddress -= sizeof(NVM_RecordMetaInfo_t);
   \                     ??NvGetLastMetaInfoAddress_4: (+1)
   \   00000094   0x3C08             SUBS     R4,R4,#+8
   1180          
   1181                  while(readAddress >= (mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + sizeof(mNvPageCounter)
   1182          #if gNvUseExtendedFeatureSet_d
   1183                  		+ mNvTableSizeInFlash + (2 * sizeof(mNvTableMarker))
   1184          #endif /* gNvUseExtendedFeatureSet_d */
   1185                  ))
   \                     ??NvGetLastMetaInfoAddress_6: (+1)
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000009E   0x7809             LDRB     R1,[R1, #+0]
   \   000000A0   0x2214             MOVS     R2,#+20
   \   000000A2   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000000A6   0x6800             LDR      R0,[R0, #+0]
   \   000000A8   0x1D00             ADDS     R0,R0,#+4
   \   000000AA   0x4284             CMP      R4,R0
   \   000000AC   0xD31F             BCC.N    ??NvGetLastMetaInfoAddress_7
   1186                  {
   1187                    NV_FlashRead(readAddress, (uint8_t*)&metaValue, sizeof(metaValue));
   \   000000AE   0x2208             MOVS     R2,#+8
   \   000000B0   0xA900             ADD      R1,SP,#+0
   \   000000B2   0x0020             MOVS     R0,R4
   \   000000B4   0x.... 0x....      BL       NV_FlashRead
   1188          
   1189                    if((metaValue.fields.NvValidationStartByte == metaValue.fields.NvValidationEndByte) &&
   1190                        ((gValidationByteSingleRecord_c == metaValue.fields.NvValidationStartByte) || 
   1191                            (gValidationByteAllRecords_c == metaValue.fields.NvValidationStartByte)))
   \   000000B8   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000BC   0xF89D 0x1007      LDRB     R1,[SP, #+7]
   \   000000C0   0x4288             CMP      R0,R1
   \   000000C2   0xD112             BNE.N    ??NvGetLastMetaInfoAddress_8
   \   000000C4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000C8   0x28AA             CMP      R0,#+170
   \   000000CA   0xD003             BEQ.N    ??NvGetLastMetaInfoAddress_9
   \   000000CC   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000D0   0x2855             CMP      R0,#+85
   \   000000D2   0xD10A             BNE.N    ??NvGetLastMetaInfoAddress_8
   1192                    {
   1193                      mNvVirtualPageProperty[mNvActivePageId].NvLastMetaInfoAddress = readAddress;
   \                     ??NvGetLastMetaInfoAddress_9: (+1)
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable13
   \   000000D8   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000000DC   0x7809             LDRB     R1,[R1, #+0]
   \   000000DE   0x2214             MOVS     R2,#+20
   \   000000E0   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000000E4   0x6104             STR      R4,[R0, #+16]
   1194                      return gNVM_OK_c;
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0xE008             B.N      ??NvGetLastMetaInfoAddress_5
   1195                    }                    
   1196                    readAddress -= sizeof(NVM_RecordMetaInfo_t);
   \                     ??NvGetLastMetaInfoAddress_8: (+1)
   \   000000EA   0x3C08             SUBS     R4,R4,#+8
   \   000000EC   0xE7D3             B.N      ??NvGetLastMetaInfoAddress_6
   1197                  }
   1198                  return gNVM_MetaNotFound_c;
   \                     ??NvGetLastMetaInfoAddress_7: (+1)
   \   000000EE   0x200B             MOVS     R0,#+11
   \   000000F0   0xE004             B.N      ??NvGetLastMetaInfoAddress_5
   1199                }
   1200                return gNVM_MetaNotFound_c;
   \                     ??NvGetLastMetaInfoAddress_3: (+1)
   \   000000F2   0x200B             MOVS     R0,#+11
   \   000000F4   0xE002             B.N      ??NvGetLastMetaInfoAddress_5
   1201              }
   1202              else
   1203              {
   1204                readAddress += sizeof(NVM_RecordMetaInfo_t);
   \                     ??NvGetLastMetaInfoAddress_2: (+1)
   \   000000F6   0x3408             ADDS     R4,R4,#+8
   \   000000F8   0xE78F             B.N      ??NvGetLastMetaInfoAddress_0
   1205              }
   1206            }    
   1207            return gNVM_MetaNotFound_c;
   \                     ??NvGetLastMetaInfoAddress_1: (+1)
   \   000000FA   0x200B             MOVS     R0,#+11
   \                     ??NvGetLastMetaInfoAddress_5: (+1)
   \   000000FC   0xB004             ADD      SP,SP,#+16
   \   000000FE   0xBD10             POP      {R4,PC}          ;; return
   1208          }
   1209          
   1210          
   1211          /******************************************************************************
   1212           * Name: NvGetMetaInfo
   1213           * Description: get meta information based on the meta information address
   1214           * Parameter(s): [IN] pageID - the ID of the page
   1215           *               [IN] metaInfoAddress - meta information address
   1216           *               [OUT] pMetaInfo - a pointer to a memory location where the 
   1217           *                                 requested meta information will be stored
   1218           * Return: gNVM_InvalidPageID_c - if the active page is not valid
   1219           *         gNVM_NullPointer_c - if the provided pointer is NULL
   1220           *         gNVM_AddressOutOfRange_c - if the provided address is out of range
   1221           *         gNVM_OK_c - if the operation completed successfully
   1222           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1223          static NVM_Status_t NvGetMetaInfo
   1224          (
   1225            NVM_VirtualPageID_t pageId,
   1226            uint32_t metaInfoAddress,
   1227            NVM_RecordMetaInfo_t* pMetaInfo
   1228          )
   1229          {
   \                     NvGetMetaInfo: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1230            /* check address range */
   1231            if(metaInfoAddress < (mNvVirtualPageProperty[pageId].NvRawSectorStartAddress + sizeof(mNvPageCounter)
   1232          #if gNvUseExtendedFeatureSet_d		  
   1233          		  + (mNvTableSizeInFlash + (2 * sizeof(mNvTableMarker)))
   1234          #endif /* gNvUseExtendedFeatureSet_d */
   1235          		  ) || metaInfoAddress > mNvVirtualPageProperty[pageId].NvRawSectorEndAddress)
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2114             MOVS     R1,#+20
   \   00000010   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x1D00             ADDS     R0,R0,#+4
   \   00000018   0x4285             CMP      R5,R0
   \   0000001A   0xD308             BCC.N    ??NvGetMetaInfo_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x2114             MOVS     R1,#+20
   \   00000024   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000028   0x6840             LDR      R0,[R0, #+4]
   \   0000002A   0x42A8             CMP      R0,R5
   \   0000002C   0xD201             BCS.N    ??NvGetMetaInfo_1
   1236            {
   1237              return gNVM_AddressOutOfRange_c;
   \                     ??NvGetMetaInfo_0: (+1)
   \   0000002E   0x2007             MOVS     R0,#+7
   \   00000030   0xE005             B.N      ??NvGetMetaInfo_2
   1238            }
   1239          
   1240            /* read the meta information tag */
   1241            NV_FlashRead(metaInfoAddress, (uint8_t*)pMetaInfo, sizeof(NVM_RecordMetaInfo_t));
   \                     ??NvGetMetaInfo_1: (+1)
   \   00000032   0x2208             MOVS     R2,#+8
   \   00000034   0x0031             MOVS     R1,R6
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0x.... 0x....      BL       NV_FlashRead
   1242          
   1243            return gNVM_OK_c;    
   \   0000003C   0x2000             MOVS     R0,#+0
   \                     ??NvGetMetaInfo_2: (+1)
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return
   1244          }
   1245          
   1246          
   1247          /******************************************************************************
   1248           * Name: NvGetPageFreeSpace
   1249           * Description: return the page free space, in bytes
   1250           * Parameter(s): [OUT] ptrFreeSpace - a pointer to a memory location where the
   1251           *                                    page free space will be stored
   1252           * Return: gNVM_InvalidPageID_c - if the active page is not valid
   1253           *         gNVM_NullPointer_c - if the provided pointer is NULL
   1254           *         gNVM_PageIsEmpty_c - if the page is empty
   1255           *         gNVM_OK_c - if the operation completed successfully
   1256           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1257          static NVM_Status_t NvGetPageFreeSpace
   1258          (    
   1259            uint32_t* ptrFreeSpace
   1260          )
   1261          {
   \                     NvGetPageFreeSpace: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   1262            NVM_RecordMetaInfo_t metaInfo;
   1263            NVM_Status_t retVal;
   1264          
   1265            if(gEmptyPageMetaAddress_c == mNvVirtualPageProperty[mNvActivePageId].NvLastMetaInfoAddress)
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
   \   00000010   0x2214             MOVS     R2,#+20
   \   00000012   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000016   0x6900             LDR      R0,[R0, #+16]
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x3fff0000
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD10B             BNE.N    ??NvGetPageFreeSpace_0
   1266            {
   1267          #if gNvUseExtendedFeatureSet_d	  
   1268              *ptrFreeSpace = mNvVirtualPageProperty[mNvActivePageId].NvTotalPageSize - mNvTableSizeInFlash - 
   1269                  (2 * (sizeof(mNvPageCounter) + sizeof(mNvTableMarker)));
   1270          #else
   1271              *ptrFreeSpace = mNvVirtualPageProperty[mNvActivePageId].NvTotalPageSize - (2 * sizeof(mNvPageCounter));
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000028   0x7809             LDRB     R1,[R1, #+0]
   \   0000002A   0x2214             MOVS     R2,#+20
   \   0000002C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000030   0x68C0             LDR      R0,[R0, #+12]
   \   00000032   0x3808             SUBS     R0,R0,#+8
   \   00000034   0x6020             STR      R0,[R4, #+0]
   \   00000036   0xE02E             B.N      ??NvGetPageFreeSpace_1
   1272          #endif /* gNvUseExtendedFeatureSet_d */
   1273            }
   1274            else
   1275            {        
   1276              retVal = NvGetMetaInfo(mNvActivePageId, mNvVirtualPageProperty[mNvActivePageId].NvLastMetaInfoAddress, &metaInfo);
   \                     ??NvGetPageFreeSpace_0: (+1)
   \   00000038   0xAA00             ADD      R2,SP,#+0
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000042   0x7809             LDRB     R1,[R1, #+0]
   \   00000044   0x2314             MOVS     R3,#+20
   \   00000046   0xFB03 0x0001      MLA      R0,R3,R1,R0
   \   0000004A   0x6901             LDR      R1,[R0, #+16]
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   00000050   0x7800             LDRB     R0,[R0, #+0]
   \   00000052   0x.... 0x....      BL       NvGetMetaInfo
   \   00000056   0x0005             MOVS     R5,R0
   1277          
   1278              if(gNVM_OK_c == retVal)
   \   00000058   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005A   0x2D00             CMP      R5,#+0
   \   0000005C   0xD119             BNE.N    ??NvGetPageFreeSpace_2
   1279              {
   1280                *ptrFreeSpace = (mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + metaInfo.fields.NvmRecordOffset) - 
   1281                    (mNvVirtualPageProperty[mNvActivePageId].NvLastMetaInfoAddress + 
   1282                        sizeof(NVM_RecordMetaInfo_t));
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000066   0x7809             LDRB     R1,[R1, #+0]
   \   00000068   0x2214             MOVS     R2,#+20
   \   0000006A   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0xF8BD 0x1005      LDRH     R1,[SP, #+5]
   \   00000074   0xFA10 0xF081      UXTAH    R0,R0,R1
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable13
   \   0000007C   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   00000080   0x7812             LDRB     R2,[R2, #+0]
   \   00000082   0x2314             MOVS     R3,#+20
   \   00000084   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000088   0x6909             LDR      R1,[R1, #+16]
   \   0000008A   0x1A40             SUBS     R0,R0,R1
   \   0000008C   0x3808             SUBS     R0,R0,#+8
   \   0000008E   0x6020             STR      R0,[R4, #+0]
   \   00000090   0xE001             B.N      ??NvGetPageFreeSpace_1
   1283              }
   1284              else
   1285              {            
   1286                *ptrFreeSpace = 0;
   \                     ??NvGetPageFreeSpace_2: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x6020             STR      R0,[R4, #+0]
   1287              }
   1288            }
   1289            return retVal;
   \                     ??NvGetPageFreeSpace_1: (+1)
   \   00000096   0x0028             MOVS     R0,R5
   \   00000098   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009A   0xBD3E             POP      {R1-R5,PC}       ;; return
   1290          }
   1291          
   1292          
   1293          /******************************************************************************
   1294           * Name: NvIsMemoryAreaAvailable
   1295           * Description: checks if the specified memory area is blank (erased)
   1296           * Parameter(s): [IN] address - start address
   1297           *               [IN] len - length to be verified
   1298           * Return: TRUE if the area is available (blank), FALSE otherwise
   1299           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1300          static bool_t NvIsMemoryAreaAvailable
   1301          (
   1302            uint32_t address,
   1303            uint32_t len
   1304          )
   1305          {
   \                     NvIsMemoryAreaAvailable: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1306            uint8_t readBuffer[gNV_LONGWORD_SIZE_c];
   1307            uint8_t loopCnt;
   1308          
   1309            if(len % (uint8_t)gNV_LONGWORD_SIZE_c != 0)
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0xFBB5 0xF1F0      UDIV     R1,R5,R0
   \   0000000E   0xFB01 0x5110      MLS      R1,R1,R0,R5
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD001             BEQ.N    ??NvIsMemoryAreaAvailable_0
   1310            {
   1311              return FALSE;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE03E             B.N      ??NvIsMemoryAreaAvailable_1
   1312            }
   1313          
   1314          
   1315            if(address < mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress ||
   1316                address > mNvVirtualPageProperty[mNvActivePageId].NvRawSectorEndAddress)
   \                     ??NvIsMemoryAreaAvailable_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000022   0x7809             LDRB     R1,[R1, #+0]
   \   00000024   0x2214             MOVS     R2,#+20
   \   00000026   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD30A             BCC.N    ??NvIsMemoryAreaAvailable_2
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000038   0x7809             LDRB     R1,[R1, #+0]
   \   0000003A   0x2214             MOVS     R2,#+20
   \   0000003C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000040   0x6840             LDR      R0,[R0, #+4]
   \   00000042   0x42A0             CMP      R0,R4
   \   00000044   0xD201             BCS.N    ??NvIsMemoryAreaAvailable_3
   1317            {
   1318              return FALSE;
   \                     ??NvIsMemoryAreaAvailable_2: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xE026             B.N      ??NvIsMemoryAreaAvailable_1
   1319            }
   1320          
   1321            if((address + len) > mNvVirtualPageProperty[mNvActivePageId].NvRawSectorEndAddress + 1)
   \                     ??NvIsMemoryAreaAvailable_3: (+1)
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000052   0x7809             LDRB     R1,[R1, #+0]
   \   00000054   0x2214             MOVS     R2,#+20
   \   00000056   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000005A   0x6840             LDR      R0,[R0, #+4]
   \   0000005C   0x1C40             ADDS     R0,R0,#+1
   \   0000005E   0x1929             ADDS     R1,R5,R4
   \   00000060   0x4288             CMP      R0,R1
   \   00000062   0xD201             BCS.N    ??NvIsMemoryAreaAvailable_4
   1322            {
   1323              return FALSE;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xE017             B.N      ??NvIsMemoryAreaAvailable_1
   1324            }
   1325          
   1326            while(len)
   \                     ??NvIsMemoryAreaAvailable_4: (+1)
   \   00000068   0x2D00             CMP      R5,#+0
   \   0000006A   0xD014             BEQ.N    ??NvIsMemoryAreaAvailable_5
   1327            {
   1328          
   1329              NV_FlashRead(address,(uint8_t*)&readBuffer[0], (uint8_t)gNV_LONGWORD_SIZE_c);
   \   0000006C   0x2204             MOVS     R2,#+4
   \   0000006E   0xA900             ADD      R1,SP,#+0
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0x.... 0x....      BL       NV_FlashRead
   1330              loopCnt = (uint8_t)gNV_LONGWORD_SIZE_c;
   \   00000076   0x2004             MOVS     R0,#+4
   \   00000078   0x0006             MOVS     R6,R0
   1331              while(loopCnt)
   \                     ??NvIsMemoryAreaAvailable_6: (+1)
   \   0000007A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007C   0x2E00             CMP      R6,#+0
   \   0000007E   0xD007             BEQ.N    ??NvIsMemoryAreaAvailable_7
   1332              {
   1333                if(readBuffer[--loopCnt] != gNvErasedFlashCellValue_c)
   \   00000080   0x1E76             SUBS     R6,R6,#+1
   \   00000082   0xA800             ADD      R0,SP,#+0
   \   00000084   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000086   0x5C30             LDRB     R0,[R6, R0]
   \   00000088   0x28FF             CMP      R0,#+255
   \   0000008A   0xD0F6             BEQ.N    ??NvIsMemoryAreaAvailable_6
   1334                {
   1335                  return FALSE;
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xE003             B.N      ??NvIsMemoryAreaAvailable_1
   1336                }            
   1337              }        
   1338              len-=(uint8_t)gNV_LONGWORD_SIZE_c;
   \                     ??NvIsMemoryAreaAvailable_7: (+1)
   \   00000090   0x1F2D             SUBS     R5,R5,#+4
   1339              address+=(uint8_t)gNV_LONGWORD_SIZE_c;
   \   00000092   0x1D24             ADDS     R4,R4,#+4
   \   00000094   0xE7E8             B.N      ??NvIsMemoryAreaAvailable_4
   1340            }
   1341            return TRUE;    
   \                     ??NvIsMemoryAreaAvailable_5: (+1)
   \   00000096   0x2001             MOVS     R0,#+1
   \                     ??NvIsMemoryAreaAvailable_1: (+1)
   \   00000098   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1342          }
   1343          
   1344          
   1345          /******************************************************************************
   1346           * Name: NvIsRecordCopied
   1347           * Description: Checks if a record or an entire table entry is already copied. 
   1348           *              Called by page copy function.
   1349           * Parameter(s): [IN] pageId - the ID of the page where to perform the check
   1350           *               [IN] metaInf - a pointer to source page meta information tag
   1351           * Return: TRUE if the element is already copied, FALSE otherwise
   1352           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1353          static bool_t NvIsRecordCopied
   1354          (
   1355            NVM_VirtualPageID_t pageId,
   1356            NVM_RecordMetaInfo_t* metaInf
   1357          )
   1358          {
   \                     NvIsRecordCopied: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1359            uint32_t loopAddress;
   1360            uint8_t dataRead[8];
   1361            bool_t retVal;
   1362            uint16_t tmp;
   1363          
   1364          #if gNvUseExtendedFeatureSet_d
   1365            loopAddress = mNvVirtualPageProperty[pageId].NvRawSectorStartAddress + sizeof(mNvPageCounter) + 
   1366                mNvTableSizeInFlash + (2 * sizeof(mNvTableMarker));
   1367          #else
   1368            loopAddress = mNvVirtualPageProperty[pageId].NvRawSectorStartAddress + sizeof(mNvPageCounter);         
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2114             MOVS     R1,#+20
   \   00000010   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x1D00             ADDS     R0,R0,#+4
   \   00000018   0x0006             MOVS     R6,R0
   1369          #endif /* gNvUseExtendedFeatureSet_d */
   1370            
   1371            retVal = FALSE;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x0007             MOVS     R7,R0
   1372          
   1373            do
   1374            {
   1375              /* read the meta information tag */
   1376              NV_FlashRead(loopAddress, (uint8_t*)dataRead, sizeof(NVM_RecordMetaInfo_t));
   \                     ??NvIsRecordCopied_0: (+1)
   \   0000001E   0x2208             MOVS     R2,#+8
   \   00000020   0xA900             ADD      R1,SP,#+0
   \   00000022   0x0030             MOVS     R0,R6
   \   00000024   0x.... 0x....      BL       NV_FlashRead
   1377          
   1378              if(dataRead[0] == gNvErasedFlashCellValue_c)
   \   00000028   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002C   0x28FF             CMP      R0,#+255
   \   0000002E   0xD04A             BEQ.N    ??NvIsRecordCopied_1
   1379              {
   1380                /* no meta starts with 0xFF */
   1381                break;
   1382              }
   1383          
   1384              if(dataRead[0] != dataRead[7])
   \                     ??NvIsRecordCopied_2: (+1)
   \   00000030   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000034   0xF89D 0x1007      LDRB     R1,[SP, #+7]
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD001             BEQ.N    ??NvIsRecordCopied_3
   1385              {
   1386                /* invalid meta */
   1387                loopAddress += sizeof(NVM_RecordMetaInfo_t);
   \   0000003C   0x3608             ADDS     R6,R6,#+8
   1388                continue;
   \   0000003E   0xE039             B.N      ??NvIsRecordCopied_4
   1389              }
   1390          
   1391              /* get the table entry ID */
   1392              tmp = (uint16_t)(((uint16_t)dataRead[2]<<8) + dataRead[1]);
   \                     ??NvIsRecordCopied_3: (+1)
   \   00000040   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000044   0x0200             LSLS     R0,R0,#+8
   \   00000046   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   0000004A   0xFA50 0xF081      UXTAB    R0,R0,R1
   \   0000004E   0x4680             MOV      R8,R0
   1393          
   1394              if(metaInf->fields.NvmDataEntryID == tmp)
   \   00000050   0xF8B5 0x0001      LDRH     R0,[R5, #+1]
   \   00000054   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000058   0x4540             CMP      R0,R8
   \   0000005A   0xD12A             BNE.N    ??NvIsRecordCopied_5
   1395              {  
   1396                if(metaInf->fields.NvValidationStartByte == gValidationByteSingleRecord_c)
   \   0000005C   0x7828             LDRB     R0,[R5, #+0]
   \   0000005E   0x28AA             CMP      R0,#+170
   \   00000060   0xD119             BNE.N    ??NvIsRecordCopied_6
   1397                {
   1398                  if(dataRead[0] == gValidationByteSingleRecord_c)
   \   00000062   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000066   0x28AA             CMP      R0,#+170
   \   00000068   0xD112             BNE.N    ??NvIsRecordCopied_7
   1399                  {
   1400                    /* get the element index */
   1401                    tmp = (uint16_t)(((uint16_t)dataRead[4]<<8) + dataRead[3]);                  
   \   0000006A   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000006E   0x0200             LSLS     R0,R0,#+8
   \   00000070   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   00000074   0xFA50 0xF081      UXTAB    R0,R0,R1
   \   00000078   0x4680             MOV      R8,R0
   1402                    if(tmp == metaInf->fields.NvmElementIndex)
   \   0000007A   0xF8B5 0x0003      LDRH     R0,[R5, #+3]
   \   0000007E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000082   0x4580             CMP      R8,R0
   \   00000084   0xD102             BNE.N    ??NvIsRecordCopied_8
   1403                    {
   1404                      retVal = TRUE;
   \   00000086   0x2001             MOVS     R0,#+1
   \   00000088   0x0007             MOVS     R7,R0
   1405                      break;
   \   0000008A   0xE01C             B.N      ??NvIsRecordCopied_1
   1406                    }
   1407          
   1408                    /* skip */
   1409                    loopAddress += sizeof(NVM_RecordMetaInfo_t);
   \                     ??NvIsRecordCopied_8: (+1)
   \   0000008C   0x3608             ADDS     R6,R6,#+8
   1410                    continue;
   \   0000008E   0xE011             B.N      ??NvIsRecordCopied_4
   1411                  }              
   1412                  retVal = TRUE;
   \                     ??NvIsRecordCopied_7: (+1)
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0x0007             MOVS     R7,R0
   1413                  break;
   \   00000094   0xE017             B.N      ??NvIsRecordCopied_1
   1414                }
   1415          
   1416                if(metaInf->fields.NvValidationStartByte == gValidationByteAllRecords_c)
   \                     ??NvIsRecordCopied_6: (+1)
   \   00000096   0x7828             LDRB     R0,[R5, #+0]
   \   00000098   0x2855             CMP      R0,#+85
   \   0000009A   0xD108             BNE.N    ??NvIsRecordCopied_9
   1417                {
   1418                  if(dataRead[0] == gValidationByteSingleRecord_c)
   \   0000009C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000A0   0x28AA             CMP      R0,#+170
   \   000000A2   0xD101             BNE.N    ??NvIsRecordCopied_10
   1419                  {
   1420                    /* skip */
   1421                    loopAddress += sizeof(NVM_RecordMetaInfo_t);
   \   000000A4   0x3608             ADDS     R6,R6,#+8
   1422                    continue;
   \   000000A6   0xE005             B.N      ??NvIsRecordCopied_4
   1423                  }
   1424                  retVal = TRUE;
   \                     ??NvIsRecordCopied_10: (+1)
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0x0007             MOVS     R7,R0
   1425                  break;
   \   000000AC   0xE00B             B.N      ??NvIsRecordCopied_1
   1426                }
   1427          
   1428                /* skip */
   1429                loopAddress += sizeof(NVM_RecordMetaInfo_t);
   \                     ??NvIsRecordCopied_9: (+1)
   \   000000AE   0x3608             ADDS     R6,R6,#+8
   1430                continue;
   \   000000B0   0xE000             B.N      ??NvIsRecordCopied_4
   1431              }      
   1432          
   1433              loopAddress += sizeof(NVM_RecordMetaInfo_t);
   \                     ??NvIsRecordCopied_5: (+1)
   \   000000B2   0x3608             ADDS     R6,R6,#+8
   1434          
   1435            } while(loopAddress < mNvVirtualPageProperty[pageId].NvRawSectorEndAddress);
   \                     ??NvIsRecordCopied_4: (+1)
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable13
   \   000000B8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BA   0x2114             MOVS     R1,#+20
   \   000000BC   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000000C0   0x6840             LDR      R0,[R0, #+4]
   \   000000C2   0x4286             CMP      R6,R0
   \   000000C4   0xD3AB             BCC.N    ??NvIsRecordCopied_0
   1436          
   1437            return retVal;
   \                     ??NvIsRecordCopied_1: (+1)
   \   000000C6   0x0038             MOVS     R0,R7
   \   000000C8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000CA   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   1438          }
   1439          
   1440          
   1441          /******************************************************************************
   1442           * Name: NvInternalCopy
   1443           * Description: Performs a copy of an record / entire table entry
   1444           * Parameter(s): [IN] dstAddress - destination record address
   1445           *               [IN] dstMetaAddress - destination meta address
   1446           *               [IN] srcMetaInfo - source meta information
   1447           *               [IN] srcTblEntryIdx - source table entry index
   1448           *               [IN] size - bytes to copy
   1449           * Return: gNVM_InvalidPageID_c - if the source or destination page is not 
   1450           *                                valid
   1451           *         gNVM_MetaInfoWriteError_c - if the meta information couldn't be 
   1452           *                                     written
   1453           *         gNVM_RecordWriteError_c - if the record couldn't be written
   1454           *         gNVM_Error_c - in case of error(s)
   1455           *         gNVM_OK_c - page copy completed successfully
   1456           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1457          static NVM_Status_t NvInternalCopy
   1458          (
   1459            uint32_t dstAddress,
   1460            uint32_t dstMetaAddress,
   1461            NVM_RecordMetaInfo_t* srcMetaInfo,
   1462            uint16_t srcTblEntryIdx,
   1463            uint16_t size
   1464          )
   1465          {
   \                     NvInternalCopy: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0xB094             SUB      SP,SP,#+80
   \   00000006   0x0005             MOVS     R5,R0
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0x9C1E             LDR      R4,[SP, #+120]
   1466            uint16_t innerOffset;
   1467            uint8_t cacheBuffer[gNvCacheBufferSize_c];
   1468            NVM_RecordMetaInfo_t dstMetaInfo;
   1469            uint16_t diffSize = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   1470            uint16_t diffIdx = 0;
   \   00000014   0xF05F 0x0900      MOVS     R9,#+0
   1471            uint16_t ramSize = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1472            uint8_t misalignedBytes;
   1473            uint8_t loopIdx;
   1474            uint16_t loopEnd;
   1475          
   1476            /* Initialize the inner offset*/
   1477            innerOffset = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x4680             MOV      R8,R0
   1478          
   1479            /* prepare destination page meta info tag and write if after the record is entirely written.
   1480             * the preparation is made here because the 'dstAddress' may change afterwards
   1481             */        
   1482            
   1483            dstMetaInfo.fields = srcMetaInfo->fields; 
   \   00000022   0xA802             ADD      R0,SP,#+8
   \   00000024   0x0031             MOVS     R1,R6
   \   00000026   0x2208             MOVS     R2,#+8
   \   00000028   0x.... 0x....      BL       __aeabi_memcpy
   1484            dstMetaInfo.fields.NvmRecordOffset = dstAddress - mNvVirtualPageProperty[(mNvActivePageId+1)%2].NvRawSectorStartAddress;
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000034   0x7809             LDRB     R1,[R1, #+0]
   \   00000036   0x1C49             ADDS     R1,R1,#+1
   \   00000038   0x2202             MOVS     R2,#+2
   \   0000003A   0xFB91 0xF3F2      SDIV     R3,R1,R2
   \   0000003E   0xFB03 0x1312      MLS      R3,R3,R2,R1
   \   00000042   0x2114             MOVS     R1,#+20
   \   00000044   0xFB01 0x0003      MLA      R0,R1,R3,R0
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x1A28             SUBS     R0,R5,R0
   \   0000004C   0xF8AD 0x000D      STRH     R0,[SP, #+13]
   1485            
   1486            ramSize = pNVM_DataTable[srcTblEntryIdx].ElementsCount * pNVM_DataTable[srcTblEntryIdx].ElementSize;
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000058   0x210C             MOVS     R1,#+12
   \   0000005A   0xFB01 0x0007      MLA      R0,R1,R7,R0
   \   0000005E   0x8880             LDRH     R0,[R0, #+4]
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000064   0x6809             LDR      R1,[R1, #+0]
   \   00000066   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000068   0x220C             MOVS     R2,#+12
   \   0000006A   0xFB02 0x1107      MLA      R1,R2,R7,R1
   \   0000006E   0x88C9             LDRH     R1,[R1, #+6]
   \   00000070   0xFB10 0xF001      SMULBB   R0,R0,R1
   \   00000074   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1487          
   1488            /* if the bytes to copy are less then RAM table entry space, the supplementary bytes to write on the destination page
   1489             * will be retrieved from RAM table entry. This is the case when the RAM table has been updated and the new
   1490             * entry's elements count is greater then the one existing in the previous RAM table, now stored in the FLASH active page
   1491             * (source page) */
   1492            if(size < ramSize)
   \   00000078   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000007C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000007E   0x4284             CMP      R4,R0
   \   00000080   0xD210             BCS.N    ??NvInternalCopy_0
   1493            {
   1494              diffSize = ramSize - size;
   \   00000082   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000086   0x1B00             SUBS     R0,R0,R4
   \   00000088   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   1495              diffIdx = size / pNVM_DataTable[srcTblEntryIdx].ElementSize;
   \   0000008C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000092   0x6800             LDR      R0,[R0, #+0]
   \   00000094   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000096   0x210C             MOVS     R1,#+12
   \   00000098   0xFB01 0x0007      MLA      R0,R1,R7,R0
   \   0000009C   0x88C0             LDRH     R0,[R0, #+6]
   \   0000009E   0xFB94 0xF0F0      SDIV     R0,R4,R0
   \   000000A2   0x4681             MOV      R9,R0
   1496            }
   1497          
   1498            while(size)
   \                     ??NvInternalCopy_0: (+1)
   \   000000A4   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000A6   0x2C00             CMP      R4,#+0
   \   000000A8   0xD047             BEQ.N    ??NvInternalCopy_1
   1499            {
   1500              if(size > (uint16_t)gNvCacheBufferSize_c)
   \   000000AA   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000AC   0x2C41             CMP      R4,#+65
   \   000000AE   0xDB23             BLT.N    ??NvInternalCopy_2
   1501              {
   1502                /* copy from FLASH to cache buffer */
   1503                NV_FlashRead(mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + srcMetaInfo->fields.NvmRecordOffset + innerOffset, 
   1504                    (uint8_t*)&cacheBuffer[0], (uint16_t)gNvCacheBufferSize_c);                    
   \   000000B0   0x2240             MOVS     R2,#+64
   \   000000B2   0xA904             ADD      R1,SP,#+16
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable13
   \   000000B8   0x.... 0x....      LDR.W    R3,??DataTable13_2
   \   000000BC   0x781B             LDRB     R3,[R3, #+0]
   \   000000BE   0xF05F 0x0C14      MOVS     R12,#+20
   \   000000C2   0xFB0C 0x0003      MLA      R0,R12,R3,R0
   \   000000C6   0x6800             LDR      R0,[R0, #+0]
   \   000000C8   0xF8B6 0x3005      LDRH     R3,[R6, #+5]
   \   000000CC   0xFA10 0xF083      UXTAH    R0,R0,R3
   \   000000D0   0xFA10 0xF088      UXTAH    R0,R0,R8
   \   000000D4   0x.... 0x....      BL       NV_FlashRead
   1505          
   1506                /* write to destination page */
   1507                if(gNV_OK_c == NV_FlashProgramLongword(&mNvConfig, dstAddress, (uint16_t)gNvCacheBufferSize_c, (uint32_t)(&cacheBuffer[0])))
   \   000000D8   0xAB04             ADD      R3,SP,#+16
   \   000000DA   0x2240             MOVS     R2,#+64
   \   000000DC   0x0029             MOVS     R1,R5
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   000000E2   0x.... 0x....      BL       NV_FlashProgramLongword
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD104             BNE.N    ??NvInternalCopy_3
   1508                {
   1509                  /* update the destination record address copy */
   1510                  dstAddress += (uint16_t)gNvCacheBufferSize_c;
   \   000000EA   0x3540             ADDS     R5,R5,#+64
   1511                  /* update the record size */
   1512                  size -= (uint16_t)gNvCacheBufferSize_c;
   \   000000EC   0x3C40             SUBS     R4,R4,#+64
   1513                  /* update the inner offset value */
   1514                  innerOffset += (uint16_t)gNvCacheBufferSize_c;
   \   000000EE   0xF118 0x0840      ADDS     R8,R8,#+64
   1515          
   1516                  continue;
   \   000000F2   0xE7D7             B.N      ??NvInternalCopy_0
   1517                }
   1518                return gNVM_RecordWriteError_c;
   \                     ??NvInternalCopy_3: (+1)
   \   000000F4   0x200C             MOVS     R0,#+12
   \   000000F6   0xE0C4             B.N      ??NvInternalCopy_4
   1519              }
   1520              else
   1521              {
   1522                /* copy from FLASH to cache buffer */
   1523                NV_FlashRead(mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + srcMetaInfo->fields.NvmRecordOffset + innerOffset, 
   1524                    (uint8_t*)&cacheBuffer[0], size);
   \                     ??NvInternalCopy_2: (+1)
   \   000000F8   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000FA   0x0022             MOVS     R2,R4
   \   000000FC   0xA904             ADD      R1,SP,#+16
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000102   0x.... 0x....      LDR.W    R3,??DataTable13_2
   \   00000106   0x781B             LDRB     R3,[R3, #+0]
   \   00000108   0xF05F 0x0C14      MOVS     R12,#+20
   \   0000010C   0xFB0C 0x0003      MLA      R0,R12,R3,R0
   \   00000110   0x6800             LDR      R0,[R0, #+0]
   \   00000112   0xF8B6 0x3005      LDRH     R3,[R6, #+5]
   \   00000116   0xFA10 0xF083      UXTAH    R0,R0,R3
   \   0000011A   0xFA10 0xF088      UXTAH    R0,R0,R8
   \   0000011E   0x.... 0x....      BL       NV_FlashRead
   1525                /* write to destination page */
   1526                if(gNV_OK_c == NV_FlashProgramLongword(&mNvConfig, dstAddress, (uint16_t)size, (uint32_t)(&cacheBuffer[0])))
   \   00000122   0xAB04             ADD      R3,SP,#+16
   \   00000124   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000126   0x0022             MOVS     R2,R4
   \   00000128   0x0029             MOVS     R1,R5
   \   0000012A   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   0000012E   0x.... 0x....      BL       NV_FlashProgramLongword
   \   00000132   0x2800             CMP      R0,#+0
   \   00000134   0xD001             BEQ.N    ??NvInternalCopy_1
   1527                {
   1528                  break;
   1529                }
   1530                return gNVM_RecordWriteError_c;
   \                     ??NvInternalCopy_5: (+1)
   \   00000136   0x200C             MOVS     R0,#+12
   \   00000138   0xE0A3             B.N      ??NvInternalCopy_4
   1531              }
   1532            }
   1533          
   1534            if(diffSize)
   \                     ??NvInternalCopy_1: (+1)
   \   0000013A   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   0000013E   0x2800             CMP      R0,#+0
   \   00000140   0xF000 0x8093      BEQ.W    ??NvInternalCopy_6
   1535            {
   1536              /* update the destination record address copy */
   1537              dstAddress += size;
   \   00000144   0xFA15 0xF584      UXTAH    R5,R5,R4
   1538              
   1539              /* check alignment and adjust it if necessary */                            
   1540              misalignedBytes = dstAddress - (dstAddress & (~0x03uL));
   \   00000148   0xF015 0x00FC      ANDS     R0,R5,#0xFC
   \   0000014C   0x1A28             SUBS     R0,R5,R0
   \   0000014E   0x4682             MOV      R10,R0
   1541              
   1542              /* initialise the inner offset */
   1543              innerOffset = 0;
   \   00000150   0x2000             MOVS     R0,#+0
   \   00000152   0x4680             MOV      R8,R0
   1544          
   1545              /* check if the destination is longword aligned or not */
   1546              if(misalignedBytes)
   \   00000154   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000158   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000015C   0xD05E             BEQ.N    ??NvInternalCopy_7
   1547              {
   1548                /* align to previous 32 bit boundary */
   1549                dstAddress &= ~0x03uL;
   \   0000015E   0x08AD             LSRS     R5,R5,#+2
   \   00000160   0x00AD             LSLS     R5,R5,#+2
   1550              	    	    	    	
   1551                /* compute the loop end */
   1552                if(pNVM_DataTable[srcTblEntryIdx].ElementSize < (4-misalignedBytes))
   \   00000162   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000166   0x6800             LDR      R0,[R0, #+0]
   \   00000168   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000016A   0x210C             MOVS     R1,#+12
   \   0000016C   0xFB01 0x0007      MLA      R0,R1,R7,R0
   \   00000170   0x88C0             LDRH     R0,[R0, #+6]
   \   00000172   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000176   0xF1DA 0x0104      RSBS     R1,R10,#+4
   \   0000017A   0x4288             CMP      R0,R1
   \   0000017C   0xDA0A             BGE.N    ??NvInternalCopy_8
   1553                {
   1554                  loopEnd = pNVM_DataTable[srcTblEntryIdx].ElementSize; 
   \   0000017E   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000182   0x6800             LDR      R0,[R0, #+0]
   \   00000184   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000186   0x210C             MOVS     R1,#+12
   \   00000188   0xFB01 0x0007      MLA      R0,R1,R7,R0
   \   0000018C   0x88C0             LDRH     R0,[R0, #+6]
   \   0000018E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \   00000192   0xE005             B.N      ??NvInternalCopy_9
   1555                }
   1556                else
   1557                {
   1558                  loopEnd = 4 - misalignedBytes;
   \                     ??NvInternalCopy_8: (+1)
   \   00000194   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000198   0xF1DA 0x0004      RSBS     R0,R10,#+4
   \   0000019C   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1559                }
   1560              	
   1561                /* read from destination page to cache buffer */
   1562                NV_FlashRead(dstAddress, (uint8_t*)&cacheBuffer[0], 4);
   \                     ??NvInternalCopy_9: (+1)
   \   000001A0   0x2204             MOVS     R2,#+4
   \   000001A2   0xA904             ADD      R1,SP,#+16
   \   000001A4   0x0028             MOVS     R0,R5
   \   000001A6   0x.... 0x....      BL       NV_FlashRead
   1563              	    	
   1564                /* update with data from RAM */
   1565                for(loopIdx = 0; loopIdx < loopEnd; loopIdx++)
   \   000001AA   0x2000             MOVS     R0,#+0
   \   000001AC   0x4683             MOV      R11,R0
   \                     ??NvInternalCopy_10: (+1)
   \   000001AE   0x4658             MOV      R0,R11
   \   000001B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001B2   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   000001B6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001B8   0x4288             CMP      R0,R1
   \   000001BA   0xD223             BCS.N    ??NvInternalCopy_11
   1566                {
   1567                  cacheBuffer[misalignedBytes] = *((uint8_t*)pNVM_DataTable[srcTblEntryIdx].pData + 
   1568              				(diffIdx * pNVM_DataTable[srcTblEntryIdx].ElementSize) + innerOffset);
   \   000001BC   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000001C0   0x6800             LDR      R0,[R0, #+0]
   \   000001C2   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000001C4   0x210C             MOVS     R1,#+12
   \   000001C6   0xFB01 0x0007      MLA      R0,R1,R7,R0
   \   000001CA   0x6800             LDR      R0,[R0, #+0]
   \   000001CC   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000001D0   0x.... 0x....      LDR.W    R1,??DataTable16
   \   000001D4   0x6809             LDR      R1,[R1, #+0]
   \   000001D6   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000001D8   0x220C             MOVS     R2,#+12
   \   000001DA   0xFB02 0x1107      MLA      R1,R2,R7,R1
   \   000001DE   0x88C9             LDRH     R1,[R1, #+6]
   \   000001E0   0xFB01 0x0009      MLA      R0,R1,R9,R0
   \   000001E4   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000001E8   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   000001EC   0xA904             ADD      R1,SP,#+16
   \   000001EE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001F2   0xF80A 0x0001      STRB     R0,[R10, R1]
   1569                  innerOffset++;
   \   000001F6   0xF118 0x0801      ADDS     R8,R8,#+1
   1570                  misalignedBytes++;
   \   000001FA   0xF11A 0x0A01      ADDS     R10,R10,#+1
   1571                }
   \   000001FE   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   00000202   0xE7D4             B.N      ??NvInternalCopy_10
   1572          
   1573                /* write to Flash destination page */
   1574                if(gNV_OK_c != NV_FlashProgramLongword(&mNvConfig, dstAddress, gNV_LONGWORD_SIZE_c, (uint32_t)(&cacheBuffer[0])))
   \                     ??NvInternalCopy_11: (+1)
   \   00000204   0xAB04             ADD      R3,SP,#+16
   \   00000206   0x2204             MOVS     R2,#+4
   \   00000208   0x0029             MOVS     R1,R5
   \   0000020A   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   0000020E   0x.... 0x....      BL       NV_FlashProgramLongword
   \   00000212   0x2800             CMP      R0,#+0
   \   00000214   0xD001             BEQ.N    ??NvInternalCopy_12
   1575                {
   1576                  return gNVM_RecordWriteError_c;
   \   00000216   0x200C             MOVS     R0,#+12
   \   00000218   0xE033             B.N      ??NvInternalCopy_4
   1577                }
   1578          
   1579                /* align to next 32 bit boundary */    	
   1580                dstAddress += gNV_LONGWORD_SIZE_c;
   \                     ??NvInternalCopy_12: (+1)
   \   0000021A   0x1D2D             ADDS     R5,R5,#+4
   1581              }
   1582          
   1583              /* write to Flash destination page */
   1584              if(gNV_OK_c != NV_FlashProgramLongword(&mNvConfig, dstAddress, diffSize - innerOffset,
   1585              		(uint32_t)(((uint8_t*)pNVM_DataTable[srcTblEntryIdx].pData + (diffIdx * pNVM_DataTable[srcTblEntryIdx].ElementSize) + innerOffset))))
   \                     ??NvInternalCopy_7: (+1)
   \   0000021C   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000220   0x6800             LDR      R0,[R0, #+0]
   \   00000222   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000224   0x210C             MOVS     R1,#+12
   \   00000226   0xFB01 0x0007      MLA      R0,R1,R7,R0
   \   0000022A   0x6800             LDR      R0,[R0, #+0]
   \   0000022C   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000230   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000234   0x6809             LDR      R1,[R1, #+0]
   \   00000236   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000238   0x220C             MOVS     R2,#+12
   \   0000023A   0xFB02 0x1107      MLA      R1,R2,R7,R1
   \   0000023E   0x88C9             LDRH     R1,[R1, #+6]
   \   00000240   0xFB01 0x0009      MLA      R0,R1,R9,R0
   \   00000244   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000248   0xEB18 0x0300      ADDS     R3,R8,R0
   \   0000024C   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   00000250   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000254   0xEBB0 0x0208      SUBS     R2,R0,R8
   \   00000258   0x0029             MOVS     R1,R5
   \   0000025A   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   0000025E   0x.... 0x....      BL       NV_FlashProgramLongword
   \   00000262   0x2800             CMP      R0,#+0
   \   00000264   0xD001             BEQ.N    ??NvInternalCopy_6
   1586              {
   1587                return gNVM_RecordWriteError_c;
   \   00000266   0x200C             MOVS     R0,#+12
   \   00000268   0xE00B             B.N      ??NvInternalCopy_4
   1588              }
   1589            }
   1590          
   1591            /* write the associated record meta information */                
   1592            if(gNV_OK_c != NV_FlashProgramLongword(&mNvConfig, dstMetaAddress, sizeof(NVM_RecordMetaInfo_t), (uint32_t)(&dstMetaInfo)))
   \                     ??NvInternalCopy_6: (+1)
   \   0000026A   0xAB02             ADD      R3,SP,#+8
   \   0000026C   0x2208             MOVS     R2,#+8
   \   0000026E   0x9914             LDR      R1,[SP, #+80]
   \   00000270   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000274   0x.... 0x....      BL       NV_FlashProgramLongword
   \   00000278   0x2800             CMP      R0,#+0
   \   0000027A   0xD001             BEQ.N    ??NvInternalCopy_13
   1593            {
   1594          	return gNVM_MetaInfoWriteError_c;                    
   \   0000027C   0x200D             MOVS     R0,#+13
   \   0000027E   0xE000             B.N      ??NvInternalCopy_4
   1595            }    
   1596            return gNVM_OK_c;
   \                     ??NvInternalCopy_13: (+1)
   \   00000280   0x2000             MOVS     R0,#+0
   \                     ??NvInternalCopy_4: (+1)
   \   00000282   0xB015             ADD      SP,SP,#+84
   \   00000284   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1597          }
   1598          
   1599          
   1600          /******************************************************************************
   1601           * Name: NvGetRecordFullSize
   1602           * Description: Computes the size of the specified table entry that will 
   1603           *              be written on FLASH memory
   1604           * Parameter(s): [IN] tableEntryIndex - table entry index               
   1605           * Return: the computed size
   1606           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1607          static uint32_t NvGetRecordFullSize
   1608          (    
   1609            NvTableEntryId_t tableEntryIndex    
   1610          )
   1611          {
   \                     NvGetRecordFullSize: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0001             MOVS     R1,R0
   1612            uint32_t size;
   1613            uint8_t paddingBytes;
   1614          
   1615            /* compute the RAM size */
   1616            size = pNVM_DataTable[tableEntryIndex].ElementSize * pNVM_DataTable[tableEntryIndex].ElementsCount;
   \   00000004   0x.... 0x....      LDR.W    R3,??DataTable16
   \   00000008   0x681B             LDR      R3,[R3, #+0]
   \   0000000A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   0x240C             MOVS     R4,#+12
   \   0000000E   0xFB04 0x3301      MLA      R3,R4,R1,R3
   \   00000012   0x88DB             LDRH     R3,[R3, #+6]
   \   00000014   0x.... 0x....      LDR.W    R4,??DataTable16
   \   00000018   0x6824             LDR      R4,[R4, #+0]
   \   0000001A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001C   0x250C             MOVS     R5,#+12
   \   0000001E   0xFB05 0x4401      MLA      R4,R5,R1,R4
   \   00000022   0x88A4             LDRH     R4,[R4, #+4]
   \   00000024   0x4363             MULS     R3,R4,R3
   \   00000026   0x0018             MOVS     R0,R3
   1617          
   1618            /* compute the size that will be actually written on FLASH memory */        
   1619            paddingBytes = size % (uint8_t)gNV_LONGWORD_SIZE_c;   
   \   00000028   0x2304             MOVS     R3,#+4
   \   0000002A   0xFBB0 0xF4F3      UDIV     R4,R0,R3
   \   0000002E   0xFB04 0x0413      MLS      R4,R4,R3,R0
   \   00000032   0x0022             MOVS     R2,R4
   1620          
   1621            if(paddingBytes)
   \   00000034   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000036   0x2A00             CMP      R2,#+0
   \   00000038   0xD003             BEQ.N    ??NvGetRecordFullSize_0
   1622            {
   1623              size += (uint8_t)((uint8_t)gNV_LONGWORD_SIZE_c-paddingBytes);
   \   0000003A   0xF1D2 0x0304      RSBS     R3,R2,#+4
   \   0000003E   0xFA50 0xF083      UXTAB    R0,R0,R3
   1624            }
   1625          
   1626            return size;
   \                     ??NvGetRecordFullSize_0: (+1)
   \   00000042   0xBC30             POP      {R4,R5}
   \   00000044   0x4770             BX       LR               ;; return
   1627          }
   1628          
   1629          
   1630          /******************************************************************************
   1631           * Name: NvGetTblEntryMetaAddrFromId
   1632           * Description: Gets the table entry meta address based on table entry ID
   1633           * Parameter(s): [IN] searchStartAddress - the search start address
   1634           *               [IN] dataEntryId - table entry ID
   1635           * Return: the value of the meta address
   1636           *****************************************************************************/
   1637          #if gNvFragmentation_Enabled_d
   1638          static uint32_t NvGetTblEntryMetaAddrFromId
   1639          (
   1640            uint32_t searchStartAddress,
   1641            uint16_t dataEntryId
   1642          )
   1643          {
   1644            NVM_RecordMetaInfo_t metaInfo;
   1645          
   1646            while(searchStartAddress >= (mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + sizeof(mNvPageCounter))
   1647          #if gNvUseExtendedFeatureSet_d
   1648          		  + (mNvTableSizeInFlash + (2 * sizeof(mNvTableMarker)))
   1649          #endif /* gNvUseExtendedFeatureSet_d */
   1650                 )
   1651            {
   1652              (void)NvGetMetaInfo(mNvActivePageId, searchStartAddress, &metaInfo);
   1653          
   1654              if((metaInfo.fields.NvValidationStartByte != gValidationByteAllRecords_c) || 
   1655                  (metaInfo.fields.NvValidationStartByte != metaInfo.fields.NvValidationEndByte))
   1656              {
   1657                searchStartAddress -= sizeof(NVM_RecordMetaInfo_t);
   1658                continue;
   1659              }
   1660          
   1661              if(metaInfo.fields.NvmDataEntryID == dataEntryId)
   1662              {
   1663                /* found it */
   1664                return searchStartAddress;
   1665              }
   1666          
   1667              searchStartAddress -= sizeof(NVM_RecordMetaInfo_t);
   1668            }    
   1669            return 0;
   1670          }
   1671          #endif /* gNvFragmentation_Enabled_d */
   1672          
   1673          
   1674          /******************************************************************************
   1675           * Name: NvInternalDefragmentedCopy
   1676           * Description: Performs defragmentation and copy from the source page to 
   1677           *              the destination one
   1678           * Parameter(s): [IN] srcMetaAddr - source page meta address
   1679           *               [IN] pSrcMetaInf - pointer to source page meta information
   1680           *               [IN] srcTblEntryIdx - source page table entry index
   1681           *               [IN] dstMetaAddr - destination meta address
   1682           *               [IN] dstRecordAddr - destination record address (to copy to)
   1683           * Return: the status of the operation
   1684           *****************************************************************************/
   1685          #if gNvFragmentation_Enabled_d
   1686          static NVM_Status_t NvInternalDefragmentedCopy
   1687          (
   1688            uint32_t srcMetaAddr,  
   1689            NVM_RecordMetaInfo_t* pSrcMetaInf,
   1690            uint16_t srcTblEntryIdx,
   1691            uint32_t dstMetaAddr,
   1692            uint32_t dstRecordAddr
   1693          )
   1694          { 
   1695            uint32_t metaAddress;
   1696            uint32_t tblEntryMetaAddress;
   1697            NVM_RecordMetaInfo_t dstMetaInfo;
   1698            NVM_RecordMetaInfo_t metaInfo;
   1699            uint32_t destination;
   1700            uint16_t elemSize;
   1701            uint16_t elemSizeCopy;
   1702            uint16_t innerOffset;
   1703            uint8_t misalignedBytes;                
   1704            uint16_t recordsCopiedCurrentIdx;    
   1705            uint16_t recordIdx;
   1706            bool_t recordIsCopied;
   1707            /* copy buffers */
   1708            uint8_t srcBuffer[4];
   1709            uint8_t dstBuffer[4];
   1710            /* loop control variables */
   1711            uint16_t loopIdx;    
   1712            uint8_t loopEnd;
   1713          #if gNvUseExtendedFeatureSet_d  
   1714            NVM_DataEntry_t flashDataEntry;
   1715            bool_t fillFromRAM = FALSE;
   1716          #endif /* gNvUseExtendedFeatureSet_d */
   1717            /* status variable */
   1718            NVM_Status_t status = gNVM_OK_c;
   1719          
   1720            /* search for a full table entry that owns the record */
   1721            tblEntryMetaAddress = NvGetTblEntryMetaAddrFromId(srcMetaAddr, pSrcMetaInf->fields.NvmDataEntryID);
   1722          
   1723            if(tblEntryMetaAddress != 0)
   1724            {
   1725              /* found it */                
   1726              metaAddress = srcMetaAddr;        
   1727          
   1728              /* reset the copied records index */
   1729              recordsCopiedCurrentIdx = 0;
   1730          
   1731              /* clear the records copied buffer */
   1732              for(loopIdx = 0; loopIdx < (uint8_t)gNvRecordsCopiedBufferSize_c; loopIdx++)
   1733              {            
   1734                maNvRecordsCpyIdx[loopIdx] = (uint16_t)gNvInvalidElementIndex_c;        
   1735              }
   1736          
   1737              while(metaAddress > tblEntryMetaAddress)
   1738              {                    
   1739                /* get meta information */
   1740                NvGetMetaInfo(mNvActivePageId, metaAddress, &metaInfo);
   1741          
   1742                /* skip invalid entries and full table records */
   1743                if((metaInfo.fields.NvValidationStartByte != metaInfo.fields.NvValidationEndByte) || 
   1744                    (metaInfo.fields.NvValidationStartByte != gValidationByteSingleRecord_c))
   1745                {
   1746                  metaAddress -= sizeof(NVM_RecordMetaInfo_t);
   1747                  continue;
   1748                }                        
   1749          
   1750                if(metaInfo.fields.NvmDataEntryID == pSrcMetaInf->fields.NvmDataEntryID) /* found it */
   1751                {   
   1752                  /* check if record is already copied */
   1753                  recordIsCopied = FALSE;
   1754          
   1755                  for(loopIdx = 0; loopIdx < (uint16_t)gNvRecordsCopiedBufferSize_c; loopIdx++)
   1756                  {
   1757                    if(metaInfo.fields.NvmElementIndex == maNvRecordsCpyIdx[loopIdx])
   1758                    {
   1759                      recordIsCopied = TRUE;
   1760                      break;
   1761                    }                
   1762                  }                                
   1763                  if(recordIsCopied)
   1764                  {
   1765                    /* skip elements already copied */
   1766                    metaAddress -= sizeof(NVM_RecordMetaInfo_t);                    
   1767                    continue;
   1768                  }                
   1769          
   1770                  /* check if the element still belongs to an valid RAM table entry */
   1771                  if(metaInfo.fields.NvmElementIndex >= pNVM_DataTable[srcTblEntryIdx].ElementsCount)
   1772                  {
   1773                    /* the FLASH element is no longer a current RAM table entry element */
   1774                    metaAddress -= sizeof(NVM_RecordMetaInfo_t);
   1775                    continue;
   1776                  }
   1777          
   1778                  /* get element size */
   1779                  elemSize = pNVM_DataTable[srcTblEntryIdx].ElementSize;
   1780          
   1781                  /* make a copy not to alter the original value and compute destination address where the element will be written */
   1782                  destination = dstRecordAddr + (metaInfo.fields.NvmElementIndex * elemSize);
   1783          
   1784                  /* check alignment and adjust it if necessary */                            
   1785                  misalignedBytes = destination - (destination & (~0x03uL));                            
   1786          
   1787                  /* check if the destination is longword aligned or not */
   1788                  if(misalignedBytes)
   1789                  {
   1790                    /* align to previous 32 bit boundary */
   1791                    destination &= ~0x03uL;                    
   1792                  }
   1793          
   1794                  innerOffset = 0;
   1795                  
   1796                  /* compute the loop end */
   1797                  if(elemSize < (4-misalignedBytes))
   1798                  {
   1799                    loopEnd = elemSize; 
   1800                  }
   1801                  else
   1802                  {
   1803                    loopEnd = 4 - misalignedBytes;
   1804                  }
   1805          
   1806                  while(elemSize)
   1807                  {
   1808                    /* read (destination) */
   1809                    NV_FlashRead(destination, (uint8_t*)&dstBuffer[0], 4);
   1810          
   1811                    /* read (source) */
   1812                    NV_FlashRead(mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + metaInfo.fields.NvmRecordOffset + innerOffset, 
   1813                  		  (uint8_t*)&srcBuffer[0], loopEnd);
   1814          
   1815                    /* modify */
   1816                    for(loopIdx = 0; loopIdx < loopEnd; loopIdx++, misalignedBytes++)
   1817                    {
   1818                      dstBuffer[misalignedBytes] = srcBuffer[loopIdx];
   1819                    }
   1820          
   1821                    /* write (destination) */
   1822                    if(gNV_OK_c == NV_FlashProgramLongword(&mNvConfig, destination, 4, (uint32_t)(&dstBuffer[0])))
   1823                    {                    
   1824                      elemSize -= loopEnd;
   1825                      innerOffset += loopEnd;
   1826                      destination += 4;
   1827                      misalignedBytes = 0;        	
   1828                      if(elemSize >= 4)
   1829                      {
   1830                        loopEnd = 4;                                    		
   1831                      }
   1832                      else
   1833                      {
   1834                        loopEnd = elemSize;
   1835                      }
   1836                    }
   1837                    else
   1838                    {
   1839                  	return gNVM_RecordWriteError_c; 
   1840                    }
   1841                  }
   1842          
   1843                  /* save the copied record offset */
   1844                  maNvRecordsCpyIdx[recordsCopiedCurrentIdx] = metaInfo.fields.NvmElementIndex;
   1845                  /* increment (and wrap if necessary) the index */
   1846                  recordsCopiedCurrentIdx = (recordsCopiedCurrentIdx + 1) & ((unsigned char) (gNvRecordsCopiedBufferSize_c - 1));                        
   1847                }
   1848          
   1849                /* continue searching */
   1850                metaAddress -= sizeof(NVM_RecordMetaInfo_t);            
   1851              }
   1852          
   1853              /* 
   1854               * now copy the elements from table entry, except the one already copied from single records 
   1855               */
   1856          
   1857              NvGetMetaInfo(mNvActivePageId, tblEntryMetaAddress, &metaInfo);
   1858              
   1859          #if gNvUseExtendedFeatureSet_d    
   1860          
   1861              fillFromRAM = FALSE;
   1862          
   1863              if(mNvTableUpdated) /* RAM table was updated */
   1864              {                           
   1865                if(NvGetTableEntry(pNVM_DataTable[srcTblEntryIdx].DataEntryID, &flashDataEntry))
   1866                {
   1867                  if(pNVM_DataTable[srcTblEntryIdx].ElementsCount > flashDataEntry.ElementsCount)
   1868                  {
   1869                    /* fill the FLASH destination page with the default RAM value for the missing element(s) */                 
   1870                    fillFromRAM = TRUE;
   1871                  }
   1872                }
   1873              }
   1874          #endif /* gNvUseExtendedFeatureSet_d */
   1875          
   1876              for(recordIdx = 0; recordIdx < pNVM_DataTable[srcTblEntryIdx].ElementsCount; recordIdx++)
   1877              {
   1878          #if gNvUseExtendedFeatureSet_d    	
   1879                if(mNvTableUpdated)
   1880                {
   1881                  if(recordIdx >= flashDataEntry.ElementsCount)
   1882                    break;
   1883                }
   1884          #endif
   1885          
   1886                recordIsCopied = FALSE;
   1887          
   1888                for(loopIdx = 0; loopIdx < (uint16_t)gNvRecordsCopiedBufferSize_c; loopIdx++)
   1889                {
   1890                  if(recordIdx == maNvRecordsCpyIdx[loopIdx])
   1891                  {
   1892                    recordIsCopied = TRUE;
   1893                    break;
   1894                  }        
   1895                }
   1896                if(recordIsCopied)
   1897                {
   1898                  /* skip already copied elements */
   1899                  continue;
   1900                }                        
   1901          
   1902                /* 
   1903                 * copy the element 
   1904                 */
   1905          
   1906                 /* refresh the element size */
   1907                 elemSizeCopy = elemSize = pNVM_DataTable[srcTblEntryIdx].ElementSize;
   1908                 /* make a copy not to alter the original value and compute destination address where the element will be written */
   1909                 destination = dstRecordAddr + (recordIdx * elemSize);
   1910                 /* check alignment and adjust it if necessary */                            
   1911                 misalignedBytes = destination - (destination & (~0x03uL));                            
   1912                 /* check if the destination is longword aligned or not */
   1913                 if(misalignedBytes)
   1914                 {
   1915                   /* align to previous 32 bit boundary */
   1916                   destination &= ~0x03uL;              
   1917                 }
   1918          
   1919                 innerOffset = 0;
   1920                 
   1921                 /* compute the loop end */
   1922                 if(elemSizeCopy < (4-misalignedBytes))
   1923                 {
   1924                   loopEnd = elemSizeCopy; 
   1925                 }
   1926                 else
   1927                 {
   1928                   loopEnd = 4 - misalignedBytes;
   1929                 }
   1930          
   1931                 while(elemSizeCopy)
   1932                 {
   1933                   /* read (destination) */
   1934                   NV_FlashRead(destination, (uint8_t*)&dstBuffer[0], 4);
   1935          
   1936                   /* read (FLASH source) */
   1937                   NV_FlashRead(mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + metaInfo.fields.NvmRecordOffset + 
   1938                  		 (recordIdx * elemSize) + innerOffset, (uint8_t*)&srcBuffer[0], loopEnd);                                     
   1939          
   1940                   /* modify */
   1941                   for(loopIdx = 0; loopIdx < loopEnd; loopIdx++, misalignedBytes++)
   1942                   {
   1943                     dstBuffer[misalignedBytes] = srcBuffer[loopIdx];
   1944                   }
   1945          
   1946                   /* write (destination) */
   1947                   if(gNV_OK_c == NV_FlashProgramLongword(&mNvConfig, destination, 4, (uint32_t)(&dstBuffer[0])))
   1948                   {                    
   1949                     elemSizeCopy -= loopEnd;
   1950                     innerOffset += loopEnd;
   1951                     destination += 4;
   1952                     misalignedBytes = 0;
   1953                     if(elemSizeCopy >= 4)
   1954                     {
   1955                       loopEnd = 4;                                    		
   1956                     }
   1957                     else
   1958                     {
   1959                       loopEnd = elemSizeCopy;
   1960                     }
   1961                   }
   1962                   else
   1963                   {
   1964                     return gNVM_RecordWriteError_c;         
   1965                   }
   1966                 }
   1967          
   1968                 /* save the copied record offset */
   1969                 maNvRecordsCpyIdx[recordsCopiedCurrentIdx] = recordIdx;
   1970                 /* increment (and wrap if necessary) the index */
   1971                 recordsCopiedCurrentIdx = (recordsCopiedCurrentIdx + 1) & ((unsigned char) (gNvRecordsCopiedBufferSize_c - 1));
   1972              }
   1973          
   1974          #if gNvUseExtendedFeatureSet_d    
   1975              /* append the elements that were not previously stored in FLASH memory, if any */
   1976              if(fillFromRAM)
   1977              {
   1978                for(; recordIdx < pNVM_DataTable[srcTblEntryIdx].ElementsCount; recordIdx++)
   1979                {           
   1980                  /* refresh the element size */
   1981                  elemSizeCopy = elemSize = pNVM_DataTable[srcTblEntryIdx].ElementSize;
   1982                  
   1983                  /* make a copy not to alter the original value and compute destination address where the element will be written */
   1984                  destination = dstRecordAddr + (recordIdx * elemSize);
   1985          
   1986                  /* check alignment and adjust it, if necessary */                            
   1987                  misalignedBytes = destination - (destination & (~0x03uL));                            
   1988          
   1989                  /* check if the destination is longword aligned or not */
   1990                  if(misalignedBytes)
   1991                  {
   1992                    /* align to previous 32 bit boundary */
   1993                    destination &= ~0x03uL;             
   1994                  }
   1995          
   1996                  innerOffset = 0;
   1997                  
   1998                  /* compute the loop end */
   1999                  if(elemSizeCopy < (4-misalignedBytes))
   2000                  {
   2001                    loopEnd = elemSizeCopy; 
   2002                  }
   2003                  else
   2004                  {
   2005                    loopEnd = 4 - misalignedBytes;
   2006                  }
   2007          
   2008                  while(elemSizeCopy)
   2009                  {
   2010                    /* read (destination) */
   2011                    NV_FlashRead(destination, (uint8_t*)&dstBuffer[0], 4);
   2012          
   2013                    /* read (RAM source) */
   2014                    NV_FlashRead((uint32_t)((uint8_t*)pNVM_DataTable[srcTblEntryIdx].pData + (recordIdx * elemSize) + innerOffset), 
   2015                  			(uint8_t*)&srcBuffer[0], loopEnd);
   2016          
   2017                    /* modify */
   2018                    for(loopIdx = 0; loopIdx < loopEnd; loopIdx++, misalignedBytes++)
   2019                    {
   2020                      dstBuffer[misalignedBytes] = srcBuffer[loopIdx];
   2021                    }
   2022          
   2023                    /* write (destination) */
   2024                    if(gNV_OK_c == NV_FlashProgramLongword(&mNvConfig, destination, 4, (uint32_t)(&dstBuffer[0])))
   2025                    {                    
   2026                      elemSizeCopy -= loopEnd;
   2027                      innerOffset += loopEnd;
   2028                      destination += 4;
   2029                      misalignedBytes = 0;
   2030                      if(elemSizeCopy >= 4)
   2031                      {
   2032                        loopEnd = 4;                                    		
   2033                      }
   2034                      else
   2035                      {
   2036                        loopEnd = elemSizeCopy;
   2037                      }
   2038                    }
   2039                    else
   2040                    {
   2041                      return gNVM_RecordWriteError_c;                      
   2042                    }
   2043                  }
   2044                  /* save the copied record offset */
   2045                  maNvRecordsCpyIdx[recordsCopiedCurrentIdx] = recordIdx;
   2046                  /* increment (and wrap if necessary) the index */
   2047                  recordsCopiedCurrentIdx = (recordsCopiedCurrentIdx + 1) & ((unsigned char) (gNvRecordsCopiedBufferSize_c - 1));
   2048                }
   2049              }
   2050          #endif /* gNvUseExtendedFeatureSet_d */    
   2051              
   2052              /* write meta information tag */
   2053              dstMetaInfo.fields.NvValidationStartByte = gValidationByteAllRecords_c;
   2054              dstMetaInfo.fields.NvmDataEntryID = pSrcMetaInf->fields.NvmDataEntryID;
   2055              dstMetaInfo.fields.NvmElementIndex = 0;
   2056              dstMetaInfo.fields.NvmRecordOffset = dstRecordAddr - mNvVirtualPageProperty[(mNvActivePageId+1)%2].NvRawSectorStartAddress;
   2057              dstMetaInfo.fields.NvValidationEndByte = gValidationByteAllRecords_c;
   2058          
   2059              /* write the associated record meta information */                
   2060              if(gNV_OK_c != NV_FlashProgramLongword(&mNvConfig, dstMetaAddr, sizeof(NVM_RecordMetaInfo_t), (uint32_t)(&dstMetaInfo)))
   2061              {
   2062                return gNVM_MetaInfoWriteError_c;                    
   2063              }
   2064            }
   2065            else
   2066            {
   2067              /* an entire table entry was not found, so copy the record as it is */
   2068              if((status = NvInternalCopy(dstRecordAddr, dstMetaAddr, pSrcMetaInf, srcTblEntryIdx, pNVM_DataTable[srcTblEntryIdx].ElementSize)) != gNVM_OK_c)
   2069              {
   2070                return status;
   2071              }
   2072            }
   2073            return status;
   2074          }
   2075          #endif /* gNvFragmentation_Enabled_d */
   2076          
   2077          /******************************************************************************
   2078           * Name: NvCopyPage
   2079           * Description: Copy the active page content to the mirror page. Only the 
   2080           *              latest table entries / elements are copied. A merge operation
   2081           *              is performed before copy if an entry has single elements 
   2082           *              saved priori and newer than the table entry. If one or more
   2083           *              elements were singular saved and the NV page doesn't has a
   2084           *              full table entry saved, then the elements are copied as they
   2085           *              are.  
   2086           * Parameter(s): [IN] skipEntryId - the entry ID to be skipped when page
   2087           *                                  copy is performed
   2088           * Return: gNVM_InvalidPageID_c - if the source or destination page is not 
   2089           *                                valid
   2090           *         gNVM_MetaInfoWriteError_c - if the meta information couldn't be 
   2091           *                                     written
   2092           *         gNVM_RecordWriteError_c - if the record couldn't be written
   2093           *         gNVM_Error_c - in case of error(s)
   2094           *         gNVM_OK_c - page copy completed successfully
   2095           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2096          static NVM_Status_t NvCopyPage
   2097          (    
   2098          #if gNvUseExtendedFeatureSet_d		
   2099            NvTableEntryId_t skipEntryId
   2100          #else
   2101            void
   2102          #endif
   2103          )
   2104          {
   \                     NvCopyPage: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   2105            /* source page related variables */
   2106            uint32_t srcMetaAddress;
   2107            NVM_RecordMetaInfo_t srcMetaInfo;
   2108            uint16_t srcTableEntryIdx;
   2109          
   2110            /* destination page related variables */    
   2111            uint32_t dstMetaAddress;    
   2112            NVM_VirtualPageID_t dstPageId;
   2113            uint32_t dstRecordAddress;
   2114          
   2115          #if gNvUseExtendedFeatureSet_d
   2116            uint16_t idx;  
   2117            bool_t entryFound;
   2118            NVM_DataEntry_t flashDataEntry;
   2119          #endif /* gNvUseExtendedFeatureSet_d */  
   2120            uint32_t bytesToCopy;
   2121          
   2122            /* status variable */
   2123            NVM_Status_t status;
   2124          
   2125            dstPageId = (NVM_VirtualPageID_t)((mNvActivePageId+1)%2);
   \   00000004   0x....             LDR.N    R0,??DataTable13_2
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   \   0000000A   0x2102             MOVS     R1,#+2
   \   0000000C   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   00000010   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   00000014   0x0017             MOVS     R7,R2
   2126          
   2127            /* Check if the destination page is blank. If not, erase it. */
   2128            if(gNVM_PageIsNotBlank_c == NvVirtualPageBlankCheck(dstPageId))
   \   00000016   0x0038             MOVS     R0,R7
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x.... 0x....      BL       NvVirtualPageBlankCheck
   \   0000001E   0x2803             CMP      R0,#+3
   \   00000020   0xD10C             BNE.N    ??NvCopyPage_0
   2129            {
   2130              status = NvEraseVirtualPage(dstPageId);
   \   00000022   0x0038             MOVS     R0,R7
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x.... 0x....      BL       NvEraseVirtualPage
   \   0000002A   0x4682             MOV      R10,R0
   2131              if(gNVM_OK_c != status)
   \   0000002C   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000030   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000034   0xD002             BEQ.N    ??NvCopyPage_0
   2132              {
   2133                return status;        
   \   00000036   0x4650             MOV      R0,R10
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0xE0A2             B.N      ??NvCopyPage_1
   2134              }
   2135            }
   2136            
   2137          #if gNvUseExtendedFeatureSet_d
   2138            /* save the current RAM table */
   2139            NvSaveRamTable(dstPageId);
   2140          #endif
   2141          
   2142            /* start with the source page last record */
   2143            srcMetaAddress = mNvVirtualPageProperty[mNvActivePageId].NvLastMetaInfoAddress;
   \                     ??NvCopyPage_0: (+1)
   \   0000003C   0x....             LDR.N    R0,??DataTable13
   \   0000003E   0x....             LDR.N    R1,??DataTable13_2
   \   00000040   0x7809             LDRB     R1,[R1, #+0]
   \   00000042   0x2214             MOVS     R2,#+20
   \   00000044   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000048   0x6900             LDR      R0,[R0, #+16]
   \   0000004A   0x0004             MOVS     R4,R0
   2144            /* initialise the destination page meta info start address */
   2145          #if gNvUseExtendedFeatureSet_d  
   2146            dstMetaAddress = mNvVirtualPageProperty[dstPageId].NvRawSectorStartAddress + sizeof(mNvPageCounter) +
   2147                (mNvTableSizeInRAM + (2 * sizeof(mNvTableMarker)));
   2148          #else
   2149            dstMetaAddress = mNvVirtualPageProperty[dstPageId].NvRawSectorStartAddress + sizeof(mNvPageCounter);
   \   0000004C   0x....             LDR.N    R0,??DataTable13
   \   0000004E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000050   0x2114             MOVS     R1,#+20
   \   00000052   0xFB01 0x0007      MLA      R0,R1,R7,R0
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x1D00             ADDS     R0,R0,#+4
   \   0000005A   0x0006             MOVS     R6,R0
   2150          #endif /* gNvUseExtendedFeatureSet_d*/  
   2151            /* initialise the destination page record start address */
   2152            dstRecordAddress = mNvVirtualPageProperty[dstPageId].NvRawSectorEndAddress - sizeof(mNvPageCounter) + 1;
   \   0000005C   0x....             LDR.N    R0,??DataTable13
   \   0000005E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000060   0x2114             MOVS     R1,#+20
   \   00000062   0xFB01 0x0007      MLA      R0,R1,R7,R0
   \   00000066   0x6840             LDR      R0,[R0, #+4]
   \   00000068   0x1EC0             SUBS     R0,R0,#+3
   \   0000006A   0x4680             MOV      R8,R0
   2153          
   2154            while(srcMetaAddress >= (mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + sizeof(mNvPageCounter))
   2155          #if gNvUseExtendedFeatureSet_d		  
   2156          		  + (mNvTableSizeInFlash + (2 * sizeof(mNvTableMarker)))
   2157          #endif 
   2158                 )
   \                     ??NvCopyPage_2: (+1)
   \   0000006C   0x....             LDR.N    R0,??DataTable13
   \   0000006E   0x....             LDR.N    R1,??DataTable13_2
   \   00000070   0x7809             LDRB     R1,[R1, #+0]
   \   00000072   0x2214             MOVS     R2,#+20
   \   00000074   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x1D00             ADDS     R0,R0,#+4
   \   0000007C   0x4284             CMP      R4,R0
   \   0000007E   0xD356             BCC.N    ??NvCopyPage_3
   2159            {
   2160              /* get current meta information */
   2161              (void)NvGetMetaInfo(mNvActivePageId, srcMetaAddress, &srcMetaInfo);
   \   00000080   0xAA01             ADD      R2,SP,#+4
   \   00000082   0x0021             MOVS     R1,R4
   \   00000084   0x....             LDR.N    R0,??DataTable13_2
   \   00000086   0x7800             LDRB     R0,[R0, #+0]
   \   00000088   0x.... 0x....      BL       NvGetMetaInfo
   \   0000008C   0x4683             MOV      R11,R0
   2162          
   2163          #if gNvUseExtendedFeatureSet_d    
   2164              /* NV RAM table has been updated */
   2165              if(mNvTableUpdated)
   2166              {
   2167                idx = 0;
   2168                entryFound = FALSE;
   2169          
   2170                /* check if the saved entry is still present in the new RAM table */
   2171                while(gNvEndOfTableId_c != pNVM_DataTable[idx].DataEntryID)
   2172                {
   2173                  if(srcMetaInfo.fields.NvmDataEntryID == pNVM_DataTable[idx].DataEntryID)
   2174                  {
   2175                    entryFound = TRUE;
   2176                    break;
   2177                  }
   2178                  idx++;
   2179                }
   2180          
   2181                if(!entryFound)
   2182                {
   2183                  /* move to the next meta info */
   2184                  srcMetaAddress -= sizeof(NVM_RecordMetaInfo_t);
   2185                  continue;
   2186                }
   2187              }
   2188          #endif /* gNvUseExtendedFeatureSet_d */
   2189          
   2190              /* get table entry index */
   2191              srcTableEntryIdx = NvGetTableEntryIndexFromId(srcMetaInfo.fields.NvmDataEntryID);
   \   0000008E   0xF8BD 0x0005      LDRH     R0,[SP, #+5]
   \   00000092   0x.... 0x....      BL       NvGetTableEntryIndexFromId
   \   00000096   0x0005             MOVS     R5,R0
   2192          
   2193              if((srcMetaInfo.fields.NvValidationStartByte != srcMetaInfo.fields.NvValidationEndByte) ||
   2194                  (srcTableEntryIdx == gNvInvalidDataEntry_c) ||
   2195          #if gNvUseExtendedFeatureSet_d
   2196                  (srcTableEntryIdx == skipEntryId) || 
   2197          #endif /* #if gNvUseExtendedFeatureSet_d */
   2198                  NvIsRecordCopied(dstPageId, &srcMetaInfo)
   2199              )
   \   00000098   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000009C   0xF89D 0x100B      LDRB     R1,[SP, #+11]
   \   000000A0   0x4288             CMP      R0,R1
   \   000000A2   0xD10B             BNE.N    ??NvCopyPage_4
   \   000000A4   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000A6   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000AA   0x4285             CMP      R5,R0
   \   000000AC   0xD006             BEQ.N    ??NvCopyPage_4
   \   000000AE   0xA901             ADD      R1,SP,#+4
   \   000000B0   0x0038             MOVS     R0,R7
   \   000000B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B4   0x.... 0x....      BL       NvIsRecordCopied
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD001             BEQ.N    ??NvCopyPage_5
   2200              {
   2201                /* go to the next meta information tag */
   2202                srcMetaAddress -= sizeof(NVM_RecordMetaInfo_t);
   \                     ??NvCopyPage_4: (+1)
   \   000000BC   0x3C08             SUBS     R4,R4,#+8
   2203                continue;
   \   000000BE   0xE7D5             B.N      ??NvCopyPage_2
   2204              }
   2205          
   2206              if((srcMetaInfo.fields.NvValidationStartByte != gValidationByteSingleRecord_c) && 
   2207                  (srcMetaInfo.fields.NvValidationStartByte != gValidationByteAllRecords_c))
   \                     ??NvCopyPage_5: (+1)
   \   000000C0   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000C4   0x28AA             CMP      R0,#+170
   \   000000C6   0xD005             BEQ.N    ??NvCopyPage_6
   \   000000C8   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000CC   0x2855             CMP      R0,#+85
   \   000000CE   0xD001             BEQ.N    ??NvCopyPage_6
   2208              {
   2209                /* go to the next meta information tag */
   2210                srcMetaAddress -= sizeof(NVM_RecordMetaInfo_t);
   \   000000D0   0x3C08             SUBS     R4,R4,#+8
   2211                continue;
   \   000000D2   0xE7CB             B.N      ??NvCopyPage_2
   2212              }
   2213          
   2214              /* compute the destination record start address */
   2215              dstRecordAddress -= NvGetRecordFullSize(srcTableEntryIdx);
   \                     ??NvCopyPage_6: (+1)
   \   000000D4   0x0028             MOVS     R0,R5
   \   000000D6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000D8   0x.... 0x....      BL       NvGetRecordFullSize
   \   000000DC   0xEBB8 0x0000      SUBS     R0,R8,R0
   \   000000E0   0x4680             MOV      R8,R0
   2216          
   2217              bytesToCopy = pNVM_DataTable[srcTableEntryIdx].ElementsCount * pNVM_DataTable[srcTableEntryIdx].ElementSize;
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000E6   0x6800             LDR      R0,[R0, #+0]
   \   000000E8   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000EA   0x210C             MOVS     R1,#+12
   \   000000EC   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   000000F0   0x8880             LDRH     R0,[R0, #+4]
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable16
   \   000000F6   0x6809             LDR      R1,[R1, #+0]
   \   000000F8   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000FA   0x220C             MOVS     R2,#+12
   \   000000FC   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000100   0x88C9             LDRH     R1,[R1, #+6]
   \   00000102   0x4348             MULS     R0,R1,R0
   \   00000104   0x4681             MOV      R9,R0
   2218          
   2219          #if gNvUseExtendedFeatureSet_d    
   2220              /* NV RAM table has been updated */
   2221              if(mNvTableUpdated)
   2222              {
   2223                if(NvGetTableEntry(pNVM_DataTable[srcTableEntryIdx].DataEntryID, &flashDataEntry))
   2224                {
   2225                  if(flashDataEntry.ElementSize != pNVM_DataTable[srcTableEntryIdx].ElementSize)
   2226                  {
   2227                    /* copying table entries with modified element size is not supported */
   2228                    return gNVM_NvTableWrongElementSize_c;
   2229                  }
   2230          
   2231                  if(flashDataEntry.ElementsCount < pNVM_DataTable[srcTableEntryIdx].ElementsCount)
   2232                  {
   2233                    /* copy only the bytes that were previously written to FLASH virtual page */
   2234                    bytesToCopy = flashDataEntry.ElementsCount * flashDataEntry.ElementSize;              
   2235                  }
   2236                }
   2237              }
   2238          #endif /* gNvUseExtendedFeatureSet_d */
   2239          
   2240          #if gNvFragmentation_Enabled_d    
   2241              /* 
   2242               * full table entry
   2243               */        
   2244              if(srcMetaInfo.fields.NvValidationStartByte == gValidationByteAllRecords_c)
   2245              {               
   2246                if((status = NvInternalCopy(dstRecordAddress, dstMetaAddress, &srcMetaInfo, srcTableEntryIdx, bytesToCopy)) != gNVM_OK_c)
   2247                {
   2248                  return status;
   2249                }
   2250              }
   2251              else
   2252              {
   2253                /* 
   2254                 * single element record
   2255                 */        
   2256                 if((status = NvInternalDefragmentedCopy(srcMetaAddress, &srcMetaInfo, srcTableEntryIdx, dstMetaAddress, dstRecordAddress)) != gNVM_OK_c)
   2257                 {
   2258                   return status;
   2259                 }            
   2260              }
   2261          #else
   2262              if((status = NvInternalCopy(dstRecordAddress, dstMetaAddress, &srcMetaInfo, srcTableEntryIdx, bytesToCopy)) != gNVM_OK_c)
   \   00000106   0x4648             MOV      R0,R9
   \   00000108   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000010A   0x9000             STR      R0,[SP, #+0]
   \   0000010C   0x002B             MOVS     R3,R5
   \   0000010E   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000110   0xAA01             ADD      R2,SP,#+4
   \   00000112   0x0031             MOVS     R1,R6
   \   00000114   0x4640             MOV      R0,R8
   \   00000116   0x.... 0x....      BL       NvInternalCopy
   \   0000011A   0x4682             MOV      R10,R0
   \   0000011C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011E   0x2800             CMP      R0,#+0
   \   00000120   0xD002             BEQ.N    ??NvCopyPage_7
   2263              {
   2264                return status;
   \   00000122   0x4650             MOV      R0,R10
   \   00000124   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000126   0xE02C             B.N      ??NvCopyPage_1
   2265              }
   2266          #endif /* gNvFragmentation_Enabled_d */
   2267          
   2268              /* update destination meta information address */
   2269              dstMetaAddress += sizeof(NVM_RecordMetaInfo_t);
   \                     ??NvCopyPage_7: (+1)
   \   00000128   0x3608             ADDS     R6,R6,#+8
   2270          
   2271              /* move to the next meta info */
   2272              srcMetaAddress -= sizeof(NVM_RecordMetaInfo_t);        
   \   0000012A   0x3C08             SUBS     R4,R4,#+8
   \   0000012C   0xE79E             B.N      ??NvCopyPage_2
   2273            };
   2274          
   2275            /* make a request to erase the old page */
   2276            mNvErasePgCmdStatus.NvPageToErase = mNvActivePageId;
   \                     ??NvCopyPage_3: (+1)
   \   0000012E   0x....             LDR.N    R0,??DataTable13_2
   \   00000130   0x7800             LDRB     R0,[R0, #+0]
   \   00000132   0x....             LDR.N    R1,??DataTable13_4
   \   00000134   0x7048             STRB     R0,[R1, #+1]
   2277            mNvErasePgCmdStatus.NvSectorAddress = mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress;
   \   00000136   0x....             LDR.N    R0,??DataTable13
   \   00000138   0x....             LDR.N    R1,??DataTable13_2
   \   0000013A   0x7809             LDRB     R1,[R1, #+0]
   \   0000013C   0x2214             MOVS     R2,#+20
   \   0000013E   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000142   0x6800             LDR      R0,[R0, #+0]
   \   00000144   0x....             LDR.N    R1,??DataTable13_4
   \   00000146   0x6048             STR      R0,[R1, #+4]
   2278            mNvErasePgCmdStatus.NvErasePending = TRUE;
   \   00000148   0x2001             MOVS     R0,#+1
   \   0000014A   0x....             LDR.N    R1,??DataTable13_4
   \   0000014C   0x7008             STRB     R0,[R1, #+0]
   2279          
   2280            /* update the the active page ID */
   2281            mNvActivePageId = dstPageId;
   \   0000014E   0x....             LDR.N    R0,??DataTable13_2
   \   00000150   0x7007             STRB     R7,[R0, #+0]
   2282          
   2283            /* update the last meta info address */
   2284            mNvVirtualPageProperty[mNvActivePageId].NvLastMetaInfoAddress = dstMetaAddress - sizeof(NVM_RecordMetaInfo_t);
   \   00000152   0xF1B6 0x0008      SUBS     R0,R6,#+8
   \   00000156   0x....             LDR.N    R1,??DataTable13
   \   00000158   0x....             LDR.N    R2,??DataTable13_2
   \   0000015A   0x7812             LDRB     R2,[R2, #+0]
   \   0000015C   0x2314             MOVS     R3,#+20
   \   0000015E   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000162   0x6108             STR      R0,[R1, #+16]
   2285          
   2286            /* write the page counter */
   2287            if(gNVM_OK_c == NvWritePageCounter(mNvActivePageId, (mNvPageCounter + 1)))
   \   00000164   0x....             LDR.N    R0,??DataTable13_3
   \   00000166   0x6800             LDR      R0,[R0, #+0]
   \   00000168   0x1C41             ADDS     R1,R0,#+1
   \   0000016A   0x....             LDR.N    R0,??DataTable13_2
   \   0000016C   0x7800             LDRB     R0,[R0, #+0]
   \   0000016E   0x.... 0x....      BL       NvWritePageCounter
   \   00000172   0x2800             CMP      R0,#+0
   \   00000174   0xD104             BNE.N    ??NvCopyPage_8
   2288            {
   2289              mNvPageCounter++;
   \   00000176   0x....             LDR.N    R0,??DataTable13_3
   \   00000178   0x6800             LDR      R0,[R0, #+0]
   \   0000017A   0x1C40             ADDS     R0,R0,#+1
   \   0000017C   0x....             LDR.N    R1,??DataTable13_3
   \   0000017E   0x6008             STR      R0,[R1, #+0]
   2290            }
   2291          
   2292          #if gNvUseExtendedFeatureSet_d  
   2293            if(mNvTableUpdated)
   2294            {
   2295              /* update the size of the NV table stored in FLASH */
   2296              mNvTableSizeInFlash = NvGetTableSize(gFLASHTable_c);
   2297          
   2298              /* clear the flag */
   2299              mNvTableUpdated = FALSE;
   2300            }
   2301          #endif /* gNvUseExtendedFeatureSet_d */
   2302          
   2303            return gNVM_OK_c;
   \                     ??NvCopyPage_8: (+1)
   \   00000180   0x2000             MOVS     R0,#+0
   \                     ??NvCopyPage_1: (+1)
   \   00000182   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   2304          }
   2305          
   2306          
   2307          /******************************************************************************
   2308           * Name: NvWritePageCounter
   2309           * Description: Write the page counter value              
   2310           * Parameter(s): [IN] pageId - the ID of the page 
   2311           *               [IN] value - the page counter value that will written to 
   2312           *                            the specified page
   2313           *               
   2314           * Return: gNVM_OK_c - if the operation completes successfully
   2315           *         gNVM_Error_c - if the format operation fails
   2316           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2317          static NVM_Status_t NvWritePageCounter
   2318          (
   2319            NVM_VirtualPageID_t pageId,
   2320            uint32_t value    
   2321          )
   2322          {
   \                     NvWritePageCounter: (+1)
   \   00000000   0xB513             PUSH     {R0,R1,R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2323            /* write page counter on page top and page bottom */
   2324            if(gNV_OK_c == NV_FlashProgramLongword(&mNvConfig, mNvVirtualPageProperty[pageId].NvRawSectorStartAddress, 
   2325                sizeof(value), (uint32_t)&value))
   \   00000004   0xAB01             ADD      R3,SP,#+4
   \   00000006   0x2204             MOVS     R2,#+4
   \   00000008   0x....             LDR.N    R0,??DataTable13
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2114             MOVS     R1,#+20
   \   0000000E   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x....             LDR.N    R0,??DataTable13_1
   \   00000016   0x.... 0x....      BL       NV_FlashProgramLongword
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD111             BNE.N    ??NvWritePageCounter_0
   2326            {            
   2327              if(gNV_OK_c == NV_FlashProgramLongword(&mNvConfig, (mNvVirtualPageProperty[pageId].NvRawSectorEndAddress - sizeof(value)), 
   2328                  sizeof(value), (uint32_t)&value))
   \   0000001E   0xAB01             ADD      R3,SP,#+4
   \   00000020   0x2204             MOVS     R2,#+4
   \   00000022   0x....             LDR.N    R0,??DataTable13
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x2114             MOVS     R1,#+20
   \   00000028   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000002C   0x6840             LDR      R0,[R0, #+4]
   \   0000002E   0x1F01             SUBS     R1,R0,#+4
   \   00000030   0x....             LDR.N    R0,??DataTable13_1
   \   00000032   0x.... 0x....      BL       NV_FlashProgramLongword
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD101             BNE.N    ??NvWritePageCounter_1
   2329              {                        
   2330                return gNVM_OK_c;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE002             B.N      ??NvWritePageCounter_2
   2331              }
   2332              return gNVM_Error_c;
   \                     ??NvWritePageCounter_1: (+1)
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xE000             B.N      ??NvWritePageCounter_2
   2333            }
   2334            return gNVM_Error_c;
   \                     ??NvWritePageCounter_0: (+1)
   \   00000042   0x2001             MOVS     R0,#+1
   \                     ??NvWritePageCounter_2: (+1)
   \   00000044   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   2335          }
   2336          
   2337          
   2338          /******************************************************************************
   2339           * Name: NvInternalFormat
   2340           * Description: Format the NV storage system. The function erases in place both
   2341           *              virtual pages and then writes the page counter value to first  
   2342           *              virtual page. The provided page counter value is automatically 
   2343           *              incremented and then written to first (active) virtual page.              
   2344           * Parameter(s): [IN] pageCounterValue - the page counter value that will
   2345           *                                       be incremented and then written to
   2346           *                                       active page
   2347           * Return: gNVM_OK_c - if the operation completes successfully
   2348           *         gNVM_FormatFailure_c - if the format operation fails
   2349           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2350          static NVM_Status_t NvInternalFormat
   2351          (
   2352            uint32_t pageCounterValue
   2353          )
   2354          {    
   \                     NvInternalFormat: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2355            uint8_t retryCount = gNvFormatRetryCount_c;
   \   00000004   0x2503             MOVS     R5,#+3
   2356          
   2357            /* increment the page counter value */
   2358            if(gPageCounterMaxValue_c == pageCounterValue)
   \   00000006   0xF114 0x0F01      CMN      R4,#+1
   \   0000000A   0xD102             BNE.N    ??NvInternalFormat_0
   2359            {
   2360              pageCounterValue = 1;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x0004             MOVS     R4,R0
   \   00000010   0xE000             B.N      ??NvInternalFormat_1
   2361            }
   2362            else
   2363            {
   2364              pageCounterValue++;
   \                     ??NvInternalFormat_0: (+1)
   \   00000012   0x1C64             ADDS     R4,R4,#+1
   2365            }
   2366          
   2367            while(retryCount--)
   \                     ??NvInternalFormat_1: (+1)
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0x1E45             SUBS     R5,R0,#+1
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD019             BEQ.N    ??NvInternalFormat_2
   2368            {
   2369              /* erase first page */
   2370              (void)NV_FlashEraseSector(&mNvConfig, mNvVirtualPageProperty[gFirstVirtualPage_c].NvRawSectorStartAddress,
   2371                  mNvVirtualPageProperty[gFirstVirtualPage_c].NvTotalPageSize);
   \   0000001E   0x....             LDR.N    R0,??DataTable13
   \   00000020   0x68C2             LDR      R2,[R0, #+12]
   \   00000022   0x....             LDR.N    R0,??DataTable13
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0x....             LDR.N    R0,??DataTable13_1
   \   00000028   0x.... 0x....      BL       NV_FlashEraseSector
   \   0000002C   0x0006             MOVS     R6,R0
   2372          
   2373              /* erase the second page */
   2374              (void)NV_FlashEraseSector(&mNvConfig, mNvVirtualPageProperty[gSecondVirtualPage_c].NvRawSectorStartAddress,
   2375                  mNvVirtualPageProperty[gSecondVirtualPage_c].NvTotalPageSize);
   \   0000002E   0x....             LDR.N    R0,??DataTable13
   \   00000030   0x6A02             LDR      R2,[R0, #+32]
   \   00000032   0x....             LDR.N    R0,??DataTable13
   \   00000034   0x6941             LDR      R1,[R0, #+20]
   \   00000036   0x....             LDR.N    R0,??DataTable13_1
   \   00000038   0x.... 0x....      BL       NV_FlashEraseSector
   \   0000003C   0x0007             MOVS     R7,R0
   2376          
   2377              if( (gNVM_OK_c == NvVirtualPageBlankCheck(gFirstVirtualPage_c)) && gNVM_OK_c == NvVirtualPageBlankCheck(gSecondVirtualPage_c))
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x.... 0x....      BL       NvVirtualPageBlankCheck
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD1E5             BNE.N    ??NvInternalFormat_1
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0x.... 0x....      BL       NvVirtualPageBlankCheck
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD1E0             BNE.N    ??NvInternalFormat_1
   2378              {
   2379                break;
   2380              }
   2381            }
   2382          
   2383            /* write page counter on page top and page bottom */
   2384            if(gNV_OK_c == NvWritePageCounter(gFirstVirtualPage_c, pageCounterValue))
   \                     ??NvInternalFormat_2: (+1)
   \   00000052   0x0021             MOVS     R1,R4
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x.... 0x....      BL       NvWritePageCounter
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD106             BNE.N    ??NvInternalFormat_3
   2385            {
   2386              /* active page after format = first virtual page */
   2387              mNvActivePageId = gFirstVirtualPage_c;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x....             LDR.N    R1,??DataTable13_2
   \   00000062   0x7008             STRB     R0,[R1, #+0]
   2388          #if gNvUseExtendedFeatureSet_d    
   2389              /* save NV table from RAM memory to FLASH memory */
   2390              NvSaveRamTable(mNvActivePageId);
   2391              /* update the size of the NV table stored in FLASH */
   2392              mNvTableSizeInFlash = NvGetTableSize(gFLASHTable_c);
   2393          #endif /* gNvUseExtendedFeatureSet_d */
   2394              /* update the page counter value */
   2395              mNvPageCounter = pageCounterValue; 
   \   00000064   0x....             LDR.N    R0,??DataTable13_3
   \   00000066   0x6004             STR      R4,[R0, #+0]
   2396          
   2397              return gNVM_OK_c;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xE000             B.N      ??NvInternalFormat_4
   2398            }
   2399          
   2400            return gNVM_FormatFailure_c;
   \                     ??NvInternalFormat_3: (+1)
   \   0000006C   0x2013             MOVS     R0,#+19
   \                     ??NvInternalFormat_4: (+1)
   \   0000006E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2401          }
   2402          
   2403          
   2404          #if gNvUseExtendedFeatureSet_d
   2405          
   2406          /******************************************************************************
   2407           * Name: NvSaveRamTable
   2408           * Description: Saves the NV table
   2409           * Parameter(s): [IN] pageId - the virtual page ID where the table will be 
   2410           *                             saved 
   2411           * Return: TRUE if table saved successfully, FALSE otherwise
   2412           ******************************************************************************/
   2413          static bool_t NvSaveRamTable
   2414          (
   2415            NVM_VirtualPageID_t pageId
   2416          )
   2417          {
   2418            uint16_t idx;
   2419            uint32_t addr;
   2420            uint32_t tblQual;
   2421            uint32_t tmp;
   2422          
   2423            if(NULL == pNVM_DataTable)
   2424              return FALSE;
   2425          
   2426            /* write table qualifier start */
   2427          
   2428            tblQual = (uint32_t)gNvTableMarker_c;
   2429            addr = mNvVirtualPageProperty[pageId].NvRawSectorStartAddress
   2430                + sizeof(mNvPageCounter);
   2431          
   2432            if(gNV_OK_c != NV_FlashProgramLongword(&mNvConfig, addr, sizeof(uint32_t),
   2433                (uint32_t)(&tblQual)))
   2434            {
   2435              return FALSE;
   2436            }
   2437          
   2438            idx = 0;
   2439            addr += sizeof(tblQual);
   2440          
   2441            while(gNvEndOfTableId_c != pNVM_DataTable[idx].DataEntryID)
   2442            {
   2443              /* write data entry ID */
   2444              tmp = (pNVM_DataTable[idx].DataEntryID << 16) + 0xFFFF;
   2445              if(gNV_OK_c != NV_FlashProgramLongword(&mNvConfig, addr, sizeof(tmp), (uint32_t)(&tmp)))
   2446              {
   2447                return FALSE;
   2448              }
   2449              /* increment address */
   2450              addr += sizeof(tmp);
   2451          
   2452              /* write element count and element size */
   2453              tmp = (pNVM_DataTable[idx].ElementsCount << 16) + pNVM_DataTable[idx].ElementSize;
   2454              if(gNV_OK_c != NV_FlashProgramLongword(&mNvConfig, addr, sizeof(tmp), (uint32_t)(&tmp)))
   2455              {
   2456                return FALSE;
   2457              }
   2458              /* increment address */
   2459              addr += sizeof(tmp);
   2460          
   2461              /* increment table entry index */
   2462              idx++;
   2463            }
   2464          
   2465            /* write table qualifier end */
   2466            if(gNV_OK_c != NV_FlashProgramLongword(&mNvConfig, addr, sizeof(uint32_t),
   2467                (uint32_t)(&tblQual)))
   2468            {
   2469              return FALSE;
   2470            }
   2471            return TRUE;
   2472          }
   2473          
   2474          /******************************************************************************
   2475           * Name: NvGetTableSize
   2476           * Description: Retrieves the size of the NV table
   2477           * Parameter(s): [IN] location - specifies if the size shall be the NV FLASH 
   2478           *                               table size (gFLASHTable_c) or the NV RAM table 
   2479           *                               size (gRAMTable_c) 
   2480           * Return: the NV table size
   2481           ******************************************************************************/
   2482          static uint32_t NvGetTableSize
   2483          (
   2484            uint8_t location
   2485          )
   2486          {
   2487            uint32_t addr;
   2488            uint32_t size = 0;
   2489            uint32_t data = 0;
   2490            uint16_t idx = 0;
   2491            bool_t tblEndFound;
   2492          
   2493            tblEndFound = FALSE;
   2494          
   2495            if(gRAMTable_c == location)
   2496            {
   2497              /* compute the size of the table stored in RAM memory, except the data pointer size
   2498               * (the data pointer is not saved into Flash memory)
   2499               */
   2500              while(gNvEndOfTableId_c != pNVM_DataTable[idx].DataEntryID)
   2501              {
   2502                size += (sizeof(NVM_DataEntry_t)-sizeof(pNVM_DataTable[idx].pData));
   2503                idx++;
   2504              }
   2505            }
   2506            else
   2507            {
   2508              /* compute the size of the table stored in Flash memory */
   2509              addr = mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress
   2510                  + sizeof(mNvPageCounter);
   2511          
   2512              NV_FlashRead(addr, (uint8_t*)&data, sizeof(data));
   2513          
   2514              if(gNvTableMarker_c != data)
   2515              {
   2516                return 0;
   2517              }
   2518          
   2519              addr += sizeof(data);
   2520          
   2521              do
   2522              {
   2523                NV_FlashRead(addr, (uint8_t*)&data, sizeof(data));
   2524                if(gNvTableMarker_c == data)
   2525                {
   2526                  tblEndFound = TRUE;
   2527                  break;
   2528                }
   2529                size += sizeof(data);
   2530                addr += sizeof(data);
   2531              } while(addr < mNvVirtualPageProperty[mNvActivePageId].NvRawSectorEndAddress);
   2532          
   2533              if(tblEndFound)
   2534              {
   2535                return size;
   2536              }
   2537              return 0;
   2538            }
   2539            return size;
   2540          }
   2541          
   2542          /******************************************************************************
   2543           * Name: NvIsRamTableUpdated
   2544           * Description: Checks if the the NV table from RAM memory has changed since
   2545           *              last system reset (e.g. via an OTAP transfer)
   2546           * Parameter(s): -
   2547           * Return: TRUE if the NV RAM table has been changed / FALSE otherwise
   2548           ******************************************************************************/
   2549          static bool_t NvIsRamTableUpdated
   2550          (
   2551            void
   2552          )
   2553          {
   2554            uint16_t idx;
   2555            uint32_t data;
   2556            uint32_t addr;
   2557            uint32_t endAddr;
   2558            bool_t idFound;
   2559          
   2560            /* address = page raw sector start address + page counter size + table marker */
   2561            addr = mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress
   2562                + sizeof(mNvPageCounter) + sizeof(data);
   2563          
   2564            /* compute the search end address */
   2565            endAddr = addr + mNvTableSizeInFlash;
   2566          
   2567            do
   2568            {
   2569              /* read ID */
   2570              NV_FlashRead(addr, (uint8_t*)&data, sizeof(data));
   2571          
   2572              idFound = FALSE;    
   2573              idx = 0;
   2574          
   2575              while(gNvEndOfTableId_c != pNVM_DataTable[idx].DataEntryID)
   2576              {
   2577                if(data == ((pNVM_DataTable[idx].DataEntryID <<16) + 0xFFFF))
   2578                {
   2579                  idFound = TRUE;
   2580                  break;
   2581                }
   2582          
   2583                /* increment the index */
   2584                idx++;
   2585              }
   2586          
   2587              if(!idFound)
   2588              {
   2589                return TRUE; 
   2590              }
   2591          
   2592              /* read element count and element size */
   2593              addr += sizeof(data);
   2594              NV_FlashRead(addr, (uint8_t*)&data, sizeof(data));
   2595          
   2596              if(data != ((pNVM_DataTable[idx].ElementsCount << 16) +
   2597                  pNVM_DataTable[idx].ElementSize)) {
   2598                return TRUE;
   2599              }
   2600          
   2601              /* increment the address */
   2602              addr += sizeof(data);   
   2603          
   2604            } while(addr < endAddr);
   2605          
   2606            return FALSE;
   2607          }
   2608          
   2609          /******************************************************************************
   2610           * Name: NvGetTableEntry
   2611           * Description: get the NV table entry information stored on FLASH memory
   2612           * Parameter(s): [IN] tblEntryId - table entry ID
   2613           *               [OUT] pDataEntry - a pointer to a memory location where the 
   2614           *                                  entry information will be stored
   2615           * Return: TRUE if the has been found / FALSE otherwise
   2616           ******************************************************************************/
   2617          static bool_t NvGetTableEntry
   2618          (
   2619            uint16_t tblEntryId,
   2620            NVM_DataEntry_t* pDataEntry
   2621          )
   2622          {
   2623            uint32_t addr;
   2624            uint32_t data;  
   2625          
   2626            pDataEntry->pData = NULL; /* the data pointer is not saved on FLASH table and 
   2627             * shall not be used by the caller of this function */
   2628          
   2629            addr = mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress
   2630                + sizeof(mNvPageCounter);
   2631          
   2632            NV_FlashRead(addr, (uint8_t*)&data, sizeof(data));
   2633          
   2634            if(data != (uint32_t)gNvTableMarker_c)
   2635            {   
   2636              pDataEntry->ElementsCount = 0;
   2637              pDataEntry->ElementSize = 0;
   2638              pDataEntry->DataEntryID = gNvInvalidDataEntry_c;
   2639              return FALSE;
   2640            }
   2641          
   2642            /* increment address */
   2643            addr += sizeof(data);
   2644          
   2645            do
   2646            {
   2647              NV_FlashRead(addr, (uint8_t*)&data, sizeof(data));
   2648          
   2649              if(data == (uint32_t)gNvTableMarker_c)
   2650              {
   2651                /* reached end of table */
   2652                break; 
   2653              }
   2654          
   2655              if(((data>>16) & 0x0000FFFF) == tblEntryId)
   2656              {     
   2657                /* read the next 4 bytes to get element count and element size */
   2658                addr += sizeof(data);
   2659                NV_FlashRead(addr, (uint8_t*)&data, sizeof(data));      
   2660                pDataEntry->ElementsCount = (uint16_t)((data>>16)& 0x0000FFFF);
   2661                pDataEntry->ElementSize = (uint16_t)(data & 0x0000FFFF);
   2662                pDataEntry->DataEntryID = tblEntryId;
   2663                return TRUE;
   2664              }
   2665          
   2666              /* continue searching */
   2667              addr += (2 * sizeof(data));
   2668          
   2669            } while(addr < mNvVirtualPageProperty[mNvActivePageId].NvRawSectorEndAddress);
   2670          
   2671            pDataEntry->pData = NULL;
   2672            pDataEntry->ElementsCount = 0;
   2673            pDataEntry->ElementSize = 0;
   2674            pDataEntry->DataEntryID = gNvInvalidDataEntry_c;
   2675          
   2676            return FALSE;
   2677          }
   2678          
   2679          #endif /* gNvUseExtendedFeatureSet_d */
   2680          
   2681          #endif /* no FlexNVM */
   2682          
   2683          
   2684          /******************************************************************************
   2685           * Name: NvGetEntryFromDataPtr
   2686           * Description: get table and element indexes based on a generic pointer address
   2687           * Parameter(s): [IN] pData - a pointer to a NVM RAM table
   2688           *               [OUT] pIndex - a pointer to a memory location where the 
   2689           *                              requested indexed will be stored
   2690           * Return: gNVM_NullPointer_c - if the provided pointer is NULL
   2691           *         gNVM_PointerOutOfRange_c - if the provided pointer cannot be founded
   2692           *                                    within the RAM table
   2693           *         gNVM_OK_c - if the operation completed successfully
   2694           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2695          static NVM_Status_t NvGetEntryFromDataPtr
   2696          (
   2697            void* pData,
   2698            NVM_TableEntryInfo_t* pIndex
   2699          )
   2700          {        
   \                     NvGetEntryFromDataPtr: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0002             MOVS     R2,R0
   2701            uint16_t idx = 0;
   \   00000004   0x2300             MOVS     R3,#+0
   2702          
   2703          
   2704            while(gNvEndOfTableId_c != pNVM_DataTable[idx].DataEntryID)
   \                     ??NvGetEntryFromDataPtr_0: (+1)
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000000E   0x240C             MOVS     R4,#+12
   \   00000010   0xFB04 0x0003      MLA      R0,R4,R3,R0
   \   00000014   0x8900             LDRH     R0,[R0, #+8]
   \   00000016   0xF64F 0x74FE      MOVW     R4,#+65534
   \   0000001A   0x42A0             CMP      R0,R4
   \   0000001C   0xD018             BEQ.N    ??NvGetEntryFromDataPtr_1
   2705            {
   2706              if((uint8_t*)pData == (uint8_t*)pNVM_DataTable[idx].pData)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000026   0x240C             MOVS     R4,#+12
   \   00000028   0xFB04 0x0003      MLA      R0,R4,R3,R0
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x4282             CMP      R2,R0
   \   00000030   0xD10C             BNE.N    ??NvGetEntryFromDataPtr_2
   2707              {
   2708                pIndex->entryId = pNVM_DataTable[idx].DataEntryID;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000003A   0x240C             MOVS     R4,#+12
   \   0000003C   0xFB04 0x0003      MLA      R0,R4,R3,R0
   \   00000040   0x8900             LDRH     R0,[R0, #+8]
   \   00000042   0x8008             STRH     R0,[R1, #+0]
   2709                pIndex->elementIndex = 0;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x8048             STRH     R0,[R1, #+2]
   2710                return gNVM_OK_c;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xE057             B.N      ??NvGetEntryFromDataPtr_3
   2711              }
   2712              idx++;
   \                     ??NvGetEntryFromDataPtr_2: (+1)
   \   0000004C   0x1C5B             ADDS     R3,R3,#+1
   \   0000004E   0xE7DA             B.N      ??NvGetEntryFromDataPtr_0
   2713            }
   2714          
   2715            idx = 0;
   \                     ??NvGetEntryFromDataPtr_1: (+1)
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x0003             MOVS     R3,R0
   2716          
   2717            while(gNvEndOfTableId_c != pNVM_DataTable[idx].DataEntryID)
   \                     ??NvGetEntryFromDataPtr_4: (+1)
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000005C   0x240C             MOVS     R4,#+12
   \   0000005E   0xFB04 0x0003      MLA      R0,R4,R3,R0
   \   00000062   0x8900             LDRH     R0,[R0, #+8]
   \   00000064   0xF64F 0x74FE      MOVW     R4,#+65534
   \   00000068   0x42A0             CMP      R0,R4
   \   0000006A   0xD046             BEQ.N    ??NvGetEntryFromDataPtr_5
   2718            {
   2719              if(((uint8_t*)pData >= (uint8_t*)pNVM_DataTable[idx].pData) && ((uint8_t*)pData < ((uint8_t*)pNVM_DataTable[idx].pData + 
   2720                  (pNVM_DataTable[idx].ElementSize * pNVM_DataTable[idx].ElementsCount))))
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000074   0x240C             MOVS     R4,#+12
   \   00000076   0xFB04 0x0003      MLA      R0,R4,R3,R0
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x4282             CMP      R2,R0
   \   0000007E   0xD33A             BCC.N    ??NvGetEntryFromDataPtr_6
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000088   0x240C             MOVS     R4,#+12
   \   0000008A   0xFB04 0x0003      MLA      R0,R4,R3,R0
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0x.... 0x....      LDR.W    R4,??DataTable16
   \   00000094   0x6824             LDR      R4,[R4, #+0]
   \   00000096   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000098   0x250C             MOVS     R5,#+12
   \   0000009A   0xFB05 0x4403      MLA      R4,R5,R3,R4
   \   0000009E   0x88E4             LDRH     R4,[R4, #+6]
   \   000000A0   0x.... 0x....      LDR.W    R5,??DataTable16
   \   000000A4   0x682D             LDR      R5,[R5, #+0]
   \   000000A6   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000A8   0x260C             MOVS     R6,#+12
   \   000000AA   0xFB06 0x5503      MLA      R5,R6,R3,R5
   \   000000AE   0x88AD             LDRH     R5,[R5, #+4]
   \   000000B0   0xFB05 0x0004      MLA      R0,R5,R4,R0
   \   000000B4   0x4282             CMP      R2,R0
   \   000000B6   0xD21E             BCS.N    ??NvGetEntryFromDataPtr_6
   2721              {
   2722                pIndex->entryId = pNVM_DataTable[idx].DataEntryID;
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000C0   0x240C             MOVS     R4,#+12
   \   000000C2   0xFB04 0x0003      MLA      R0,R4,R3,R0
   \   000000C6   0x8900             LDRH     R0,[R0, #+8]
   \   000000C8   0x8008             STRH     R0,[R1, #+0]
   2723                pIndex->elementIndex = (((uint32_t)pData - (uint32_t)pNVM_DataTable[idx].pData)/(pNVM_DataTable[idx].ElementSize));
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000CE   0x6800             LDR      R0,[R0, #+0]
   \   000000D0   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000D2   0x240C             MOVS     R4,#+12
   \   000000D4   0xFB04 0x0003      MLA      R0,R4,R3,R0
   \   000000D8   0x6800             LDR      R0,[R0, #+0]
   \   000000DA   0x1A10             SUBS     R0,R2,R0
   \   000000DC   0x.... 0x....      LDR.W    R4,??DataTable16
   \   000000E0   0x6824             LDR      R4,[R4, #+0]
   \   000000E2   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000E4   0x250C             MOVS     R5,#+12
   \   000000E6   0xFB05 0x4403      MLA      R4,R5,R3,R4
   \   000000EA   0x88E4             LDRH     R4,[R4, #+6]
   \   000000EC   0xFBB0 0xF0F4      UDIV     R0,R0,R4
   \   000000F0   0x8048             STRH     R0,[R1, #+2]
   2724                return gNVM_OK_c;
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0xE002             B.N      ??NvGetEntryFromDataPtr_3
   2725              }
   2726              /* increment the loop counter */
   2727              idx++;
   \                     ??NvGetEntryFromDataPtr_6: (+1)
   \   000000F6   0x1C5B             ADDS     R3,R3,#+1
   \   000000F8   0xE7AC             B.N      ??NvGetEntryFromDataPtr_4
   2728            }    
   2729            return gNVM_PointerOutOfRange_c;
   \                     ??NvGetEntryFromDataPtr_5: (+1)
   \   000000FA   0x2006             MOVS     R0,#+6
   \                     ??NvGetEntryFromDataPtr_3: (+1)
   \   000000FC   0xBC70             POP      {R4-R6}
   \   000000FE   0x4770             BX       LR               ;; return
   2730          }
   2731          
   2732          
   2733          /******************************************************************************
   2734           * Name: NvWriteRecord
   2735           * Description: writes a record
   2736           * Parameter(s): [IN] tblIndexes - a pointer to table and element indexes
   2737           * Return: gNVM_InvalidPageID_c - if the active page is not valid
   2738           *         gNVM_NullPointer_c - if the provided pointer is NULL
   2739           *         gNVM_MetaInfoWriteError_c - if the meta information couldn't be 
   2740           *                                     written
   2741           *         gNVM_RecordWriteError_c - if the record couldn't be written
   2742           *         gNVM_OK_c - if the operation completed successfully
   2743           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2744          static NVM_Status_t NvWriteRecord
   2745          (        
   2746            NVM_TableEntryInfo_t* tblIndexes
   2747          )
   2748          {
   \                     NvWriteRecord: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   2749          #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */  
   2750            uint32_t metaInfoAddress;
   2751            uint32_t lastRecordAddress;
   2752            uint32_t newRecordAddress;
   2753            NVM_RecordMetaInfo_t metaInfo;        
   2754            uint32_t realRecordSize;
   2755            uint32_t totalRecordSize; /* record + meta */    
   2756            uint32_t pageFreeSpace;
   2757            uint8_t paddingBytes;
   2758            bool_t doWrite;    
   2759            uint32_t srcAddress;
   2760          #else /* FlexNVM */
   2761            uint32_t lastFlexMetaInfoAddress;
   2762            NVM_FlexMetaInfo_t lastFlexMetaInfo;
   2763            NVM_FlexMetaInfo_t flexMetaInfo;
   2764            uint32_t destRecordEndAddress;
   2765          
   2766          #endif
   2767          
   2768            uint16_t tableEntryIdx;
   2769            uint32_t recordSize;
   2770          
   2771            tableEntryIdx = NvGetTableEntryIndexFromId(tblIndexes->entryId);
   \   00000008   0x8820             LDRH     R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       NvGetTableEntryIndexFromId
   \   0000000E   0x4680             MOV      R8,R0
   2772          
   2773            if(gNvInvalidTableEntryIndex_c == tableEntryIdx)
   \   00000010   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000014   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000018   0x4580             CMP      R8,R0
   \   0000001A   0xD101             BNE.N    ??NvWriteRecord_0
   2774            {
   2775              return gNVM_InvalidTableEntry_c;
   \   0000001C   0x2009             MOVS     R0,#+9
   \   0000001E   0xE153             B.N      ??NvWriteRecord_1
   2776            }
   2777          
   2778          #if (gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c != 0) /* FlexNVM */
   2779          
   2780            recordSize = pNVM_DataTable[tableEntryIdx].ElementsCount * pNVM_DataTable[tableEntryIdx].ElementSize;
   2781          
   2782            NvGetFlexMetaInfoFromId(tblIndexes->entryId, &flexMetaInfo);
   2783          
   2784            if(flexMetaInfo.rawValue == gNvFlexGuardValue_c) /* no meta found for this table entry ID */
   2785            {
   2786              /* set entry ID */
   2787              flexMetaInfo.fields.NvDataEntryID = tblIndexes->entryId;      
   2788              /* get last meta info tag address */
   2789              lastFlexMetaInfoAddress = NvGetFlexLastMetaInfo();
   2790          
   2791              if(lastFlexMetaInfoAddress < mNvConfig.EERAMBlockBase) /* FlexRAM empty */
   2792              {              
   2793                flexMetaInfo.fields.NvDataOffset = mNvConfig.EEEBlockSize - recordSize;
   2794                destRecordEndAddress = mNvConfig.EERAMBlockBase + mNvConfig.EEEBlockSize;
   2795                lastFlexMetaInfoAddress = mNvConfig.EERAMBlockBase;
   2796              }
   2797              else
   2798              {
   2799                /* wait for EEPROM system to be ready */
   2800                while(!(gNV_REG_READ(mNvConfig.ftfxRegBase + gNV_FCNFG_OFFSET_c) & gNV_FCNFG_EEERDY_c));
   2801                /* read last meta tag */
   2802                NV_FlashRead(lastFlexMetaInfoAddress, (uint8_t*)&lastFlexMetaInfo, sizeof(NVM_FlexMetaInfo_t));
   2803                /* compute record destination end address */
   2804                destRecordEndAddress = mNvConfig.EERAMBlockBase + lastFlexMetaInfo.fields.NvDataOffset;
   2805                /* compute record offset */
   2806                flexMetaInfo.fields.NvDataOffset = lastFlexMetaInfo.fields.NvDataOffset - recordSize;
   2807                /* increment the last meta info address and reused it as address of the current meta info tag */
   2808                lastFlexMetaInfoAddress += sizeof(NVM_FlexMetaInfo_t);
   2809              }
   2810          
   2811              /* wait for EEPROM system to be ready */
   2812              while(!(gNV_REG_READ(mNvConfig.ftfxRegBase + gNV_FCNFG_OFFSET_c) & gNV_FCNFG_EEERDY_c));
   2813          
   2814              /* write record */
   2815              if(gNV_OK_c != NV_EEEWrite(&mNvConfig, (uint32_t) ((uint8_t*)(pNVM_DataTable[tableEntryIdx].pData)), destRecordEndAddress - recordSize, recordSize))
   2816              {
   2817                return gNVM_RecordWriteError_c;
   2818              }   
   2819          
   2820              /* wait for EEPROM system to be ready */
   2821              while(!(gNV_REG_READ(mNvConfig.ftfxRegBase + gNV_FCNFG_OFFSET_c) & gNV_FCNFG_EEERDY_c));
   2822          
   2823              /* write meta */
   2824              if(gNV_OK_c != NV_EEEWrite(&mNvConfig, (uint32_t)(&flexMetaInfo.rawValue), lastFlexMetaInfoAddress, sizeof(NVM_FlexMetaInfo_t)))
   2825              {
   2826                return gNVM_RecordWriteError_c;      
   2827              }
   2828            }
   2829            else /* table entry ID already in FlexRAM, update the corresponding record */
   2830            {
   2831              /* wait for EEPROM system to be ready */
   2832              while(!(gNV_REG_READ(mNvConfig.ftfxRegBase + gNV_FCNFG_OFFSET_c) & gNV_FCNFG_EEERDY_c));
   2833          
   2834              if(gNV_OK_c != NV_EEEWrite(&mNvConfig, (uint32_t) ((uint8_t*)(pNVM_DataTable[tableEntryIdx].pData)), 
   2835                  (uint32_t)(mNvConfig.EERAMBlockBase + flexMetaInfo.fields.NvDataOffset), recordSize))
   2836              {
   2837                return gNVM_RecordWriteError_c;
   2838              }
   2839            }
   2840          
   2841            return gNVM_OK_c;
   2842          
   2843          #else
   2844          
   2845            if(tblIndexes->saveRestoreAll)
   \                     ??NvWriteRecord_0: (+1)
   \   00000020   0x7920             LDRB     R0,[R4, #+4]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD015             BEQ.N    ??NvWriteRecord_2
   2846            {
   2847              realRecordSize = recordSize = pNVM_DataTable[tableEntryIdx].ElementSize * pNVM_DataTable[tableEntryIdx].ElementsCount;        
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000030   0x210C             MOVS     R1,#+12
   \   00000032   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   00000036   0x88C0             LDRH     R0,[R0, #+6]
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000003C   0x6809             LDR      R1,[R1, #+0]
   \   0000003E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000042   0x220C             MOVS     R2,#+12
   \   00000044   0xFB02 0x1108      MLA      R1,R2,R8,R1
   \   00000048   0x8889             LDRH     R1,[R1, #+4]
   \   0000004A   0x4348             MULS     R0,R1,R0
   \   0000004C   0x4681             MOV      R9,R0
   \   0000004E   0x46CA             MOV      R10,R9
   \   00000050   0xE00A             B.N      ??NvWriteRecord_3
   2848            }
   2849            else
   2850            {
   2851              realRecordSize = recordSize = pNVM_DataTable[tableEntryIdx].ElementSize;
   \                     ??NvWriteRecord_2: (+1)
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000005C   0x210C             MOVS     R1,#+12
   \   0000005E   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   00000062   0x88C0             LDRH     R0,[R0, #+6]
   \   00000064   0x4681             MOV      R9,R0
   \   00000066   0x46CA             MOV      R10,R9
   2852            }
   2853          
   2854            /* get active page free space */
   2855            NvGetPageFreeSpace(&pageFreeSpace);
   \                     ??NvWriteRecord_3: (+1)
   \   00000068   0xA803             ADD      R0,SP,#+12
   \   0000006A   0x.... 0x....      BL       NvGetPageFreeSpace
   2856          
   2857            /* compute the 'real record size' taking into consideration that the FTFL controller only writes in burst of 4 bytes */    
   2858            paddingBytes = recordSize % (uint8_t)gNV_LONGWORD_SIZE_c;
   \   0000006E   0x2004             MOVS     R0,#+4
   \   00000070   0xFBB9 0xF1F0      UDIV     R1,R9,R0
   \   00000074   0xFB01 0x9110      MLS      R1,R1,R0,R9
   \   00000078   0xF88D 0x1009      STRB     R1,[SP, #+9]
   2859            if(paddingBytes)
   \   0000007C   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD005             BEQ.N    ??NvWriteRecord_4
   2860            {
   2861              realRecordSize += (uint8_t)((uint8_t)gNV_LONGWORD_SIZE_c-paddingBytes);
   \   00000084   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   00000088   0xF1D0 0x0004      RSBS     R0,R0,#+4
   \   0000008C   0xFA5A 0xFA80      UXTAB    R10,R10,R0
   2862            }
   2863          
   2864            /* compute the total size (record + meta info) */
   2865            totalRecordSize = realRecordSize + sizeof(NVM_RecordMetaInfo_t);
   \                     ??NvWriteRecord_4: (+1)
   \   00000090   0xF11A 0x0008      ADDS     R0,R10,#+8
   \   00000094   0x0006             MOVS     R6,R0
   2866          
   2867            /* check if the record fits the page's free space.  
   2868             * one extra meta info space must be kept always free, to be able to perform the meta info search */
   2869            if(totalRecordSize + sizeof(NVM_RecordMetaInfo_t) > pageFreeSpace) 
   \   00000096   0x9803             LDR      R0,[SP, #+12]
   \   00000098   0xF116 0x0108      ADDS     R1,R6,#+8
   \   0000009C   0x4288             CMP      R0,R1
   \   0000009E   0xD205             BCS.N    ??NvWriteRecord_5
   2870            {        
   2871              /* there is no space to save the record, try to copy the current active page latest records
   2872               * to the other page
   2873               */
   2874          #if gNvUseExtendedFeatureSet_d	  
   2875              mNvSkipTableEntryId = gNvCopyAll_c;
   2876          #endif /* #if gNvUseExtendedFeatureSet_d */
   2877              mNvCopyOperationIsPending = TRUE;
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable26
   \   000000A6   0x7008             STRB     R0,[R1, #+0]
   2878              return gNVM_PageCopyPending_c;        
   \   000000A8   0x2011             MOVS     R0,#+17
   \   000000AA   0xE10D             B.N      ??NvWriteRecord_1
   2879            }
   2880            else
   2881            {        
   2882              metaInfoAddress = mNvVirtualPageProperty[mNvActivePageId].NvLastMetaInfoAddress;
   \                     ??NvWriteRecord_5: (+1)
   \   000000AC   0x....             LDR.N    R0,??DataTable14_1
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   000000B2   0x7809             LDRB     R1,[R1, #+0]
   \   000000B4   0x2214             MOVS     R2,#+20
   \   000000B6   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000000BA   0x6900             LDR      R0,[R0, #+16]
   \   000000BC   0x4683             MOV      R11,R0
   2883          
   2884              if(gEmptyPageMetaAddress_c == metaInfoAddress) 
   \   000000BE   0x....             LDR.N    R0,??DataTable14  ;; 0x3fff0000
   \   000000C0   0x4583             CMP      R11,R0
   \   000000C2   0xD14B             BNE.N    ??NvWriteRecord_6
   2885              {      
   2886                /* empty page, first write */
   2887          
   2888                /* set new record address */
   2889                newRecordAddress = mNvVirtualPageProperty[mNvActivePageId].NvRawSectorEndAddress - sizeof(mNvPageCounter) - realRecordSize + 1;
   \   000000C4   0x....             LDR.N    R0,??DataTable14_1
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   000000CA   0x7809             LDRB     R1,[R1, #+0]
   \   000000CC   0x2214             MOVS     R2,#+20
   \   000000CE   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000000D2   0x6840             LDR      R0,[R0, #+4]
   \   000000D4   0x1F00             SUBS     R0,R0,#+4
   \   000000D6   0xEBB0 0x000A      SUBS     R0,R0,R10
   \   000000DA   0x1C40             ADDS     R0,R0,#+1
   \   000000DC   0x0005             MOVS     R5,R0
   2890          
   2891                /* set associated meta info */            
   2892                if(tblIndexes->saveRestoreAll)
   \   000000DE   0x7920             LDRB     R0,[R4, #+4]
   \   000000E0   0x2800             CMP      R0,#+0
   \   000000E2   0xD006             BEQ.N    ??NvWriteRecord_7
   2893                {
   2894                  metaInfo.fields.NvValidationStartByte = gValidationByteAllRecords_c;
   \   000000E4   0x2055             MOVS     R0,#+85
   \   000000E6   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2895                  metaInfo.fields.NvValidationEndByte = gValidationByteAllRecords_c;
   \   000000EA   0x2055             MOVS     R0,#+85
   \   000000EC   0xF88D 0x0007      STRB     R0,[SP, #+7]
   \   000000F0   0xE005             B.N      ??NvWriteRecord_8
   2896                }
   2897                else
   2898                {
   2899                  metaInfo.fields.NvValidationStartByte = gValidationByteSingleRecord_c;
   \                     ??NvWriteRecord_7: (+1)
   \   000000F2   0x20AA             MOVS     R0,#+170
   \   000000F4   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2900                  metaInfo.fields.NvValidationEndByte = gValidationByteSingleRecord_c;
   \   000000F8   0x20AA             MOVS     R0,#+170
   \   000000FA   0xF88D 0x0007      STRB     R0,[SP, #+7]
   2901                }
   2902          
   2903                metaInfo.fields.NvmDataEntryID = pNVM_DataTable[tableEntryIdx].DataEntryID;
   \                     ??NvWriteRecord_8: (+1)
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000102   0x6800             LDR      R0,[R0, #+0]
   \   00000104   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000108   0x210C             MOVS     R1,#+12
   \   0000010A   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   0000010E   0x8900             LDRH     R0,[R0, #+8]
   \   00000110   0xF8AD 0x0001      STRH     R0,[SP, #+1]
   2904                metaInfo.fields.NvmElementIndex = tblIndexes->elementIndex;
   \   00000114   0x8860             LDRH     R0,[R4, #+2]
   \   00000116   0xF8AD 0x0003      STRH     R0,[SP, #+3]
   2905                metaInfo.fields.NvmRecordOffset = mNvVirtualPageProperty[mNvActivePageId].NvRawSectorEndAddress - 
   2906                    mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress - realRecordSize - sizeof(mNvPageCounter) + 1;
   \   0000011A   0x....             LDR.N    R0,??DataTable14_1
   \   0000011C   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   00000120   0x7809             LDRB     R1,[R1, #+0]
   \   00000122   0x2214             MOVS     R2,#+20
   \   00000124   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000128   0x6840             LDR      R0,[R0, #+4]
   \   0000012A   0x....             LDR.N    R1,??DataTable14_1
   \   0000012C   0x.... 0x....      LDR.W    R2,??DataTable16_1
   \   00000130   0x7812             LDRB     R2,[R2, #+0]
   \   00000132   0x2314             MOVS     R3,#+20
   \   00000134   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000138   0x6809             LDR      R1,[R1, #+0]
   \   0000013A   0x1A40             SUBS     R0,R0,R1
   \   0000013C   0xEBB0 0x000A      SUBS     R0,R0,R10
   \   00000140   0x1EC0             SUBS     R0,R0,#+3
   \   00000142   0xF8AD 0x0005      STRH     R0,[SP, #+5]
   2907          
   2908                /* gEmptyPageMetaAddress_c is not a valid address and it is used only as an empty page marker;
   2909                 * therefore, set the valid value of meta information address */
   2910          #if gNvUseExtendedFeatureSet_d      
   2911                metaInfoAddress = mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + sizeof(mNvPageCounter) +
   2912                    mNvTableSizeInFlash + (2 * sizeof(mNvTableMarker));
   2913          #else
   2914                metaInfoAddress = mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + sizeof(mNvPageCounter);
   \   00000146   0x....             LDR.N    R0,??DataTable14_1
   \   00000148   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   0000014C   0x7809             LDRB     R1,[R1, #+0]
   \   0000014E   0x2214             MOVS     R2,#+20
   \   00000150   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000154   0x6800             LDR      R0,[R0, #+0]
   \   00000156   0x1D00             ADDS     R0,R0,#+4
   \   00000158   0x4683             MOV      R11,R0
   \   0000015A   0xE042             B.N      ??NvWriteRecord_9
   2915          #endif /* gNvUseExtendedFeatureSet_d */
   2916              }
   2917              else    
   2918              {
   2919                /* get the meta information of the last successfully written record */
   2920                NvGetMetaInfo(mNvActivePageId, metaInfoAddress, &metaInfo);
   \                     ??NvWriteRecord_6: (+1)
   \   0000015C   0xAA00             ADD      R2,SP,#+0
   \   0000015E   0x4659             MOV      R1,R11
   \   00000160   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   00000164   0x7800             LDRB     R0,[R0, #+0]
   \   00000166   0x.... 0x....      BL       NvGetMetaInfo
   2921          
   2922                /* get the last record start address (the address is always 4-bytes aligned) */
   2923                lastRecordAddress = mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + metaInfo.fields.NvmRecordOffset;
   \   0000016A   0x....             LDR.N    R0,??DataTable14_1
   \   0000016C   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   00000170   0x7809             LDRB     R1,[R1, #+0]
   \   00000172   0x2214             MOVS     R2,#+20
   \   00000174   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000178   0x6800             LDR      R0,[R0, #+0]
   \   0000017A   0xF8BD 0x1005      LDRH     R1,[SP, #+5]
   \   0000017E   0xFA10 0xF081      UXTAH    R0,R0,R1
   \   00000182   0x9004             STR      R0,[SP, #+16]
   2924          
   2925                /* set new record address */
   2926                newRecordAddress = lastRecordAddress - realRecordSize;
   \   00000184   0x9804             LDR      R0,[SP, #+16]
   \   00000186   0xEBB0 0x000A      SUBS     R0,R0,R10
   \   0000018A   0x0005             MOVS     R5,R0
   2927          
   2928                /* set associated meta info */
   2929                if(tblIndexes->saveRestoreAll)
   \   0000018C   0x7920             LDRB     R0,[R4, #+4]
   \   0000018E   0x2800             CMP      R0,#+0
   \   00000190   0xD006             BEQ.N    ??NvWriteRecord_10
   2930                {
   2931                  metaInfo.fields.NvValidationStartByte = gValidationByteAllRecords_c;
   \   00000192   0x2055             MOVS     R0,#+85
   \   00000194   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2932                  metaInfo.fields.NvValidationEndByte = gValidationByteAllRecords_c;
   \   00000198   0x2055             MOVS     R0,#+85
   \   0000019A   0xF88D 0x0007      STRB     R0,[SP, #+7]
   \   0000019E   0xE005             B.N      ??NvWriteRecord_11
   2933                }
   2934                else
   2935                {
   2936                  metaInfo.fields.NvValidationStartByte = gValidationByteSingleRecord_c;
   \                     ??NvWriteRecord_10: (+1)
   \   000001A0   0x20AA             MOVS     R0,#+170
   \   000001A2   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2937                  metaInfo.fields.NvValidationEndByte = gValidationByteSingleRecord_c;
   \   000001A6   0x20AA             MOVS     R0,#+170
   \   000001A8   0xF88D 0x0007      STRB     R0,[SP, #+7]
   2938                }
   2939                metaInfo.fields.NvmDataEntryID = pNVM_DataTable[tableEntryIdx].DataEntryID;
   \                     ??NvWriteRecord_11: (+1)
   \   000001AC   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000001B0   0x6800             LDR      R0,[R0, #+0]
   \   000001B2   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000001B6   0x210C             MOVS     R1,#+12
   \   000001B8   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   000001BC   0x8900             LDRH     R0,[R0, #+8]
   \   000001BE   0xF8AD 0x0001      STRH     R0,[SP, #+1]
   2940                metaInfo.fields.NvmElementIndex = tblIndexes->elementIndex;
   \   000001C2   0x8860             LDRH     R0,[R4, #+2]
   \   000001C4   0xF8AD 0x0003      STRH     R0,[SP, #+3]
   2941                metaInfo.fields.NvmRecordOffset = newRecordAddress - mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress;
   \   000001C8   0x....             LDR.N    R0,??DataTable14_1
   \   000001CA   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   000001CE   0x7809             LDRB     R1,[R1, #+0]
   \   000001D0   0x2214             MOVS     R2,#+20
   \   000001D2   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000001D6   0x6800             LDR      R0,[R0, #+0]
   \   000001D8   0x1A28             SUBS     R0,R5,R0
   \   000001DA   0xF8AD 0x0005      STRH     R0,[SP, #+5]
   2942          
   2943                metaInfoAddress += sizeof(NVM_RecordMetaInfo_t);
   \   000001DE   0xF11B 0x0B08      ADDS     R11,R11,#+8
   2944              }       
   2945          
   2946              /* check if the space needed by the record is really free (erased).
   2947               * this check is necessary because it may happens that a record to be successfully written,
   2948               * but the system fails (e.g. POR) before the associated meta information has been written.
   2949               * the theoretically free space is computed as the difference between the last meta info 
   2950               * address and the start address of the last successfully written record. This information
   2951               * is valuable but may not reflect the reality, as mentioned in the explanation above */
   2952          
   2953              doWrite = FALSE;
   \                     ??NvWriteRecord_9: (+1)
   \   000001E2   0x2000             MOVS     R0,#+0
   \   000001E4   0xF88D 0x0008      STRB     R0,[SP, #+8]
   2954          
   2955              while(totalRecordSize + sizeof(NVM_RecordMetaInfo_t) < pageFreeSpace)
   \                     ??NvWriteRecord_12: (+1)
   \   000001E8   0xF116 0x0008      ADDS     R0,R6,#+8
   \   000001EC   0x9903             LDR      R1,[SP, #+12]
   \   000001EE   0x4288             CMP      R0,R1
   \   000001F0   0xD20F             BCS.N    ??NvWriteRecord_13
   2956              {
   2957                if(!NvIsMemoryAreaAvailable(newRecordAddress, realRecordSize))
   \   000001F2   0x4651             MOV      R1,R10
   \   000001F4   0x0028             MOVS     R0,R5
   \   000001F6   0x.... 0x....      BL       NvIsMemoryAreaAvailable
   \   000001FA   0x2800             CMP      R0,#+0
   \   000001FC   0xD106             BNE.N    ??NvWriteRecord_14
   2958                {
   2959                  /* the memory space is not blank */
   2960                  pageFreeSpace -= realRecordSize;
   \   000001FE   0x9803             LDR      R0,[SP, #+12]
   \   00000200   0xEBB0 0x000A      SUBS     R0,R0,R10
   \   00000204   0x9003             STR      R0,[SP, #+12]
   2961                  newRecordAddress -= realRecordSize;
   \   00000206   0xEBB5 0x050A      SUBS     R5,R5,R10
   \   0000020A   0xE7ED             B.N      ??NvWriteRecord_12
   2962                }
   2963                else
   2964                {
   2965                  /* the memory space is blank */
   2966                  doWrite = TRUE;
   \                     ??NvWriteRecord_14: (+1)
   \   0000020C   0x2001             MOVS     R0,#+1
   \   0000020E   0xF88D 0x0008      STRB     R0,[SP, #+8]
   2967                  break;
   2968                }            
   2969              }  
   2970          
   2971              /* update the meta info offset, if changed */
   2972              if(newRecordAddress - mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress != metaInfo.fields.NvmRecordOffset)
   \                     ??NvWriteRecord_13: (+1)
   \   00000212   0x....             LDR.N    R0,??DataTable14_1
   \   00000214   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   00000218   0x7809             LDRB     R1,[R1, #+0]
   \   0000021A   0x2214             MOVS     R2,#+20
   \   0000021C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000220   0x6800             LDR      R0,[R0, #+0]
   \   00000222   0x1A28             SUBS     R0,R5,R0
   \   00000224   0xF8BD 0x1005      LDRH     R1,[SP, #+5]
   \   00000228   0x4288             CMP      R0,R1
   \   0000022A   0xD00A             BEQ.N    ??NvWriteRecord_15
   2973              {
   2974                metaInfo.fields.NvmRecordOffset = newRecordAddress - mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress;
   \   0000022C   0x....             LDR.N    R0,??DataTable14_1
   \   0000022E   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   00000232   0x7809             LDRB     R1,[R1, #+0]
   \   00000234   0x2214             MOVS     R2,#+20
   \   00000236   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000023A   0x6800             LDR      R0,[R0, #+0]
   \   0000023C   0x1A28             SUBS     R0,R5,R0
   \   0000023E   0xF8AD 0x0005      STRH     R0,[SP, #+5]
   2975              }
   2976          
   2977              /* Write the record and associated meta information */
   2978              if(doWrite)
   \                     ??NvWriteRecord_15: (+1)
   \   00000242   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000246   0x2800             CMP      R0,#+0
   \   00000248   0xD039             BEQ.N    ??NvWriteRecord_16
   2979              {            
   2980                if(tblIndexes->saveRestoreAll)
   \   0000024A   0x7920             LDRB     R0,[R4, #+4]
   \   0000024C   0x2800             CMP      R0,#+0
   \   0000024E   0xD00A             BEQ.N    ??NvWriteRecord_17
   2981                {
   2982                  srcAddress = (uint32_t)((uint8_t*)(((uint8_t*)(pNVM_DataTable[tableEntryIdx]).pData)));
   \   00000250   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000254   0x6800             LDR      R0,[R0, #+0]
   \   00000256   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000025A   0x210C             MOVS     R1,#+12
   \   0000025C   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   00000260   0x6800             LDR      R0,[R0, #+0]
   \   00000262   0x0007             MOVS     R7,R0
   \   00000264   0xE00C             B.N      ??NvWriteRecord_18
   2983                }
   2984                else
   2985                {
   2986                  srcAddress = (uint32_t)((uint8_t*)(((uint8_t*)(pNVM_DataTable[tableEntryIdx]).pData)) + (tblIndexes->elementIndex * recordSize));
   \                     ??NvWriteRecord_17: (+1)
   \   00000266   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000026A   0x6800             LDR      R0,[R0, #+0]
   \   0000026C   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000270   0x210C             MOVS     R1,#+12
   \   00000272   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   00000276   0x6800             LDR      R0,[R0, #+0]
   \   00000278   0x8861             LDRH     R1,[R4, #+2]
   \   0000027A   0xFB09 0x0001      MLA      R0,R9,R1,R0
   \   0000027E   0x0007             MOVS     R7,R0
   2987                }
   2988          
   2989                if(gNV_OK_c == NV_FlashProgramLongword(&mNvConfig, newRecordAddress, recordSize, srcAddress))
   \                     ??NvWriteRecord_18: (+1)
   \   00000280   0x003B             MOVS     R3,R7
   \   00000282   0x464A             MOV      R2,R9
   \   00000284   0x0029             MOVS     R1,R5
   \   00000286   0x....             LDR.N    R0,??DataTable14_2
   \   00000288   0x.... 0x....      BL       NV_FlashProgramLongword
   \   0000028C   0x2800             CMP      R0,#+0
   \   0000028E   0xD114             BNE.N    ??NvWriteRecord_19
   2990                {                    
   2991          
   2992                  /* record successfully written, now write the associated record meta information */
   2993                  if(gNV_OK_c == NV_FlashProgramLongword(&mNvConfig, metaInfoAddress, sizeof(NVM_RecordMetaInfo_t), (uint32_t)(&metaInfo)))
   \   00000290   0xAB00             ADD      R3,SP,#+0
   \   00000292   0x2208             MOVS     R2,#+8
   \   00000294   0x4659             MOV      R1,R11
   \   00000296   0x....             LDR.N    R0,??DataTable14_2
   \   00000298   0x.... 0x....      BL       NV_FlashProgramLongword
   \   0000029C   0x2800             CMP      R0,#+0
   \   0000029E   0xD10A             BNE.N    ??NvWriteRecord_20
   2994                  {      
   2995                    /* update the last record meta information */
   2996                    mNvVirtualPageProperty[mNvActivePageId].NvLastMetaInfoAddress = metaInfoAddress;                    
   \   000002A0   0x....             LDR.N    R0,??DataTable14_1
   \   000002A2   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   000002A6   0x7809             LDRB     R1,[R1, #+0]
   \   000002A8   0x2214             MOVS     R2,#+20
   \   000002AA   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000002AE   0xF8C0 0xB010      STR      R11,[R0, #+16]
   2997                    return gNVM_OK_c;                    
   \   000002B2   0x2000             MOVS     R0,#+0
   \   000002B4   0xE008             B.N      ??NvWriteRecord_1
   2998                  }
   2999                  else
   3000                  {
   3001                    return gNVM_MetaInfoWriteError_c;
   \                     ??NvWriteRecord_20: (+1)
   \   000002B6   0x200D             MOVS     R0,#+13
   \   000002B8   0xE006             B.N      ??NvWriteRecord_1
   3002                  }
   3003                }
   3004                else
   3005                {
   3006                  return gNVM_RecordWriteError_c;
   \                     ??NvWriteRecord_19: (+1)
   \   000002BA   0x200C             MOVS     R0,#+12
   \   000002BC   0xE004             B.N      ??NvWriteRecord_1
   3007                }
   3008              }
   3009              else
   3010              {
   3011                /* there is no space to save the record, try to copy the current active page latest records
   3012                 * to the other page
   3013                 */           
   3014          #if gNvUseExtendedFeatureSet_d    	
   3015                mNvSkipTableEntryId = gNvCopyAll_c;
   3016          #endif /* gNvUseExtendedFeatureSet_d */      
   3017                mNvCopyOperationIsPending = TRUE;
   \                     ??NvWriteRecord_16: (+1)
   \   000002BE   0x2001             MOVS     R0,#+1
   \   000002C0   0x.... 0x....      LDR.W    R1,??DataTable26
   \   000002C4   0x7008             STRB     R0,[R1, #+0]
   3018                return gNVM_PageCopyPending_c;
   \   000002C6   0x2011             MOVS     R0,#+17
   \                     ??NvWriteRecord_1: (+1)
   \   000002C8   0xB005             ADD      SP,SP,#+20
   \   000002CA   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   3019              }
   3020            }
   3021          #endif /* gNvUseFlexNVM_d */
   3022          }
   3023          
   3024          
   3025          /******************************************************************************
   3026           * Name: NvRestoreData
   3027           * Description: restore an element from NVM storage to its original RAM location
   3028           * Parameter(s): [IN] tblIdx - pointer to table and element indexes
   3029           * Return: gNVM_NullPointer_c - if the provided pointer is NULL
   3030           *         gNVM_PageIsEmpty_c - if page is empty
   3031           *         gNVM_Error_c - in case of error(s)
   3032           *         gNVM_OK_c - if the operation completed successfully
   3033           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3034          static NVM_Status_t NvRestoreData
   3035          (        
   3036            NVM_TableEntryInfo_t* tblIdx
   3037          )
   3038          {
   \                     NvRestoreData: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   3039          #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */
   3040            NVM_RecordMetaInfo_t metaInfo;
   3041            uint32_t metaInfoAddress;
   3042            bool_t restoreSingleRecord;        
   3043            uint32_t restoreAllMetaInfoAddress;
   3044            uint32_t loopEndAddress;
   3045            uint16_t elemMinIdx, elemMaxIdx, loopCnt;
   3046            NVM_Status_t status;
   3047          #else
   3048            NVM_FlexMetaInfo_t flexMetaInfo;
   3049            uint32_t EERamAddress;
   3050          #endif
   3051          
   3052            uint16_t tableEntryIdx;
   3053          
   3054          #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */    
   3055            
   3056            /* get the last meta information address */
   3057            if((metaInfoAddress = mNvVirtualPageProperty[mNvActivePageId].NvLastMetaInfoAddress) == gEmptyPageMetaAddress_c)
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable28
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   00000010   0x7809             LDRB     R1,[R1, #+0]
   \   00000012   0x2214             MOVS     R2,#+20
   \   00000014   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000018   0x6900             LDR      R0,[R0, #+16]
   \   0000001A   0x4683             MOV      R11,R0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x3fff0000
   \   00000020   0x4583             CMP      R11,R0
   \   00000022   0xD101             BNE.N    ??NvRestoreData_0
   3058            {
   3059              /* blank page, no data to restore */
   3060              return gNVM_PageIsEmpty_c;
   \   00000024   0x200A             MOVS     R0,#+10
   \   00000026   0xE1E5             B.N      ??NvRestoreData_1
   3061            }    
   3062          
   3063            if(tblIdx->entryId == gNvInvalidDataEntry_c)
   \                     ??NvRestoreData_0: (+1)
   \   00000028   0x8820             LDRH     R0,[R4, #+0]
   \   0000002A   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD101             BNE.N    ??NvRestoreData_2
   3064            {
   3065              /* invalid table entry */
   3066              return gNVM_InvalidTableEntry_c;
   \   00000032   0x2009             MOVS     R0,#+9
   \   00000034   0xE1DE             B.N      ??NvRestoreData_1
   3067            }
   3068          #endif
   3069          
   3070            tableEntryIdx = NvGetTableEntryIndexFromId(tblIdx->entryId);
   \                     ??NvRestoreData_2: (+1)
   \   00000036   0x8820             LDRH     R0,[R4, #+0]
   \   00000038   0x.... 0x....      BL       NvGetTableEntryIndexFromId
   \   0000003C   0x4682             MOV      R10,R0
   3071          
   3072            if(gNvInvalidTableEntryIndex_c == tableEntryIdx)
   \   0000003E   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000042   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000046   0x4582             CMP      R10,R0
   \   00000048   0xD101             BNE.N    ??NvRestoreData_3
   3073            {
   3074              return gNVM_InvalidTableEntry_c;
   \   0000004A   0x2009             MOVS     R0,#+9
   \   0000004C   0xE1D2             B.N      ??NvRestoreData_1
   3075            }
   3076          
   3077          #if (gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c != 0) /* FlexNVM */
   3078          
   3079            /* restore data from EERAM */
   3080            EERamAddress = mNvConfig.EERAMBlockBase;
   3081          
   3082            do
   3083            {
   3084              /* wait for EEPROM system to be ready */
   3085              while(!(gNV_REG_READ(mNvConfig.ftfxRegBase + gNV_FCNFG_OFFSET_c) & gNV_FCNFG_EEERDY_c));
   3086              /* read meta info tag */
   3087              NV_FlashRead(EERamAddress, (uint8_t*)&flexMetaInfo, sizeof(flexMetaInfo));
   3088          
   3089              if(flexMetaInfo.rawValue == gNvFlexGuardValue_c) /* end of meta info space */
   3090              {
   3091                break;
   3092              }
   3093          
   3094              if(tblIdx->entryId == flexMetaInfo.fields.NvDataEntryID)
   3095              {
   3096                if(tblIdx->saveRestoreAll)
   3097                {
   3098                  /* wait for EEPROM system to be ready */
   3099                  while(!(gNV_REG_READ(mNvConfig.ftfxRegBase + gNV_FCNFG_OFFSET_c) & gNV_FCNFG_EEERDY_c));
   3100                  /* read all elements */
   3101                  NV_FlashRead((mNvConfig.EERAMBlockBase + flexMetaInfo.fields.NvDataOffset),
   3102                      (uint8_t*)(pNVM_DataTable[tableEntryIdx].pData),
   3103                      pNVM_DataTable[tableEntryIdx].ElementSize * pNVM_DataTable[tableEntryIdx].ElementsCount);
   3104                  return gNVM_OK_c;
   3105                }
   3106                else
   3107                {
   3108                  /* wait for EEPROM system to be ready */
   3109                  while(!(gNV_REG_READ(mNvConfig.ftfxRegBase + gNV_FCNFG_OFFSET_c) & gNV_FCNFG_EEERDY_c));
   3110                  /* read element */
   3111                  NV_FlashRead(mNvConfig.EERAMBlockBase + flexMetaInfo.fields.NvDataOffset + (tblIdx->elementIndex * pNVM_DataTable[tableEntryIdx].ElementSize),
   3112                      (uint8_t*)(((uint8_t*)pNVM_DataTable[tableEntryIdx].pData) + (tblIdx->elementIndex * pNVM_DataTable[tableEntryIdx].ElementSize)),
   3113                      pNVM_DataTable[tableEntryIdx].ElementSize);
   3114                  return gNVM_OK_c;
   3115                } 
   3116              }       
   3117          
   3118              /* go to next meta tag */
   3119              EERamAddress += sizeof(flexMetaInfo);
   3120          
   3121            } while(EERamAddress < (mNvConfig.EERAMBlockBase + mNvConfig.EEEBlockSize));
   3122          
   3123            return gNVM_MetaNotFound_c;
   3124          #else    
   3125          
   3126            restoreSingleRecord = FALSE;                                    
   \                     ??NvRestoreData_3: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xF88D 0x000C      STRB     R0,[SP, #+12]
   3127            restoreAllMetaInfoAddress = gNvInvalidMetaInfoAddress_c;
   \   00000054   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000058   0x9002             STR      R0,[SP, #+8]
   3128          
   3129            /*
   3130             * If the meta info is found, the associated record is restored, 
   3131             * otherwise the gNVM_MetaNotFound_c will be returned
   3132             */
   3133            status = gNVM_MetaNotFound_c;
   \   0000005A   0x200B             MOVS     R0,#+11
   \   0000005C   0x4681             MOV      R9,R0
   3134          
   3135            
   3136            /*** restore all ***/  
   3137            if(tblIdx->saveRestoreAll)
   \   0000005E   0x7920             LDRB     R0,[R4, #+4]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xF000 0x8114      BEQ.W    ??NvRestoreData_4
   3138            {
   3139              elemMinIdx = pNVM_DataTable[tableEntryIdx].ElementsCount;
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000070   0x210C             MOVS     R1,#+12
   \   00000072   0xFB01 0x000A      MLA      R0,R1,R10,R0
   \   00000076   0x8880             LDRH     R0,[R0, #+4]
   \   00000078   0x0006             MOVS     R6,R0
   3140              elemMaxIdx = 0;			
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x0007             MOVS     R7,R0
   3141          	  
   3142              /* parse meta info backwards until the element is found */
   3143              while(metaInfoAddress >= (mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + sizeof(mNvPageCounter)
   3144          #if gNvUseExtendedFeatureSet_d
   3145              		+ mNvTableSizeInFlash + (2 * sizeof(mNvTableMarker))
   3146          #endif /* gNvUseExtendedFeatureSet_d */
   3147                   ))
   \                     ??NvRestoreData_5: (+1)
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable28
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   00000086   0x7809             LDRB     R1,[R1, #+0]
   \   00000088   0x2214             MOVS     R2,#+20
   \   0000008A   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0x1D00             ADDS     R0,R0,#+4
   \   00000092   0x4583             CMP      R11,R0
   \   00000094   0xD363             BCC.N    ??NvRestoreData_6
   3148              {
   3149                /* get the meta information */
   3150                NvGetMetaInfo(mNvActivePageId, metaInfoAddress, &metaInfo);
   \   00000096   0xAA00             ADD      R2,SP,#+0
   \   00000098   0x4659             MOV      R1,R11
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   0000009E   0x7800             LDRB     R0,[R0, #+0]
   \   000000A0   0x.... 0x....      BL       NvGetMetaInfo
   3151          
   3152                if(metaInfo.fields.NvValidationStartByte != metaInfo.fields.NvValidationEndByte)
   \   000000A4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000A8   0xF89D 0x1007      LDRB     R1,[SP, #+7]
   \   000000AC   0x4288             CMP      R0,R1
   \   000000AE   0xD002             BEQ.N    ??NvRestoreData_7
   3153                {
   3154                  /* invalid meta info, move to the previous meta info */
   3155              	metaInfoAddress -= sizeof(NVM_RecordMetaInfo_t);
   \   000000B0   0xF1BB 0x0B08      SUBS     R11,R11,#+8
   3156                  continue;
   \   000000B4   0xE7E3             B.N      ??NvRestoreData_5
   3157                }
   3158          
   3159                if(metaInfo.fields.NvmDataEntryID == tblIdx->entryId)
   \                     ??NvRestoreData_7: (+1)
   \   000000B6   0xF8BD 0x0001      LDRH     R0,[SP, #+1]
   \   000000BA   0x8821             LDRH     R1,[R4, #+0]
   \   000000BC   0x4288             CMP      R0,R1
   \   000000BE   0xD14B             BNE.N    ??NvRestoreData_8
   3160                {                
   3161                  if(metaInfo.fields.NvValidationStartByte == gValidationByteSingleRecord_c)
   \   000000C0   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000C4   0x28AA             CMP      R0,#+170
   \   000000C6   0xD115             BNE.N    ??NvRestoreData_9
   3162                  {
   3163                    /* A 'restore all' command has been requested but this meta refers a single element record
   3164                     * Mark the corresponding flag  
   3165                     */
   3166                    restoreSingleRecord = TRUE;
   \   000000C8   0x2001             MOVS     R0,#+1
   \   000000CA   0xF88D 0x000C      STRB     R0,[SP, #+12]
   3167                    
   3168                    /* set the search limits */
   3169                    if(metaInfo.fields.NvmElementIndex < elemMinIdx)
   \   000000CE   0xF8BD 0x0003      LDRH     R0,[SP, #+3]
   \   000000D2   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000D4   0x42B0             CMP      R0,R6
   \   000000D6   0xD202             BCS.N    ??NvRestoreData_10
   3170                    {
   3171                      elemMinIdx = metaInfo.fields.NvmElementIndex;
   \   000000D8   0xF8BD 0x0003      LDRH     R0,[SP, #+3]
   \   000000DC   0x0006             MOVS     R6,R0
   3172                    }
   3173                    if(metaInfo.fields.NvmElementIndex > elemMaxIdx)
   \                     ??NvRestoreData_10: (+1)
   \   000000DE   0xF8BD 0x0003      LDRH     R0,[SP, #+3]
   \   000000E2   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000E4   0x4287             CMP      R7,R0
   \   000000E6   0xD202             BCS.N    ??NvRestoreData_11
   3174                    {
   3175                      elemMaxIdx = metaInfo.fields.NvmElementIndex;
   \   000000E8   0xF8BD 0x0003      LDRH     R0,[SP, #+3]
   \   000000EC   0x0007             MOVS     R7,R0
   3176                    }
   3177                    
   3178                    metaInfoAddress -= sizeof(NVM_RecordMetaInfo_t);
   \                     ??NvRestoreData_11: (+1)
   \   000000EE   0xF1BB 0x0B08      SUBS     R11,R11,#+8
   3179                    continue;
   \   000000F2   0xE7C4             B.N      ??NvRestoreData_5
   3180                  }
   3181          
   3182                  if(metaInfo.fields.NvValidationStartByte == gValidationByteAllRecords_c)
   \                     ??NvRestoreData_9: (+1)
   \   000000F4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000F8   0x2855             CMP      R0,#+85
   \   000000FA   0xD12D             BNE.N    ??NvRestoreData_8
   3183                  {       
   3184                    /* restore all records */
   3185                    NV_FlashRead( (mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + metaInfo.fields.NvmRecordOffset),
   3186                        (uint8_t*)pNVM_DataTable[tableEntryIdx].pData,
   3187                        (pNVM_DataTable[tableEntryIdx].ElementsCount * pNVM_DataTable[tableEntryIdx].ElementSize));
   \   000000FC   0x....             LDR.N    R0,??DataTable16
   \   000000FE   0x6800             LDR      R0,[R0, #+0]
   \   00000100   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000104   0x210C             MOVS     R1,#+12
   \   00000106   0xFB01 0x000A      MLA      R0,R1,R10,R0
   \   0000010A   0x8880             LDRH     R0,[R0, #+4]
   \   0000010C   0x....             LDR.N    R1,??DataTable16
   \   0000010E   0x6809             LDR      R1,[R1, #+0]
   \   00000110   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000114   0x220C             MOVS     R2,#+12
   \   00000116   0xFB02 0x110A      MLA      R1,R2,R10,R1
   \   0000011A   0x88C9             LDRH     R1,[R1, #+6]
   \   0000011C   0xFB01 0xF200      MUL      R2,R1,R0
   \   00000120   0x....             LDR.N    R0,??DataTable16
   \   00000122   0x6800             LDR      R0,[R0, #+0]
   \   00000124   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000128   0x210C             MOVS     R1,#+12
   \   0000012A   0xFB01 0x000A      MLA      R0,R1,R10,R0
   \   0000012E   0x6801             LDR      R1,[R0, #+0]
   \   00000130   0x.... 0x....      LDR.W    R0,??DataTable28
   \   00000134   0x....             LDR.N    R3,??DataTable16_1
   \   00000136   0x781B             LDRB     R3,[R3, #+0]
   \   00000138   0xF05F 0x0C14      MOVS     R12,#+20
   \   0000013C   0xFB0C 0x0003      MLA      R0,R12,R3,R0
   \   00000140   0x6800             LDR      R0,[R0, #+0]
   \   00000142   0xF8BD 0x3005      LDRH     R3,[SP, #+5]
   \   00000146   0xFA10 0xF083      UXTAH    R0,R0,R3
   \   0000014A   0x.... 0x....      BL       NV_FlashRead
   3188          
   3189                    restoreAllMetaInfoAddress = metaInfoAddress;
   \   0000014E   0xF8CD 0xB008      STR      R11,[SP, #+8]
   3190                    status = gNVM_OK_c;
   \   00000152   0x2000             MOVS     R0,#+0
   \   00000154   0x4681             MOV      R9,R0
   3191                    break;
   \   00000156   0xE002             B.N      ??NvRestoreData_6
   3192                  }                    
   3193                }
   3194                /* move to the previous meta info */
   3195                metaInfoAddress -= sizeof(NVM_RecordMetaInfo_t);
   \                     ??NvRestoreData_8: (+1)
   \   00000158   0xF1BB 0x0B08      SUBS     R11,R11,#+8
   \   0000015C   0xE78F             B.N      ??NvRestoreData_5
   3196              }
   3197          
   3198              /* restore singular element, if any */
   3199              if(restoreSingleRecord)
   \                     ??NvRestoreData_6: (+1)
   \   0000015E   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   00000162   0x2800             CMP      R0,#+0
   \   00000164   0xD078             BEQ.N    ??NvRestoreData_12
   3200              {                  
   3201                /* set the loop end address */
   3202                if(gNvInvalidMetaInfoAddress_c == restoreAllMetaInfoAddress)
   \   00000166   0x9802             LDR      R0,[SP, #+8]
   \   00000168   0xF110 0x0F01      CMN      R0,#+1
   \   0000016C   0xD10A             BNE.N    ??NvRestoreData_13
   3203                {
   3204          #if gNvUseExtendedFeatureSet_d
   3205                  loopEndAddress = (mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + sizeof(mNvPageCounter) +
   3206                      mNvTableSizeInFlash + (2 * sizeof(mNvTableMarker)));
   3207          #else
   3208                  loopEndAddress = (mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + sizeof(mNvPageCounter));
   \   0000016E   0x.... 0x....      LDR.W    R0,??DataTable28
   \   00000172   0x....             LDR.N    R1,??DataTable16_1
   \   00000174   0x7809             LDRB     R1,[R1, #+0]
   \   00000176   0x2214             MOVS     R2,#+20
   \   00000178   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000017C   0x6800             LDR      R0,[R0, #+0]
   \   0000017E   0x1D00             ADDS     R0,R0,#+4
   \   00000180   0x0005             MOVS     R5,R0
   \   00000182   0xE002             B.N      ??NvRestoreData_14
   3209          #endif /* gNvUseExtendedFeatureSet_d */
   3210                }
   3211                else
   3212                {
   3213                  loopEndAddress = restoreAllMetaInfoAddress + sizeof(NVM_RecordMetaInfo_t);
   \                     ??NvRestoreData_13: (+1)
   \   00000184   0x9802             LDR      R0,[SP, #+8]
   \   00000186   0x3008             ADDS     R0,R0,#+8
   \   00000188   0x0005             MOVS     R5,R0
   3214                }
   3215                
   3216                for(loopCnt = elemMinIdx; loopCnt <= elemMaxIdx; loopCnt++)
   \                     ??NvRestoreData_14: (+1)
   \   0000018A   0x46B0             MOV      R8,R6
   \                     ??NvRestoreData_15: (+1)
   \   0000018C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000018E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000192   0x4547             CMP      R7,R8
   \   00000194   0xD360             BCC.N    ??NvRestoreData_12
   3217                {
   3218              	  /* copy the meta info address */
   3219              	  metaInfoAddress = mNvVirtualPageProperty[mNvActivePageId].NvLastMetaInfoAddress;
   \   00000196   0x.... 0x....      LDR.W    R0,??DataTable28
   \   0000019A   0x....             LDR.N    R1,??DataTable16_1
   \   0000019C   0x7809             LDRB     R1,[R1, #+0]
   \   0000019E   0x2214             MOVS     R2,#+20
   \   000001A0   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000001A4   0x6900             LDR      R0,[R0, #+16]
   \   000001A6   0x4683             MOV      R11,R0
   3220              	  
   3221              	  while(metaInfoAddress >= loopEndAddress)
   \                     ??NvRestoreData_16: (+1)
   \   000001A8   0x45AB             CMP      R11,R5
   \   000001AA   0xD352             BCC.N    ??NvRestoreData_17
   3222              	  {
   3223              		  /* get the meta information */
   3224              		  NvGetMetaInfo(mNvActivePageId, metaInfoAddress, &metaInfo);
   \   000001AC   0xAA00             ADD      R2,SP,#+0
   \   000001AE   0x4659             MOV      R1,R11
   \   000001B0   0x....             LDR.N    R0,??DataTable16_1
   \   000001B2   0x7800             LDRB     R0,[R0, #+0]
   \   000001B4   0x.... 0x....      BL       NvGetMetaInfo
   3225              		  
   3226              		  if(metaInfo.fields.NvValidationStartByte != metaInfo.fields.NvValidationEndByte)
   \   000001B8   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000001BC   0xF89D 0x1007      LDRB     R1,[SP, #+7]
   \   000001C0   0x4288             CMP      R0,R1
   \   000001C2   0xD002             BEQ.N    ??NvRestoreData_18
   3227              		  {
   3228              			  /* invalid meta info, move to the previous meta info */
   3229              			  metaInfoAddress -= sizeof(NVM_RecordMetaInfo_t);
   \   000001C4   0xF1BB 0x0B08      SUBS     R11,R11,#+8
   3230              			  continue;
   \   000001C8   0xE7EE             B.N      ??NvRestoreData_16
   3231              		  }
   3232              		  
   3233              		  if(metaInfo.fields.NvValidationStartByte == gValidationByteAllRecords_c)
   \                     ??NvRestoreData_18: (+1)
   \   000001CA   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000001CE   0x2855             CMP      R0,#+85
   \   000001D0   0xD102             BNE.N    ??NvRestoreData_19
   3234              		  {
   3235                            /* not a single element record, continue searching */
   3236                            metaInfoAddress -= sizeof(NVM_RecordMetaInfo_t);
   \   000001D2   0xF1BB 0x0B08      SUBS     R11,R11,#+8
   3237                            continue;
   \   000001D6   0xE7E7             B.N      ??NvRestoreData_16
   3238              		  }
   3239          
   3240              		  if((metaInfo.fields.NvmDataEntryID == tblIdx->entryId) && 
   3241              				  (loopCnt == metaInfo.fields.NvmElementIndex))
   \                     ??NvRestoreData_19: (+1)
   \   000001D8   0xF8BD 0x0001      LDRH     R0,[SP, #+1]
   \   000001DC   0x8821             LDRH     R1,[R4, #+0]
   \   000001DE   0x4288             CMP      R0,R1
   \   000001E0   0xD134             BNE.N    ??NvRestoreData_20
   \   000001E2   0xF8BD 0x0003      LDRH     R0,[SP, #+3]
   \   000001E6   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000001EA   0x4580             CMP      R8,R0
   \   000001EC   0xD12E             BNE.N    ??NvRestoreData_20
   3242              		  {                                        
   3243              			  /* restore the element */                
   3244              			  NV_FlashRead(mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + metaInfo.fields.NvmRecordOffset, 
   3245              					  (uint8_t*)((uint8_t*)pNVM_DataTable[tableEntryIdx].pData + 
   3246              							  (metaInfo.fields.NvmElementIndex * pNVM_DataTable[tableEntryIdx].ElementSize)), 
   3247              							  pNVM_DataTable[tableEntryIdx].ElementSize);
   \   000001EE   0x....             LDR.N    R0,??DataTable16
   \   000001F0   0x6800             LDR      R0,[R0, #+0]
   \   000001F2   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000001F6   0x210C             MOVS     R1,#+12
   \   000001F8   0xFB01 0x000A      MLA      R0,R1,R10,R0
   \   000001FC   0x88C2             LDRH     R2,[R0, #+6]
   \   000001FE   0x....             LDR.N    R0,??DataTable16
   \   00000200   0x6800             LDR      R0,[R0, #+0]
   \   00000202   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000206   0x210C             MOVS     R1,#+12
   \   00000208   0xFB01 0x000A      MLA      R0,R1,R10,R0
   \   0000020C   0x6800             LDR      R0,[R0, #+0]
   \   0000020E   0xF8BD 0x1003      LDRH     R1,[SP, #+3]
   \   00000212   0x....             LDR.N    R3,??DataTable16
   \   00000214   0x681B             LDR      R3,[R3, #+0]
   \   00000216   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   0000021A   0xF05F 0x0C0C      MOVS     R12,#+12
   \   0000021E   0xFB0C 0x330A      MLA      R3,R12,R10,R3
   \   00000222   0x88DB             LDRH     R3,[R3, #+6]
   \   00000224   0xFB03 0x0101      MLA      R1,R3,R1,R0
   \   00000228   0x.... 0x....      LDR.W    R0,??DataTable28
   \   0000022C   0x....             LDR.N    R3,??DataTable16_1
   \   0000022E   0x781B             LDRB     R3,[R3, #+0]
   \   00000230   0xF05F 0x0C14      MOVS     R12,#+20
   \   00000234   0xFB0C 0x0003      MLA      R0,R12,R3,R0
   \   00000238   0x6800             LDR      R0,[R0, #+0]
   \   0000023A   0xF8BD 0x3005      LDRH     R3,[SP, #+5]
   \   0000023E   0xFA10 0xF083      UXTAH    R0,R0,R3
   \   00000242   0x.... 0x....      BL       NV_FlashRead
   3248                            status = gNVM_OK_c;
   \   00000246   0x2000             MOVS     R0,#+0
   \   00000248   0x4681             MOV      R9,R0
   3249                            break;
   \   0000024A   0xE002             B.N      ??NvRestoreData_17
   3250              		  }
   3251          
   3252              		  /* move to the previous meta info */
   3253              		  metaInfoAddress -= sizeof(NVM_RecordMetaInfo_t);
   \                     ??NvRestoreData_20: (+1)
   \   0000024C   0xF1BB 0x0B08      SUBS     R11,R11,#+8
   \   00000250   0xE7AA             B.N      ??NvRestoreData_16
   3254              	  }    	  
   3255                }      
   \                     ??NvRestoreData_17: (+1)
   \   00000252   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000256   0xE799             B.N      ??NvRestoreData_15
   3256              }
   3257          
   3258              if(gNVM_OK_c == status)
   \                     ??NvRestoreData_12: (+1)
   \   00000258   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000025C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000260   0xD112             BNE.N    ??NvRestoreData_21
   3259              {        
   3260                maDatasetInfo[tableEntryIdx].saveNextInterval = FALSE;
   \   00000262   0x2000             MOVS     R0,#+0
   \   00000264   0x.... 0x....      LDR.W    R1,??DataTable32
   \   00000268   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   0000026C   0x2206             MOVS     R2,#+6
   \   0000026E   0xFB02 0x110A      MLA      R1,R2,R10,R1
   \   00000272   0x7008             STRB     R0,[R1, #+0]
   3261                maDatasetInfo[tableEntryIdx].countsToNextSave = gNvCountsBetweenSaves_c;
   \   00000274   0xF44F 0x7080      MOV      R0,#+256
   \   00000278   0x.... 0x....      LDR.W    R1,??DataTable32
   \   0000027C   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000280   0x2206             MOVS     R2,#+6
   \   00000282   0xFB02 0x110A      MLA      R1,R2,R10,R1
   \   00000286   0x8088             STRH     R0,[R1, #+4]
   3262              }
   3263          
   3264              return status;
   \                     ??NvRestoreData_21: (+1)
   \   00000288   0x4648             MOV      R0,R9
   \   0000028A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000028C   0xE0B2             B.N      ??NvRestoreData_1
   3265            }
   3266          
   3267            /*** restore single ***/
   3268          
   3269            /* parse meta info backwards until the element is found */
   3270            while(metaInfoAddress >= (mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + sizeof(mNvPageCounter))
   3271          #if gNvUseExtendedFeatureSet_d		  
   3272                + mNvTableSizeInFlash + (2 * sizeof(mNvTableMarker))
   3273          #endif /* gNvUseExtendedFeatureSet_d */
   3274                )
   \                     ??NvRestoreData_4: (+1)
   \   0000028E   0x.... 0x....      LDR.W    R0,??DataTable28
   \   00000292   0x....             LDR.N    R1,??DataTable16_1
   \   00000294   0x7809             LDRB     R1,[R1, #+0]
   \   00000296   0x2214             MOVS     R2,#+20
   \   00000298   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000029C   0x6800             LDR      R0,[R0, #+0]
   \   0000029E   0x1D00             ADDS     R0,R0,#+4
   \   000002A0   0x4583             CMP      R11,R0
   \   000002A2   0xF0C0 0x808D      BCC.W    ??NvRestoreData_22
   3275            {
   3276              /* get the meta information */
   3277              NvGetMetaInfo(mNvActivePageId, metaInfoAddress, &metaInfo);
   \   000002A6   0xAA00             ADD      R2,SP,#+0
   \   000002A8   0x4659             MOV      R1,R11
   \   000002AA   0x....             LDR.N    R0,??DataTable16_1
   \   000002AC   0x7800             LDRB     R0,[R0, #+0]
   \   000002AE   0x.... 0x....      BL       NvGetMetaInfo
   3278          
   3279              if(metaInfo.fields.NvValidationStartByte != metaInfo.fields.NvValidationEndByte)
   \   000002B2   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000002B6   0xF89D 0x1007      LDRB     R1,[SP, #+7]
   \   000002BA   0x4288             CMP      R0,R1
   \   000002BC   0xD002             BEQ.N    ??NvRestoreData_23
   3280              {
   3281                /* invalid meta info, move to the previous meta info */
   3282                metaInfoAddress -= sizeof(NVM_RecordMetaInfo_t);
   \   000002BE   0xF1BB 0x0B08      SUBS     R11,R11,#+8
   3283                continue;
   \   000002C2   0xE7E4             B.N      ??NvRestoreData_4
   3284              }
   3285          
   3286              if(metaInfo.fields.NvmDataEntryID == tblIdx->entryId)
   \                     ??NvRestoreData_23: (+1)
   \   000002C4   0xF8BD 0x0001      LDRH     R0,[SP, #+1]
   \   000002C8   0x8821             LDRH     R1,[R4, #+0]
   \   000002CA   0x4288             CMP      R0,R1
   \   000002CC   0xD175             BNE.N    ??NvRestoreData_24
   3287              {                
   3288                if(metaInfo.fields.NvValidationStartByte == gValidationByteSingleRecord_c)
   \   000002CE   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000002D2   0x28AA             CMP      R0,#+170
   \   000002D4   0xD12E             BNE.N    ??NvRestoreData_25
   3289                {                
   3290                  /* restore the element */                
   3291                  NV_FlashRead(mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + metaInfo.fields.NvmRecordOffset, 
   3292                      (uint8_t*)((uint8_t*)pNVM_DataTable[tableEntryIdx].pData + 
   3293                          (metaInfo.fields.NvmElementIndex * pNVM_DataTable[tableEntryIdx].ElementSize)), 
   3294                          pNVM_DataTable[tableEntryIdx].ElementSize);
   \   000002D6   0x....             LDR.N    R0,??DataTable16
   \   000002D8   0x6800             LDR      R0,[R0, #+0]
   \   000002DA   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000002DE   0x210C             MOVS     R1,#+12
   \   000002E0   0xFB01 0x000A      MLA      R0,R1,R10,R0
   \   000002E4   0x88C2             LDRH     R2,[R0, #+6]
   \   000002E6   0x....             LDR.N    R0,??DataTable16
   \   000002E8   0x6800             LDR      R0,[R0, #+0]
   \   000002EA   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000002EE   0x210C             MOVS     R1,#+12
   \   000002F0   0xFB01 0x000A      MLA      R0,R1,R10,R0
   \   000002F4   0x6800             LDR      R0,[R0, #+0]
   \   000002F6   0xF8BD 0x1003      LDRH     R1,[SP, #+3]
   \   000002FA   0x....             LDR.N    R3,??DataTable16
   \   000002FC   0x681B             LDR      R3,[R3, #+0]
   \   000002FE   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000302   0xF05F 0x0C0C      MOVS     R12,#+12
   \   00000306   0xFB0C 0x330A      MLA      R3,R12,R10,R3
   \   0000030A   0x88DB             LDRH     R3,[R3, #+6]
   \   0000030C   0xFB03 0x0101      MLA      R1,R3,R1,R0
   \   00000310   0x.... 0x....      LDR.W    R0,??DataTable28
   \   00000314   0x....             LDR.N    R3,??DataTable16_1
   \   00000316   0x781B             LDRB     R3,[R3, #+0]
   \   00000318   0xF05F 0x0C14      MOVS     R12,#+20
   \   0000031C   0xFB0C 0x0003      MLA      R0,R12,R3,R0
   \   00000320   0x6800             LDR      R0,[R0, #+0]
   \   00000322   0xF8BD 0x3005      LDRH     R3,[SP, #+5]
   \   00000326   0xFA10 0xF083      UXTAH    R0,R0,R3
   \   0000032A   0x.... 0x....      BL       NV_FlashRead
   3295                  status = gNVM_OK_c;
   \   0000032E   0x2000             MOVS     R0,#+0
   \   00000330   0x4681             MOV      R9,R0
   3296                  break;
   \   00000332   0xE045             B.N      ??NvRestoreData_22
   3297                }
   3298          
   3299                if(metaInfo.fields.NvValidationStartByte == gValidationByteAllRecords_c)
   \                     ??NvRestoreData_25: (+1)
   \   00000334   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000338   0x2855             CMP      R0,#+85
   \   0000033A   0xD13E             BNE.N    ??NvRestoreData_24
   3300                {   
   3301                  /* restore the single element from the entire table entry record */
   3302                  NV_FlashRead((mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + metaInfo.fields.NvmRecordOffset + 
   3303                      (metaInfo.fields.NvmElementIndex * pNVM_DataTable[tableEntryIdx].ElementSize)), 
   3304                      ((uint8_t*)pNVM_DataTable[tableEntryIdx].pData + (metaInfo.fields.NvmElementIndex * pNVM_DataTable[tableEntryIdx].ElementSize)),
   3305                      pNVM_DataTable[tableEntryIdx].ElementSize);
   \   0000033C   0x....             LDR.N    R0,??DataTable16
   \   0000033E   0x6800             LDR      R0,[R0, #+0]
   \   00000340   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000344   0x210C             MOVS     R1,#+12
   \   00000346   0xFB01 0x000A      MLA      R0,R1,R10,R0
   \   0000034A   0x88C2             LDRH     R2,[R0, #+6]
   \   0000034C   0x....             LDR.N    R0,??DataTable16
   \   0000034E   0x6800             LDR      R0,[R0, #+0]
   \   00000350   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000354   0x210C             MOVS     R1,#+12
   \   00000356   0xFB01 0x000A      MLA      R0,R1,R10,R0
   \   0000035A   0x6800             LDR      R0,[R0, #+0]
   \   0000035C   0xF8BD 0x1003      LDRH     R1,[SP, #+3]
   \   00000360   0x....             LDR.N    R3,??DataTable16
   \   00000362   0x681B             LDR      R3,[R3, #+0]
   \   00000364   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000368   0xF05F 0x0C0C      MOVS     R12,#+12
   \   0000036C   0xFB0C 0x330A      MLA      R3,R12,R10,R3
   \   00000370   0x88DB             LDRH     R3,[R3, #+6]
   \   00000372   0xFB03 0x0101      MLA      R1,R3,R1,R0
   \   00000376   0x.... 0x....      LDR.W    R0,??DataTable28
   \   0000037A   0x....             LDR.N    R3,??DataTable16_1
   \   0000037C   0x781B             LDRB     R3,[R3, #+0]
   \   0000037E   0xF05F 0x0C14      MOVS     R12,#+20
   \   00000382   0xFB0C 0x0003      MLA      R0,R12,R3,R0
   \   00000386   0x6800             LDR      R0,[R0, #+0]
   \   00000388   0xF8BD 0x3005      LDRH     R3,[SP, #+5]
   \   0000038C   0xFA10 0xF083      UXTAH    R0,R0,R3
   \   00000390   0xF8BD 0x3003      LDRH     R3,[SP, #+3]
   \   00000394   0x.... 0x....      LDR.W    R12,??DataTable16
   \   00000398   0xF8DC 0xC000      LDR      R12,[R12, #+0]
   \   0000039C   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000003A0   0xF05F 0x0E0C      MOVS     LR,#+12
   \   000003A4   0xFB0E 0xCC0A      MLA      R12,LR,R10,R12
   \   000003A8   0xF8BC 0xC006      LDRH     R12,[R12, #+6]
   \   000003AC   0xFB0C 0x0003      MLA      R0,R12,R3,R0
   \   000003B0   0x.... 0x....      BL       NV_FlashRead
   3306                  status = gNVM_OK_c;
   \   000003B4   0x2000             MOVS     R0,#+0
   \   000003B6   0x4681             MOV      R9,R0
   3307                  break;
   \   000003B8   0xE002             B.N      ??NvRestoreData_22
   3308                }                    
   3309              }
   3310          
   3311              /* move to the previous meta info */
   3312              metaInfoAddress -= sizeof(NVM_RecordMetaInfo_t);
   \                     ??NvRestoreData_24: (+1)
   \   000003BA   0xF1BB 0x0B08      SUBS     R11,R11,#+8
   \   000003BE   0xE766             B.N      ??NvRestoreData_4
   3313            }
   3314          
   3315          
   3316            if(gNVM_OK_c == status)
   \                     ??NvRestoreData_22: (+1)
   \   000003C0   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000003C4   0xF1B9 0x0F00      CMP      R9,#+0
   \   000003C8   0xD112             BNE.N    ??NvRestoreData_26
   3317            {        
   3318              maDatasetInfo[tableEntryIdx].saveNextInterval = FALSE;
   \   000003CA   0x2000             MOVS     R0,#+0
   \   000003CC   0x.... 0x....      LDR.W    R1,??DataTable32
   \   000003D0   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000003D4   0x2206             MOVS     R2,#+6
   \   000003D6   0xFB02 0x110A      MLA      R1,R2,R10,R1
   \   000003DA   0x7008             STRB     R0,[R1, #+0]
   3319              maDatasetInfo[tableEntryIdx].countsToNextSave = gNvCountsBetweenSaves_c;
   \   000003DC   0xF44F 0x7080      MOV      R0,#+256
   \   000003E0   0x.... 0x....      LDR.W    R1,??DataTable32
   \   000003E4   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000003E8   0x2206             MOVS     R2,#+6
   \   000003EA   0xFB02 0x110A      MLA      R1,R2,R10,R1
   \   000003EE   0x8088             STRH     R0,[R1, #+4]
   3320            }
   3321          
   3322            return status;
   \                     ??NvRestoreData_26: (+1)
   \   000003F0   0x4648             MOV      R0,R9
   \   000003F2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??NvRestoreData_1: (+1)
   \   000003F4   0xB005             ADD      SP,SP,#+20
   \   000003F6   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   3323          
   3324          #endif /* gNvUseFlexNVM_d */    
   3325          }
   3326          
   3327          
   3328          /******************************************************************************
   3329           * Name: NvGetTableEntryIndex
   3330           * Description: get the table entry index from the provided ID
   3331           * Parameter(s): [IN] entryId - the ID of the table entry
   3332           * Return: table entry index of gNvInvalidTableEntryIndex_c
   3333           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3334          static uint16_t NvGetTableEntryIndexFromId
   3335          (
   3336            NvTableEntryId_t entryId 
   3337          )
   3338          {
   \                     NvGetTableEntryIndexFromId: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   3339            uint16_t loopCnt = 0;
   \   00000002   0x2200             MOVS     R2,#+0
   3340          
   3341            while(gNvEndOfTableId_c != pNVM_DataTable[loopCnt].DataEntryID)
   \                     ??NvGetTableEntryIndexFromId_0: (+1)
   \   00000004   0x....             LDR.N    R0,??DataTable16
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000A   0x230C             MOVS     R3,#+12
   \   0000000C   0xFB03 0x0002      MLA      R0,R3,R2,R0
   \   00000010   0x8900             LDRH     R0,[R0, #+8]
   \   00000012   0xF64F 0x73FE      MOVW     R3,#+65534
   \   00000016   0x4298             CMP      R0,R3
   \   00000018   0xD00E             BEQ.N    ??NvGetTableEntryIndexFromId_1
   3342            {
   3343              if(pNVM_DataTable[loopCnt].DataEntryID == entryId)
   \   0000001A   0x....             LDR.N    R0,??DataTable16
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000020   0x230C             MOVS     R3,#+12
   \   00000022   0xFB03 0x0002      MLA      R0,R3,R2,R0
   \   00000026   0x8900             LDRH     R0,[R0, #+8]
   \   00000028   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD102             BNE.N    ??NvGetTableEntryIndexFromId_2
   3344              {
   3345                return loopCnt;
   \   0000002E   0x0010             MOVS     R0,R2
   \   00000030   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000032   0xE003             B.N      ??NvGetTableEntryIndexFromId_3
   3346              }
   3347              /* increment the loop counter */
   3348              loopCnt++;
   \                     ??NvGetTableEntryIndexFromId_2: (+1)
   \   00000034   0x1C52             ADDS     R2,R2,#+1
   \   00000036   0xE7E5             B.N      ??NvGetTableEntryIndexFromId_0
   3349            }
   3350            return gNvInvalidTableEntryIndex_c;
   \                     ??NvGetTableEntryIndexFromId_1: (+1)
   \   00000038   0xF64F 0x70FF      MOVW     R0,#+65535
   \                     ??NvGetTableEntryIndexFromId_3: (+1)
   \   0000003C   0x4770             BX       LR               ;; return
   3351          }
   3352          
   3353          
   3354          /******************************************************************************
   3355           * Name: NvAddSaveRequestToQueue
   3356           * Description: Add save request to save requests queue; if the request is 
   3357           *              already stored, ignore the current request  
   3358           * Parameter(s): [IN] ptrTblIdx - pointer to table index
   3359           * Return: gNVM_OK_c - if operation completed successfully
   3360           *         gNVM_SaveRequestRejected_c - if the request couldn't be queued         
   3361           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3362          static NVM_Status_t NvAddSaveRequestToQueue
   3363          (
   3364            NVM_TableEntryInfo_t* ptrTblIdx
   3365          )
   3366          {
   \                     NvAddSaveRequestToQueue: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   3367            uint8_t loopIdx;  
   3368            bool_t isQueued;
   3369          
   3370                
   3371            if(mNvPendingSavesQueue.EntriesCount == 0)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000008   0xF890 0x00C2      LDRB     R0,[R0, #+194]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD112             BNE.N    ??NvAddSaveRequestToQueue_0
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x0021             MOVS     R1,R4
   \   00000014   0x2206             MOVS     R2,#+6
   \   00000016   0x.... 0x....      BL       __aeabi_memcpy
   3372            {
   3373              /* add request to queue */
   3374              if(NvPushPendingSave(&mNvPendingSavesQueue, *ptrTblIdx))
   \   0000001A   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \   0000001E   0x000A             MOVS     R2,R1
   \   00000020   0x0001             MOVS     R1,R0
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000026   0x.... 0x....      BL       NvPushPendingSave
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD001             BEQ.N    ??NvAddSaveRequestToQueue_1
   3375              {        
   3376                return gNVM_OK_c;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xE06E             B.N      ??NvAddSaveRequestToQueue_2
   3377              }
   3378              return gNVM_SaveRequestRejected_c;
   \                     ??NvAddSaveRequestToQueue_1: (+1)
   \   00000032   0x2017             MOVS     R0,#+23
   \   00000034   0xE06C             B.N      ??NvAddSaveRequestToQueue_2
   3379            }
   3380          
   3381            isQueued = FALSE;
   \                     ??NvAddSaveRequestToQueue_0: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x0006             MOVS     R6,R0
   3382            
   3383            /* start from the queue's head */
   3384            loopIdx = mNvPendingSavesQueue.Head;  
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   0000003E   0xF890 0x00C0      LDRB     R0,[R0, #+192]
   \   00000042   0x0005             MOVS     R5,R0
   3385            
   3386            /* check if the request is not already stored in queue */
   3387            while(loopIdx != mNvPendingSavesQueue.Tail)
   \                     ??NvAddSaveRequestToQueue_3: (+1)
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000048   0xF890 0x00C1      LDRB     R0,[R0, #+193]
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x4285             CMP      R5,R0
   \   00000050   0xD047             BEQ.N    ??NvAddSaveRequestToQueue_4
   3388            {
   3389              if(ptrTblIdx->entryId == mNvPendingSavesQueue.QData[loopIdx].entryId)                
   \   00000052   0x8820             LDRH     R0,[R4, #+0]
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable32_1
   \   00000058   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005A   0x2206             MOVS     R2,#+6
   \   0000005C   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000060   0x8809             LDRH     R1,[R1, #+0]
   \   00000062   0x4288             CMP      R0,R1
   \   00000064   0xD139             BNE.N    ??NvAddSaveRequestToQueue_5
   3390              {   
   3391                if(mNvPendingSavesQueue.QData[loopIdx].saveRestoreAll == TRUE) /* full table entry already queued */
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   0000006A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000006C   0x2106             MOVS     R1,#+6
   \   0000006E   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000072   0x7900             LDRB     R0,[R0, #+4]
   \   00000074   0x2801             CMP      R0,#+1
   \   00000076   0xD102             BNE.N    ??NvAddSaveRequestToQueue_6
   3392                {
   3393                  /* request is already queued */
   3394                  isQueued = TRUE;
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x0006             MOVS     R6,R0
   3395                  break;
   \   0000007C   0xE031             B.N      ??NvAddSaveRequestToQueue_4
   3396                }
   3397          
   3398                /* single element from table entry is queued */
   3399                if(ptrTblIdx->saveRestoreAll == TRUE) /* a full table entry is requested to be saved */
   \                     ??NvAddSaveRequestToQueue_6: (+1)
   \   0000007E   0x7920             LDRB     R0,[R4, #+4]
   \   00000080   0x2801             CMP      R0,#+1
   \   00000082   0xD10A             BNE.N    ??NvAddSaveRequestToQueue_7
   3400                {
   3401                  /* update only the flag of the already queued request */
   3402                  mNvPendingSavesQueue.QData[loopIdx].saveRestoreAll = TRUE;
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable32_1
   \   0000008A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008C   0x2206             MOVS     R2,#+6
   \   0000008E   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000092   0x7108             STRB     R0,[R1, #+4]
   3403                  /* request is already queued */
   3404                  isQueued = TRUE;
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0x0006             MOVS     R6,R0
   3405                  break;
   \   00000098   0xE023             B.N      ??NvAddSaveRequestToQueue_4
   3406                }
   3407          
   3408                /* The request is for a single element and the queued request is also for a single element;
   3409                 * Check if the request is for the same element. If the request is for a different element, 
   3410                 * add the new request to queue.
   3411                 */
   3412                if(ptrTblIdx->elementIndex == mNvPendingSavesQueue.QData[loopIdx].elementIndex)
   \                     ??NvAddSaveRequestToQueue_7: (+1)
   \   0000009A   0x8860             LDRH     R0,[R4, #+2]
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable32_1
   \   000000A0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A2   0x2206             MOVS     R2,#+6
   \   000000A4   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   000000A8   0x8849             LDRH     R1,[R1, #+2]
   \   000000AA   0x4288             CMP      R0,R1
   \   000000AC   0xD102             BNE.N    ??NvAddSaveRequestToQueue_8
   3413                {
   3414                  /* request is already queued */
   3415                  isQueued = TRUE;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0x0006             MOVS     R6,R0
   3416                  break;
   \   000000B2   0xE016             B.N      ??NvAddSaveRequestToQueue_4
   3417                }
   \                     ??NvAddSaveRequestToQueue_8: (+1)
   \   000000B4   0xA800             ADD      R0,SP,#+0
   \   000000B6   0x0021             MOVS     R1,R4
   \   000000B8   0x2206             MOVS     R2,#+6
   \   000000BA   0x.... 0x....      BL       __aeabi_memcpy
   3418          
   3419                /* add request to queue */
   3420                if(NvPushPendingSave(&mNvPendingSavesQueue, *ptrTblIdx))
   \   000000BE   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \   000000C2   0x000A             MOVS     R2,R1
   \   000000C4   0x0001             MOVS     R1,R0
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   000000CA   0x.... 0x....      BL       NvPushPendingSave
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD001             BEQ.N    ??NvAddSaveRequestToQueue_9
   3421                {        
   3422                  return gNVM_OK_c;
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0xE01C             B.N      ??NvAddSaveRequestToQueue_2
   3423                }                                     
   3424                return gNVM_SaveRequestRejected_c;            
   \                     ??NvAddSaveRequestToQueue_9: (+1)
   \   000000D6   0x2017             MOVS     R0,#+23
   \   000000D8   0xE01A             B.N      ??NvAddSaveRequestToQueue_2
   3425              }
   3426              /* increment and wrap the loop index */    
   3427              loopIdx = (loopIdx + 1)  & ((uint8_t)(gNvPendigSavesQueueSize_c - 1));
   \                     ??NvAddSaveRequestToQueue_5: (+1)
   \   000000DA   0x1C68             ADDS     R0,R5,#+1
   \   000000DC   0xF010 0x051F      ANDS     R5,R0,#0x1F
   \   000000E0   0xE7B0             B.N      ??NvAddSaveRequestToQueue_3
   3428            }
   3429          
   3430            if(!isQueued)
   \                     ??NvAddSaveRequestToQueue_4: (+1)
   \   000000E2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000E4   0x2E00             CMP      R6,#+0
   \   000000E6   0xD112             BNE.N    ??NvAddSaveRequestToQueue_10
   \   000000E8   0xA800             ADD      R0,SP,#+0
   \   000000EA   0x0021             MOVS     R1,R4
   \   000000EC   0x2206             MOVS     R2,#+6
   \   000000EE   0x.... 0x....      BL       __aeabi_memcpy
   3431            {
   3432              /* push the request to save operation pending queue */
   3433              if(NvPushPendingSave(&mNvPendingSavesQueue, *ptrTblIdx))
   \   000000F2   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \   000000F6   0x000A             MOVS     R2,R1
   \   000000F8   0x0001             MOVS     R1,R0
   \   000000FA   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   000000FE   0x.... 0x....      BL       NvPushPendingSave
   \   00000102   0x2800             CMP      R0,#+0
   \   00000104   0xD001             BEQ.N    ??NvAddSaveRequestToQueue_11
   3434              {        
   3435                return gNVM_OK_c;
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0xE002             B.N      ??NvAddSaveRequestToQueue_2
   3436              }
   3437              return gNVM_SaveRequestRejected_c;
   \                     ??NvAddSaveRequestToQueue_11: (+1)
   \   0000010A   0x2017             MOVS     R0,#+23
   \   0000010C   0xE000             B.N      ??NvAddSaveRequestToQueue_2
   3438            }
   3439          
   3440            return gNVM_OK_c;
   \                     ??NvAddSaveRequestToQueue_10: (+1)
   \   0000010E   0x2000             MOVS     R0,#+0
   \                     ??NvAddSaveRequestToQueue_2: (+1)
   \   00000110   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   3441          }
   3442          
   3443          /******************************************************************************
   3444           * Name: NvIntervalTimerCallback
   3445           * Description: Callback function of the timer used by the NvSaveOnInterval()
   3446           * Parameter(s): [IN] timerID - timer ID
   3447           * Return: -
   3448           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3449          static void NvIntervalTimerCallback
   3450          (
   3451            tmrTimerID_t timerID
   3452          )
   3453          {
   3454            mNvSaveOnIntervalEvent = TRUE;
   \                     NvIntervalTimerCallback: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable32_2
   \   00000006   0x7011             STRB     R1,[R2, #+0]
   3455          }
   \   00000008   0x4770             BX       LR               ;; return
   3456          
   3457          /******************************************************************************
   3458           * Name: NvGetRandomRange
   3459           * Description: Returns a random number between 'low' and 'high'
   3460           * Parameter(s): [IN] low, high - generated number range
   3461           * Return: 0..255
   3462           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3463          static uint8_t NvGetRandomRange
   3464          (
   3465            uint8_t low, 
   3466            uint8_t high
   3467          )
   3468          {
   \                     NvGetRandomRange: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   3469            uint32_t random;
   3470          
   3471            RNG_GetRandomNo(&random);
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x.... 0x....      BL       RNG_GetRandomNo
   3472          
   3473            if(high <= low)
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x42AC             CMP      R4,R5
   \   00000012   0xD302             BCC.N    ??NvGetRandomRange_0
   3474            {
   3475              return low;
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0xE00B             B.N      ??NvGetRandomRange_1
   3476            }
   3477            return low + (uint8_t)(random % (high - low + 1));    
   \                     ??NvGetRandomRange_0: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x1B28             SUBS     R0,R5,R4
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0x9900             LDR      R1,[SP, #+0]
   \   00000024   0x1909             ADDS     R1,R1,R4
   \   00000026   0x9A00             LDR      R2,[SP, #+0]
   \   00000028   0xFBB2 0xF2F0      UDIV     R2,R2,R0
   \   0000002C   0xFB00 0x1012      MLS      R0,R0,R2,R1
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??NvGetRandomRange_1: (+1)
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3478          };
   3479          
   3480          #if (gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c != 0) /* FlexNVM */
   3481          /******************************************************************************
   3482           * Name: NvGetFlexLastMetaInfo
   3483           * Description: Get FlexRAM last meta information address 
   3484           * Parameter(s): -
   3485           * Return: the address of the last valid meta information       
   3486           ******************************************************************************/
   3487          static uint32_t NvGetFlexLastMetaInfo
   3488          (
   3489            void
   3490          )
   3491          {
   3492            uint32_t address, size;
   3493            NVM_FlexMetaInfo_t flexMetaInfo;
   3494          
   3495            address = mNvConfig.EERAMBlockBase;
   3496            size = mNvConfig.EEEBlockSize;
   3497          
   3498            while(size)
   3499            {
   3500              /* wait for EEPROM system to be ready */
   3501              while(!(gNV_REG_READ(mNvConfig.ftfxRegBase + gNV_FCNFG_OFFSET_c) & gNV_FCNFG_EEERDY_c)); 
   3502              /* read meta info tag */
   3503              NV_FlashRead(address, (uint8_t*)&flexMetaInfo, sizeof(flexMetaInfo));
   3504              if(flexMetaInfo.rawValue == gNvFlexGuardValue_c)
   3505              {    
   3506                break;
   3507              }
   3508              address += sizeof(flexMetaInfo);
   3509              size -= sizeof(flexMetaInfo);
   3510            }  
   3511            return address - sizeof(flexMetaInfo);  
   3512          }
   3513          
   3514          /******************************************************************************
   3515           * Name: NvGetFlexMetaInfoFromId
   3516           * Description: Get FlexRAM meta information tag from table entry ID 
   3517           * Parameter(s): [IN] tblEntryId - table entry ID
   3518           *               [OUT] pMetaInfo - a pointer to a memory location where the
   3519           *                                 meta information tag will be stored
   3520           * Return: -
   3521           ******************************************************************************/
   3522          static void NvGetFlexMetaInfoFromId
   3523          (
   3524            NvTableEntryId_t tblEntryId,
   3525            NVM_FlexMetaInfo_t* pMetaInfo
   3526          )
   3527          {
   3528            uint32_t address, size;
   3529            NVM_FlexMetaInfo_t flexMetaInfo;
   3530          
   3531            address = mNvConfig.EERAMBlockBase;
   3532            size = mNvConfig.EEEBlockSize;
   3533          
   3534            while(size)
   3535            {
   3536              /* wait for EEPROM system to be ready */
   3537              while(!(gNV_REG_READ(mNvConfig.ftfxRegBase + gNV_FCNFG_OFFSET_c) & gNV_FCNFG_EEERDY_c));
   3538          
   3539              NV_FlashRead(address, (uint8_t*)&flexMetaInfo, sizeof(flexMetaInfo));
   3540              if(flexMetaInfo.rawValue == gNvFlexGuardValue_c)
   3541              {
   3542                break;
   3543              }
   3544          
   3545              if(flexMetaInfo.fields.NvDataEntryID == tblEntryId)
   3546              {
   3547                pMetaInfo->fields.NvDataEntryID = flexMetaInfo.fields.NvDataEntryID;
   3548                pMetaInfo->fields.NvDataOffset = flexMetaInfo.fields.NvDataOffset;
   3549                return;
   3550              }
   3551          
   3552              address += sizeof(flexMetaInfo);
   3553              size -= sizeof(flexMetaInfo);
   3554            }
   3555          
   3556            pMetaInfo->rawValue = gNvFlexGuardValue_c;
   3557          }
   3558          
   3559          /******************************************************************************
   3560           * Name: NvCheckNvmTableForFlexRAMUsage
   3561           * Description: Check if the existing NVM table fits within the FlexRAM window 
   3562           * Parameter(s): -
   3563           * Return: gNVM_NvTableExceedFlexRAMSize_c - the table exceed the size of
   3564           *                                           FlexRAM window
   3565           *         gNVM_OK_c - the table fits within the size of window FlexRAM window                                  
   3566           ******************************************************************************/
   3567          static NVM_Status_t NvCheckNvmTableForFlexRAMUsage
   3568          (
   3569            void
   3570          )
   3571          {
   3572            index_t loopCnt = 0;
   3573            uint32_t allDatasetSize = 0;    
   3574          
   3575            while(gNvEndOfTableId_c != pNVM_DataTable[loopCnt].DataEntryID)
   3576            {
   3577              if(gNvInvalidDataEntry_c == pNVM_DataTable[loopCnt].DataEntryID)
   3578              {
   3579                loopCnt++;
   3580                continue;
   3581              }  
   3582              /* add the record size */
   3583              allDatasetSize += (pNVM_DataTable[loopCnt].ElementsCount * pNVM_DataTable[loopCnt].ElementSize);
   3584              /* add the meta size */
   3585              allDatasetSize += sizeof(NVM_FlexMetaInfo_t);
   3586              /* increment the loop counter */
   3587              loopCnt++;
   3588            }
   3589          
   3590            /* add the safe guard space (equal to meta size) */
   3591            allDatasetSize += sizeof(NVM_FlexMetaInfo_t);
   3592          
   3593            if(allDatasetSize > mNvConfig.EEEBlockSize)
   3594            {
   3595              return gNVM_NvTableExceedFlexRAMSize_c;  
   3596            }  
   3597          
   3598            return gNVM_OK_c;
   3599          }
   3600          
   3601          #endif /* gNvUseFlexNVM_d */
   3602          
   3603          #endif /* gNvStorageIncluded_d */
   3604          
   3605          
   3606          
   3607          /*****************************************************************************
   3608           *****************************************************************************
   3609           * Public functions
   3610           *****************************************************************************
   3611           *****************************************************************************/
   3612          
   3613          
   3614          /******************************************************************************
   3615           * Name: NvModuleInit
   3616           * Description: Initialize the NV storage module
   3617           * Parameter(s): -
   3618           * Return: gNVM_ModuleAlreadyInitialized_c - if the module is already 
   3619           *                                           initialized
   3620           *         gNVM_InvalidSectorsCount_c - if the sector count configured in the
   3621           *                                      project linker file is invalid
   3622           *         gNVM_MetaNotFound_c - if no meta information was found                                       
   3623           *         gNVM_OK_c - module was successfully initialized
   3624           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3625          NVM_Status_t NvModuleInit
   3626          (
   3627            void
   3628          )
   3629          {
   \                     NvModuleInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   3630          #if gNvStorageIncluded_d
   3631          
   3632            index_t loopCnt;
   3633          #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */
   3634          #if gNvUseExtendedFeatureSet_d
   3635            uint32_t pageCounterValue;
   3636          #endif /* gNvUseExtendedFeatureSet_d */
   3637          #endif    
   3638            bool_t  eot = FALSE; /* end of table marker flag */
   \   00000002   0x2500             MOVS     R5,#+0
   3639          
   3640            if(mNvModuleInitialized)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable32_3
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD001             BEQ.N    ??NvModuleInit_0
   3641            {
   3642              return gNVM_ModuleAlreadyInitialized_c;
   \   0000000E   0x2010             MOVS     R0,#+16
   \   00000010   0xE0BB             B.N      ??NvModuleInit_1
   3643            }
   3644          
   3645          #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */    
   3646            /* check linker file symbol definition for sector count; it should be multiple of 2 */
   3647            if((uint32_t)((uint8_t*) NV_STORAGE_MAX_SECTORS) >> 1 != (uint32_t)((uint8_t*) NV_STORAGE_MAX_SECTORS) - 
   3648                ((uint32_t)((uint8_t*) NV_STORAGE_MAX_SECTORS) >> 1))
   \                     ??NvModuleInit_0: (+1)
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable32_4
   \   00000016   0x0840             LSRS     R0,R0,#+1
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable32_4
   \   0000001C   0x.... 0x....      LDR.W    R2,??DataTable32_4
   \   00000020   0xEBB1 0x0152      SUBS     R1,R1,R2, LSR #+1
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD001             BEQ.N    ??NvModuleInit_2
   3649            {
   3650              return gNVM_InvalidSectorsCount_c;
   \   00000028   0x2008             MOVS     R0,#+8
   \   0000002A   0xE0AE             B.N      ??NvModuleInit_1
   3651            }
   3652          #endif
   3653          
   3654          /* check the RAM table to have 'End-Of-Table' terminator */
   3655            for(loopCnt = 0; loopCnt < (index_t)gNvTableEntriesCountMax_c; loopCnt++)
   \                     ??NvModuleInit_2: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x0004             MOVS     R4,R0
   \                     ??NvModuleInit_3: (+1)
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x2C20             CMP      R4,#+32
   \   00000034   0xDA18             BGE.N    ??NvModuleInit_4
   3656            {
   3657              if((NULL == pNVM_DataTable[loopCnt].pData) && (gNvEndOfTableId_c == pNVM_DataTable[loopCnt].DataEntryID))
   \   00000036   0x....             LDR.N    R0,??DataTable24
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003C   0x210C             MOVS     R1,#+12
   \   0000003E   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD10D             BNE.N    ??NvModuleInit_5
   \   00000048   0x....             LDR.N    R0,??DataTable24
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004E   0x210C             MOVS     R1,#+12
   \   00000050   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000054   0x8900             LDRH     R0,[R0, #+8]
   \   00000056   0xF64F 0x71FE      MOVW     R1,#+65534
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD102             BNE.N    ??NvModuleInit_5
   3658              {
   3659                eot = TRUE;
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0x0005             MOVS     R5,R0
   3660                break;
   \   00000062   0xE001             B.N      ??NvModuleInit_4
   3661              }
   3662            }    
   \                     ??NvModuleInit_5: (+1)
   \   00000064   0x1C64             ADDS     R4,R4,#+1
   \   00000066   0xE7E3             B.N      ??NvModuleInit_3
   3663            if(!eot)
   \                     ??NvModuleInit_4: (+1)
   \   00000068   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000006A   0x2D00             CMP      R5,#+0
   \   0000006C   0xD101             BNE.N    ??NvModuleInit_6
   3664            {
   3665              return gNVM_MissingEndOfTableMarker_c;
   \   0000006E   0x2019             MOVS     R0,#+25
   \   00000070   0xE08B             B.N      ??NvModuleInit_1
   3666            }
   3667          
   3668          #if (gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c != 0) /* FlexNVM */    
   3669            /* check if the NVM table fits within the size of the FlexRAM window */
   3670            if(gNVM_OK_c != NvCheckNvmTableForFlexRAMUsage())
   3671            {
   3672              return gNVM_NvTableExceedFlexRAMSize_c;
   3673            }    
   3674          #endif /* FlexNVM */
   3675          
   3676          #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */    
   3677            /* avoid compiler warnings, only sizeof(mNvTableMarker) is required in this code */
   3678          #if gNvUseExtendedFeatureSet_d
   3679            (void)mNvTableMarker;
   3680          #endif /* gNvUseExtendedFeatureSet_d */
   3681          #endif /* no FlexNVM */
   3682          
   3683            /* Initialize flash HAL driver */
   3684            NV_FlashInit(&mNvConfig);
   \                     ??NvModuleInit_6: (+1)
   \   00000072   0x....             LDR.N    R0,??DataTable21
   \   00000074   0x.... 0x....      BL       NV_FlashInit
   3685          
   3686          #if (gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c != 0)  /* FlexNVM */
   3687          
   3688            /* check data flash IFR map */
   3689            if(mNvConfig.EEEBlockSize == 0)
   3690            {
   3691              return gNVM_NvWrongFlashDataIFRMap_c;
   3692            }
   3693          
   3694            /* Enable the EERAM */
   3695            NV_SetEEEEnable(&mNvConfig, gNV_FLEXRAM_FNC_CTRL_CODE);
   3696          
   3697          #else /* no FlexNVM */   
   3698          
   3699            /* Initialize the active page ID */
   3700            mNvActivePageId = gVirtualPageNone_c;
   \   00000078   0x2002             MOVS     R0,#+2
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable32_5
   \   0000007E   0x7008             STRB     R0,[R1, #+0]
   3701          
   3702            /* First virtual page initialisation */
   3703            mNvVirtualPageProperty[gFirstVirtualPage_c].NvRawSectorStartAddress = (uint32_t)((uint8_t*)NV_STORAGE_END_ADDRESS);
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable32_6
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable28
   \   00000088   0x6008             STR      R0,[R1, #+0]
   3704            mNvVirtualPageProperty[gFirstVirtualPage_c].NvRawSectorsCount = (uint32_t)((uint8_t*) NV_STORAGE_MAX_SECTORS) >> 1;
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable32_4
   \   0000008E   0x0840             LSRS     R0,R0,#+1
   \   00000090   0x.... 0x....      LDR.W    R1,??DataTable28
   \   00000094   0x7208             STRB     R0,[R1, #+8]
   3705            mNvVirtualPageProperty[gFirstVirtualPage_c].NvTotalPageSize = mNvVirtualPageProperty[gFirstVirtualPage_c].NvRawSectorsCount * 
   3706                (uint32_t)((uint8_t*)NV_STORAGE_SECTOR_SIZE);
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable28
   \   0000009A   0x7A00             LDRB     R0,[R0, #+8]
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable32_7
   \   000000A0   0x4348             MULS     R0,R1,R0
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable28
   \   000000A6   0x60C8             STR      R0,[R1, #+12]
   3707            mNvVirtualPageProperty[gFirstVirtualPage_c].NvRawSectorEndAddress = mNvVirtualPageProperty[gFirstVirtualPage_c].NvRawSectorStartAddress + 
   3708                mNvVirtualPageProperty[gFirstVirtualPage_c].NvTotalPageSize - 1;
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable28
   \   000000AC   0x6800             LDR      R0,[R0, #+0]
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable28
   \   000000B2   0x68C9             LDR      R1,[R1, #+12]
   \   000000B4   0x1808             ADDS     R0,R1,R0
   \   000000B6   0x1E40             SUBS     R0,R0,#+1
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable28
   \   000000BC   0x6048             STR      R0,[R1, #+4]
   3709          
   3710            /* Second virtual page initialisation */
   3711            mNvVirtualPageProperty[gSecondVirtualPage_c].NvRawSectorStartAddress = mNvVirtualPageProperty[gFirstVirtualPage_c].NvRawSectorEndAddress + 1;
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable28
   \   000000C2   0x6840             LDR      R0,[R0, #+4]
   \   000000C4   0x1C40             ADDS     R0,R0,#+1
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable28
   \   000000CA   0x6148             STR      R0,[R1, #+20]
   3712            mNvVirtualPageProperty[gSecondVirtualPage_c].NvRawSectorsCount = (uint32_t)((uint8_t*) NV_STORAGE_MAX_SECTORS) >> 1;
   \   000000CC   0x.... 0x....      LDR.W    R0,??DataTable32_4
   \   000000D0   0x0840             LSRS     R0,R0,#+1
   \   000000D2   0x.... 0x....      LDR.W    R1,??DataTable28
   \   000000D6   0x7708             STRB     R0,[R1, #+28]
   3713            mNvVirtualPageProperty[gSecondVirtualPage_c].NvTotalPageSize = mNvVirtualPageProperty[gSecondVirtualPage_c].NvRawSectorsCount * 
   3714                (uint32_t)((uint8_t*)NV_STORAGE_SECTOR_SIZE);
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable28
   \   000000DC   0x7F00             LDRB     R0,[R0, #+28]
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable32_7
   \   000000E2   0x4348             MULS     R0,R1,R0
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable28
   \   000000E8   0x6208             STR      R0,[R1, #+32]
   3715            mNvVirtualPageProperty[gSecondVirtualPage_c].NvRawSectorEndAddress = mNvVirtualPageProperty[gSecondVirtualPage_c].NvRawSectorStartAddress + 
   3716                mNvVirtualPageProperty[gSecondVirtualPage_c].NvTotalPageSize - 1;
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable28
   \   000000EE   0x6940             LDR      R0,[R0, #+20]
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable28
   \   000000F4   0x6A09             LDR      R1,[R1, #+32]
   \   000000F6   0x1808             ADDS     R0,R1,R0
   \   000000F8   0x1E40             SUBS     R0,R0,#+1
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable28
   \   000000FE   0x6188             STR      R0,[R1, #+24]
   3717          
   3718            /* no pending erase operations on system initialisation */
   3719            mNvErasePgCmdStatus.NvErasePending = FALSE;
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x.... 0x....      LDR.W    R1,??DataTable32_8
   \   00000106   0x7008             STRB     R0,[R1, #+0]
   3720          
   3721            /* at init, no table entries are to be skipped when copy */
   3722          #if gNvUseExtendedFeatureSet_d  
   3723            mNvSkipTableEntryId = gNvCopyAll_c;
   3724          #endif /* #if gNvUseExtendedFeatureSet_d */
   3725          
   3726            /* Initialize the storage system: get active page and page counter */
   3727            NvInitStorageSystem();
   \   00000108   0x.... 0x....      BL       NvInitStorageSystem
   3728          
   3729          #endif
   3730          
   3731            /* Initialize the pending saves queue */
   3732            NvInitPendingSavesQueue(&mNvPendingSavesQueue);
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000110   0x.... 0x....      BL       NvInitPendingSavesQueue
   3733          
   3734            /* Initialize the data set info table */
   3735            for(loopCnt = 0; loopCnt < (index_t)gNvTableEntriesCountMax_c; loopCnt++)
   \   00000114   0x2000             MOVS     R0,#+0
   \   00000116   0x0004             MOVS     R4,R0
   \                     ??NvModuleInit_7: (+1)
   \   00000118   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000011A   0x2C20             CMP      R4,#+32
   \   0000011C   0xDA13             BGE.N    ??NvModuleInit_8
   3736            {      
   3737              maDatasetInfo[loopCnt].saveNextInterval = FALSE;
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0x.... 0x....      LDR.W    R1,??DataTable32
   \   00000124   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000126   0x2206             MOVS     R2,#+6
   \   00000128   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000012C   0x7008             STRB     R0,[R1, #+0]
   3738              maDatasetInfo[loopCnt].countsToNextSave = gNvCountsBetweenSaves;
   \   0000012E   0x.... 0x....      LDR.W    R0,??DataTable32_9
   \   00000132   0x8800             LDRH     R0,[R0, #+0]
   \   00000134   0x.... 0x....      LDR.W    R1,??DataTable32
   \   00000138   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000013A   0x2206             MOVS     R2,#+6
   \   0000013C   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000140   0x8088             STRH     R0,[R1, #+4]
   3739            }
   \   00000142   0x1C64             ADDS     R4,R4,#+1
   \   00000144   0xE7E8             B.N      ??NvModuleInit_7
   3740          
   3741            /* initialize the event used by save-on-interval functionality */
   3742            mNvSaveOnIntervalEvent = FALSE;
   \                     ??NvModuleInit_8: (+1)
   \   00000146   0x2000             MOVS     R0,#+0
   \   00000148   0x.... 0x....      LDR.W    R1,??DataTable32_2
   \   0000014C   0x7008             STRB     R0,[R1, #+0]
   3743          
   3744            /* initialize the timer used by the save-on-interval functionality */
   3745            mNvSaveOnIntervalTimerID = gTmrInvalidTimerID_c; 
   \   0000014E   0x20FF             MOVS     R0,#+255
   \   00000150   0x.... 0x....      LDR.W    R1,??DataTable32_10
   \   00000154   0x7008             STRB     R0,[R1, #+0]
   3746          
   3747          #if (gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c != 0) /* FlexNVM */
   3748          
   3749            /* NVM module is now initialized */
   3750            mNvModuleInitialized = TRUE;
   3751            return gNVM_OK_c;
   3752          
   3753          #else /* no FlexNVM */
   3754          
   3755          #if gNvUseExtendedFeatureSet_d  
   3756            /* get the size of the NV table stored in RAM memory */
   3757            mNvTableSizeInRAM = NvGetTableSize(gRAMTable_c);
   3758            /* get the size of the NV table stored in FLASH memory */
   3759            mNvTableSizeInFlash = NvGetTableSize(gFLASHTable_c);
   3760          
   3761            if(0 == mNvTableSizeInFlash) /* no NV table found in FLASH, format the system */
   3762            {
   3763              NV_FlashRead(mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress,
   3764                  (uint8_t*)&pageCounterValue, sizeof(pageCounterValue));
   3765              NvInternalFormat(pageCounterValue); /* will also save the NV table to FLASH memory */
   3766            }
   3767            else /* found an valid NV table in FLASH memory */
   3768            {
   3769              mNvTableUpdated = FALSE;
   3770          
   3771              /* check if the RAM table was updated (e.g. new binary image via OTAP) */
   3772              if((mNvTableUpdated = NvIsRamTableUpdated()) == TRUE)
   3773              {
   3774                if(gNV_OK_c == NvGetLastMetaInfoAddress())
   3775                {       
   3776                  /* copy the new RAM table and the page content */    	  
   3777                  (void)NvCopyPage(gNvCopyAll_c);
   3778                  /* NVM module is now initialised */
   3779                  mNvModuleInitialized = TRUE;          
   3780                  return gNVM_OK_c;
   3781                }
   3782          
   3783                /* format the system */
   3784                if(gNVM_OK_c == NvInternalFormat(0))
   3785                {     
   3786                  if(gNV_OK_c == NvGetLastMetaInfoAddress())
   3787                  {       
   3788                    /* NVM module is now initialised */
   3789                    mNvModuleInitialized = TRUE;
   3790                    return gNVM_OK_c;
   3791                  }
   3792                }
   3793                return gNVM_FormatFailure_c;
   3794              }      
   3795            }
   3796          #endif /* gNvUseExtendedFeatureSet_d */
   3797          
   3798            /* get the last meta information address */
   3799            if(gNV_OK_c == NvGetLastMetaInfoAddress())
   \   00000156   0x.... 0x....      BL       NvGetLastMetaInfoAddress
   \   0000015A   0x2800             CMP      R0,#+0
   \   0000015C   0xD105             BNE.N    ??NvModuleInit_9
   3800            {       
   3801              /* NVM module is now initialized */
   3802              mNvModuleInitialized = TRUE;
   \   0000015E   0x2001             MOVS     R0,#+1
   \   00000160   0x.... 0x....      LDR.W    R1,??DataTable32_3
   \   00000164   0x7008             STRB     R0,[R1, #+0]
   3803              return gNVM_OK_c;
   \   00000166   0x2000             MOVS     R0,#+0
   \   00000168   0xE00F             B.N      ??NvModuleInit_1
   3804            }
   3805          
   3806            /* format the system */
   3807            if(gNVM_OK_c == NvInternalFormat(0))
   \                     ??NvModuleInit_9: (+1)
   \   0000016A   0x2000             MOVS     R0,#+0
   \   0000016C   0x.... 0x....      BL       NvInternalFormat
   \   00000170   0x2800             CMP      R0,#+0
   \   00000172   0xD109             BNE.N    ??NvModuleInit_10
   3808            {     
   3809              if(gNV_OK_c == NvGetLastMetaInfoAddress())
   \   00000174   0x.... 0x....      BL       NvGetLastMetaInfoAddress
   \   00000178   0x2800             CMP      R0,#+0
   \   0000017A   0xD105             BNE.N    ??NvModuleInit_10
   3810              {       
   3811                /* NVM module is now initialised */
   3812                mNvModuleInitialized = TRUE;
   \   0000017C   0x2001             MOVS     R0,#+1
   \   0000017E   0x.... 0x....      LDR.W    R1,??DataTable32_3
   \   00000182   0x7008             STRB     R0,[R1, #+0]
   3813                return gNVM_OK_c;
   \   00000184   0x2000             MOVS     R0,#+0
   \   00000186   0xE000             B.N      ??NvModuleInit_1
   3814              }
   3815            }
   3816          
   3817            return gNVM_FormatFailure_c;
   \                     ??NvModuleInit_10: (+1)
   \   00000188   0x2013             MOVS     R0,#+19
   \                     ??NvModuleInit_1: (+1)
   \   0000018A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3818          
   3819          #endif /* no FlexNVM */
   3820          
   3821          #else
   3822            return gNVM_Error_c;
   3823          #endif /* #if gNvStorageIncluded_d */
   3824          
   3825          }
   3826          
   3827          
   3828          /******************************************************************************
   3829           * Name: NvSaveOnIdle
   3830           * Description: Save the data pointed by ptrData on the next call to NvIdle()
   3831           * Parameter(s): [IN] ptrData - pointer to data to be saved
   3832           *               [IN] saveRestoreAll - specify if all the elements from the NVM table
   3833           *                              entry shall be saved
   3834           * Return: gNVM_OK_c - if operation completed successfully
   3835           *         gNVM_Error_c - in case of error(s)
   3836           *         Note: see also return codes of NvGetEntryFromDataPtr() function         
   3837           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3838          NVM_Status_t NvSaveOnIdle
   3839          (
   3840            void* ptrData,
   3841            bool_t saveAll
   3842          )
   3843          {    
   \                     NvSaveOnIdle: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   3844          #if gNvStorageIncluded_d    
   3845            NVM_Status_t status;
   3846            NVM_TableEntryInfo_t tblIdx;
   3847          
   3848            if(!mNvModuleInitialized)
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable32_3
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD101             BNE.N    ??NvSaveOnIdle_0
   3849            {
   3850              return gNVM_ModuleNotInitialized_c;
   \   00000010   0x200E             MOVS     R0,#+14
   \   00000012   0xE01C             B.N      ??NvSaveOnIdle_1
   3851            }
   3852          
   3853            if(NULL == ptrData)
   \                     ??NvSaveOnIdle_0: (+1)
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD101             BNE.N    ??NvSaveOnIdle_2
   3854            {
   3855              return gNVM_NullPointer_c;
   \   00000018   0x2005             MOVS     R0,#+5
   \   0000001A   0xE018             B.N      ??NvSaveOnIdle_1
   3856            }
   3857          
   3858            /* get the NVM table entry */
   3859            if((status = NvGetEntryFromDataPtr(ptrData, &tblIdx)) != gNVM_OK_c)
   \                     ??NvSaveOnIdle_2: (+1)
   \   0000001C   0xA900             ADD      R1,SP,#+0
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       NvGetEntryFromDataPtr
   \   00000024   0x0006             MOVS     R6,R0
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD002             BEQ.N    ??NvSaveOnIdle_3
   3860            {
   3861              return status;
   \   0000002C   0x0030             MOVS     R0,R6
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0xE00D             B.N      ??NvSaveOnIdle_1
   3862            }
   3863          
   3864            if(gNvInvalidDataEntry_c == tblIdx.entryId)
   \                     ??NvSaveOnIdle_3: (+1)
   \   00000032   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000036   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000003A   0x4288             CMP      R0,R1
   \   0000003C   0xD101             BNE.N    ??NvSaveOnIdle_4
   3865            {
   3866              return gNVM_InvalidTableEntry_c;
   \   0000003E   0x2009             MOVS     R0,#+9
   \   00000040   0xE005             B.N      ??NvSaveOnIdle_1
   3867            }
   3868          
   3869            /* write the save all flag */
   3870          #if gNvFragmentation_Enabled_d    
   3871            tblIdx.saveRestoreAll = saveAll;
   3872          #else
   3873            tblIdx.saveRestoreAll = TRUE;
   \                     ??NvSaveOnIdle_4: (+1)
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xF88D 0x0004      STRB     R0,[SP, #+4]
   3874          #endif /* gNvFragmentation_Enabled_d */
   3875          
   3876            return NvAddSaveRequestToQueue(&tblIdx);
   \   00000048   0xA800             ADD      R0,SP,#+0
   \   0000004A   0x.... 0x....      BL       NvAddSaveRequestToQueue
   \                     ??NvSaveOnIdle_1: (+1)
   \   0000004E   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   3877          
   3878          #else
   3879            (void)ptrData;
   3880            (void)saveAll;
   3881            return gNVM_Error_c;
   3882          #endif /* # gNvStorageIncluded_d */
   3883          }
   3884          
   3885          /******************************************************************************
   3886           * Name: NvSaveOnInterval
   3887           * Description:  save no more often than a given time interval. If it has 
   3888           *               been at least that long since the last save,
   3889           *               this function will cause a save the next time the idle 
   3890           *               task runs.
   3891           * Parameters: [IN] ptrData - pointer to data to be saved
   3892           * NOTE: this function saves all the element of the table entry pointed by
   3893           *       ptrData 
   3894           * Return: NVM_OK_c - if operation completed successfully
   3895           *         Note: see also return codes of NvGetEntryFromDataPtr() function 
   3896           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3897          NVM_Status_t NvSaveOnInterval
   3898          (
   3899            void* ptrData
   3900          )
   3901          {
   \                     NvSaveOnInterval: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   3902          #if gNvStorageIncluded_d
   3903          
   3904            NVM_Status_t status;
   3905            NVM_TableEntryInfo_t tblIdx;
   3906            uint16_t tableEntryIdx;
   3907          
   3908            if(!mNvModuleInitialized)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable32_3
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??NvSaveOnInterval_0
   3909            {
   3910              return gNVM_ModuleNotInitialized_c;
   \   0000000E   0x200E             MOVS     R0,#+14
   \   00000010   0xE054             B.N      ??NvSaveOnInterval_1
   3911            }
   3912          
   3913            if(NULL == ptrData)
   \                     ??NvSaveOnInterval_0: (+1)
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD101             BNE.N    ??NvSaveOnInterval_2
   3914            {
   3915              return gNVM_NullPointer_c;
   \   00000016   0x2005             MOVS     R0,#+5
   \   00000018   0xE050             B.N      ??NvSaveOnInterval_1
   3916            }
   3917          
   3918            if(gTmrInvalidTimerID_c == mNvSaveOnIntervalTimerID)
   \                     ??NvSaveOnInterval_2: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable32_10
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x28FF             CMP      R0,#+255
   \   00000022   0xD10B             BNE.N    ??NvSaveOnInterval_3
   3919            {
   3920              /* try to allocate the timer used by the save-on-interval functionality */      
   3921              mNvSaveOnIntervalTimerID = TMR_AllocateTimer();
   \   00000024   0x.... 0x....      BL       TMR_AllocateTimer
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable32_10
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
   3922          
   3923              if(gTmrInvalidTimerID_c == mNvSaveOnIntervalTimerID)
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable32_10
   \   00000032   0x7800             LDRB     R0,[R0, #+0]
   \   00000034   0x28FF             CMP      R0,#+255
   \   00000036   0xD101             BNE.N    ??NvSaveOnInterval_3
   3924              {
   3925                return gNVM_InvalidTimerID_c;
   \   00000038   0x2018             MOVS     R0,#+24
   \   0000003A   0xE03F             B.N      ??NvSaveOnInterval_1
   3926              }
   3927            }
   3928          
   3929            /* get the NVM table entry */
   3930            if((status = NvGetEntryFromDataPtr(ptrData, &tblIdx)) != gNVM_OK_c)
   \                     ??NvSaveOnInterval_3: (+1)
   \   0000003C   0xA900             ADD      R1,SP,#+0
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       NvGetEntryFromDataPtr
   \   00000044   0x0005             MOVS     R5,R0
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD002             BEQ.N    ??NvSaveOnInterval_4
   3931            {
   3932              return status;
   \   0000004C   0x0028             MOVS     R0,R5
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0xE034             B.N      ??NvSaveOnInterval_1
   3933            }
   3934          
   3935            if(gNvInvalidDataEntry_c == tblIdx.entryId)
   \                     ??NvSaveOnInterval_4: (+1)
   \   00000052   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000056   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD101             BNE.N    ??NvSaveOnInterval_5
   3936            {
   3937              return gNVM_InvalidTableEntry_c;
   \   0000005E   0x2009             MOVS     R0,#+9
   \   00000060   0xE02C             B.N      ??NvSaveOnInterval_1
   3938            }
   3939          
   3940            tableEntryIdx = NvGetTableEntryIndexFromId(tblIdx.entryId);
   \                     ??NvSaveOnInterval_5: (+1)
   \   00000062   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000066   0x.... 0x....      BL       NvGetTableEntryIndexFromId
   \   0000006A   0x0006             MOVS     R6,R0
   3941          
   3942            if(gNvInvalidTableEntryIndex_c == tableEntryIdx)
   \   0000006C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000006E   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000072   0x4286             CMP      R6,R0
   \   00000074   0xD101             BNE.N    ??NvSaveOnInterval_6
   3943            {
   3944              return gNVM_InvalidTableEntry_c;
   \   00000076   0x2009             MOVS     R0,#+9
   \   00000078   0xE020             B.N      ??NvSaveOnInterval_1
   3945            }
   3946          
   3947            if(maDatasetInfo[tableEntryIdx].saveNextInterval == FALSE)
   \                     ??NvSaveOnInterval_6: (+1)
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000007E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000080   0x2106             MOVS     R1,#+6
   \   00000082   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00000086   0x7800             LDRB     R0,[R0, #+0]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD115             BNE.N    ??NvSaveOnInterval_7
   3948            {
   3949              maDatasetInfo[tableEntryIdx].ticksToNextSave = gNvMinimumTicksBetweenSaves;
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable32_11
   \   00000090   0x8800             LDRH     R0,[R0, #+0]
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable32
   \   00000096   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000098   0x2206             MOVS     R2,#+6
   \   0000009A   0xFB02 0x1106      MLA      R1,R2,R6,R1
   \   0000009E   0x8048             STRH     R0,[R1, #+2]
   3950              maDatasetInfo[tableEntryIdx].saveNextInterval = TRUE;
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable32
   \   000000A6   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000A8   0x2206             MOVS     R2,#+6
   \   000000AA   0xFB02 0x1106      MLA      R1,R2,R6,R1
   \   000000AE   0x7008             STRB     R0,[R1, #+0]
   3951              mNvSaveOnIntervalEvent = TRUE;
   \   000000B0   0x2001             MOVS     R0,#+1
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable32_2
   \   000000B6   0x7008             STRB     R0,[R1, #+0]
   3952            }
   3953          
   3954            return status;
   \                     ??NvSaveOnInterval_7: (+1)
   \   000000B8   0x0028             MOVS     R0,R5
   \   000000BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??NvSaveOnInterval_1: (+1)
   \   000000BC   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   3955          #else    
   3956            (void)ptrData;
   3957            return gNVM_Error_c;
   3958          #endif
   3959          }                                       /* NvSaveOnInterval() */
   3960          
   3961          
   3962          /******************************************************************************
   3963           * Name: NvSaveOnCount
   3964           * Description: Decrement the counter. Once it reaches 0, the next call to 
   3965           *              NvIdle() will save the entire table entry (all elements).
   3966           * Parameters: [IN] ptrData - pointer to data to be saved
   3967           * Return: NVM_OK_c - if operation completed successfully
   3968           *         Note: see also return codes of NvGetEntryFromDataPtr() function 
   3969           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3970          NVM_Status_t NvSaveOnCount
   3971          (
   3972            void* ptrData
   3973          )
   3974          {
   \                     NvSaveOnCount: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   3975          #if gNvStorageIncluded_d
   3976          
   3977            NVM_Status_t status;
   3978            NVM_TableEntryInfo_t tblIdx;
   3979            uint16_t tableEntryIdx;
   3980          
   3981            if(!mNvModuleInitialized)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable32_3
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??NvSaveOnCount_0
   3982            {
   3983              return gNVM_ModuleNotInitialized_c;
   \   0000000E   0x200E             MOVS     R0,#+14
   \   00000010   0xE044             B.N      ??NvSaveOnCount_1
   3984            }
   3985          
   3986            if(NULL == ptrData)
   \                     ??NvSaveOnCount_0: (+1)
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD101             BNE.N    ??NvSaveOnCount_2
   3987            {
   3988              return gNVM_NullPointer_c;
   \   00000016   0x2005             MOVS     R0,#+5
   \   00000018   0xE040             B.N      ??NvSaveOnCount_1
   3989            }
   3990          
   3991            /* get the NVM table entry */
   3992            if((status = NvGetEntryFromDataPtr(ptrData, &tblIdx)) != gNVM_OK_c)
   \                     ??NvSaveOnCount_2: (+1)
   \   0000001A   0xA900             ADD      R1,SP,#+0
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       NvGetEntryFromDataPtr
   \   00000022   0x0006             MOVS     R6,R0
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD002             BEQ.N    ??NvSaveOnCount_3
   3993            {
   3994              return status;
   \   0000002A   0x0030             MOVS     R0,R6
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0xE035             B.N      ??NvSaveOnCount_1
   3995            }
   3996          
   3997            if(gNvInvalidDataEntry_c == tblIdx.entryId)
   \                     ??NvSaveOnCount_3: (+1)
   \   00000030   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000034   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD101             BNE.N    ??NvSaveOnCount_4
   3998            {
   3999              return gNVM_InvalidTableEntry_c;
   \   0000003C   0x2009             MOVS     R0,#+9
   \   0000003E   0xE02D             B.N      ??NvSaveOnCount_1
   4000            }
   4001          
   4002            tableEntryIdx = NvGetTableEntryIndexFromId(tblIdx.entryId);
   \                     ??NvSaveOnCount_4: (+1)
   \   00000040   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000044   0x.... 0x....      BL       NvGetTableEntryIndexFromId
   \   00000048   0x0005             MOVS     R5,R0
   4003          
   4004            if(gNvInvalidTableEntryIndex_c == tableEntryIdx)
   \   0000004A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004C   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000050   0x4285             CMP      R5,R0
   \   00000052   0xD101             BNE.N    ??NvSaveOnCount_5
   4005            {
   4006              return gNVM_InvalidTableEntry_c;
   \   00000054   0x2009             MOVS     R0,#+9
   \   00000056   0xE021             B.N      ??NvSaveOnCount_1
   4007            }
   4008          
   4009            if(maDatasetInfo[tableEntryIdx].countsToNextSave)
   \                     ??NvSaveOnCount_5: (+1)
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000005C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005E   0x2106             MOVS     R1,#+6
   \   00000060   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000064   0x8880             LDRH     R0,[R0, #+4]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD00F             BEQ.N    ??NvSaveOnCount_6
   4010            {
   4011              --maDatasetInfo[tableEntryIdx].countsToNextSave;
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000006E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000070   0x2106             MOVS     R1,#+6
   \   00000072   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000076   0x8880             LDRH     R0,[R0, #+4]
   \   00000078   0x1E40             SUBS     R0,R0,#+1
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable32
   \   0000007E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000080   0x2206             MOVS     R2,#+6
   \   00000082   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000086   0x8088             STRH     R0,[R1, #+4]
   \   00000088   0xE006             B.N      ??NvSaveOnCount_7
   4012            }
   4013            else
   4014            {
   4015              /* all the elements of the NVM table entry will be saved */
   4016              tblIdx.saveRestoreAll = TRUE;
   \                     ??NvSaveOnCount_6: (+1)
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0xF88D 0x0004      STRB     R0,[SP, #+4]
   4017          
   4018              status = NvAddSaveRequestToQueue(&tblIdx);        
   \   00000090   0xA800             ADD      R0,SP,#+0
   \   00000092   0x.... 0x....      BL       NvAddSaveRequestToQueue
   \   00000096   0x0006             MOVS     R6,R0
   4019            }
   4020          
   4021            return status;
   \                     ??NvSaveOnCount_7: (+1)
   \   00000098   0x0030             MOVS     R0,R6
   \   0000009A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??NvSaveOnCount_1: (+1)
   \   0000009C   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   4022          
   4023          #else    
   4024            (void)ptrData;
   4025            return gNVM_Error_c;
   4026          #endif
   4027          }                                       /* NvSaveOnCount() */
   4028          
   4029          
   4030          /******************************************************************************
   4031           * Name: NvSetMinimumTicksBetweenSaves
   4032           * Description: Set the timer used by NvSaveOnInterval(). Takes effect after 
   4033           *              the next save.
   4034           * Parameters: [IN] newInterval - new time interval
   4035           * Return: - 
   4036           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4037          void NvSetMinimumTicksBetweenSaves
   4038          (
   4039            NvSaveInterval_t newInterval
   4040          )
   4041          {
   4042          #if gNvStorageIncluded_d
   4043            gNvMinimumTicksBetweenSaves = newInterval;
   \                     NvSetMinimumTicksBetweenSaves: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable32_11
   \   00000004   0x8008             STRH     R0,[R1, #+0]
   4044          #else
   4045            (void)newInterval;
   4046          #endif
   4047          }                                       /* NvSetMinimumTicksBetweenSaves() */
   \   00000006   0x4770             BX       LR               ;; return
   4048          
   4049          
   4050          /******************************************************************************
   4051           * Name: NvSetCountsBetweenSaves
   4052           * Description: Set the counter trigger value used by NvSaveOnCount().
   4053           *              Takes effect after the next save.
   4054           * Parameters: [IN] newCounter - new counter value
   4055           * Return: - 
   4056           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4057          void NvSetCountsBetweenSaves
   4058          (
   4059            NvSaveCounter_t newCounter
   4060          )
   4061          {
   4062          #if gNvStorageIncluded_d    
   4063            gNvCountsBetweenSaves = newCounter;    
   \                     NvSetCountsBetweenSaves: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable32_9
   \   00000004   0x8008             STRH     R0,[R1, #+0]
   4064          #else
   4065            (void)newCounter;
   4066          #endif
   4067          }                                       /* NvSetCountsBetweenSaves() */
   \   00000006   0x4770             BX       LR               ;; return
   4068          
   4069          
   4070          /******************************************************************************
   4071           * Name: NvTimerTick
   4072           * Description: Called from the idle task to process save-on-interval requests
   4073           * Parameters: [IN] countTick - enable/disable tick count
   4074           * Return: FALSE if the timer tick counters for all data sets have reached 
   4075           *         zero. In this case, the timer can be turned off.
   4076           *         TRUE if any of the data sets' timer tick counters have not yet
   4077           *         counted down to zero. In this case, the timer should be active
   4078           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4079          bool_t NvTimerTick
   4080          (
   4081            bool_t countTick
   4082          )
   4083          {
   \                     NvTimerTick: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   4084          #if gNvStorageIncluded_d
   4085          
   4086            bool_t fTicksLeft;                
   4087            NVM_TableEntryInfo_t tblIdx;
   4088            uint16_t idx;
   4089          
   4090            if(!mNvModuleInitialized)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable32_3
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??NvTimerTick_0
   4091            {
   4092              return gNVM_ModuleNotInitialized_c;
   \   0000000E   0x200E             MOVS     R0,#+14
   \   00000010   0xE08E             B.N      ??NvTimerTick_1
   4093            }
   4094          
   4095            idx = 0;
   \                     ??NvTimerTick_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x0006             MOVS     R6,R0
   4096            fTicksLeft = FALSE;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x0005             MOVS     R5,R0
   4097          
   4098            if(countTick) 
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xF000 0x8085      BEQ.W    ??NvTimerTick_2
   4099            {
   4100              while(gNvEndOfTableId_c != pNVM_DataTable[idx].DataEntryID)
   \                     ??NvTimerTick_3: (+1)
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable32_12
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000002A   0x210C             MOVS     R1,#+12
   \   0000002C   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00000030   0x8900             LDRH     R0,[R0, #+8]
   \   00000032   0xF64F 0x71FE      MOVW     R1,#+65534
   \   00000036   0x4288             CMP      R0,R1
   \   00000038   0xD078             BEQ.N    ??NvTimerTick_2
   4101              {
   4102                if(maDatasetInfo[idx].ticksToNextSave)
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000003E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000040   0x2106             MOVS     R1,#+6
   \   00000042   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00000046   0x8840             LDRH     R0,[R0, #+2]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD00E             BEQ.N    ??NvTimerTick_4
   4103                {
   4104                  --maDatasetInfo[idx].ticksToNextSave;
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000050   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000052   0x2106             MOVS     R1,#+6
   \   00000054   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00000058   0x8840             LDRH     R0,[R0, #+2]
   \   0000005A   0x1E40             SUBS     R0,R0,#+1
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable32
   \   00000060   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000062   0x2206             MOVS     R2,#+6
   \   00000064   0xFB02 0x1106      MLA      R1,R2,R6,R1
   \   00000068   0x8048             STRH     R0,[R1, #+2]
   4105                }
   4106          
   4107                if(maDatasetInfo[idx].ticksToNextSave)
   \                     ??NvTimerTick_4: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000006E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000070   0x2106             MOVS     R1,#+6
   \   00000072   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00000076   0x8840             LDRH     R0,[R0, #+2]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD001             BEQ.N    ??NvTimerTick_5
   4108                {
   4109                  fTicksLeft = TRUE;
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0x0005             MOVS     R5,R0
   4110                }
   4111          
   4112                if(maDatasetInfo[idx].saveNextInterval && !maDatasetInfo[idx].ticksToNextSave)
   \                     ??NvTimerTick_5: (+1)
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000084   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000086   0x2106             MOVS     R1,#+6
   \   00000088   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   0000008C   0x7800             LDRB     R0,[R0, #+0]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD04A             BEQ.N    ??NvTimerTick_6
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000096   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000098   0x2106             MOVS     R1,#+6
   \   0000009A   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   0000009E   0x8840             LDRH     R0,[R0, #+2]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD141             BNE.N    ??NvTimerTick_6
   4113                {
   4114                  if(!mNvCriticalSectionFlag)
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable32_13
   \   000000A8   0x7800             LDRB     R0,[R0, #+0]
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD129             BNE.N    ??NvTimerTick_7
   4115                  {
   4116                    tblIdx.entryId = pNVM_DataTable[idx].DataEntryID;
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable32_12
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000B6   0x210C             MOVS     R1,#+12
   \   000000B8   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   000000BC   0x8900             LDRH     R0,[R0, #+8]
   \   000000BE   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   4117                    tblIdx.elementIndex = 0;
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   4118                    tblIdx.saveRestoreAll = TRUE;
   \   000000C8   0x2001             MOVS     R0,#+1
   \   000000CA   0xF88D 0x0004      STRB     R0,[SP, #+4]
   4119          #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */
   4120                    if(NvWriteRecord(&tblIdx) == gNVM_PageCopyPending_c)
   \   000000CE   0xA800             ADD      R0,SP,#+0
   \   000000D0   0x.... 0x....      BL       NvWriteRecord
   \   000000D4   0x2811             CMP      R0,#+17
   \   000000D6   0xD102             BNE.N    ??NvTimerTick_8
   4121                    {
   4122                      NvAddSaveRequestToQueue(&tblIdx);
   \   000000D8   0xA800             ADD      R0,SP,#+0
   \   000000DA   0x.... 0x....      BL       NvAddSaveRequestToQueue
   4123                    }                                                   
   4124          #else /* FlexNVM */
   4125                    NvWriteRecord(&tblIdx);
   4126          #endif
   4127                    maDatasetInfo[idx].saveNextInterval = FALSE;
   \                     ??NvTimerTick_8: (+1)
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0x.... 0x....      LDR.W    R1,??DataTable32
   \   000000E4   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000E6   0x2206             MOVS     R2,#+6
   \   000000E8   0xFB02 0x1106      MLA      R1,R2,R6,R1
   \   000000EC   0x7008             STRB     R0,[R1, #+0]
   4128                    maDatasetInfo[idx].countsToNextSave = gNvCountsBetweenSaves_c;
   \   000000EE   0xF44F 0x7080      MOV      R0,#+256
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable32
   \   000000F6   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000F8   0x2206             MOVS     R2,#+6
   \   000000FA   0xFB02 0x1106      MLA      R1,R2,R6,R1
   \   000000FE   0x8088             STRH     R0,[R1, #+4]
   \   00000100   0xE012             B.N      ??NvTimerTick_6
   4129                  }
   4130                  else
   4131                  {                    
   4132                    tblIdx.entryId = pNVM_DataTable[idx].DataEntryID;
   \                     ??NvTimerTick_7: (+1)
   \   00000102   0x.... 0x....      LDR.W    R0,??DataTable32_12
   \   00000106   0x6800             LDR      R0,[R0, #+0]
   \   00000108   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000010A   0x210C             MOVS     R1,#+12
   \   0000010C   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00000110   0x8900             LDRH     R0,[R0, #+8]
   \   00000112   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   4133                    tblIdx.elementIndex = 0;
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   4134                    tblIdx.saveRestoreAll = TRUE;
   \   0000011C   0x2001             MOVS     R0,#+1
   \   0000011E   0xF88D 0x0004      STRB     R0,[SP, #+4]
   4135                    /* push the pending save to pending queue */
   4136                    NvAddSaveRequestToQueue(&tblIdx);
   \   00000122   0xA800             ADD      R0,SP,#+0
   \   00000124   0x.... 0x....      BL       NvAddSaveRequestToQueue
   4137                  }
   4138                }        
   4139                /* increment the loop counter */
   4140                idx++;
   \                     ??NvTimerTick_6: (+1)
   \   00000128   0x1C76             ADDS     R6,R6,#+1
   \   0000012A   0xE77A             B.N      ??NvTimerTick_3
   4141              }
   4142            }
   4143            return fTicksLeft;
   \                     ??NvTimerTick_2: (+1)
   \   0000012C   0x0028             MOVS     R0,R5
   \   0000012E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??NvTimerTick_1: (+1)
   \   00000130   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   4144          
   4145          #else
   4146            (void)countTick;
   4147            return FALSE;
   4148          #endif /* #if gNvStorageIncluded_d */
   4149          }                                       /* NvTimerTick() */
   4150          
   4151          
   4152          /******************************************************************************
   4153           * Name: NvRestoreDataSet
   4154           * Description: copy the most recent version of the element/table entry pointed 
   4155           *              by ptrData from NVM storage system to RAM memory
   4156           * Parameter(s): [IN] ptrData - pointer to data (element) to be restored 
   4157           *               [IN] restoreAll - if FALSE restores a single element
   4158           *                               - if TRUE restores an entire table entry
   4159           * Return: status of the restore operation
   4160           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4161          NVM_Status_t NvRestoreDataSet
   4162          (
   4163            void* ptrData,    
   4164            bool_t restoreAll
   4165          )
   4166          {
   \                     NvRestoreDataSet: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   4167          #if gNvStorageIncluded_d
   4168          
   4169            NVM_TableEntryInfo_t tblIdx;
   4170          
   4171            if(!mNvModuleInitialized)
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable32_3
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD101             BNE.N    ??NvRestoreDataSet_0
   4172            {
   4173              return gNVM_ModuleNotInitialized_c;
   \   00000012   0x200E             MOVS     R0,#+14
   \   00000014   0xE011             B.N      ??NvRestoreDataSet_1
   4174            }
   4175          
   4176            if(NULL == ptrData)
   \                     ??NvRestoreDataSet_0: (+1)
   \   00000016   0x2C00             CMP      R4,#+0
   \   00000018   0xD101             BNE.N    ??NvRestoreDataSet_2
   4177            {
   4178              return gNVM_NullPointer_c;
   \   0000001A   0x2005             MOVS     R0,#+5
   \   0000001C   0xE00D             B.N      ??NvRestoreDataSet_1
   4179            }
   4180          
   4181          #if gNvFragmentation_Enabled_d
   4182            tblIdx.saveRestoreAll = restoreAll;
   4183          #else
   4184            tblIdx.saveRestoreAll = TRUE;
   \                     ??NvRestoreDataSet_2: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF88D 0x0004      STRB     R0,[SP, #+4]
   4185          #endif /* gNvFragmentation_Enabled_d */
   4186          
   4187            if(NvGetEntryFromDataPtr(ptrData, &tblIdx) != gNVM_OK_c)
   \   00000024   0xA900             ADD      R1,SP,#+0
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       NvGetEntryFromDataPtr
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD001             BEQ.N    ??NvRestoreDataSet_3
   4188            {
   4189              return gNVM_PointerOutOfRange_c;
   \   00000030   0x2006             MOVS     R0,#+6
   \   00000032   0xE002             B.N      ??NvRestoreDataSet_1
   4190            }
   4191          
   4192            return NvRestoreData(&tblIdx);    
   \                     ??NvRestoreDataSet_3: (+1)
   \   00000034   0xA800             ADD      R0,SP,#+0
   \   00000036   0x.... 0x....      BL       NvRestoreData
   \                     ??NvRestoreDataSet_1: (+1)
   \   0000003A   0xBD3E             POP      {R1-R5,PC}       ;; return
   4193          
   4194          #else
   4195            (void)ptrData;
   4196            return gNVM_Error_c;
   4197          #endif
   4198          }
   4199          
   4200          /******************************************************************************
   4201           * Name: NvClearCriticalSection
   4202           * Description: leave critical section
   4203           * Parameters: -
   4204           * Return: - 
   4205           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4206          void NvClearCriticalSection
   4207          (
   4208            void
   4209          ) 
   4210          {
   4211          #if (gNvStorageIncluded_d && gNvEnableCriticalSection_c)
   4212            if(mNvCriticalSectionFlag)  /* in case of set/clear mismatch */
   4213              --mNvCriticalSectionFlag;
   4214          #endif
   4215          }
   \                     NvClearCriticalSection: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4216          
   4217          
   4218          /******************************************************************************
   4219           * Name: NvSetCriticalSection
   4220           * Description: enter critical section
   4221           * Parameters: -
   4222           * Return: - 
   4223           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4224          void NvSetCriticalSection
   4225          (
   4226            void
   4227          ) 
   4228          {
   4229          #if (gNvStorageIncluded_d && gNvEnableCriticalSection_c)
   4230            ++mNvCriticalSectionFlag;
   4231          #endif    
   4232          }
   \                     NvSetCriticalSection: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4233          
   4234          
   4235          /******************************************************************************
   4236           * Name: NvIdle
   4237           * Description: Called from the idle task (bare-metal) or NVM_Task (MQX,
   4238           *              FreeRTOS) to process the pending saves, erase or copy 
   4239           *              operations.
   4240           * Parameters: -
   4241           * Return: -
   4242           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4243          void NvIdle
   4244          (
   4245            void
   4246          )
   4247          {
   \                     NvIdle: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   4248          #if gNvStorageIncluded_d
   4249          
   4250            NVM_TableEntryInfo_t tblIdx;
   4251            uint16_t tableEntryIdx;
   4252            uint8_t timerJitter;
   4253          
   4254            if (!mNvModuleInitialized || mNvCriticalSectionFlag) 
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable32_3
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD004             BEQ.N    ??NvIdle_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable32_13
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD000             BEQ.N    ??NvIdle_1
   4255            {
   4256              return;
   \                     ??NvIdle_0: (+1)
   \   00000016   0xE09A             B.N      ??NvIdle_2
   4257            }
   4258          
   4259          #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */    
   4260          
   4261            if(mNvCopyOperationIsPending)
   \                     ??NvIdle_1: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable32_14
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD005             BEQ.N    ??NvIdle_3
   4262            {
   4263          #if gNvUseExtendedFeatureSet_d	  
   4264              (void)NvCopyPage(mNvSkipTableEntryId);
   4265          #else
   4266              (void)NvCopyPage();
   \   00000022   0x.... 0x....      BL       NvCopyPage
   4267          #endif /* #if gNvUseExtendedFeatureSet_d */
   4268              mNvCopyOperationIsPending = FALSE;
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable32_14
   \   0000002C   0x7011             STRB     R1,[R2, #+0]
   4269            }    
   4270          
   4271            if(mNvErasePgCmdStatus.NvErasePending)
   \                     ??NvIdle_3: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable32_8
   \   00000032   0x7800             LDRB     R0,[R0, #+0]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD038             BEQ.N    ??NvIdle_4
   4272            {
   4273              if(mNvErasePgCmdStatus.NvSectorAddress >= mNvVirtualPageProperty[mNvErasePgCmdStatus.NvPageToErase].NvRawSectorEndAddress)
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable32_8
   \   0000003C   0x6840             LDR      R0,[R0, #+4]
   \   0000003E   0x....             LDR.N    R1,??DataTable28
   \   00000040   0x.... 0x....      LDR.W    R2,??DataTable32_8
   \   00000044   0x7852             LDRB     R2,[R2, #+1]
   \   00000046   0x2314             MOVS     R3,#+20
   \   00000048   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   0000004C   0x6849             LDR      R1,[R1, #+4]
   \   0000004E   0x4288             CMP      R0,R1
   \   00000050   0xD30D             BCC.N    ??NvIdle_5
   4274              {
   4275                /* all sectors of the page had been erased */
   4276                mNvVirtualPageProperty[mNvErasePgCmdStatus.NvPageToErase].NvLastMetaInfoAddress = gEmptyPageMetaAddress_c;
   \   00000052   0x....             LDR.N    R0,??DataTable28
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable32_8
   \   00000058   0x7849             LDRB     R1,[R1, #+1]
   \   0000005A   0x2214             MOVS     R2,#+20
   \   0000005C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000060   0x....             LDR.N    R1,??DataTable28_1  ;; 0x3fff0000
   \   00000062   0x6101             STR      R1,[R0, #+16]
   4277                mNvErasePgCmdStatus.NvErasePending = FALSE;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable32_8
   \   0000006A   0x7008             STRB     R0,[R1, #+0]
   4278                return;
   \   0000006C   0xE06F             B.N      ??NvIdle_2
   4279              }
   4280          
   4281              /* erase */
   4282              (void)NV_FlashEraseSector(&mNvConfig, mNvErasePgCmdStatus.NvSectorAddress, (uint32_t)((uint8_t*)NV_STORAGE_SECTOR_SIZE));
   \                     ??NvIdle_5: (+1)
   \   0000006E   0x.... 0x....      LDR.W    R2,??DataTable32_7
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable32_8
   \   00000076   0x6841             LDR      R1,[R0, #+4]
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable32_15
   \   0000007C   0x.... 0x....      BL       NV_FlashEraseSector
   \   00000080   0x0006             MOVS     R6,R0
   4283          
   4284              /* blank check */
   4285              if(gNV_OK_c == NV_FlashVerifySection(&mNvConfig, mNvErasePgCmdStatus.NvSectorAddress,
   4286                  (uint32_t)((uint8_t*)NV_STORAGE_SECTOR_SIZE), gNV_MARGIN_NORMAL_c))
   \   00000082   0x2300             MOVS     R3,#+0
   \   00000084   0x.... 0x....      LDR.W    R2,??DataTable32_7
   \   00000088   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable32_8
   \   0000008E   0x6841             LDR      R1,[R0, #+4]
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable32_15
   \   00000094   0x.... 0x....      BL       NV_FlashVerifySection
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD106             BNE.N    ??NvIdle_4
   4287              {
   4288                mNvErasePgCmdStatus.NvSectorAddress += (uint32_t)((uint8_t*)NV_STORAGE_SECTOR_SIZE);
   \   0000009C   0x....             LDR.N    R0,??DataTable32_8
   \   0000009E   0x6840             LDR      R0,[R0, #+4]
   \   000000A0   0x....             LDR.N    R1,??DataTable32_7
   \   000000A2   0x1808             ADDS     R0,R1,R0
   \   000000A4   0x....             LDR.N    R1,??DataTable32_8
   \   000000A6   0x6048             STR      R0,[R1, #+4]
   4289                return;
   \   000000A8   0xE051             B.N      ??NvIdle_2
   4290              }        
   4291            }
   4292          #endif
   4293          
   4294            /* process the save-on-interval requests */    
   4295            if(NvTimerTick(mNvSaveOnIntervalEvent)) 
   \                     ??NvIdle_4: (+1)
   \   000000AA   0x....             LDR.N    R0,??DataTable32_2
   \   000000AC   0x7800             LDRB     R0,[R0, #+0]
   \   000000AE   0x.... 0x....      BL       NvTimerTick
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD012             BEQ.N    ??NvIdle_6
   4296            {
   4297              if(!TMR_IsTimerActive(mNvSaveOnIntervalTimerID))
   \   000000B6   0x....             LDR.N    R0,??DataTable32_10
   \   000000B8   0x7800             LDRB     R0,[R0, #+0]
   \   000000BA   0x.... 0x....      BL       TMR_IsTimerActive
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD10C             BNE.N    ??NvIdle_6
   4298              {
   4299                timerJitter = NvGetRandomRange(0,255);
   \   000000C2   0x21FF             MOVS     R1,#+255
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0x.... 0x....      BL       NvGetRandomRange
   \   000000CA   0x0005             MOVS     R5,R0
   4300                TMR_StartSingleShotTimer(mNvSaveOnIntervalTimerID,
   4301                    TmrSeconds(1) + timerJitter - 128,
   4302                    NvIntervalTimerCallback);
   \   000000CC   0x....             LDR.N    R2,??DataTable32_16
   \   000000CE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000D0   0xF515 0x715A      ADDS     R1,R5,#+872
   \   000000D4   0x....             LDR.N    R0,??DataTable32_10
   \   000000D6   0x7800             LDRB     R0,[R0, #+0]
   \   000000D8   0x.... 0x....      BL       TMR_StartSingleShotTimer
   4303              }
   4304            }
   4305          
   4306            if(mNvSaveOnIntervalEvent)
   \                     ??NvIdle_6: (+1)
   \   000000DC   0x....             LDR.N    R0,??DataTable32_2
   \   000000DE   0x7800             LDRB     R0,[R0, #+0]
   \   000000E0   0x2800             CMP      R0,#+0
   \   000000E2   0xD002             BEQ.N    ??NvIdle_7
   4307            {
   4308              mNvSaveOnIntervalEvent = FALSE;
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0x....             LDR.N    R1,??DataTable32_2
   \   000000E8   0x7008             STRB     R0,[R1, #+0]
   4309            }
   4310          
   4311            /* process the save-on-idle requests */
   4312            if(NvGetPendingSavesCount(&mNvPendingSavesQueue))
   \                     ??NvIdle_7: (+1)
   \   000000EA   0x....             LDR.N    R0,??DataTable32_1
   \   000000EC   0x.... 0x....      BL       NvGetPendingSavesCount
   \   000000F0   0x2800             CMP      R0,#+0
   \   000000F2   0xD02C             BEQ.N    ??NvIdle_8
   4313            {
   4314              while(NvPopPendingSave(&mNvPendingSavesQueue, &tblIdx))
   \                     ??NvIdle_9: (+1)
   \   000000F4   0xA900             ADD      R1,SP,#+0
   \   000000F6   0x....             LDR.N    R0,??DataTable32_1
   \   000000F8   0x.... 0x....      BL       NvPopPendingSave
   \   000000FC   0x2800             CMP      R0,#+0
   \   000000FE   0xD026             BEQ.N    ??NvIdle_8
   4315              {            
   4316                tableEntryIdx = NvGetTableEntryIndexFromId(tblIdx.entryId);
   \   00000100   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000104   0x.... 0x....      BL       NvGetTableEntryIndexFromId
   \   00000108   0x0004             MOVS     R4,R0
   4317          
   4318                if(gNvInvalidTableEntryIndex_c == tableEntryIdx)
   \   0000010A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000010C   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000110   0x4284             CMP      R4,R0
   \   00000112   0xD0EF             BEQ.N    ??NvIdle_9
   4319                {
   4320                  continue;
   4321                }            
   4322          
   4323          #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */            
   4324                if(NvWriteRecord(&tblIdx) == gNVM_PageCopyPending_c)
   \                     ??NvIdle_10: (+1)
   \   00000114   0xA800             ADD      R0,SP,#+0
   \   00000116   0x.... 0x....      BL       NvWriteRecord
   \   0000011A   0x2811             CMP      R0,#+17
   \   0000011C   0xD103             BNE.N    ??NvIdle_11
   4325                {
   4326                  NvAddSaveRequestToQueue(&tblIdx);
   \   0000011E   0xA800             ADD      R0,SP,#+0
   \   00000120   0x.... 0x....      BL       NvAddSaveRequestToQueue
   4327                  break;
   \   00000124   0xE013             B.N      ??NvIdle_8
   4328                }
   4329          #else /* FlexNVM */
   4330                NvWriteRecord(&tblIdx);
   4331          #endif
   4332          
   4333                if(tblIdx.saveRestoreAll)
   \                     ??NvIdle_11: (+1)
   \   00000126   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD0E2             BEQ.N    ??NvIdle_9
   4334                {
   4335                  maDatasetInfo[tableEntryIdx].saveNextInterval = FALSE;
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0x....             LDR.N    R1,??DataTable32
   \   00000132   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000134   0x2206             MOVS     R2,#+6
   \   00000136   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000013A   0x7008             STRB     R0,[R1, #+0]
   4336                  maDatasetInfo[tableEntryIdx].countsToNextSave = gNvCountsBetweenSaves_c;
   \   0000013C   0xF44F 0x7080      MOV      R0,#+256
   \   00000140   0x....             LDR.N    R1,??DataTable32
   \   00000142   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000144   0x2206             MOVS     R2,#+6
   \   00000146   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000014A   0x8088             STRH     R0,[R1, #+4]
   \   0000014C   0xE7D2             B.N      ??NvIdle_9
   4337                }
   4338              }
   4339            }
   4340          #endif
   4341          }                                       /* NvIdle() */
   \                     ??NvIdle_8: (+1)
   \                     ??NvIdle_2: (+1)
   \   0000014E   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   4342          
   4343          
   4344          /******************************************************************************
   4345           * Name: NvIsDataSetDirty
   4346           * Description: return TRUE if the element pointed by ptrData is dirty
   4347           * Parameters: [IN] ptrData - pointer to data to be checked
   4348           * Return: TRUE if the element is dirty, FALSE otherwise 
   4349           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4350          bool_t NvIsDataSetDirty
   4351          (
   4352            void* ptrData
   4353          )
   4354          {    
   \                     NvIsDataSetDirty: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   4355          #if gNvStorageIncluded_d
   4356          
   4357            NVM_TableEntryInfo_t tblIdx;
   4358            uint16_t tableEntryIdx;
   4359          
   4360            if(!mNvModuleInitialized)
   \   00000006   0x....             LDR.N    R0,??DataTable32_3
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??NvIsDataSetDirty_0
   4361            {
   4362              return FALSE;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE02C             B.N      ??NvIsDataSetDirty_1
   4363            }
   4364          
   4365            if(NULL == ptrData)
   \                     ??NvIsDataSetDirty_0: (+1)
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD101             BNE.N    ??NvIsDataSetDirty_2
   4366            {
   4367              return gNVM_NullPointer_c;
   \   00000016   0x2005             MOVS     R0,#+5
   \   00000018   0xE028             B.N      ??NvIsDataSetDirty_1
   4368            }
   4369          
   4370            if(gNVM_OK_c != NvGetEntryFromDataPtr(ptrData, &tblIdx))
   \                     ??NvIsDataSetDirty_2: (+1)
   \   0000001A   0xA900             ADD      R1,SP,#+0
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       NvGetEntryFromDataPtr
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD001             BEQ.N    ??NvIsDataSetDirty_3
   4371            {
   4372              return FALSE;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE020             B.N      ??NvIsDataSetDirty_1
   4373            }
   4374            else
   4375            {
   4376              tableEntryIdx = NvGetTableEntryIndexFromId(tblIdx.entryId);
   \                     ??NvIsDataSetDirty_3: (+1)
   \   0000002A   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000002E   0x.... 0x....      BL       NvGetTableEntryIndexFromId
   \   00000032   0x0005             MOVS     R5,R0
   4377          
   4378              if(gNvInvalidTableEntryIndex_c == tableEntryIdx)
   \   00000034   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000036   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000003A   0x4285             CMP      R5,R0
   \   0000003C   0xD101             BNE.N    ??NvIsDataSetDirty_4
   4379              {
   4380                return FALSE;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE014             B.N      ??NvIsDataSetDirty_1
   4381              }
   4382          
   4383              return(maDatasetInfo[tableEntryIdx].saveNextInterval || 
   4384                  (maDatasetInfo[tableEntryIdx].countsToNextSave != gNvCountsBetweenSaves_c));         
   \                     ??NvIsDataSetDirty_4: (+1)
   \   00000042   0x....             LDR.N    R0,??DataTable32
   \   00000044   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000046   0x2106             MOVS     R1,#+6
   \   00000048   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD108             BNE.N    ??NvIsDataSetDirty_5
   \   00000052   0x....             LDR.N    R0,??DataTable32
   \   00000054   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000056   0x2106             MOVS     R1,#+6
   \   00000058   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   0000005C   0x8880             LDRH     R0,[R0, #+4]
   \   0000005E   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000062   0xD001             BEQ.N    ??NvIsDataSetDirty_6
   \                     ??NvIsDataSetDirty_5: (+1)
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0xE000             B.N      ??NvIsDataSetDirty_7
   \                     ??NvIsDataSetDirty_6: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \                     ??NvIsDataSetDirty_7: (+1)
   \   0000006A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??NvIsDataSetDirty_1: (+1)
   \   0000006C   0xBD3E             POP      {R1-R5,PC}       ;; return
   4385            }
   4386          
   4387          #else
   4388            (void)ptrData;
   4389            return FALSE;
   4390          #endif
   4391          }
   4392          
   4393          /******************************************************************************
   4394           * Name: NvGetStatistics
   4395           * Description:       
   4396           * Parameter(s): [OUT] ptrStat - pointer to a memory location where the pages
   4397           *                               statistics (erase cycles of each page) will 
   4398           *                               be stored
   4399           * Return: -
   4400           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4401          void NvGetPagesStatistics
   4402          (
   4403            NVM_Statistics_t* ptrStat 
   4404          )
   4405          {    
   4406          #if gNvStorageIncluded_d
   4407          #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */    
   4408            if(!mNvModuleInitialized)
   \                     NvGetPagesStatistics: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable32_3
   \   00000002   0x7809             LDRB     R1,[R1, #+0]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD016             BEQ.N    ??NvGetPagesStatistics_0
   4409            {
   4410              return;
   4411            }
   4412          
   4413            if(NULL == ptrStat)
   \                     ??NvGetPagesStatistics_1: (+1)
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD014             BEQ.N    ??NvGetPagesStatistics_0
   4414            {
   4415              return;
   4416            }
   4417          
   4418            if(mNvPageCounter%2)
   \                     ??NvGetPagesStatistics_2: (+1)
   \   0000000C   0x....             LDR.N    R1,??DataTable32_17
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
   \   00000010   0x07C9             LSLS     R1,R1,#+31
   \   00000012   0xD507             BPL.N    ??NvGetPagesStatistics_3
   4419            {
   4420              ptrStat->FirstPageEraseCyclesCount = ptrStat->SecondPageEraseCyclesCount = (mNvPageCounter-1)/2;
   \   00000014   0x....             LDR.N    R1,??DataTable32_17
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0x1E49             SUBS     R1,R1,#+1
   \   0000001A   0x0849             LSRS     R1,R1,#+1
   \   0000001C   0x6041             STR      R1,[R0, #+4]
   \   0000001E   0x6841             LDR      R1,[R0, #+4]
   \   00000020   0x6001             STR      R1,[R0, #+0]
   \   00000022   0xE008             B.N      ??NvGetPagesStatistics_4
   4421            }
   4422            else
   4423            {
   4424              ptrStat->FirstPageEraseCyclesCount = mNvPageCounter/2;
   \                     ??NvGetPagesStatistics_3: (+1)
   \   00000024   0x....             LDR.N    R1,??DataTable32_17
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0x0849             LSRS     R1,R1,#+1
   \   0000002A   0x6001             STR      R1,[R0, #+0]
   4425              ptrStat->SecondPageEraseCyclesCount = (mNvPageCounter-2)/2;
   \   0000002C   0x....             LDR.N    R1,??DataTable32_17
   \   0000002E   0x6809             LDR      R1,[R1, #+0]
   \   00000030   0x1E89             SUBS     R1,R1,#+2
   \   00000032   0x0849             LSRS     R1,R1,#+1
   \   00000034   0x6041             STR      R1,[R0, #+4]
   4426            }
   4427          
   4428          #else /* FlexNVM */
   4429          ptrStat->FirstPageEraseCyclesCount = 0;
   4430          ptrStat->SecondPageEraseCyclesCount = 0;
   4431          return;
   4432          #endif
   4433          
   4434          #else
   4435          (void)ptrStat;
   4436          return;
   4437          #endif
   4438          }
   \                     ??NvGetPagesStatistics_4: (+1)
   \                     ??NvGetPagesStatistics_0: (+1)
   \   00000036   0x4770             BX       LR               ;; return
   4439          
   4440          /******************************************************************************
   4441           * Name: NvFormat
   4442           * Description: Format the NV storage system. The function erases both virtual
   4443           *              pages and then writes the page counter to active page.              
   4444           * Parameter(s): -
   4445           * Return: gNVM_OK_c - if the operation completes successfully
   4446           *         gNVM_FormatFailure_c - if the format operation fails
   4447           *         gNVM_ModuleNotInitialized_c - if the NVM  module is not initialized
   4448           *         gNVM_CriticalSectionActive_c - if the system has entered in a 
   4449           *                                        critical section
   4450           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4451          NVM_Status_t NvFormat
   4452          (
   4453            void
   4454          )
   4455          {
   \                     NvFormat: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   4456          #if gNvStorageIncluded_d
   4457          
   4458          #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */  
   4459          
   4460            uint32_t pageCounterValue;  
   4461            NVM_Status_t status;
   4462          
   4463            if(!mNvModuleInitialized)
   \   00000002   0x....             LDR.N    R0,??DataTable32_3
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD101             BNE.N    ??NvFormat_0
   4464            {
   4465              return gNVM_ModuleNotInitialized_c;
   \   0000000A   0x200E             MOVS     R0,#+14
   \   0000000C   0xE01B             B.N      ??NvFormat_1
   4466            }
   4467          
   4468            if(mNvCriticalSectionFlag)
   \                     ??NvFormat_0: (+1)
   \   0000000E   0x....             LDR.N    R0,??DataTable32_13
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD001             BEQ.N    ??NvFormat_2
   4469            {
   4470              return gNVM_CriticalSectionActive_c;
   \   00000016   0x200F             MOVS     R0,#+15
   \   00000018   0xE015             B.N      ??NvFormat_1
   4471            }
   4472          
   4473            NV_FlashRead(mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress, (uint8_t*)&pageCounterValue, sizeof(pageCounterValue));        
   \                     ??NvFormat_2: (+1)
   \   0000001A   0x2204             MOVS     R2,#+4
   \   0000001C   0xA900             ADD      R1,SP,#+0
   \   0000001E   0x....             LDR.N    R0,??DataTable32_18
   \   00000020   0x....             LDR.N    R3,??DataTable32_5
   \   00000022   0x781B             LDRB     R3,[R3, #+0]
   \   00000024   0x2514             MOVS     R5,#+20
   \   00000026   0xFB05 0x0003      MLA      R0,R5,R3,R0
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x.... 0x....      BL       NV_FlashRead
   4474          
   4475            if((status = NvInternalFormat(pageCounterValue)) == gNVM_OK_c)
   \   00000030   0x9800             LDR      R0,[SP, #+0]
   \   00000032   0x.... 0x....      BL       NvInternalFormat
   \   00000036   0x0004             MOVS     R4,R0
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD101             BNE.N    ??NvFormat_3
   4476            {     
   4477              /* update last meta info address */
   4478              (void)NvGetLastMetaInfoAddress();
   \   0000003E   0x.... 0x....      BL       NvGetLastMetaInfoAddress
   4479            }
   4480          
   4481            return status;
   \                     ??NvFormat_3: (+1)
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??NvFormat_1: (+1)
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   4482          
   4483          #else /* FlexNVM */
   4484          
   4485            uint8_t buff[gNvFlexFormatBufferSize_c];
   4486            uint32_t addr;
   4487            uint16_t size;
   4488          
   4489            FLib_MemSet(buff, gNvErasedFlashCellValue_c, gNvFlexFormatBufferSize_c);
   4490          
   4491            addr = mNvConfig.EERAMBlockBase;
   4492            size = mNvConfig.EEEBlockSize;
   4493          
   4494            while(size)
   4495            {
   4496              /* wait for EEPROM system to be ready */
   4497              while(!(gNV_REG_READ(mNvConfig.ftfxRegBase + gNV_FCNFG_OFFSET_c) & gNV_FCNFG_EEERDY_c));
   4498          
   4499              if(gNV_OK_c != NV_EEEWrite(&mNvConfig, (uint32_t)(&buff), addr, sizeof(buff)))        
   4500              {
   4501                return gNVM_FormatFailure_c;
   4502              }
   4503              size -= gNvFlexFormatBufferSize_c;
   4504              addr += gNvFlexFormatBufferSize_c;
   4505            }    
   4506            return gNVM_OK_c;
   4507          #endif /* gNvUseFlexNVM_d */
   4508          
   4509          #else    
   4510            return gNVM_Error_c;
   4511          #endif /* gNvStorageIncluded_d */    
   4512          }
   4513          
   4514          
   4515          /******************************************************************************
   4516           * Name: NvRegisterTableEntry
   4517           * Description: The function tries to register a new table entry within an
   4518           *              existing NV table. If the NV table contained an erased (invalid)
   4519           *              entry, the entry will be overwritten with a new one (provided
   4520           *              by the mean of this function arguments)      
   4521           * Parameter(s): [IN] ptrData - generic pointer to RAM data to be registered
   4522           *                              within the NV storage system
   4523           *               [IN] uniqueId - an unique ID of the table entry
   4524           *               [IN] elemCount - how many elements the table entry contains
   4525           *               [IN] elemSize - the size of an element 
   4526           *               [IN] overwrite - if an existing table entry shall be 
   4527           *                                overwritten
   4528           * Return: gNVM_OK_c - if the operation completes successfully         
   4529           *         gNVM_ModuleNotInitialized_c - if the NVM  module is not initialized
   4530           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4531          NVM_Status_t NvRegisterTableEntry
   4532          (
   4533            void* ptrData,
   4534            NvTableEntryId_t uniqueId,
   4535            uint16_t elemCount,
   4536            uint16_t elemSize,
   4537            bool_t overwrite
   4538          )
   4539          {
   \                     NvRegisterTableEntry: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0004             MOVS     R4,R0
   4540          #if gNvStorageIncluded_d && gNvUseExtendedFeatureSet_d
   4541          
   4542            uint16_t loopCnt = 0;
   4543            uint16_t nullPos = gNvTableEntriesCountMax_c;
   4544          
   4545            if(!mNvModuleInitialized)
   4546            {
   4547              return gNVM_ModuleNotInitialized_c;
   4548            }
   4549          
   4550            if((gNvInvalidDataEntry_c == uniqueId) || (gNvEndOfTableId_c == uniqueId))
   4551            {
   4552              return gNVM_RegisterFailure_c;
   4553            }
   4554          
   4555            while(gNvEndOfTableId_c != pNVM_DataTable[loopCnt].DataEntryID)
   4556            {
   4557              if(NULL == pNVM_DataTable[loopCnt].pData)
   4558              {
   4559                nullPos = loopCnt;        
   4560              }
   4561          
   4562              if(pNVM_DataTable[loopCnt].DataEntryID == uniqueId)            
   4563              {
   4564                if(overwrite)
   4565                {
   4566                  pNVM_DataTable[loopCnt].pData= ptrData;                
   4567                  pNVM_DataTable[loopCnt].ElementsCount = elemCount;
   4568                  pNVM_DataTable[loopCnt].ElementSize = elemSize;
   4569                  return gNVM_OK_c;
   4570                }
   4571                else
   4572                {
   4573                  return gNVM_AlreadyRegistered;
   4574                }        
   4575              }
   4576              /* increment the loop counter */
   4577              loopCnt++;
   4578            }
   4579          
   4580            if(gNvTableEntriesCountMax_c != nullPos)
   4581            {
   4582              pNVM_DataTable[nullPos].pData= ptrData;
   4583              pNVM_DataTable[nullPos].DataEntryID = uniqueId;
   4584              pNVM_DataTable[nullPos].ElementsCount = elemCount;
   4585              pNVM_DataTable[nullPos].ElementSize = elemSize;
   4586              return gNVM_OK_c;
   4587            }        
   4588          
   4589            return gNVM_RegisterFailure_c;
   4590          #else
   4591            (void)ptrData;
   4592            (void)uniqueId;
   4593            (void)elemCount;
   4594            (void)elemSize;
   4595            (void)overwrite;
   4596            return gNVM_Error_c;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xBC10             POP      {R4}
   \   00000008   0x4770             BX       LR               ;; return
   4597          #endif
   4598          }
   4599          
   4600          
   4601          /******************************************************************************
   4602           * Name: NvEraseEntryFromStorage
   4603           * Description: The function removes a table entry within the existing NV 
   4604           *              table. 
   4605           * Parameter(s): [IN] ptrData - a pointer to an existing RAM data that is
   4606           *                              managed by the NV storage system    
   4607           * Return: gNVM_OK_c - if the operation completes successfully         
   4608           *         gNVM_ModuleNotInitialized_c - if the NVM  module is not initialized
   4609           *         gNVM_NullPointer_c - if a NULL pointer is provided
   4610           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4611          NVM_Status_t NvEraseEntryFromStorage
   4612          (
   4613            void* ptrData
   4614          )
   4615          {
   \                     NvEraseEntryFromStorage: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   4616          #if gNvStorageIncluded_d && gNvUseExtendedFeatureSet_d
   4617          
   4618            NVM_TableEntryInfo_t tblIdx;    
   4619            uint16_t tableEntryIndex;
   4620          
   4621          #if (gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c != 0) /* FlexNVM */    
   4622            index_t loopCnt;    
   4623            NVM_Status_t status;
   4624          #endif
   4625          
   4626            if(!mNvModuleInitialized)
   4627            {
   4628              return gNVM_ModuleNotInitialized_c;
   4629            }
   4630          
   4631            if(mNvCriticalSectionFlag)
   4632            {
   4633              return gNVM_CriticalSectionActive_c;
   4634            }
   4635          
   4636            if(NULL == ptrData)
   4637            {
   4638              return gNVM_NullPointer_c;
   4639            }
   4640          
   4641            if(gNVM_PointerOutOfRange_c == NvGetEntryFromDataPtr(ptrData, &tblIdx))
   4642            {
   4643              return gNVM_PointerOutOfRange_c;
   4644            }
   4645          
   4646            if(gNvInvalidDataEntry_c == tblIdx.entryId)
   4647            {
   4648              /* element already deleted from RAM table, it can be assumed that also the associated NVM records are erased */
   4649              return gNVM_OK_c;
   4650            }
   4651          
   4652            if((tableEntryIndex = NvGetTableEntryIndexFromId(tblIdx.entryId)) == gNvInvalidTableEntryIndex_c)
   4653            {
   4654              return gNVM_InvalidTableEntry_c;
   4655            }
   4656          
   4657            /* invalidate the table entry */
   4658            pNVM_DataTable[tableEntryIndex].DataEntryID = gNvInvalidDataEntry_c;
   4659          
   4660          #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */
   4661            /* erase the table entry by making a copy of the active page to the inactive one, 
   4662             * but skipping while copying the table entry to be erased */     
   4663            mNvSkipTableEntryId = tblIdx.entryId;
   4664            /* make a request to make a page copy */
   4665            mNvCopyOperationIsPending = TRUE;
   4666          
   4667            return gNVM_OK_c;
   4668          #else /* FlexNVM */
   4669          
   4670            /* format the FlexRAM window */
   4671            NvFormat();
   4672          
   4673            /* re-write the entire NVM table */    
   4674            loopCnt = 0;
   4675            while(gNvEndOfTableId_c != pNVM_DataTable[loopCnt].DataEntryID)
   4676            {
   4677              NvGetEntryFromDataPtr(pNVM_DataTable[loopCnt].pData, &tblIdx);
   4678          
   4679              if(gNvInvalidDataEntry_c == tblIdx.entryId)
   4680              {
   4681                loopCnt++;
   4682                continue;
   4683              }
   4684          
   4685              if(gNVM_OK_c != (status = NvWriteRecord(&tblIdx)))
   4686              {
   4687                return status;
   4688              }
   4689              /* increment the loop counter */
   4690              loopCnt++;
   4691            }
   4692            return status;
   4693          #endif /* FlexNVM */
   4694          
   4695          #else
   4696            (void)ptrData;
   4697            return gNVM_Error_c;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x4770             BX       LR               ;; return
   4698          #endif    
   4699          }
   4700          
   4701          /******************************************************************************
   4702           * Name: NvSyncSave
   4703           * Description: The function saves the pointed element or the entire table
   4704           *              entry to the storage system. The save operation is not
   4705           *              performed on the idle task but within this function call.
   4706           * Parameter(s): [IN] ptrData - a pointer to data to be saved
   4707           *               [IN] saveAll - specifies if the entire table entry shall be 
   4708           *                              saved or only the pointed element
   4709           *               [IN] ignoreCriticalSectionFlag - if set to TRUE, the critical
   4710           *                                                section flag is ignored
   4711           * Return: gNVM_OK_c - if the operation completes successfully         
   4712           *         gNVM_ModuleNotInitialized_c - if the NVM  module is not initialized
   4713           *         gNVM_NullPointer_c - if a NULL pointer is provided
   4714           *         gNVM_PointerOutOfRange_c - if the pointer is out of range
   4715           *         gNVM_InvalidTableEntry_c - if the table entry is not valid
   4716           *         gNVM_MetaInfoWriteError_c - meta tag couldn't be written
   4717           *         gNVM_RecordWriteError_c - record couldn't be written
   4718           *         gNVM_CriticalSectionActive_c - the module is in critical section                             
   4719           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4720          NVM_Status_t NvSyncSave
   4721          (
   4722            void* ptrData,
   4723            bool_t saveAll,
   4724            bool_t ignoreCriticalSectionFlag
   4725          )
   4726          {
   \                     NvSyncSave: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   4727          #if gNvStorageIncluded_d
   4728          
   4729            NVM_TableEntryInfo_t tblIdx;
   4730            NVM_Status_t status;
   4731          
   4732            if(!mNvModuleInitialized)
   \   0000000A   0x....             LDR.N    R0,??DataTable32_3
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD101             BNE.N    ??NvSyncSave_0
   4733            {
   4734              return gNVM_ModuleNotInitialized_c;
   \   00000012   0x200E             MOVS     R0,#+14
   \   00000014   0xE068             B.N      ??NvSyncSave_1
   4735            }
   4736          
   4737            if(mNvCriticalSectionFlag && !ignoreCriticalSectionFlag)
   \                     ??NvSyncSave_0: (+1)
   \   00000016   0x....             LDR.N    R0,??DataTable32_13
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD007             BEQ.N    ??NvSyncSave_2
   \   0000001E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xD104             BNE.N    ??NvSyncSave_2
   4738            {
   4739              NvAddSaveRequestToQueue(&tblIdx);
   \   00000024   0xA800             ADD      R0,SP,#+0
   \   00000026   0x.... 0x....      BL       NvAddSaveRequestToQueue
   4740              return gNVM_CriticalSectionActive_c;
   \   0000002A   0x200F             MOVS     R0,#+15
   \   0000002C   0xE05C             B.N      ??NvSyncSave_1
   4741            }
   4742          
   4743            if(NULL == ptrData)
   \                     ??NvSyncSave_2: (+1)
   \   0000002E   0x2C00             CMP      R4,#+0
   \   00000030   0xD101             BNE.N    ??NvSyncSave_3
   4744            {
   4745              return gNVM_NullPointer_c;
   \   00000032   0x2005             MOVS     R0,#+5
   \   00000034   0xE058             B.N      ??NvSyncSave_1
   4746            }
   4747          
   4748            if((status = NvGetEntryFromDataPtr(ptrData, &tblIdx)) != gNVM_OK_c)
   \                     ??NvSyncSave_3: (+1)
   \   00000036   0xA900             ADD      R1,SP,#+0
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       NvGetEntryFromDataPtr
   \   0000003E   0x0007             MOVS     R7,R0
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD002             BEQ.N    ??NvSyncSave_4
   4749            {
   4750              return status;
   \   00000046   0x0038             MOVS     R0,R7
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0xE04D             B.N      ??NvSyncSave_1
   4751            }
   4752          
   4753            tblIdx.saveRestoreAll = saveAll;
   \                     ??NvSyncSave_4: (+1)
   \   0000004C   0xF88D 0x5004      STRB     R5,[SP, #+4]
   4754          
   4755          #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */
   4756            if((status = NvWriteRecord(&tblIdx)) == gNVM_PageCopyPending_c)
   \   00000050   0xA800             ADD      R0,SP,#+0
   \   00000052   0x.... 0x....      BL       NvWriteRecord
   \   00000056   0x0007             MOVS     R7,R0
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0x2811             CMP      R0,#+17
   \   0000005C   0xD142             BNE.N    ??NvSyncSave_5
   4757            {
   4758          #if gNvUseExtendedFeatureSet_d    	  
   4759          	/* copy active page */
   4760              if((status = NvCopyPage(gNvCopyAll_c)) != gNVM_OK_c)
   4761              {
   4762          	  return status;
   4763          	}
   4764          #else
   4765              /* copy active page */
   4766              if((status = NvCopyPage()) != gNVM_OK_c)
   \   0000005E   0x.... 0x....      BL       NvCopyPage
   \   00000062   0x0007             MOVS     R7,R0
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD002             BEQ.N    ??NvSyncSave_6
   4767              {
   4768                return status;
   \   0000006A   0x0038             MOVS     R0,R7
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0xE03B             B.N      ??NvSyncSave_1
   4769              }
   4770          #endif /* #if gNvUseExtendedFeatureSet_d */
   4771          
   4772              mNvCopyOperationIsPending = FALSE;
   \                     ??NvSyncSave_6: (+1)
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x....             LDR.N    R1,??DataTable32_14
   \   00000074   0x7008             STRB     R0,[R1, #+0]
   4773          
   4774              /* erase old page */
   4775              (void)NV_FlashEraseSector(&mNvConfig, mNvVirtualPageProperty[mNvErasePgCmdStatus.NvPageToErase].NvRawSectorStartAddress,
   4776                  mNvVirtualPageProperty[mNvErasePgCmdStatus.NvPageToErase].NvTotalPageSize);
   \   00000076   0x....             LDR.N    R0,??DataTable32_18
   \   00000078   0x....             LDR.N    R1,??DataTable32_8
   \   0000007A   0x7849             LDRB     R1,[R1, #+1]
   \   0000007C   0x2214             MOVS     R2,#+20
   \   0000007E   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000082   0x68C2             LDR      R2,[R0, #+12]
   \   00000084   0x....             LDR.N    R0,??DataTable32_18
   \   00000086   0x....             LDR.N    R1,??DataTable32_8
   \   00000088   0x7849             LDRB     R1,[R1, #+1]
   \   0000008A   0x2314             MOVS     R3,#+20
   \   0000008C   0xFB03 0x0001      MLA      R0,R3,R1,R0
   \   00000090   0x6801             LDR      R1,[R0, #+0]
   \   00000092   0x....             LDR.N    R0,??DataTable32_15
   \   00000094   0x.... 0x....      BL       NV_FlashEraseSector
   \   00000098   0x4680             MOV      R8,R0
   4777          
   4778              /* blank check */
   4779              if(gNV_OK_c == NV_FlashVerifySection(&mNvConfig, mNvVirtualPageProperty[mNvErasePgCmdStatus.NvPageToErase].NvRawSectorStartAddress,
   4780                  mNvVirtualPageProperty[mNvErasePgCmdStatus.NvPageToErase].NvTotalPageSize, gNV_MARGIN_NORMAL_c))
   \   0000009A   0x2300             MOVS     R3,#+0
   \   0000009C   0x....             LDR.N    R0,??DataTable32_18
   \   0000009E   0x....             LDR.N    R1,??DataTable32_8
   \   000000A0   0x7849             LDRB     R1,[R1, #+1]
   \   000000A2   0x2214             MOVS     R2,#+20
   \   000000A4   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000000A8   0x68C2             LDR      R2,[R0, #+12]
   \   000000AA   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000AC   0x....             LDR.N    R0,??DataTable32_18
   \   000000AE   0x....             LDR.N    R1,??DataTable32_8
   \   000000B0   0x7849             LDRB     R1,[R1, #+1]
   \   000000B2   0xF05F 0x0C14      MOVS     R12,#+20
   \   000000B6   0xFB0C 0x0001      MLA      R0,R12,R1,R0
   \   000000BA   0x6801             LDR      R1,[R0, #+0]
   \   000000BC   0x....             LDR.N    R0,??DataTable32_15
   \   000000BE   0x.... 0x....      BL       NV_FlashVerifySection
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD10A             BNE.N    ??NvSyncSave_7
   4781              {
   4782                mNvVirtualPageProperty[mNvErasePgCmdStatus.NvPageToErase].NvLastMetaInfoAddress = gEmptyPageMetaAddress_c;
   \   000000C6   0x....             LDR.N    R0,??DataTable32_18
   \   000000C8   0x....             LDR.N    R1,??DataTable32_8
   \   000000CA   0x7849             LDRB     R1,[R1, #+1]
   \   000000CC   0x2214             MOVS     R2,#+20
   \   000000CE   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000000D2   0x....             LDR.N    R1,??DataTable32_19  ;; 0x3fff0000
   \   000000D4   0x6101             STR      R1,[R0, #+16]
   4783                mNvErasePgCmdStatus.NvErasePending = FALSE;
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0x....             LDR.N    R1,??DataTable32_8
   \   000000DA   0x7008             STRB     R0,[R1, #+0]
   4784              }
   4785          
   4786              /* write record */
   4787              status = NvWriteRecord(&tblIdx);
   \                     ??NvSyncSave_7: (+1)
   \   000000DC   0xA800             ADD      R0,SP,#+0
   \   000000DE   0x.... 0x....      BL       NvWriteRecord
   \   000000E2   0x0007             MOVS     R7,R0
   4788            }
   4789          #else /* FlexNVM */
   4790            /* write record */
   4791            status = NvWriteRecord(&tblIdx);
   4792            /* wait for EEPROM system to be ready (fix@ENGR283453) */
   4793            while(!(gNV_REG_READ(mNvConfig.ftfxRegBase + gNV_FCNFG_OFFSET_c) & gNV_FCNFG_EEERDY_c));
   4794          #endif
   4795          
   4796            return status;
   \                     ??NvSyncSave_5: (+1)
   \   000000E4   0x0038             MOVS     R0,R7
   \   000000E6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??NvSyncSave_1: (+1)
   \   000000E8   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   4797          
   4798          #else
   4799            (void)ptrData;
   4800            (void)saveAll;
   4801            return gNVM_Error_c;
   4802          #endif
   4803          }
   4804          
   4805          
   4806          /******************************************************************************
   4807           * Name: NvAtomicSave
   4808           * Description: The function performs an atomic save of the entire NV table
   4809           *              to the storage system. The operation is performed
   4810           *              in place (atomic).
   4811           * Parameter(s):  [IN] ignoreCriticalSectionFlag - if set to TRUE, the critical
   4812           *                                                section flag is ignored
   4813           * Return: gNVM_OK_c - if the operation completes successfully
   4814           *         gNVM_ModuleNotInitialized_c - if the NVM  module is not initialized
   4815           *         gNVM_NullPointer_c - if a NULL pointer is provided
   4816           *         gNVM_PointerOutOfRange_c - if the pointer is out of range
   4817           *         gNVM_InvalidTableEntry_c - if the table entry is not valid
   4818           *         gNVM_MetaInfoWriteError_c - meta tag couldn't be written
   4819           *         gNVM_RecordWriteError_c - record couldn't be written
   4820           *         gNVM_CriticalSectionActive_c - the module is in critical section
   4821           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4822          NVM_Status_t NvAtomicSave
   4823          (
   4824            bool_t ignoreCriticalSectionFlag
   4825          )
   4826          {
   \                     NvAtomicSave: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   4827          #if gNvStorageIncluded_d
   4828            NVM_Status_t status = gNVM_OK_c;
   \   00000004   0x2500             MOVS     R5,#+0
   4829            index_t loopCnt = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   4830          
   4831            while(gNvEndOfTableId_c != pNVM_DataTable[loopCnt].DataEntryID)
   \                     ??NvAtomicSave_0: (+1)
   \   00000008   0x....             LDR.N    R0,??DataTable32_12
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000000E   0x210C             MOVS     R1,#+12
   \   00000010   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00000014   0x8900             LDRH     R0,[R0, #+8]
   \   00000016   0xF64F 0x71FE      MOVW     R1,#+65534
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD019             BEQ.N    ??NvAtomicSave_1
   4832            {
   4833              status = NvSyncSave(pNVM_DataTable[loopCnt].pData, TRUE, ignoreCriticalSectionFlag);
   \   0000001E   0x0022             MOVS     R2,R4
   \   00000020   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x....             LDR.N    R0,??DataTable32_12
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002A   0x230C             MOVS     R3,#+12
   \   0000002C   0xFB03 0x0006      MLA      R0,R3,R6,R0
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x.... 0x....      BL       NvSyncSave
   \   00000036   0x0005             MOVS     R5,R0
   4834          
   4835              if((gNVM_CriticalSectionActive_c == status) || (gNVM_NullPointer_c == status))
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D0F             CMP      R5,#+15
   \   0000003C   0xD002             BEQ.N    ??NvAtomicSave_2
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2D05             CMP      R5,#+5
   \   00000042   0xD101             BNE.N    ??NvAtomicSave_3
   4836              {
   4837                /* skip */
   4838                loopCnt++;
   \                     ??NvAtomicSave_2: (+1)
   \   00000044   0x1C76             ADDS     R6,R6,#+1
   4839                continue;
   \   00000046   0xE7DF             B.N      ??NvAtomicSave_0
   4840              }
   4841          
   4842              if(gNVM_OK_c != status)
   \                     ??NvAtomicSave_3: (+1)
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD101             BNE.N    ??NvAtomicSave_1
   4843              {
   4844                /* error */
   4845                break;
   4846              }
   4847          
   4848              /* increment the loop counter */
   4849              loopCnt++;
   \                     ??NvAtomicSave_4: (+1)
   \   0000004E   0x1C76             ADDS     R6,R6,#+1
   \   00000050   0xE7DA             B.N      ??NvAtomicSave_0
   4850            }
   4851            return status;
   \                     ??NvAtomicSave_1: (+1)
   \   00000052   0x0028             MOVS     R0,R5
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
   4852          #else
   4853            return gNVM_Error_c;
   4854          #endif
   4855          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     mNvVirtualPageProperty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     mNvConfig

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     mNvActivePageId

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     mNvPageCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x........         DC32     mNvErasePgCmdStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x3FFF0000         DC32     0x3fff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     mNvVirtualPageProperty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     mNvConfig

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     pNVM_DataTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x........         DC32     mNvActivePageId

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x........         DC32     mNvConfig

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x........         DC32     pNVM_DataTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x........         DC32     mNvCopyOperationIsPending

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0x........         DC32     mNvVirtualPageProperty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \   00000000   0x3FFF0000         DC32     0x3fff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \   00000000   0x........         DC32     maDatasetInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_1:
   \   00000000   0x........         DC32     mNvPendingSavesQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_2:
   \   00000000   0x........         DC32     mNvSaveOnIntervalEvent

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_3:
   \   00000000   0x........         DC32     mNvModuleInitialized

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_4:
   \   00000000   0x........         DC32     NV_STORAGE_MAX_SECTORS

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_5:
   \   00000000   0x........         DC32     mNvActivePageId

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_6:
   \   00000000   0x........         DC32     NV_STORAGE_END_ADDRESS

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_7:
   \   00000000   0x........         DC32     NV_STORAGE_SECTOR_SIZE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_8:
   \   00000000   0x........         DC32     mNvErasePgCmdStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_9:
   \   00000000   0x........         DC32     gNvCountsBetweenSaves

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_10:
   \   00000000   0x........         DC32     mNvSaveOnIntervalTimerID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_11:
   \   00000000   0x........         DC32     gNvMinimumTicksBetweenSaves

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_12:
   \   00000000   0x........         DC32     pNVM_DataTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_13:
   \   00000000   0x........         DC32     mNvCriticalSectionFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_14:
   \   00000000   0x........         DC32     mNvCopyOperationIsPending

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_15:
   \   00000000   0x........         DC32     mNvConfig

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_16:
   \   00000000   0x........         DC32     NvIntervalTimerCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_17:
   \   00000000   0x........         DC32     mNvPageCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_18:
   \   00000000   0x........         DC32     mNvVirtualPageProperty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_19:
   \   00000000   0x3FFF0000         DC32     0x3fff0000
   4856          
   4857          /* EOF */
   4858          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   NvAddSaveRequestToQueue
        24   -> NvPushPendingSave
        24   -> __aeabi_memcpy
      16   NvAtomicSave
        16   -> NvSyncSave
       0   NvClearCriticalSection
      48   NvCopyPage
        48   -> NvEraseVirtualPage
        48   -> NvGetMetaInfo
        48   -> NvGetRecordFullSize
        48   -> NvGetTableEntryIndexFromId
        48   -> NvInternalCopy
        48   -> NvIsRecordCopied
        48   -> NvVirtualPageBlankCheck
        48   -> NvWritePageCounter
       0   NvEraseEntryFromStorage
       8   NvEraseVirtualPage
         8   -> NV_FlashEraseSector
      16   NvFormat
        16   -> NV_FlashRead
        16   -> NvGetLastMetaInfoAddress
        16   -> NvInternalFormat
      12   NvGetEntryFromDataPtr
      24   NvGetLastMetaInfoAddress
        24   -> NV_FlashRead
      16   NvGetMetaInfo
        16   -> NV_FlashRead
      24   NvGetPageFreeSpace
        24   -> NvGetMetaInfo
       0   NvGetPagesStatistics
       0   NvGetPendingSavesCount
      16   NvGetRandomRange
        16   -> RNG_GetRandomNo
       8   NvGetRecordFullSize
       0   NvGetTableEntryIndexFromId
      24   NvIdle
        24   -> NV_FlashEraseSector
        24   -> NV_FlashVerifySection
        24   -> NvAddSaveRequestToQueue
        24   -> NvCopyPage
        24   -> NvGetPendingSavesCount
        24   -> NvGetRandomRange
        24   -> NvGetTableEntryIndexFromId
        24   -> NvPopPendingSave
        24   -> NvTimerTick
        24   -> NvWriteRecord
        24   -> TMR_IsTimerActive
        24   -> TMR_StartSingleShotTimer
       0   NvInitPendingSavesQueue
      24   NvInitStorageSystem
        24   -> NV_FlashRead
        24   -> NvInternalFormat
        24   -> NvVirtualPageBlankCheck
     120   NvInternalCopy
       120   -> NV_FlashProgramLongword
       120   -> NV_FlashRead
       120   -> __aeabi_memcpy
      24   NvInternalFormat
        24   -> NV_FlashEraseSector
        24   -> NvVirtualPageBlankCheck
        24   -> NvWritePageCounter
       0   NvIntervalTimerCallback
      24   NvIsDataSetDirty
        24   -> NvGetEntryFromDataPtr
        24   -> NvGetTableEntryIndexFromId
      24   NvIsMemoryAreaAvailable
        24   -> NV_FlashRead
      32   NvIsRecordCopied
        32   -> NV_FlashRead
      16   NvModuleInit
        16   -> NV_FlashInit
        16   -> NvGetLastMetaInfoAddress
        16   -> NvInitPendingSavesQueue
        16   -> NvInitStorageSystem
        16   -> NvInternalFormat
      16   NvPopPendingSave
        16   -> __aeabi_memcpy
      16   NvPushPendingSave
        16   -> __aeabi_memcpy
       4   NvRegisterTableEntry
      56   NvRestoreData
        56   -> NV_FlashRead
        56   -> NvGetMetaInfo
        56   -> NvGetTableEntryIndexFromId
      24   NvRestoreDataSet
        24   -> NvGetEntryFromDataPtr
        24   -> NvRestoreData
      24   NvSaveOnCount
        24   -> NvAddSaveRequestToQueue
        24   -> NvGetEntryFromDataPtr
        24   -> NvGetTableEntryIndexFromId
      24   NvSaveOnIdle
        24   -> NvAddSaveRequestToQueue
        24   -> NvGetEntryFromDataPtr
      24   NvSaveOnInterval
        24   -> NvGetEntryFromDataPtr
        24   -> NvGetTableEntryIndexFromId
        24   -> TMR_AllocateTimer
       0   NvSetCountsBetweenSaves
       0   NvSetCriticalSection
       0   NvSetMinimumTicksBetweenSaves
      32   NvSyncSave
        32   -> NV_FlashEraseSector
        32   -> NV_FlashVerifySection
        32   -> NvAddSaveRequestToQueue
        32   -> NvCopyPage
        32   -> NvGetEntryFromDataPtr
        32   -> NvWriteRecord
      24   NvTimerTick
        24   -> NvAddSaveRequestToQueue
        24   -> NvWriteRecord
       8   NvVirtualPageBlankCheck
         8   -> NV_FlashVerifySection
      16   NvWritePageCounter
        16   -> NV_FlashProgramLongword
      56   NvWriteRecord
        56   -> NV_FlashProgramLongword
        56   -> NvGetMetaInfo
        56   -> NvGetPageFreeSpace
        56   -> NvGetTableEntryIndexFromId
        56   -> NvIsMemoryAreaAvailable


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable21
       4  ??DataTable24
       4  ??DataTable26
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable32
       4  ??DataTable32_1
       4  ??DataTable32_10
       4  ??DataTable32_11
       4  ??DataTable32_12
       4  ??DataTable32_13
       4  ??DataTable32_14
       4  ??DataTable32_15
       4  ??DataTable32_16
       4  ??DataTable32_17
       4  ??DataTable32_18
       4  ??DataTable32_19
       4  ??DataTable32_2
       4  ??DataTable32_3
       4  ??DataTable32_4
       4  ??DataTable32_5
       4  ??DataTable32_6
       4  ??DataTable32_7
       4  ??DataTable32_8
       4  ??DataTable32_9
     274  NvAddSaveRequestToQueue
      88  NvAtomicSave
       2  NvClearCriticalSection
     390  NvCopyPage
       6  NvEraseEntryFromStorage
      62  NvEraseVirtualPage
      72  NvFormat
     256  NvGetEntryFromDataPtr
     256  NvGetLastMetaInfoAddress
      64  NvGetMetaInfo
     156  NvGetPageFreeSpace
      56  NvGetPagesStatistics
      16  NvGetPendingSavesCount
      52  NvGetRandomRange
      70  NvGetRecordFullSize
      62  NvGetTableEntryIndexFromId
     336  NvIdle
      32  NvInitPendingSavesQueue
     486  NvInitStorageSystem
     648  NvInternalCopy
     112  NvInternalFormat
      10  NvIntervalTimerCallback
     110  NvIsDataSetDirty
     154  NvIsMemoryAreaAvailable
     206  NvIsRecordCopied
     396  NvModuleInit
      78  NvPopPendingSave
      96  NvPushPendingSave
      10  NvRegisterTableEntry
    1018  NvRestoreData
      60  NvRestoreDataSet
     158  NvSaveOnCount
      80  NvSaveOnIdle
     190  NvSaveOnInterval
       8  NvSetCountsBetweenSaves
       2  NvSetCriticalSection
       8  NvSetMinimumTicksBetweenSaves
     236  NvSyncSave
     306  NvTimerTick
      66  NvVirtualPageBlankCheck
      70  NvWritePageCounter
     718  NvWriteRecord
       2  gNvCountsBetweenSaves
       2  gNvMinimumTicksBetweenSaves
       1  mNvActivePageId
      32  mNvConfig
       1  mNvCopyOperationIsPending
       1  mNvCriticalSectionFlag
       8  mNvErasePgCmdStatus
       1  mNvModuleInitialized
       4  mNvPageCounter
     196  mNvPendingSavesQueue
       1  mNvSaveOnIntervalEvent
       1  mNvSaveOnIntervalTimerID
      40  mNvVirtualPageProperty
     192  maDatasetInfo

 
   446 bytes in section .bss
    36 bytes in section .data
 7 616 bytes in section .text
 
 7 616 bytes of CODE memory
   482 bytes of DATA memory

Errors: none
Warnings: none
