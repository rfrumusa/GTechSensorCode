###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        02/Sep/2018  13:33:22
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\Common\usb_framework.c
#    Command line =  
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\Common\usb_framework.c" -D IAR --preprocess
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\List\" -lC
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\List\" -lB
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\List\"
#        --diag_suppress Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\CDC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\Descriptor\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\USB\Class\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Sys Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
#    List file    =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\Debug\List\usb_framework.lst
#    Object file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\Debug\Obj\usb_framework.o
#
###############################################################################

F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\usb_framework.c
      1          /******************************************************************************
      2           *
      3           * Freescale Semiconductor Inc.
      4           * (c) Copyright 2004-2010 Freescale Semiconductor, Inc.
      5           * ALL RIGHTS RESERVED.
      6           *
      7           ******************************************************************************
      8           *
      9           * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR 
     10           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
     11           * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
     12           * IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
     13           * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
     14           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
     15           * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
     16           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
     17           * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
     18           * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
     19           * THE POSSIBILITY OF SUCH DAMAGE.
     20           *
     21           **************************************************************************//*!
     22           *
     23           * @file usb_framework.c
     24           *
     25           * @author
     26           *
     27           * @version
     28           *
     29           * @date
     30           *
     31           * @brief The file contains USB stack framework module implementation.
     32           *
     33           *****************************************************************************/
     34          
     35          /******************************************************************************
     36           * Includes
     37           *****************************************************************************/
     38          #include "EmbeddedTypes.h"          /* Contains User Defined Data Types */
     39          #include "USB_Configuration.h" 
     40          #include "usb_class.h"      /* USB class Header File */
     41          #include "usb_framework.h"  /* USB Framework Header File */
     42          #include "usb_descriptor.h" /* USB descriptor Header File */
     43          #include "USB.h"
     44          #include "Utilities_Interface.h"
     45          
     46          #if gUsbIncluded_d
     47          /*****************************************************************************
     48           * Constant and Macro's
     49           *****************************************************************************/
     50          /****************************************************************************
     51           * Global Variables
     52           ****************************************************************************/

   \                                 In section .bss, align 4
     53          static usbSetupPacket_t* gpaSetupPkt[gNumUsbControllers_d];
   \                     gpaSetupPkt:
   \   00000000                      DS8 4
     54          /*is used to store the value of data which needs to be sent to the USB
     55          host in response to the standard requests.*/

   \                                 In section .bss, align 2
     56          static uint16_t gStdFrameworkData;
   \                     gStdFrameworkData:
   \   00000000                      DS8 2
     57          /*used to store the address received in Set Address in the standard request.*/

   \                                 In section .bss, align 1
     58          static uint8_t  gAssignedAddress;
   \                     gAssignedAddress:
   \   00000000                      DS8 1
     59          /* Framework module callback pointer */
     60          #define  gpfFrameworkCallback(controller_ID) gpfClassFrameworkCallback
     61          #define  gpfOtherReqCallback(controller_ID) gpfOtherReqCallback_

   \                                 In section .bss, align 4
     62          static pfusbReqHandler_t gpfOtherReqCallback_ = NULL;
   \                     gpfOtherReqCallback_:
   \   00000000                      DS8 4
     63          
     64          /* Other Requests Callback pointer */
     65          
     66          

   \                                 In section .rodata, align 4
     67          bool_t const gValidateRequest[gMaxStrdReq_d][3] =
   \                     gValidateRequest:
   \   00000000   0x01 0x01          DC8 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0
   \              0x00 0x01    
   \              0x01 0x00    
   \              0x00 0x00    
   \              0x00 0x01    
   \              0x01 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x00    
   \              0x00         
   \   00000017   0x00 0x01          DC8 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0
   \              0x01 0x00    
   \              0x01 0x01    
   \              0x00 0x01    
   \              0x00 0x00    
   \              0x01 0x00    
   \              0x00 0x01    
   \              0x00 0x00    
   \              0x00         
     68          {
     69            {TRUE,TRUE,FALSE}, /*USB_StrdReq_GetStatus*/
     70                   /* configured state: valid for existing interfaces/endpoints
     71                      address state   : valid only for interface or endpoint 0
     72                      default state   : not specified
     73                   */
     74            {TRUE,TRUE,FALSE}, /* Clear Feature */
     75                   /* configured state: valid only for device in configured state
     76                      address state   : valid only for device (in address state),
     77                                        interface and endpoint 0
     78                      default state   : not specified
     79                   */
     80            {FALSE,FALSE,FALSE}, /*reserved for future use*/
     81                   /* configured state: request not supported
     82                      address state   : request not supported
     83                      default state   : request not supported
     84                   */
     85            {TRUE,TRUE,FALSE}, /* Set Feature */
     86                  /*  configured state: valid only for device in configured state
     87                      address state   : valid only for interface or endpoint 0
     88                      default state   : not specified
     89                  */
     90                  
     91            {FALSE,FALSE,FALSE}, /*reserved for future use*/
     92                  /*  configured state: request not supported
     93                      address state   : request not supported
     94                      default state   : request not supported
     95                   */
     96            {FALSE,TRUE,TRUE}, /*USB_StrdReq_SetAddress*/
     97                  /*  configured state: not specified
     98                      address state   : changes to default state if specified addr == 0,
     99                                        but uses newly specified address
    100                      default state   : changes to address state if specified addr != 0
    101                   */
    102            {TRUE,TRUE,TRUE}, /*USB_StrdReq_GetDescriptor*/
    103                   /* configured state: valid request
    104                      address state   : valid request
    105                      default state   : valid request
    106                   */
    107            {FALSE,FALSE,FALSE}, /*Set Descriptor*/
    108                   /* configured state: request not supported
    109                      address state   : request not supported
    110                      default state   : request not supported
    111                   */
    112            {TRUE,TRUE,FALSE}, /*USB_StrdReq_GetConfig*/
    113                   /* configured state: bConfiguration Value of current config returned
    114                      address state   : value zero must be returned
    115                      default state   : not specified
    116                   */
    117            {TRUE,TRUE,FALSE}, /*USB_StrdReq_SetConfig*/
    118                   /* configured state: If the specified configuration value is zero,
    119                                        then the device enters the Address state.If the
    120                                        specified configuration value matches the
    121                                        configuration value from a config descriptor,
    122                                        then that config is selected and the device
    123                                        remains in the Configured state. Otherwise, the
    124                                        device responds with a Request Error.
    125          
    126                      address state   : If the specified configuration value is zero,
    127                                        then the device remains in the Address state. If
    128                                        the specified configuration value matches the
    129                                        configuration value from a configuration
    130                                        descriptor, then that configuration is selected
    131                                        and the device enters the Configured state.
    132                                        Otherwise,response is Request Error.
    133                      default state   : not specified
    134                   */
    135            {TRUE,FALSE,FALSE}, /*USB_StrdReq_GetInterface*/
    136                   /* configured state: valid request
    137                      address state   : request error
    138                      default state   : not specified
    139                   */
    140            {TRUE,FALSE,FALSE}, /*USB_StrdReq_SetInterface*/
    141                   /* configured state: valid request
    142                      address state   : request error
    143                      default state   : not specified
    144                   */
    145            {TRUE,FALSE,FALSE} /*USB_StrdReq_SyncFrame*/
    146                   /* configured state: valid request
    147                      address state   : request error
    148                      default state   : not specified
    149                   */
    150          };
    151          /*****************************************************************************
    152           * Global Functions Prototypes - None
    153           *****************************************************************************/
    154          
    155          /*****************************************************************************
    156           * Local Types - None
    157           *****************************************************************************/
    158          
    159          /*****************************************************************************
    160           * Local Functions Prototypes
    161           *****************************************************************************/
    162          static void USB_Service_Control (usbDeviceEvent_t * event );
    163          static void USB_ControlServiceHandler(uint8_t controller_ID,
    164                                          uint8_t status,
    165                                          usbSetupPacket_t * setup_packet,
    166                                          uint8_t* *data,
    167                                          usbPacketSize_t *size);
    168          static uint8_t USB_StrdReq_GetStatus(uint8_t      controller_ID,
    169                                          usbSetupPacket_t * setup_packet,
    170                                          uint8_t* *data,
    171                                          usbPacketSize_t *size);
    172          static uint8_t USB_StrdReq_Feature(uint8_t     controller_ID,
    173                                          usbSetupPacket_t * setup_packet,
    174                                          uint8_t* *data,
    175                                          usbPacketSize_t *size);
    176          static uint8_t USB_StrdReq_SetAddress(uint8_t     controller_ID,
    177                                          usbSetupPacket_t * setup_packet,
    178                                          uint8_t* *data,
    179                                          usbPacketSize_t *size);
    180          static uint8_t USB_AssignAddress(uint8_t controller_ID);
    181          static uint8_t USB_StrdReq_GetConfig(uint8_t      controller_ID,
    182                                          usbSetupPacket_t * setup_packet,
    183                                          uint8_t* *data,
    184                                          usbPacketSize_t *size);
    185          static uint8_t USB_StrdReq_SetConfig(uint8_t      controller_ID,
    186                                          usbSetupPacket_t * setup_packet,
    187                                          uint8_t* *data,
    188                                          usbPacketSize_t *size);
    189          static uint8_t USB_StrdReq_GetInterface(uint8_t   controller_ID,
    190                                          usbSetupPacket_t * setup_packet,
    191                                          uint8_t* *data,
    192                                          usbPacketSize_t *size);
    193          static uint8_t USB_StrdReq_SetInterface(uint8_t   controller_ID,
    194                                          usbSetupPacket_t * setup_packet,
    195                                          uint8_t* *data,
    196                                          usbPacketSize_t *size);
    197          static uint8_t USB_StrdReq_SyncFrame(uint8_t      controller_ID,
    198                                          usbSetupPacket_t * setup_packet,
    199                                          uint8_t* *data,
    200                                          usbPacketSize_t *size);
    201          static uint8_t USB_StrdReq_GetDescriptor(uint8_t      controller_ID,
    202                                          usbSetupPacket_t * setup_packet,
    203                                          uint8_t* *data,
    204                                          usbPacketSize_t *size);
    205          
    206          
    207          /*****************************************************************************
    208           * Local Functions Prototypes
    209           *****************************************************************************/
    210          
    211          /*****************************************************************************
    212           * Local Variables
    213           *****************************************************************************/
    214          

   \                                 In section .bss, align 4
    215          static uint8_t extReqToDevice[32];/* used for extended OUT transactions on
   \                     extReqToDevice:
   \   00000000                      DS8 32
    216                                               CONTROL ENDPOINT*/
    217          /*****************************************************************************
    218           * Global Variables
    219           *****************************************************************************/

   \                                 In section .rodata, align 4
    220          pfusbReqHandler_t const gapfStandardRequest[gMaxStrdReq_d] =
   \                     gapfStandardRequest:
   \   00000000   0x........         DC32 USB_StrdReq_GetStatus, USB_StrdReq_Feature, 0H
   \              0x........   
   \              0x00000000   
   \   0000000C   0x........         DC32 USB_StrdReq_Feature, 0H, USB_StrdReq_SetAddress
   \              0x00000000   
   \              0x........   
   \   00000018   0x........         DC32 USB_StrdReq_GetDescriptor, 0H, USB_StrdReq_GetConfig
   \              0x00000000   
   \              0x........   
   \   00000024   0x........         DC32 USB_StrdReq_SetConfig, USB_StrdReq_GetInterface
   \              0x........   
   \   0000002C   0x........         DC32 USB_StrdReq_SetInterface, USB_StrdReq_SyncFrame
   \              0x........   
    221          {
    222              USB_StrdReq_GetStatus,
    223              USB_StrdReq_Feature,
    224              NULL,
    225              USB_StrdReq_Feature,
    226              NULL,
    227              USB_StrdReq_SetAddress,
    228              USB_StrdReq_GetDescriptor,
    229              NULL,
    230              USB_StrdReq_GetConfig,
    231              USB_StrdReq_SetConfig,
    232              USB_StrdReq_GetInterface,
    233              USB_StrdReq_SetInterface,
    234              USB_StrdReq_SyncFrame
    235          };
    236          
    237          /**************************************************************************//*!
    238           *
    239           * @name  USB_Framework_Init
    240           *
    241           * @brief The funtion initializes the Class Module
    242           *
    243           * @param controller_ID     : Controller ID
    244           * @param class_callback    : Class callback pointer
    245           * @param other_req_callback: Other Request Callback
    246           *
    247           * @return status
    248           *         gUsbErr_NoError_c           : When Successfull
    249           *         Others           : Errors
    250           *
    251           ******************************************************************************
    252           * This fuction registers the service on the control endpoint
    253           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    254          uint8_t USB_Framework_Init (
    255              uint8_t              controllerId,       /* [IN] Controller ID */
    256              pfUsbToAppEventHandler_t  pfClassCallback,      /* Class Callback */
    257              pfusbReqHandler_t        pfOtherReqCallback   /* Other Request Callback */
    258          )
    259          {
   \                     USB_Framework_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    260            uint8_t error=gUsbErr_NoError_c;
   \   00000008   0x2700             MOVS     R7,#+0
    261            /* save input parameters */
    262            gpfFrameworkCallback(controllerId) = pfClassCallback;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable10
   \   0000000E   0x6005             STR      R5,[R0, #+0]
    263            gpfOtherReqCallback(controllerId) = pfOtherReqCallback;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000014   0x6006             STR      R6,[R0, #+0]
    264            /* Register CONTROL service */
    265            error = USB_DeviceRegisterService(controllerId, gUsbService_Ep0_d, USB_Service_Control);
   \   00000016   0x.... 0x....      ADR.W    R2,USB_Service_Control
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x.... 0x....      BL       USB_DeviceRegisterService
   \   00000024   0x0007             MOVS     R7,R0
    266            return error;
   \   00000026   0x0038             MOVS     R0,R7
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    267          }
    268          
    269          /**************************************************************************//*!
    270           *
    271           * @name  USB_Framework_DeInit
    272           *
    273           * @brief The funtion De-initializes the Class Module
    274           *
    275           * @param controller_ID     : Controller ID
    276           *
    277           * @return status
    278           *         gUsbErr_NoError_c           : When Successfull
    279           *         Others           : Errors
    280           *
    281           ******************************************************************************
    282           * This fuction unregisters control service
    283           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    284          uint8_t USB_Framework_DeInit
    285          (
    286              uint8_t controllerId       /* [IN] Controller ID */
    287          ) 
    288          {
   \                     USB_Framework_DeInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    289              uint8_t error;
    290              error =  USB_DeviceDeinit (controllerId);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       USB_DeviceDeinit
   \   0000000C   0x0005             MOVS     R5,R0
    291              /* Free framwork_callback */
    292              gpfFrameworkCallback(controllerId) = NULL;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000014   0x6008             STR      R0,[R1, #+0]
    293                /* Free other_req_callback */
    294              gpfOtherReqCallback(controllerId) = NULL;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    295                /* Return error */
    296              return error;
   \   0000001E   0x0028             MOVS     R0,R5
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    297          }
    298          
    299          /**************************************************************************//*!
    300           *
    301           * @name  USB_Service_Control
    302           *
    303           * @brief Called upon a completed endpoint 0 transfer
    304           *
    305           * @param event : Pointer to USB Event Structure
    306           *
    307           * @return None
    308           *
    309           ******************************************************************************
    310           * This function handles the data sent or received on the control endpoint
    311           *****************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    312          static void USB_Service_Control (
    313              usbDeviceEvent_t * event /* [IN] Pointer to USB Event Structure */
    314          )
    315          {
   \                     USB_Service_Control: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0004             MOVS     R4,R0
    316            uint16_t    deviceState = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    317            uint8_t     status = gUsbErr_InvalidReqType_c;
   \   0000000C   0x25CD             MOVS     R5,#+205
    318            uint8_t* data = NULL;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x9002             STR      R0,[SP, #+8]
    319            usbPacketSize_t size;
    320            usbSetupPacket_t* pSetupPkt = gpaSetupPkt[event->controllerId];
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000016   0x7821             LDRB     R1,[R4, #+0]
   \   00000018   0xF850 0x6021      LDR      R6,[R0, R1, LSL #+2]
    321            /* get the device state  */
    322            (void)USB_DeviceGetStatus(event->controllerId , gUsbComponentStatus_DeviceState_d , &deviceState);
   \   0000001C   0xF10D 0x0206      ADD      R2,SP,#+6
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x7820             LDRB     R0,[R4, #+0]
   \   00000024   0x.... 0x....      BL       USB_DeviceGetStatus
    323            if (event->setup == TRUE)
   \   00000028   0x78A1             LDRB     R1,[R4, #+2]
   \   0000002A   0x2901             CMP      R1,#+1
   \   0000002C   0xD171             BNE.N    ??USB_Service_Control_0
    324            {
    325              /* get the setup packet */
    326              pSetupPkt = gpaSetupPkt[event->controllerId] = (usbSetupPacket_t*)event->pBuffer;
   \   0000002E   0x6860             LDR      R0,[R4, #+4]
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   00000034   0x7822             LDRB     R2,[R4, #+0]
   \   00000036   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   0000003E   0x7821             LDRB     R1,[R4, #+0]
   \   00000040   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000044   0x0006             MOVS     R6,R0
    327              /* take care of endianess  of the 16 bt fields correctly */
    328          #if (gLittle_Endian_d == 0)    
    329              pSetupPkt->index = USB_ByteSwap16(pSetupPkt->index);
    330              pSetupPkt->value = USB_ByteSwap16(pSetupPkt->value);
    331              pSetupPkt->length = USB_ByteSwap16(pSetupPkt->length);
    332          #endif    
    333              /* if the request is standard request */
    334              if ((pSetupPkt->requestType & gUsbRequestClassMask_d) == gUsbRequestClass_Strd_d)
   \   00000046   0x7830             LDRB     R0,[R6, #+0]
   \   00000048   0x2160             MOVS     R1,#+96
   \   0000004A   0x4208             TST      R0,R1
   \   0000004C   0xD122             BNE.N    ??USB_Service_Control_1
    335              {
    336                /* if callback is not NULL */
    337                if (gapfStandardRequest[pSetupPkt->request] != NULL)
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   00000052   0x7871             LDRB     R1,[R6, #+1]
   \   00000054   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD050             BEQ.N    ??USB_Service_Control_2
    338                {
    339                  /* if the request is valid in this device state */
    340                  if((deviceState < gUsbDeviceState_Powered_d) && (gValidateRequest[pSetupPkt->request][deviceState] == TRUE))
   \   0000005C   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \   00000060   0x2803             CMP      R0,#+3
   \   00000062   0xDA4C             BGE.N    ??USB_Service_Control_2
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \   00000068   0x7871             LDRB     R1,[R6, #+1]
   \   0000006A   0x2203             MOVS     R2,#+3
   \   0000006C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000070   0xF8BD 0x1006      LDRH     R1,[SP, #+6]
   \   00000074   0x5C08             LDRB     R0,[R1, R0]
   \   00000076   0x2801             CMP      R0,#+1
   \   00000078   0xD141             BNE.N    ??USB_Service_Control_2
    341                  {
    342                    /* Standard Request function pointers */
    343                    status = gapfStandardRequest[pSetupPkt->request](event->controllerId, pSetupPkt, &data, (usbPacketSize_t *)&size);
   \   0000007A   0xAB01             ADD      R3,SP,#+4
   \   0000007C   0xAA02             ADD      R2,SP,#+8
   \   0000007E   0x0031             MOVS     R1,R6
   \   00000080   0x7820             LDRB     R0,[R4, #+0]
   \   00000082   0x.... 0x....      LDR.W    R7,??DataTable10_3
   \   00000086   0xF896 0xC001      LDRB     R12,[R6, #+1]
   \   0000008A   0xF857 0x702C      LDR      R7,[R7, R12, LSL #+2]
   \   0000008E   0x47B8             BLX      R7
   \   00000090   0x0005             MOVS     R5,R0
   \   00000092   0xE034             B.N      ??USB_Service_Control_2
    344                  }
    345                }
    346              }
    347              else /* for Class/Vendor requests */
    348              {
    349                /*get the length from the setup_request*/
    350                size = (usbPacketSize_t)pSetupPkt->length;
   \                     ??USB_Service_Control_1: (+1)
   \   00000094   0x88F0             LDRH     R0,[R6, #+6]
   \   00000096   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    351                if( (size != 0) && ((pSetupPkt->requestType & gUsbDataDirMask_d) == gUsbDataDir_ToDevice_d) )
   \   0000009A   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD01F             BEQ.N    ??USB_Service_Control_3
   \   000000A2   0x7830             LDRB     R0,[R6, #+0]
   \   000000A4   0x0600             LSLS     R0,R0,#+24
   \   000000A6   0xD41C             BMI.N    ??USB_Service_Control_3
    352                {
    353                  (void)MemoryCpy(extReqToDevice, pSetupPkt, gUsbSetupPacketSize_d);
   \   000000A8   0x2208             MOVS     R2,#+8
   \   000000AA   0x0031             MOVS     R1,R6
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   000000B0   0x.... 0x....      BL       MemoryCpy
    354                  gpaSetupPkt[event->controllerId] = (usbSetupPacket_t*)extReqToDevice;
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   000000BC   0x7822             LDRB     R2,[R4, #+0]
   \   000000BE   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
    355                  /* expecting host to send data (OUT TRANSACTION)*/
    356                  if(size > (sizeof(extReqToDevice) - gUsbSetupPacketSize_d))
   \   000000C2   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   000000C6   0x2819             CMP      R0,#+25
   \   000000C8   0xD302             BCC.N    ??USB_Service_Control_4
    357                  {
    358                    size = sizeof(extReqToDevice) - gUsbSetupPacketSize_d;
   \   000000CA   0x2018             MOVS     R0,#+24
   \   000000CC   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    359                  }
    360                  (void)USB_DeviceRecvData(event->controllerId, gUsbControlEndpoint_d, extReqToDevice+gUsbSetupPacketSize_d,
    361                  (usbPacketSize_t)(size));
   \                     ??USB_Service_Control_4: (+1)
   \   000000D0   0xF8BD 0x3004      LDRH     R3,[SP, #+4]
   \   000000D4   0x.... 0x....      LDR.W    R2,??DataTable10_6
   \   000000D8   0x2100             MOVS     R1,#+0
   \   000000DA   0x7820             LDRB     R0,[R4, #+0]
   \   000000DC   0x.... 0x....      BL       USB_DeviceRecvData
    362                  return;
   \   000000E0   0xE059             B.N      ??USB_Service_Control_5
    363                }
    364                else if(gpfOtherReqCallback(event->controllerId) != NULL)/*call class/vendor request*/
   \                     ??USB_Service_Control_3: (+1)
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   000000E6   0x6800             LDR      R0,[R0, #+0]
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD008             BEQ.N    ??USB_Service_Control_2
    365                {
    366                  status = gpfOtherReqCallback(event->controllerId)(event->controllerId,
    367                              pSetupPkt, &data, (usbPacketSize_t*)&size);
   \   000000EC   0xAB01             ADD      R3,SP,#+4
   \   000000EE   0xAA02             ADD      R2,SP,#+8
   \   000000F0   0x0031             MOVS     R1,R6
   \   000000F2   0x7820             LDRB     R0,[R4, #+0]
   \   000000F4   0x.... 0x....      LDR.W    R7,??DataTable10_1
   \   000000F8   0x683F             LDR      R7,[R7, #+0]
   \   000000FA   0x47B8             BLX      R7
   \   000000FC   0x0005             MOVS     R5,R0
    368                }
    369              }
    370              USB_ControlServiceHandler(event->controllerId , status , pSetupPkt , &data, (usbPacketSize_t*)&size);
   \                     ??USB_Service_Control_2: (+1)
   \   000000FE   0xA801             ADD      R0,SP,#+4
   \   00000100   0x9000             STR      R0,[SP, #+0]
   \   00000102   0xAB02             ADD      R3,SP,#+8
   \   00000104   0x0032             MOVS     R2,R6
   \   00000106   0x0029             MOVS     R1,R5
   \   00000108   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000010A   0x7820             LDRB     R0,[R4, #+0]
   \   0000010C   0x.... 0x....      BL       USB_ControlServiceHandler
   \   00000110   0xE041             B.N      ??USB_Service_Control_6
    371            }
    372            /* if its not a setup request */
    373            else if(deviceState == gUsbDeviceState_PendingAddress_d)
   \                     ??USB_Service_Control_0: (+1)
   \   00000112   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \   00000116   0x2804             CMP      R0,#+4
   \   00000118   0xD103             BNE.N    ??USB_Service_Control_7
    374            {
    375              /* Device state is PENDING_ADDRESS */
    376              /* Assign the new adddress to the Device */
    377              (void)USB_AssignAddress(event->controllerId);
   \   0000011A   0x7820             LDRB     R0,[R4, #+0]
   \   0000011C   0x.... 0x....      BL       USB_AssignAddress
    378              return;
   \   00000120   0xE039             B.N      ??USB_Service_Control_5
    379            }
    380            else if( ((pSetupPkt->requestType & gUsbDataDirMask_d) == gUsbDataDir_ToDevice_d) &&
    381                      (event->direction == gUsbEpDirection_Out_c) )
   \                     ??USB_Service_Control_7: (+1)
   \   00000122   0x7830             LDRB     R0,[R6, #+0]
   \   00000124   0x0600             LSLS     R0,R0,#+24
   \   00000126   0xD41F             BMI.N    ??USB_Service_Control_8
   \   00000128   0x78E0             LDRB     R0,[R4, #+3]
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD11C             BNE.N    ??USB_Service_Control_8
    382            {
    383              /* execution enters Control Service because of OUT transaction on gUsbControlEndpoint_d*/
    384              if(gpfOtherReqCallback(event->controllerId) != NULL)
   \   0000012E   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000132   0x6800             LDR      R0,[R0, #+0]
   \   00000134   0x2800             CMP      R0,#+0
   \   00000136   0xD00D             BEQ.N    ??USB_Service_Control_9
    385              {/* class or vendor request */
    386                size = (usbPacketSize_t)(event->len + gUsbSetupPacketSize_d);
   \   00000138   0x8920             LDRH     R0,[R4, #+8]
   \   0000013A   0x3008             ADDS     R0,R0,#+8
   \   0000013C   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    387                status = gpfOtherReqCallback(event->controllerId)(event->controllerId,
    388                          (usbSetupPacket_t*)(extReqToDevice), &data, 
    389                          (usbPacketSize_t*)&size);
   \   00000140   0xAB01             ADD      R3,SP,#+4
   \   00000142   0xAA02             ADD      R2,SP,#+8
   \   00000144   0x.... 0x....      LDR.W    R1,??DataTable10_5
   \   00000148   0x7820             LDRB     R0,[R4, #+0]
   \   0000014A   0x.... 0x....      LDR.W    R7,??DataTable10_1
   \   0000014E   0x683F             LDR      R7,[R7, #+0]
   \   00000150   0x47B8             BLX      R7
   \   00000152   0x0005             MOVS     R5,R0
    390              }
    391          
    392              USB_ControlServiceHandler(event->controllerId , status , pSetupPkt , &data , (usbPacketSize_t*)&size);
   \                     ??USB_Service_Control_9: (+1)
   \   00000154   0xA801             ADD      R0,SP,#+4
   \   00000156   0x9000             STR      R0,[SP, #+0]
   \   00000158   0xAB02             ADD      R3,SP,#+8
   \   0000015A   0x0032             MOVS     R2,R6
   \   0000015C   0x0029             MOVS     R1,R5
   \   0000015E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000160   0x7820             LDRB     R0,[R4, #+0]
   \   00000162   0x.... 0x....      BL       USB_ControlServiceHandler
   \   00000166   0xE016             B.N      ??USB_Service_Control_6
    393            }
    394            else
    395            {
    396              if(event->shortSend && (event->direction == gUsbEpDirection_In_c))
   \                     ??USB_Service_Control_8: (+1)
   \   00000168   0x7AE0             LDRB     R0,[R4, #+11]
   \   0000016A   0x2800             CMP      R0,#+0
   \   0000016C   0xD013             BEQ.N    ??USB_Service_Control_6
   \   0000016E   0x78E0             LDRB     R0,[R4, #+3]
   \   00000170   0x2801             CMP      R0,#+1
   \   00000172   0xD110             BNE.N    ??USB_Service_Control_6
    397              {
    398                usbMsg_t usbMsg;
    399                usbMsg.controllerId = event->controllerId;
   \   00000174   0x7820             LDRB     R0,[R4, #+0]
   \   00000176   0xF88D 0x000C      STRB     R0,[SP, #+12]
    400                usbMsg.eventType = gUsbToAppEvent_ShortSendComplete_c;
   \   0000017A   0x200B             MOVS     R0,#+11
   \   0000017C   0xF88D 0x000D      STRB     R0,[SP, #+13]
    401                usbMsg.eventParam.shortSendCompleteEvent.epNum = event->epNum;
   \   00000180   0x7860             LDRB     R0,[R4, #+1]
   \   00000182   0xF88D 0x0010      STRB     R0,[SP, #+16]
    402                usbMsg.eventParam.shortSendCompleteEvent.pBuffer = event->pBuffer;
   \   00000186   0x6860             LDR      R0,[R4, #+4]
   \   00000188   0x9005             STR      R0,[SP, #+20]
    403                usbMsg.eventParam.shortSendCompleteEvent.len = event->len;
   \   0000018A   0x8920             LDRH     R0,[R4, #+8]
   \   0000018C   0xF8AD 0x0018      STRH     R0,[SP, #+24]
    404                USB_IsrEvent(&usbMsg);           
   \   00000190   0xA803             ADD      R0,SP,#+12
   \   00000192   0x.... 0x....      BL       USB_IsrEvent
    405              }
    406            }
    407            return;
   \                     ??USB_Service_Control_6: (+1)
   \                     ??USB_Service_Control_5: (+1)
   \   00000196   0xB007             ADD      SP,SP,#+28
   \   00000198   0xBDF0             POP      {R4-R7,PC}       ;; return
    408          }
    409          
    410          /**************************************************************************//*!
    411           *
    412           * @name  USB_ControlServiceHandler
    413           *
    414           * @brief The function is used to send a response to the Host based.
    415           *
    416           * @param controller_ID : Controller ID
    417           * @param status        : Status of request
    418           * @param setup_packet  : Setup packet received
    419           * @param data          : Data to be send back
    420           * @param size          : Size to be returned
    421           *
    422           * @return None
    423           *
    424           ******************************************************************************
    425           * This function sends a response to the data received on the control endpoint.
    426           * the request is decoded in the control service
    427           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    428          static void USB_ControlServiceHandler (
    429              uint8_t    controllerId,            /* [IN] Controller ID */
    430              uint8_t status,                      /* [IN] Device Status */
    431              usbSetupPacket_t * pSetupPacket,    /* [IN] Setup packet received */
    432              uint8_t* *data,                   /* [OUT] Data to be send back */
    433              usbPacketSize_t *size               /* [OUT] Size to be returned */
    434          )
    435          {
   \                     USB_ControlServiceHandler: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8030      LDR      R8,[SP, #+48]
    436            if(status == gUsbErr_InvalidReqType_c)
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x2DCD             CMP      R5,#+205
   \   00000016   0xD106             BNE.N    ??USB_ControlServiceHandler_0
    437            {
    438              /* incase of error Stall endpoint */
    439              (void)USB_DeviceSetStatus(controllerId,
    440                      (uint8_t)(gUsbComponentStatus_Endpoint_d | gUsbControlEndpoint_d |
    441                      (gUsbEpDirection_In_c << gUsbComponent_DirectionShift_d)),
    442                      gUsbStatus_Stalled_d);
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0x2190             MOVS     R1,#+144
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x.... 0x....      BL       USB_DeviceSetStatus
   \   00000024   0xE028             B.N      ??USB_ControlServiceHandler_1
    443            }
    444            else if(status == gUsbErr_ProcessLater_c)
   \                     ??USB_ControlServiceHandler_0: (+1)
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x2DCF             CMP      R5,#+207
   \   0000002A   0xD109             BNE.N    ??USB_ControlServiceHandler_2
    445            {
    446              usbMsg_t usbMsg;
    447              usbMsg.controllerId = controllerId;
   \   0000002C   0xF88D 0x4004      STRB     R4,[SP, #+4]
    448              usbMsg.eventType = gUsbToAppEvent_RequestPending_c;
   \   00000030   0x200A             MOVS     R0,#+10
   \   00000032   0xF88D 0x0005      STRB     R0,[SP, #+5]
    449              usbMsg.eventParam.requestPendingEvent.pSetupPacket = pSetupPacket;
   \   00000036   0x9602             STR      R6,[SP, #+8]
    450              USB_IsrEvent(&usbMsg);  
   \   00000038   0xA801             ADD      R0,SP,#+4
   \   0000003A   0x.... 0x....      BL       USB_IsrEvent
   \   0000003E   0xE01B             B.N      ??USB_ControlServiceHandler_1
    451            }
    452            else /* Need to send Data to the USB Host */
    453            {
    454              /* send the data prepared by the handlers.*/
    455              if(*size > pSetupPacket->length)
   \                     ??USB_ControlServiceHandler_2: (+1)
   \   00000040   0x88F0             LDRH     R0,[R6, #+6]
   \   00000042   0xF8B8 0x1000      LDRH     R1,[R8, #+0]
   \   00000046   0x4288             CMP      R0,R1
   \   00000048   0xD202             BCS.N    ??USB_ControlServiceHandler_3
    456              {
    457                *size = (usbPacketSize_t)pSetupPacket->length;
   \   0000004A   0x88F0             LDRH     R0,[R6, #+6]
   \   0000004C   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    458              }
    459              /* send the data to the host */
    460              (void)USB_ClassSendData(controllerId , gUsbControlEndpoint_d, *data, *size);
   \                     ??USB_ControlServiceHandler_3: (+1)
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x9000             STR      R0,[SP, #+0]
   \   00000054   0xF8B8 0x3000      LDRH     R3,[R8, #+0]
   \   00000058   0x683A             LDR      R2,[R7, #+0]
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0x.... 0x....      BL       USB_ClassSendData_
    461              if((pSetupPacket->requestType & gUsbDataDirMask_d) ==
    462                      gUsbDataDir_ToHost_d)
   \   00000064   0x7831             LDRB     R1,[R6, #+0]
   \   00000066   0x0609             LSLS     R1,R1,#+24
   \   00000068   0xD506             BPL.N    ??USB_ControlServiceHandler_1
    463                  {   /* Request was to Get Data from device */
    464                      /* setup rcv to get status from host */
    465                      (void)USB_DeviceRecvData(controllerId,
    466                          gUsbControlEndpoint_d,NULL,0);
   \   0000006A   0x2300             MOVS     R3,#+0
   \   0000006C   0x2200             MOVS     R2,#+0
   \   0000006E   0x2100             MOVS     R1,#+0
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000074   0x.... 0x....      BL       USB_DeviceRecvData
    467                  }
    468            }
    469            return;
   \                     ??USB_ControlServiceHandler_1: (+1)
   \   00000078   0xB006             ADD      SP,SP,#+24
   \   0000007A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    470          }
    471          /*************************************************************************//*!
    472           *
    473           * @name  USB_StrdReq_GetStatus
    474           *
    475           * @brief  This function is called in response to Get Status request
    476           *
    477           * @param controller_ID : Controller ID
    478           * @param setup_packet  : Setup packet received
    479           * @param data          : Data to be send back
    480           * @param size          : Size to be returned
    481           *
    482           * @return status:
    483           *               gUsbErr_NoError_c : When Successfull
    484           *               Others : When Error
    485           *
    486           ******************************************************************************
    487           * this is a ch9 request and is called by the host to know the status of the
    488           * device, the interface and the endpoint
    489           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    490          static uint8_t USB_StrdReq_GetStatus (
    491              uint8_t    controllerId,            /* [IN] Controller ID */
    492              usbSetupPacket_t * pSetupPacket,    /* [IN] Setup packet received */
    493              uint8_t* *data,                   /* [OUT] Data to be send back */
    494              usbPacketSize_t *size               /* [OUT] Size to be returned */
    495          )
    496          {
   \                     USB_StrdReq_GetStatus: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    497            uint8_t interface, endpoint;
    498            uint8_t status = gUsbErr_InvalidReqType_c;
   \   0000000C   0xF05F 0x0ACD      MOVS     R10,#+205
    499          
    500            if((pSetupPacket->requestType & gUsbRequestSrcMask_d) == gUsbRequestSrc_Device_d)
   \   00000010   0x7828             LDRB     R0,[R5, #+0]
   \   00000012   0x2103             MOVS     R1,#+3
   \   00000014   0x4208             TST      R0,R1
   \   00000016   0xD10F             BNE.N    ??USB_StrdReq_GetStatus_0
    501            {    
    502                   /* request for Device */
    503            status = USB_DeviceGetStatus(controllerId , gUsbComponentStatus_Device_d , &gStdFrameworkData);
   \   00000018   0x....             LDR.N    R2,??DataTable10_7
   \   0000001A   0x2106             MOVS     R1,#+6
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x.... 0x....      BL       USB_DeviceGetStatus
   \   00000024   0x4682             MOV      R10,R0
    504            gStdFrameworkData &= gUsbGetStatusDeviceMask_d;
   \   00000026   0x....             LDR.N    R0,??DataTable10_7
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   0000002E   0x....             LDR.N    R1,??DataTable10_7
   \   00000030   0x8008             STRH     R0,[R1, #+0]
    505          #if (gLittle_Endian_d == 0)
    506            gStdFrameworkData = USB_ByteSwap16(gStdFrameworkData);
    507          #endif
    508            *size = gDeviceStatusSize_d;
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x8038             STRH     R0,[R7, #+0]
   \   00000036   0xE024             B.N      ??USB_StrdReq_GetStatus_1
    509            }
    510            else if ((pSetupPacket->requestType & gUsbRequestSrcMask_d) == gUsbRequestSrc_Interface_d)
   \                     ??USB_StrdReq_GetStatus_0: (+1)
   \   00000038   0x7828             LDRB     R0,[R5, #+0]
   \   0000003A   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xD10C             BNE.N    ??USB_StrdReq_GetStatus_2
    511            {    
    512              /* request for Interface */
    513              interface  = (uint8_t) pSetupPacket->index;
   \   00000042   0x88A8             LDRH     R0,[R5, #+4]
   \   00000044   0x4680             MOV      R8,R0
    514              status =  USB_Desc_GetInterface(controllerId , interface , (uint8_t*)&gStdFrameworkData);
   \   00000046   0x....             LDR.N    R2,??DataTable10_7
   \   00000048   0x4641             MOV      R1,R8
   \   0000004A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x.... 0x....      BL       USB_Desc_GetInterface
   \   00000054   0x4682             MOV      R10,R0
    515              *size = gUsbInterfaceStatusSize_d;
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0x8038             STRH     R0,[R7, #+0]
   \   0000005A   0xE012             B.N      ??USB_StrdReq_GetStatus_1
    516            }
    517            else if ((pSetupPacket->requestType & gUsbRequestSrcMask_d) == gUsbRequestSrc_Endpoint_d)
   \                     ??USB_StrdReq_GetStatus_2: (+1)
   \   0000005C   0x7828             LDRB     R0,[R5, #+0]
   \   0000005E   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000062   0x2802             CMP      R0,#+2
   \   00000064   0xD10D             BNE.N    ??USB_StrdReq_GetStatus_1
    518            {   
    519              /* request for Endpoint */
    520              endpoint  = (uint8_t)(((uint8_t) pSetupPacket->index) | gUsbComponentStatus_Endpoint_d);
   \   00000066   0x88A8             LDRH     R0,[R5, #+4]
   \   00000068   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000006C   0x4681             MOV      R9,R0
    521              status =  USB_DeviceGetStatus(controllerId , endpoint , &gStdFrameworkData);
   \   0000006E   0x....             LDR.N    R2,??DataTable10_7
   \   00000070   0x4649             MOV      R1,R9
   \   00000072   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0x.... 0x....      BL       USB_DeviceGetStatus
   \   0000007C   0x4682             MOV      R10,R0
    522          #if (gLittle_Endian_d == 0)    
    523              gStdFrameworkData = USB_ByteSwap16(gStdFrameworkData);
    524          #endif    
    525              *size = gUsbEndpStatusSize_d;
   \   0000007E   0x2002             MOVS     R0,#+2
   \   00000080   0x8038             STRH     R0,[R7, #+0]
    526            }
    527            *data = (uint8_t*)&gStdFrameworkData;
   \                     ??USB_StrdReq_GetStatus_1: (+1)
   \   00000082   0x....             LDR.N    R0,??DataTable10_7
   \   00000084   0x6030             STR      R0,[R6, #+0]
    528            return status;
   \   00000086   0x4650             MOV      R0,R10
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    529          }
    530          
    531          /**************************************************************************//*!
    532           *
    533           * @name  USB_StrdReq_Feature
    534           *
    535           * @brief  This function is called in response to Clear or Set Feature request
    536           *
    537           * @param controller_ID : Controller ID
    538           * @param setup_packet  : Setup packet received
    539           * @param data          : Data to be send back
    540           * @param size          : Size to be returned
    541           *
    542           * @return status:
    543           *               gUsbErr_NoError_c : When Successfull
    544           *               Others : When Error
    545           *
    546           ******************************************************************************
    547           * This is a ch9 request, used to set/clear a feature on the device
    548           * (device_remote_wakeup and test_mode) or on the endpoint(ep halt)
    549           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    550          static uint8_t USB_StrdReq_Feature (
    551              uint8_t    controllerId,            /* [IN] Controller ID */
    552              usbSetupPacket_t * pSetupPacket,    /* [IN] Setup packet received */
    553              uint8_t* *data,                   /* [OUT] Data to be send back */
    554              usbPacketSize_t *size               /* [OUT] Size to be returned */
    555          )
    556          {
   \                     USB_StrdReq_Feature: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    557            uint16_t deviceStatus;
    558            uint8_t  setRequest;
    559            uint8_t  status = gUsbErr_InvalidReqType_c;
   \   0000000E   0xF05F 0x08CD      MOVS     R8,#+205
    560            uint8_t  epinfo;
    561            gUsbToAppEvent_t event;
    562            usbMsg_t usbMsg;
    563            (void) (data);
    564            *size=0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x8038             STRH     R0,[R7, #+0]
    565            /* find whether its a clear feature request or a set feature request */
    566            setRequest = (uint8_t)((pSetupPacket->request & gUsbSetRequestMask_d) >> 1 );
   \   00000016   0x7868             LDRB     R0,[R5, #+1]
   \   00000018   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000001C   0x4683             MOV      R11,R0
    567            if((pSetupPacket->requestType & gUsbRequestSrcMask_d) == gUsbRequestSrc_Device_d)
   \   0000001E   0x7828             LDRB     R0,[R5, #+0]
   \   00000020   0x2103             MOVS     R1,#+3
   \   00000022   0x4208             TST      R0,R1
   \   00000024   0xD152             BNE.N    ??USB_StrdReq_Feature_0
    568            {
    569              if(setRequest == TRUE)
   \   00000026   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000002A   0xF1BB 0x0F01      CMP      R11,#+1
   \   0000002E   0xD128             BNE.N    ??USB_StrdReq_Feature_1
    570              { 
    571                uint16_t device_set_feature_bitfield = gUsbDeviceSetFeatureMask_d;
   \   00000030   0xF05F 0x0A02      MOVS     R10,#+2
    572                if(((uint16_t)(1 << (uint8_t)pSetupPacket->value)) & device_set_feature_bitfield)
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x8869             LDRH     R1,[R5, #+2]
   \   00000038   0x4088             LSLS     R0,R0,R1
   \   0000003A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003C   0xEA10 0x0F0A      TST      R0,R10
   \   00000040   0xD01C             BEQ.N    ??USB_StrdReq_Feature_2
    573                {
    574                  status = gUsbErr_NoError_c;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x4680             MOV      R8,R0
    575                  if(pSetupPacket->value == gUsbDeviceFeatureRemoteWakeup_d)
   \   00000046   0x8868             LDRH     R0,[R5, #+2]
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD16F             BNE.N    ??USB_StrdReq_Feature_3
    576                  {
    577                    status = USB_DeviceGetStatus(controllerId , gUsbComponentStatus_Device_d , &deviceStatus);
   \   0000004C   0xAA00             ADD      R2,SP,#+0
   \   0000004E   0x2106             MOVS     R1,#+6
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000054   0x.... 0x....      BL       USB_DeviceGetStatus
   \   00000058   0x4680             MOV      R8,R0
    578                    /* add the request to be cleared from device_status */
    579                    deviceStatus |= (uint16_t)(1 << (uint8_t)pSetupPacket->value);                   
   \   0000005A   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0x886A             LDRH     R2,[R5, #+2]
   \   00000062   0x4091             LSLS     R1,R1,R2
   \   00000064   0x4308             ORRS     R0,R1,R0
   \   00000066   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    580                    /* set the status on the device */
    581                    status = USB_DeviceSetStatus(controllerId , gUsbComponentStatus_Device_d, deviceStatus);
   \   0000006A   0xF8BD 0x2000      LDRH     R2,[SP, #+0]
   \   0000006E   0x2106             MOVS     R1,#+6
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000074   0x.... 0x....      BL       USB_DeviceSetStatus
   \   00000078   0x4680             MOV      R8,R0
   \   0000007A   0xE057             B.N      ??USB_StrdReq_Feature_3
    582                  }
    583                }
    584                else
    585                {
    586                  status = gUsbErr_InvalidReqType_c;    
   \                     ??USB_StrdReq_Feature_2: (+1)
   \   0000007C   0x20CD             MOVS     R0,#+205
   \   0000007E   0x4680             MOV      R8,R0
   \   00000080   0xE054             B.N      ??USB_StrdReq_Feature_3
    587                }
    588              }
    589              else//(set_request == FALSE) it is a clear feature request
    590              {
    591                if(((uint16_t)(1 << (uint8_t)pSetupPacket->value)) & gUsbDeviceClearFeatureMask_d) 
   \                     ??USB_StrdReq_Feature_1: (+1)
   \   00000082   0x2002             MOVS     R0,#+2
   \   00000084   0x8869             LDRH     R1,[R5, #+2]
   \   00000086   0x4108             ASRS     R0,R0,R1
   \   00000088   0x07C0             LSLS     R0,R0,#+31
   \   0000008A   0xD51C             BPL.N    ??USB_StrdReq_Feature_4
    592                {
    593                  status = gUsbErr_NoError_c;
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x4680             MOV      R8,R0
    594                  if(pSetupPacket->value == gUsbDeviceFeatureRemoteWakeup_d)
   \   00000090   0x8868             LDRH     R0,[R5, #+2]
   \   00000092   0x2801             CMP      R0,#+1
   \   00000094   0xD14A             BNE.N    ??USB_StrdReq_Feature_3
    595                  {
    596                    status = USB_DeviceGetStatus(controllerId , gUsbComponentStatus_Device_d , &deviceStatus);
   \   00000096   0xAA00             ADD      R2,SP,#+0
   \   00000098   0x2106             MOVS     R1,#+6
   \   0000009A   0x0020             MOVS     R0,R4
   \   0000009C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009E   0x.... 0x....      BL       USB_DeviceGetStatus
   \   000000A2   0x4680             MOV      R8,R0
    597                    /* remove the request to be cleared from device_status */
    598                    deviceStatus &= (uint16_t)~(1 << (uint8_t)pSetupPacket->value);
   \   000000A4   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000A8   0x2101             MOVS     R1,#+1
   \   000000AA   0x886A             LDRH     R2,[R5, #+2]
   \   000000AC   0x4091             LSLS     R1,R1,R2
   \   000000AE   0x4388             BICS     R0,R0,R1
   \   000000B0   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    599                    status = USB_DeviceSetStatus(controllerId , gUsbComponentStatus_Device_d, deviceStatus);
   \   000000B4   0xF8BD 0x2000      LDRH     R2,[SP, #+0]
   \   000000B8   0x2106             MOVS     R1,#+6
   \   000000BA   0x0020             MOVS     R0,R4
   \   000000BC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BE   0x.... 0x....      BL       USB_DeviceSetStatus
   \   000000C2   0x4680             MOV      R8,R0
   \   000000C4   0xE032             B.N      ??USB_StrdReq_Feature_3
    600                  }
    601                }
    602                else
    603                {
    604                  status = gUsbErr_InvalidReqType_c;   
   \                     ??USB_StrdReq_Feature_4: (+1)
   \   000000C6   0x20CD             MOVS     R0,#+205
   \   000000C8   0x4680             MOV      R8,R0
   \   000000CA   0xE02F             B.N      ??USB_StrdReq_Feature_3
    605                }
    606              }
    607            }
    608            else if ((pSetupPacket->requestType & gUsbRequestSrcMask_d) == gUsbRequestSrc_Endpoint_d)
   \                     ??USB_StrdReq_Feature_0: (+1)
   \   000000CC   0x7828             LDRB     R0,[R5, #+0]
   \   000000CE   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   000000D2   0x2802             CMP      R0,#+2
   \   000000D4   0xD12A             BNE.N    ??USB_StrdReq_Feature_3
    609            {
    610              /* request for Endpoint */
    611              epinfo = (uint8_t)(pSetupPacket->index & 0x00FF);
   \   000000D6   0x88A8             LDRH     R0,[R5, #+4]
   \   000000D8   0xF88D 0x0002      STRB     R0,[SP, #+2]
    612          	  status = USB_DeviceSetStatus(controllerId , (uint8_t)(epinfo|gUsbComponentStatus_Endpoint_d) , setRequest);
   \   000000DC   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000E0   0x465A             MOV      R2,R11
   \   000000E2   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000E4   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   000000E8   0xF050 0x0110      ORRS     R1,R0,#0x10
   \   000000EC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000EE   0x0020             MOVS     R0,R4
   \   000000F0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F2   0x.... 0x....      BL       USB_DeviceSetStatus
   \   000000F6   0x4680             MOV      R8,R0
    613              event = setRequest ? gUsbToAppEvent_EpStalled_c : gUsbToAppEvent_EpUnstalled_c;      
   \   000000F8   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000FC   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000100   0xD002             BEQ.N    ??USB_StrdReq_Feature_5
   \   00000102   0xF05F 0x0907      MOVS     R9,#+7
   \   00000106   0xE001             B.N      ??USB_StrdReq_Feature_6
   \                     ??USB_StrdReq_Feature_5: (+1)
   \   00000108   0xF05F 0x0908      MOVS     R9,#+8
    614              /* inform the upper layers of stall/unstall */
    615              usbMsg.controllerId = controllerId;
   \                     ??USB_StrdReq_Feature_6: (+1)
   \   0000010C   0xF88D 0x4004      STRB     R4,[SP, #+4]
    616              usbMsg.eventType = event;
   \   00000110   0xF88D 0x9005      STRB     R9,[SP, #+5]
    617              usbMsg.eventParam.stallEvent.stallEp = epinfo;
   \   00000114   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000118   0xF88D 0x0008      STRB     R0,[SP, #+8]
    618              gpfFrameworkCallback(controllerId)(controllerId,event,&usbMsg);
   \   0000011C   0xAA01             ADD      R2,SP,#+4
   \   0000011E   0x4649             MOV      R1,R9
   \   00000120   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000122   0x0020             MOVS     R0,R4
   \   00000124   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000126   0x....             LDR.N    R3,??DataTable10
   \   00000128   0x681B             LDR      R3,[R3, #+0]
   \   0000012A   0x4798             BLX      R3
    619            }
    620            return status;
   \                     ??USB_StrdReq_Feature_3: (+1)
   \   0000012C   0x4640             MOV      R0,R8
   \   0000012E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000130   0xB005             ADD      SP,SP,#+20
   \   00000132   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    621          }
    622          
    623          /**************************************************************************//*!
    624           *
    625           * @name  USB_StrdReq_SetAddress
    626           *
    627           * @brief  This function is called in response to Set Address request
    628           *
    629           * @param controller_ID : Controller ID
    630           * @param setup_packet  : Setup packet received
    631           * @param data          : Data to be send back
    632           * @param size          : Size to be returned
    633           *
    634           * @return status:
    635           *               gUsbErr_NoError_c : When Successfull
    636           *               Others : When Error
    637           *
    638           ******************************************************************************
    639           * This is a ch9 request, saves the new address in a global variable. this
    640           * address is assigned to the device after this transaction completes
    641           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    642          static uint8_t USB_StrdReq_SetAddress (
    643              uint8_t    controllerId,            /* [IN] Controller ID */
    644              usbSetupPacket_t * pSetupPacket,    /* [IN] Setup packet received */
    645              uint8_t* *data,                   /* [OUT] Data to be send back */
    646              usbPacketSize_t *size               /* [OUT] Size to be returned */
    647          )
    648          {
   \                     USB_StrdReq_SetAddress: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    649            (void) (data);
    650            *size=0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x8038             STRH     R0,[R7, #+0]
    651            /* update device stae */
    652            (void)USB_DeviceSetStatus(controllerId , gUsbComponentStatus_DeviceState_d , gUsbDeviceState_PendingAddress_d);
   \   0000000E   0x2204             MOVS     R2,#+4
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x.... 0x....      BL       USB_DeviceSetStatus
   \   0000001A   0x0001             MOVS     R1,R0
    653            /*store the address from setup_packet into assigned_address*/
    654            gAssignedAddress = (uint8_t)pSetupPacket->value;
   \   0000001C   0x8868             LDRH     R0,[R5, #+2]
   \   0000001E   0x....             LDR.N    R2,??DataTable10_8
   \   00000020   0x7010             STRB     R0,[R2, #+0]
    655            return gUsbErr_NoError_c;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    656          }
    657          
    658          /**************************************************************************//*!
    659           *
    660           * @name  USB_AssignAddress
    661           *
    662           * @brief  This function assigns the address to the Device
    663           *
    664           * @param controller_ID : Controller ID
    665           *
    666           * @return status
    667           *                       gUsbErr_NoError_c: Always
    668           *
    669           ******************************************************************************
    670           * This function assigns the new address and is called (from the control
    671           * service) after the set address transaction completes
    672           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    673          static uint8_t USB_AssignAddress (
    674              uint8_t    controllerId         /* [IN] Controller ID */
    675          )
    676          {
   \                     USB_AssignAddress: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    677            /* Set Device Address */
    678            (void)USB_DeviceSetAddress(controllerId, gAssignedAddress);
   \   00000004   0x....             LDR.N    R0,??DataTable10_8
   \   00000006   0x7801             LDRB     R1,[R0, #+0]
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       USB_DeviceSetAddress
    679            /* Set Device state */
    680            (void)USB_DeviceSetStatus(controllerId , gUsbComponentStatus_DeviceState_d , gUsbDeviceState_Address_d);
   \   00000010   0x2201             MOVS     R2,#+1
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x.... 0x....      BL       USB_DeviceSetStatus
   \   0000001C   0x0005             MOVS     R5,R0
    681              /* Set Device state */
    682            (void)USB_DeviceSetStatus(controllerId , gUsbComponentStatus_Address_d , gAssignedAddress);
   \   0000001E   0x....             LDR.N    R0,??DataTable10_8
   \   00000020   0x7802             LDRB     R2,[R0, #+0]
   \   00000022   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000024   0x2103             MOVS     R1,#+3
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x.... 0x....      BL       USB_DeviceSetStatus
   \   0000002E   0x0001             MOVS     R1,R0
    683            return gUsbErr_NoError_c;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    684          }
    685          
    686          /**************************************************************************//*!
    687           *
    688           * @name  USB_StrdReq_GetConfig
    689           *
    690           * @brief  This function is called in response to Get Config request
    691           *
    692           * @param controller_ID : Controller ID
    693           * @param setup_packet  : Setup packet received
    694           * @param data          : Data to be send back
    695           * @param size          : Size to be returned
    696           *
    697           * @return status:
    698           *               gUsbErr_NoError_c : Always
    699           *
    700           ******************************************************************************
    701           * This is a ch9 request and is used to know the currently used configuration
    702           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    703          static uint8_t USB_StrdReq_GetConfig (
    704              uint8_t    controllerId,            /* [IN] Controller ID */
    705              usbSetupPacket_t * pSetupPacket,    /* [IN] Setup packet received */
    706              uint8_t* *data,                   /* [OUT] Data to be send back */
    707              usbPacketSize_t *size               /* [OUT] Size to be returned */
    708          )
    709          {
   \                     USB_StrdReq_GetConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    710            (void)(pSetupPacket);
    711            *size = gUsbConfigSize_d;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x8038             STRH     R0,[R7, #+0]
    712            (void)USB_DeviceGetStatus(controllerId , gUsbComponentStatus_CurrentConfig_d , &gStdFrameworkData);
   \   0000000E   0x....             LDR.N    R2,??DataTable10_7
   \   00000010   0x2104             MOVS     R1,#+4
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x.... 0x....      BL       USB_DeviceGetStatus
   \   0000001A   0x0001             MOVS     R1,R0
    713           #if (gLittle_Endian_d == 0)
    714            gStdFrameworkData = USB_ByteSwap16(gStdFrameworkData);
    715          #endif
    716            *data = (uint8_t*)(&gStdFrameworkData);
   \   0000001C   0x....             LDR.N    R0,??DataTable10_7
   \   0000001E   0x6030             STR      R0,[R6, #+0]
    717            return gUsbErr_NoError_c;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    718          }
    719          
    720          /**************************************************************************//*!
    721           *
    722           * @name  USB_StrdReq_SetConfig
    723           *
    724           * @brief  This function is called in response to Set Config request
    725           *
    726           * @param controller_ID : Controller ID
    727           * @param setup_packet  : Setup packet received
    728           * @param data          : Data to be send back
    729           * @param size          : Size to be returned
    730           *
    731           * @return status:
    732           *               gUsbErr_NoError_c : When Successfull
    733           *               Others : When Error
    734           *
    735           ******************************************************************************
    736           * This is a ch9 request and is used by the host to set the new configuration
    737           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    738          static uint8_t USB_StrdReq_SetConfig (
    739              uint8_t    controllerId,            /* [IN] Controller ID */
    740              usbSetupPacket_t * pSetupPacket,    /* [IN] Setup packet received */
    741              uint8_t* *data,                   /* [OUT] Data to be send back */
    742              usbPacketSize_t *size               /* [OUT] Size to be returned */
    743          )
    744          {
   \                     USB_StrdReq_SetConfig: (+1)
   \   00000000   0xE92D 0x47FF      PUSH     {R0-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    745            uint8_t status = gUsbErr_InvalidReqType_c;
   \   0000000C   0xF05F 0x08CD      MOVS     R8,#+205
    746            uint16_t configVal;
    747            usbMsg_t usbMsg;
    748            (void) (data);
    749            *size = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x8038             STRH     R0,[R7, #+0]
    750            status = gUsbStatus_Error_d;
   \   00000014   0x2004             MOVS     R0,#+4
   \   00000016   0x4680             MOV      R8,R0
    751            configVal = pSetupPacket->value;
   \   00000018   0x8868             LDRH     R0,[R5, #+2]
   \   0000001A   0x4681             MOV      R9,R0
    752            if (USB_Desc_ValidConfiguration(controllerId, configVal))
   \   0000001C   0x4649             MOV      R1,R9
   \   0000001E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0x.... 0x....      BL       USB_Desc_ValidConfiguration
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD035             BEQ.N    ??USB_StrdReq_SetConfig_0
    753            /*if valid configuration (fn returns bool_t value)*/
    754            {
    755              uint16_t deviceState = gUsbDeviceState_Config_d;
   \   0000002C   0xF05F 0x0A00      MOVS     R10,#+0
    756              /* if config_val is 0 */
    757              if (!configVal) 
   \   00000030   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000034   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000038   0xD101             BNE.N    ??USB_StrdReq_SetConfig_1
    758              {
    759                deviceState = gUsbDeviceState_Address_d ;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x4682             MOV      R10,R0
    760              }
    761              status = USB_DeviceSetStatus(controllerId, gUsbComponentStatus_DeviceState_d, deviceState);
   \                     ??USB_StrdReq_SetConfig_1: (+1)
   \   0000003E   0x4652             MOV      R2,R10
   \   00000040   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000042   0x2101             MOVS     R1,#+1
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0x.... 0x....      BL       USB_DeviceSetStatus
   \   0000004C   0x4680             MOV      R8,R0
    762              status = USB_DeviceSetStatus(controllerId, gUsbComponentStatus_CurrentConfig_d, configVal);
   \   0000004E   0x464A             MOV      R2,R9
   \   00000050   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000052   0x2104             MOVS     R1,#+4
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0x.... 0x....      BL       USB_DeviceSetStatus
   \   0000005C   0x4680             MOV      R8,R0
    763              /* Callback to the app. to let the application know about the new Configuration  */
    764              usbMsg.controllerId = controllerId;
   \   0000005E   0xF88D 0x4000      STRB     R4,[SP, #+0]
    765              usbMsg.eventType = gUsbToAppEvent_ConfigChanged_c;
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0xF88D 0x0001      STRB     R0,[SP, #+1]
    766              usbMsg.eventParam.configEvent.configValue = configVal;
   \   00000068   0xF8AD 0x9004      STRH     R9,[SP, #+4]
    767              gpfFrameworkCallback(controllerId)(controllerId,gUsbToAppEvent_ConfigChanged_c,&usbMsg);
   \   0000006C   0xAA00             ADD      R2,SP,#+0
   \   0000006E   0x2101             MOVS     R1,#+1
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000074   0x....             LDR.N    R3,??DataTable10
   \   00000076   0x681B             LDR      R3,[R3, #+0]
   \   00000078   0x4798             BLX      R3
    768              if(configVal)
   \   0000007A   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000007E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000082   0xD009             BEQ.N    ??USB_StrdReq_SetConfig_0
    769              {
    770              usbMsg.eventType = gUsbToAppEvent_EnumComplete_c;
   \   00000084   0x2002             MOVS     R0,#+2
   \   00000086   0xF88D 0x0001      STRB     R0,[SP, #+1]
    771              gpfFrameworkCallback(controllerId)(controllerId,gUsbToAppEvent_EnumComplete_c, &usbMsg);
   \   0000008A   0xAA00             ADD      R2,SP,#+0
   \   0000008C   0x2102             MOVS     R1,#+2
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000092   0x....             LDR.N    R3,??DataTable10
   \   00000094   0x681B             LDR      R3,[R3, #+0]
   \   00000096   0x4798             BLX      R3
    772              }
    773            }
    774            return status;
   \                     ??USB_StrdReq_SetConfig_0: (+1)
   \   00000098   0x4640             MOV      R0,R8
   \   0000009A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009C   0xB004             ADD      SP,SP,#+16
   \   0000009E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    775          }
    776          
    777          /**************************************************************************//*!
    778           *
    779           * @name  USB_StrdReq_GetInterface
    780           *
    781           * @brief  This function is called in response to Get Interface request
    782           *
    783           * @param controller_ID : Controller ID
    784           * @param setup_packet  : Setup packet received
    785           * @param data          : Data to be send back
    786           * @param size          : Size to be returned
    787           *
    788           * @return status:
    789           *               gUsbErr_NoError_c : When Successfull
    790           *               Others : When Error
    791           *
    792           ******************************************************************************
    793           * This is a ch9 request and is used to know the current interface
    794           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    795          static uint8_t USB_StrdReq_GetInterface (
    796              uint8_t    controllerId,            /* [IN] Controller ID */
    797              usbSetupPacket_t * pSetupPacket,    /* [IN] Setup packet received */
    798              uint8_t* *data,                   /* [OUT] Data to be send back */
    799              usbPacketSize_t *size               /* [OUT] Size to be returned */
    800          )
    801          {
   \                     USB_StrdReq_GetInterface: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    802            uint8_t status;
    803            *size = gUsbInterfaceStatusSize_d;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x8038             STRH     R0,[R7, #+0]
    804            status = USB_Desc_GetInterface(controllerId , (uint8_t)pSetupPacket->index , (uint8_t*)&gStdFrameworkData);
   \   00000010   0x....             LDR.N    R2,??DataTable10_7
   \   00000012   0x88A9             LDRH     R1,[R5, #+4]
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x.... 0x....      BL       USB_Desc_GetInterface
   \   0000001E   0x4680             MOV      R8,R0
    805            *data = (uint8_t*)&gStdFrameworkData;
   \   00000020   0x....             LDR.N    R0,??DataTable10_7
   \   00000022   0x6030             STR      R0,[R6, #+0]
    806            return status;
   \   00000024   0x4640             MOV      R0,R8
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    807          }
    808          
    809          /**************************************************************************//*!
    810           *
    811           * @name  USB_StrdReq_SetInterface
    812           *
    813           * @brief  This function is called in response to Set Interface request
    814           *
    815           * @param controller_ID : Controller ID
    816           * @param setup_packet  : Setup packet received
    817           * @param data          : Data to be send back
    818           * @param size          : Size to be returned
    819           *
    820           * @return status:
    821           *               gUsbErr_NoError_c : Always
    822           *
    823           ******************************************************************************
    824           * This is a ch9 request and is used by the  host to set the interface
    825           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    826          static uint8_t USB_StrdReq_SetInterface (
    827              uint8_t    controllerId,            /* [IN] Controller ID */
    828              usbSetupPacket_t * pSetupPacket,    /* [IN] Setup packet received */
    829              uint8_t* *data,                   /* [OUT] Data to be send back */
    830              usbPacketSize_t *size               /* [OUT] Size to be returned */
    831          )
    832          {
   \                     USB_StrdReq_SetInterface: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    833            (void) (data);
    834            *size=0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x8038             STRH     R0,[R7, #+0]
    835            /* Request type not for interface */
    836            if ((pSetupPacket->requestType & 0x03) != 0x01)
   \   0000000E   0x7828             LDRB     R0,[R5, #+0]
   \   00000010   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD001             BEQ.N    ??USB_StrdReq_SetInterface_0
    837            {
    838              return gUsbStatus_Error_d;
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0xE009             B.N      ??USB_StrdReq_SetInterface_1
    839            }
    840            /* Get Interface and alternate interface from setup_packet */
    841            (void)USB_Desc_SetInterface(controllerId , (uint8_t)pSetupPacket->index , (uint8_t)pSetupPacket->value);
   \                     ??USB_StrdReq_SetInterface_0: (+1)
   \   0000001C   0x886A             LDRH     R2,[R5, #+2]
   \   0000001E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000020   0x88A9             LDRH     R1,[R5, #+4]
   \   00000022   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x.... 0x....      BL       USB_Desc_SetInterface
   \   0000002C   0x0001             MOVS     R1,R0
    842            return gUsbErr_NoError_c;
   \   0000002E   0x2000             MOVS     R0,#+0
   \                     ??USB_StrdReq_SetInterface_1: (+1)
   \   00000030   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    843          }
    844          
    845          /**************************************************************************//*!
    846           *
    847           * @name  USB_StrdReq_SyncFrame
    848           *
    849           * @brief  This function is called in response to Sync Frame request
    850           *
    851           * @param controller_ID : Controller ID
    852           * @param setup_packet  : Setup packet received
    853           * @param data          : Data to be send back
    854           * @param size          : Size to be returned
    855           *
    856           * @return status:
    857           *               gUsbErr_NoError_c : When Successfull
    858           *               Others : When Error
    859           *
    860           ******************************************************************************
    861           * This req is used to set and then report an ep's synchronization frame
    862           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    863          static uint8_t USB_StrdReq_SyncFrame (
    864              uint8_t    controllerId,            /* [IN] Controller ID */
    865              usbSetupPacket_t * pSetupPacket,    /* [IN] Setup packet received */
    866              uint8_t* *data,                   /* [OUT] Data to be send back */
    867              usbPacketSize_t *size               /* [OUT] Size to be returned */
    868          )
    869          {
   \                     USB_StrdReq_SyncFrame: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    870            uint8_t status;
    871            (void) (pSetupPacket);
    872            *size=gUsbFrameSize_d;
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0x8038             STRH     R0,[R7, #+0]
    873            /* Get the frame number */
    874            status = USB_DeviceGetStatus(controllerId , gUsbComponentStatus_SOFCount_d , &gStdFrameworkData);
   \   00000010   0x....             LDR.N    R2,??DataTable10_7
   \   00000012   0x2105             MOVS     R1,#+5
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x.... 0x....      BL       USB_DeviceGetStatus
   \   0000001C   0x4680             MOV      R8,R0
    875            *data = (uint8_t*)&gStdFrameworkData;
   \   0000001E   0x....             LDR.N    R0,??DataTable10_7
   \   00000020   0x6030             STR      R0,[R6, #+0]
    876            return status;
   \   00000022   0x4640             MOV      R0,R8
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    877          }
    878          
    879          
    880          /**************************************************************************//*!
    881           *
    882           * @name  USB_Std_Req_Get_Descriptor
    883           *
    884           * @brief  This function is called in response to Get Descriptor request
    885           *
    886           * @param controller_ID : Controller ID
    887           * @param setup_packet  : Setup packet received
    888           * @param data          : Data to be send back
    889           * @param size          : Size to be returned
    890           *
    891           * @return status:
    892           *               gUsbErr_NoError_c : When Successfull
    893           *               Others : When Error
    894           *
    895           ******************************************************************************
    896           * This is a ch9 request and is used to send the descriptor requested by the
    897           * host
    898           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    899          static uint8_t USB_StrdReq_GetDescriptor (
    900              uint8_t    controllerId,            /* [IN] Controller ID */
    901              usbSetupPacket_t * pSetupPacket,    /* [IN] Setup packet received */
    902              uint8_t* *data,                   /* [OUT] Data to be send back */
    903              usbPacketSize_t *size               /* [OUT] Size to be returned */
    904          )
    905          {
   \                     USB_StrdReq_GetDescriptor: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    906            uint8_t type = USB_UInt16High(pSetupPacket->value);
   \   0000000E   0x8868             LDRH     R0,[R5, #+2]
   \   00000010   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000012   0xEA5F 0x2810      LSRS     R8,R0,#+8
    907            uint16_t index = (uint8_t)gUninitialisedVal_d;
   \   00000016   0xF04F 0x09FF      MOV      R9,#+255
    908            uint8_t strNum = (uint8_t)gUninitialisedVal_d;
   \   0000001A   0xF04F 0x0AFF      MOV      R10,#+255
    909            uint8_t status;
    910            /* for string descriptor set the language and string number */
    911            index = pSetupPacket->index;
   \   0000001E   0x88A8             LDRH     R0,[R5, #+4]
   \   00000020   0x4681             MOV      R9,R0
    912            /*g_setup_pkt.lValue*/
    913            strNum = USB_UInt16Low(pSetupPacket->value);
   \   00000022   0x8868             LDRH     R0,[R5, #+2]
   \   00000024   0x4682             MOV      R10,R0
    914            /* Call descriptor class to get descriptor */
    915            status = USB_Desc_GetDescriptor(controllerId , type , strNum , index , data , size);
   \   00000026   0x9701             STR      R7,[SP, #+4]
   \   00000028   0x9600             STR      R6,[SP, #+0]
   \   0000002A   0x464B             MOV      R3,R9
   \   0000002C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000002E   0x4652             MOV      R2,R10
   \   00000030   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000032   0x4641             MOV      R1,R8
   \   00000034   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x.... 0x....      BL       USB_Desc_GetDescriptor
   \   0000003E   0x4683             MOV      R11,R0
    916            return status;
   \   00000040   0x4658             MOV      R0,R11
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    917          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     gpfClassFrameworkCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     gpfOtherReqCallback_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     gpaSetupPkt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     gapfStandardRequest

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     gValidateRequest

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     extReqToDevice

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     extReqToDevice+0x8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     gStdFrameworkData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     gAssignedAddress
    918          #endif // gUsbIncluded_d

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   USB_AssignAddress
        16   -> USB_DeviceSetAddress
        16   -> USB_DeviceSetStatus
      48   USB_ControlServiceHandler
        48   -> USB_ClassSendData_
        48   -> USB_DeviceRecvData
        48   -> USB_DeviceSetStatus
        48   -> USB_IsrEvent
      16   USB_Framework_DeInit
        16   -> USB_DeviceDeinit
      24   USB_Framework_Init
        24   -> USB_DeviceRegisterService
      48   USB_Service_Control
        48   -- Indirect call
        48   -> MemoryCpy
        48   -> USB_AssignAddress
        48   -> USB_ControlServiceHandler
        48   -> USB_DeviceGetStatus
        48   -> USB_DeviceRecvData
        48   -> USB_IsrEvent
      56   USB_StrdReq_Feature
        56   -- Indirect call
        56   -> USB_DeviceGetStatus
        56   -> USB_DeviceSetStatus
      24   USB_StrdReq_GetConfig
        24   -> USB_DeviceGetStatus
      48   USB_StrdReq_GetDescriptor
        48   -> USB_Desc_GetDescriptor
      24   USB_StrdReq_GetInterface
        24   -> USB_Desc_GetInterface
      32   USB_StrdReq_GetStatus
        32   -> USB_Desc_GetInterface
        32   -> USB_DeviceGetStatus
      24   USB_StrdReq_SetAddress
        24   -> USB_DeviceSetStatus
      48   USB_StrdReq_SetConfig
        48   -- Indirect call
        48   -> USB_Desc_ValidConfiguration
        48   -> USB_DeviceSetStatus
      24   USB_StrdReq_SetInterface
        24   -> USB_Desc_SetInterface
      24   USB_StrdReq_SyncFrame
        24   -> USB_DeviceGetStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
      52  USB_AssignAddress
     126  USB_ControlServiceHandler
      36  USB_Framework_DeInit
      44  USB_Framework_Init
     410  USB_Service_Control
     310  USB_StrdReq_Feature
      36  USB_StrdReq_GetConfig
      72  USB_StrdReq_GetDescriptor
      44  USB_StrdReq_GetInterface
     142  USB_StrdReq_GetStatus
      38  USB_StrdReq_SetAddress
     162  USB_StrdReq_SetConfig
      50  USB_StrdReq_SetInterface
      42  USB_StrdReq_SyncFrame
      32  extReqToDevice
       1  gAssignedAddress
       2  gStdFrameworkData
      40  gValidateRequest
      52  gapfStandardRequest
       4  gpaSetupPkt
       4  gpfOtherReqCallback_

 
    43 bytes in section .bss
    92 bytes in section .rodata
 1 600 bytes in section .text
 
 1 600 bytes of CODE  memory
    92 bytes of CONST memory
    43 bytes of DATA  memory

Errors: none
Warnings: none
