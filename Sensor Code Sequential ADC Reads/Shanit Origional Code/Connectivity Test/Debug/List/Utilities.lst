###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        20/Mar/2018  09:41:55
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Generic
#        Services\Source\Utilities.c
#    Command line =  
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Generic
#        Services\Source\Utilities.c" -D IAR --preprocess
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Debug\List\" -lC
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Debug\List\" -lB
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Debug\List\"
#        --diag_suppress Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Debug\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\rfrum\OneDrive\2018
#        Spring Semester\Senior Design\Sensor Code\Shanit Origional
#        Code\Connectivity Test\PLM\Configure\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Environment\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Interface\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Generic
#        Services\Interface\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Uart\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\CDC\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\Descriptor\" -I "C:\Users\rfrum\OneDrive\2018
#        Spring Semester\Senior Design\Sensor Code\Shanit Origional
#        Code\Connectivity Test\PLM\Source\USB\Class\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\"
#        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
#        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Radio\MC1324x\PHY\" -I "C:\Users\rfrum\OneDrive\2018
#        Spring Semester\Senior Design\Sensor Code\Shanit Origional
#        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\Sys Common\"
#        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Application\Source\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Application\Configure\"
#        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -On
#    List file    =  
#        C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Debug\List\Utilities.lst
#    Object file  =  
#        C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Debug\Obj\Utilities.o
#
###############################################################################

C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity Test\Generic Services\Source\Utilities.c
      1          /*****************************************************************************
      2          * Source file for Utilities.
      3          * 
      4          * 
      5          * Copyright (c) 2009, Freescale, Inc. All rights reserved.
      6          *
      7          * 
      8          * No part of this document must be reproduced in any form - including copied,
      9          * transcribed, printed or by any electronic means - without specific written
     10          * permission from Freescale Semiconductor.
     11          *
     12          *****************************************************************************/
     13          
     14          #include "Utilities_Interface.h"
     15          #include "mcg.h"
     16          
     17          /************************************************************************************
     18          * Delay_ms
     19          *
     20          ************************************************************************************/
     21          /*
     22          void Delay_ms
     23          (
     24            uint16_t u16ms
     25          ) 
     26          {                                            
     27            uint16_t u16ctr;                                          
     28            for(u16ctr = 0; u16ctr < ((gSystemClock_d/40000)*u16ms); u16ctr++){
     29              asm NOP; 
     30              asm NOP;
     31            }    
     32          }
     33          */
     34          /************************************************************************************
     35          * Delay_ms
     36          *
     37          ************************************************************************************/
     38          

   \                                 In section .text, align 2, keep-with-next
     39           void delayMs(uint16_t val)
     40          {
     41          	/* Turn on clock to LPTMR module */
     42          	SIM_SCGC5 |= SIM_SCGC5_LPTIMER_MASK;
   \                     delayMs: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable3  ;; 0x40048038
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable3  ;; 0x40048038
   \   0000000E   0x6011             STR      R1,[R2, #+0]
     43                  
     44          	/* Disable LPTMR */
     45          	LPTMR0_CSR &= ~(LPTMR_CSR_TEN_MASK);
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable3_1  ;; 0x40040000
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x0849             LSRS     R1,R1,#+1
   \   00000018   0x0049             LSLS     R1,R1,#+1
   \   0000001A   0x.... 0x....      LDR.W    R2,??DataTable3_1  ;; 0x40040000
   \   0000001E   0x6011             STR      R1,[R2, #+0]
     46          
     47          	/* Set compare value */
     48          	LPTMR0_CMR = val;
   \   00000020   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable3_2  ;; 0x40040008
   \   00000026   0x6008             STR      R0,[R1, #+0]
     49          
     50          	/* Use 1Khz LPO clock and bypass prescaler */
     51          	LPTMR0_PSR = LPTMR_PSR_PCS(1)|LPTMR_PSR_PBYP_MASK;
   \   00000028   0x2105             MOVS     R1,#+5
   \   0000002A   0x.... 0x....      LDR.W    R2,??DataTable3_3  ;; 0x40040004
   \   0000002E   0x6011             STR      R1,[R2, #+0]
     52          
     53          	/* Start counting */
     54          	LPTMR0_CSR |= LPTMR_CSR_TEN_MASK;
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable3_1  ;; 0x40040000
   \   00000034   0x6809             LDR      R1,[R1, #+0]
   \   00000036   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   0000003A   0x.... 0x....      LDR.W    R2,??DataTable3_1  ;; 0x40040000
   \   0000003E   0x6011             STR      R1,[R2, #+0]
     55          
     56          	/* Wait for counter to reach compare value */
     57          	while (!(LPTMR0_CSR & LPTMR_CSR_TCF_MASK)) {}
   \                     ??delayMs_0: (+1)
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable3_1  ;; 0x40040000
   \   00000044   0x6809             LDR      R1,[R1, #+0]
   \   00000046   0x0609             LSLS     R1,R1,#+24
   \   00000048   0xD5FA             BPL.N    ??delayMs_0
     58          
     59          	/* Clear Timer Compare Flag */
     60          	LPTMR0_CSR &= ~LPTMR_CSR_TEN_MASK;
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable3_1  ;; 0x40040000
   \   0000004E   0x6809             LDR      R1,[R1, #+0]
   \   00000050   0x0849             LSRS     R1,R1,#+1
   \   00000052   0x0049             LSLS     R1,R1,#+1
   \   00000054   0x.... 0x....      LDR.W    R2,??DataTable3_1  ;; 0x40040000
   \   00000058   0x6011             STR      R1,[R2, #+0]
     61          
     62          	/* Turn off clock to LPTMR module */
     63          	SIM_SCGC5 &= ~SIM_SCGC5_LPTIMER_MASK;	
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable3  ;; 0x40048038
   \   0000005E   0x6809             LDR      R1,[R1, #+0]
   \   00000060   0x0849             LSRS     R1,R1,#+1
   \   00000062   0x0049             LSLS     R1,R1,#+1
   \   00000064   0x.... 0x....      LDR.W    R2,??DataTable3  ;; 0x40048038
   \   00000068   0x6011             STR      R1,[R2, #+0]
     64          }
   \   0000006A   0x4770             BX       LR               ;; return
     65          /************************************************************************************
     66          * Delay_us
     67          *
     68          ************************************************************************************/
     69          /*
     70          void Delay_us
     71          (
     72            uint16_t u16us
     73          ) 
     74          {
     75            uint16_t u16ctr;                                          
     76            for(u16ctr = 0; u16ctr < (((gSystemClock_d*10/40000000)*u16us)/10); u16ctr++){
     77              asm NOP; 
     78              asm NOP;     
     79            }      
     80          }
     81          */
     82          
     83           
     84          /*******************************************************************************  
     85          * HexToAscii
     86          *
     87          * This function converts an hexadecimal value in ascii code.
     88          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     89          uint8_t HexToAscii(uint8_t u8Hex)
     90          {
     91            u8Hex &= 0x0F;
   \                     HexToAscii: (+1)
   \   00000000   0xF010 0x000F      ANDS     R0,R0,#0xF
     92            return u8Hex + ((u8Hex <= 9) ? '0' : ('A'-10));
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x280A             CMP      R0,#+10
   \   00000008   0xDA01             BGE.N    ??HexToAscii_0
   \   0000000A   0x2130             MOVS     R1,#+48
   \   0000000C   0xE000             B.N      ??HexToAscii_1
   \                     ??HexToAscii_0: (+1)
   \   0000000E   0x2137             MOVS     R1,#+55
   \                     ??HexToAscii_1: (+1)
   \   00000010   0x1808             ADDS     R0,R1,R0
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x4770             BX       LR               ;; return
     93          }
     94          
     95          
     96          
     97          /**************************************************************************************/
     98          
     99          
    100          
    101          /************************************************************************************
    102          * convert_2_bcd function
    103          *
    104          * This function converts the received data as parameter to bcd format
    105          *
    106          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    107          sixDigitBcd_t convert_2_bcd(uint16_t u16Value)
    108          {
   \                     convert_2_bcd: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
   \   00000002   0x0001             MOVS     R1,R0
    109            sixDigitBcd_t u16RtrnVal;
    110            uint16_t tmp;
    111            u16RtrnVal.u8Units = 0;
   \   00000004   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000008   0xF010 0x00F0      ANDS     R0,R0,#0xF0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    112            u16RtrnVal.u8Tens = 0;
   \   00000010   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000014   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000018   0xF88D 0x0000      STRB     R0,[SP, #+0]
    113            u16RtrnVal.u8Houndreds = 0;
   \   0000001C   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000020   0xF010 0x00F0      ANDS     R0,R0,#0xF0
   \   00000024   0xF88D 0x0001      STRB     R0,[SP, #+1]
    114            u16RtrnVal.u8Thousands = 0;
   \   00000028   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000002C   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000030   0xF88D 0x0001      STRB     R0,[SP, #+1]
    115            u16RtrnVal.u8TensThousands = 0;
   \   00000034   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000038   0xF010 0x00F0      ANDS     R0,R0,#0xF0
   \   0000003C   0xF88D 0x0002      STRB     R0,[SP, #+2]
    116            u16RtrnVal.u8HoundredsThousands = 0;
   \   00000040   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000044   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000048   0xF88D 0x0002      STRB     R0,[SP, #+2]
    117            if(65535 > u16Value)
   \   0000004C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000004E   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000052   0x4281             CMP      R1,R0
   \   00000054   0xD06C             BEQ.N    ??convert_2_bcd_0
    118            {
    119              tmp = u16Value;
   \   00000056   0x000A             MOVS     R2,R1
    120              if(10000 <= u16Value)
   \   00000058   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000005A   0xF242 0x7010      MOVW     R0,#+10000
   \   0000005E   0x4281             CMP      R1,R0
   \   00000060   0xDB15             BLT.N    ??convert_2_bcd_1
    121              {
    122                tmp = u16Value/10000;
   \   00000062   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000064   0xF242 0x7010      MOVW     R0,#+10000
   \   00000068   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \   0000006C   0x0002             MOVS     R2,R0
    123                u16RtrnVal.u8TensThousands = (uint8_t)tmp;
   \   0000006E   0x0010             MOVS     R0,R2
   \   00000070   0xF89D 0x3002      LDRB     R3,[SP, #+2]
   \   00000074   0xF360 0x0303      BFI      R3,R0,#+0,#+4
   \   00000078   0xF88D 0x3002      STRB     R3,[SP, #+2]
    124                tmp = u16Value%10000;
   \   0000007C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000007E   0xF242 0x7010      MOVW     R0,#+10000
   \   00000082   0xFB91 0xF3F0      SDIV     R3,R1,R0
   \   00000086   0xFB00 0x1013      MLS      R0,R0,R3,R1
   \   0000008A   0x0002             MOVS     R2,R0
    125                u16Value = tmp;
   \   0000008C   0x0011             MOVS     R1,R2
    126              }
    127          
    128              if(1000 <= u16Value)
   \                     ??convert_2_bcd_1: (+1)
   \   0000008E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000090   0xF5B1 0x7F7A      CMP      R1,#+1000
   \   00000094   0xDB16             BLT.N    ??convert_2_bcd_2
    129              {
    130                tmp = u16Value/1000;
   \   00000096   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000098   0xF44F 0x707A      MOV      R0,#+1000
   \   0000009C   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \   000000A0   0x0002             MOVS     R2,R0
    131                u16RtrnVal.u8Thousands = (uint8_t)tmp;
   \   000000A2   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000000A6   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   000000AA   0xEA50 0x1002      ORRS     R0,R0,R2, LSL #+4
   \   000000AE   0xF88D 0x0001      STRB     R0,[SP, #+1]
    132                tmp = u16Value%1000;
   \   000000B2   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000B4   0xF44F 0x707A      MOV      R0,#+1000
   \   000000B8   0xFB91 0xF3F0      SDIV     R3,R1,R0
   \   000000BC   0xFB00 0x1013      MLS      R0,R0,R3,R1
   \   000000C0   0x0002             MOVS     R2,R0
    133                u16Value = tmp;
   \   000000C2   0x0011             MOVS     R1,R2
    134              }
    135              if(100 <= u16Value)
   \                     ??convert_2_bcd_2: (+1)
   \   000000C4   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000C6   0x2964             CMP      R1,#+100
   \   000000C8   0xDB13             BLT.N    ??convert_2_bcd_3
    136              {
    137                tmp = u16Value/100;
   \   000000CA   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000CC   0x2064             MOVS     R0,#+100
   \   000000CE   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \   000000D2   0x0002             MOVS     R2,R0
    138                u16RtrnVal.u8Houndreds = (uint8_t)tmp;
   \   000000D4   0x0010             MOVS     R0,R2
   \   000000D6   0xF89D 0x3001      LDRB     R3,[SP, #+1]
   \   000000DA   0xF360 0x0303      BFI      R3,R0,#+0,#+4
   \   000000DE   0xF88D 0x3001      STRB     R3,[SP, #+1]
    139                tmp = u16Value%100;
   \   000000E2   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000E4   0x2064             MOVS     R0,#+100
   \   000000E6   0xFB91 0xF3F0      SDIV     R3,R1,R0
   \   000000EA   0xFB00 0x1013      MLS      R0,R0,R3,R1
   \   000000EE   0x0002             MOVS     R2,R0
    140                u16Value = tmp;
   \   000000F0   0x0011             MOVS     R1,R2
    141              }
    142              if(10 <= u16Value)
   \                     ??convert_2_bcd_3: (+1)
   \   000000F2   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000F4   0x290A             CMP      R1,#+10
   \   000000F6   0xDB14             BLT.N    ??convert_2_bcd_4
    143              {
    144                tmp = u16Value/10;
   \   000000F8   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000FA   0x200A             MOVS     R0,#+10
   \   000000FC   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \   00000100   0x0002             MOVS     R2,R0
    145                u16RtrnVal.u8Tens = (uint8_t)tmp;
   \   00000102   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000106   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000010A   0xEA50 0x1002      ORRS     R0,R0,R2, LSL #+4
   \   0000010E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    146                tmp = u16Value%10;
   \   00000112   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000114   0x200A             MOVS     R0,#+10
   \   00000116   0xFB91 0xF3F0      SDIV     R3,R1,R0
   \   0000011A   0xFB00 0x1013      MLS      R0,R0,R3,R1
   \   0000011E   0x0002             MOVS     R2,R0
    147                u16Value = tmp;
   \   00000120   0x0011             MOVS     R1,R2
    148              }
    149              u16RtrnVal.u8Units = (uint8_t)tmp;
   \                     ??convert_2_bcd_4: (+1)
   \   00000122   0x0010             MOVS     R0,R2
   \   00000124   0xF89D 0x3000      LDRB     R3,[SP, #+0]
   \   00000128   0xF360 0x0303      BFI      R3,R0,#+0,#+4
   \   0000012C   0xF88D 0x3000      STRB     R3,[SP, #+0]
    150            }
    151            return u16RtrnVal;
   \                     ??convert_2_bcd_0: (+1)
   \   00000130   0x9800             LDR      R0,[SP, #+0]
   \   00000132   0xB001             ADD      SP,SP,#+4
   \   00000134   0x4770             BX       LR               ;; return
    152          } 
    153          

   \                                 In section .text, align 2, keep-with-next
    154          uint8_t HexaToAscii(uint8_t u8Hex)
    155          {
    156            u8Hex &= 0x0F;
   \                     HexaToAscii: (+1)
   \   00000000   0xF010 0x000F      ANDS     R0,R0,#0xF
    157            return u8Hex + ((u8Hex <= 9) ? '0' : ('A'-10));
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x280A             CMP      R0,#+10
   \   00000008   0xDA01             BGE.N    ??HexaToAscii_0
   \   0000000A   0x2130             MOVS     R1,#+48
   \   0000000C   0xE000             B.N      ??HexaToAscii_1
   \                     ??HexaToAscii_0: (+1)
   \   0000000E   0x2137             MOVS     R1,#+55
   \                     ??HexaToAscii_1: (+1)
   \   00000010   0x1808             ADDS     R0,R1,R0
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x4770             BX       LR               ;; return
    158          }
    159          
    160          /************************************************************************************
    161          * stringComp
    162          *
    163          * ...
    164          *
    165          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    166          bool_t stringComp(char * au8leftString, char * au8RightString, uint8_t bytesToCompare)
    167          {
   \                     stringComp: (+1)
   \   00000000   0xB410             PUSH     {R4}
    168            do
    169            {
    170            }while((*au8leftString++ == *au8RightString++) && --bytesToCompare);
   \                     ??stringComp_0: (+1)
   \   00000002   0x0003             MOVS     R3,R0
   \   00000004   0x1C58             ADDS     R0,R3,#+1
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x1C61             ADDS     R1,R4,#+1
   \   0000000A   0x781B             LDRB     R3,[R3, #+0]
   \   0000000C   0x7824             LDRB     R4,[R4, #+0]
   \   0000000E   0x42A3             CMP      R3,R4
   \   00000010   0xD103             BNE.N    ??stringComp_1
   \   00000012   0x1E52             SUBS     R2,R2,#+1
   \   00000014   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD1F3             BNE.N    ??stringComp_0
    171            return(0 == bytesToCompare);
   \                     ??stringComp_1: (+1)
   \   0000001A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001C   0x2A00             CMP      R2,#+0
   \   0000001E   0xD101             BNE.N    ??stringComp_2
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE000             B.N      ??stringComp_3
   \                     ??stringComp_2: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??stringComp_3: (+1)
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0xBC10             POP      {R4}
   \   0000002A   0x4770             BX       LR               ;; return
    172          }
    173          
    174          
    175          /************************************************************************************
    176          * MemoryCpy
    177          *
    178          * This function copy a buffer source to a buffer destination
    179          *
    180          ************************************************************************************/
    181          

   \                                 In section .text, align 2, keep-with-next
    182          void MemoryCpy
    183          (
    184            void *pDst, // Destination buffer
    185            void *pSrc, // Source buffer
    186            uint8_t n   // Byte count
    187          )
    188          {
    189              // Code looks weird, but is quite optimal on a HCS08 CPU
    190            while(n) {
   \                     MemoryCpy: (+1)
   \                     ??MemoryCpy_0: (+1)
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD005             BEQ.N    ??MemoryCpy_1
    191              *((uint8_t *)pDst) = *((uint8_t *)pSrc);
   \   00000006   0x780B             LDRB     R3,[R1, #+0]
   \   00000008   0x7003             STRB     R3,[R0, #+0]
    192              pDst=((uint8_t *)pDst)+1;
   \   0000000A   0x1C40             ADDS     R0,R0,#+1
    193              pSrc=((uint8_t *)pSrc)+1;
   \   0000000C   0x1C49             ADDS     R1,R1,#+1
    194              n--;
   \   0000000E   0x1E52             SUBS     R2,R2,#+1
   \   00000010   0xE7F6             B.N      ??MemoryCpy_0
    195            }
    196          }
   \                     ??MemoryCpy_1: (+1)
   \   00000012   0x4770             BX       LR               ;; return
    197          
    198          /************************************************************************************
    199          * MemorySet
    200          *
    201          * This function set an specific value into a buffer destination
    202          *
    203          ************************************************************************************/
    204          

   \                                 In section .text, align 2, keep-with-next
    205          void MemorySet
    206          (
    207            void *pDst,    // Buffer to be reset
    208            uint8_t value, // Byte value
    209            uint16_t cnt    // Byte count
    210          )
    211          {
    212            while(cnt) {
   \                     MemorySet: (+1)
   \                     ??MemorySet_0: (+1)
   \   00000000   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD003             BEQ.N    ??MemorySet_1
    213              ((uint8_t *)pDst)[--cnt] = value;
   \   00000006   0x1E52             SUBS     R2,R2,#+1
   \   00000008   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000A   0x5411             STRB     R1,[R2, R0]
   \   0000000C   0xE7F8             B.N      ??MemorySet_0
    214            }
    215          }
   \                     ??MemorySet_1: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
    216          
    217          /**************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    218          void PrintByteOnHexFormatBlocking(uint8_t u8Byte, bool_t bPrintComma, uint8_t port)
    219          {
   \                     PrintByteOnHexFormatBlocking: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    220            static uint8_t HexString[4] = {0};
    221              
    222            HexString[0] = HexToAscii(u8Byte>>4);
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x0920             LSRS     R0,R4,#+4
   \   0000000C   0x.... 0x....      BL       HexToAscii
   \   00000010   0x....             LDR.N    R1,??DataTable3_4
   \   00000012   0x7008             STRB     R0,[R1, #+0]
    223            HexString[1] = HexToAscii(u8Byte);
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x.... 0x....      BL       HexToAscii
   \   0000001C   0x....             LDR.N    R1,??DataTable3_4
   \   0000001E   0x7048             STRB     R0,[R1, #+1]
    224            
    225            if(bPrintComma){
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD003             BEQ.N    ??PrintByteOnHexFormatBlocking_0
    226              HexString[2] = ',';  
   \   00000026   0x202C             MOVS     R0,#+44
   \   00000028   0x....             LDR.N    R1,??DataTable3_4
   \   0000002A   0x7088             STRB     R0,[R1, #+2]
   \   0000002C   0xE002             B.N      ??PrintByteOnHexFormatBlocking_1
    227            }else{
    228              HexString[2] = 0;      
   \                     ??PrintByteOnHexFormatBlocking_0: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x....             LDR.N    R1,??DataTable3_4
   \   00000032   0x7088             STRB     R0,[R1, #+2]
    229            }
    230            HexString[3] = 0;      
   \                     ??PrintByteOnHexFormatBlocking_1: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x....             LDR.N    R1,??DataTable3_4
   \   00000038   0x70C8             STRB     R0,[R1, #+3]
    231            
    232            CommUtil_Print((char *)HexString, gAllowToBlock_d);
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x....             LDR.N    R0,??DataTable3_4
   \   0000003E   0x.... 0x....      BL       CommUtil_Print
    233          }
   \   00000042   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .bss, align 4
   \                     ??HexString:
   \   00000000                      DS8 4
    234          
    235          
    236          /**************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    237          void PrintWordOnDecimalFormatBlocking(uint16_t u16Dec, uint8_t u8MinDigs,bool_t bNegative, uint8_t port)
    238          {
   \                     PrintWordOnDecimalFormatBlocking: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    239            static uint8_t decString[7] = {0};
    240            uint8_t ind,Sing;
    241              
    242            int2BCD(u16Dec, &decString[1]);
   \   0000000C   0x....             LDR.N    R1,??DataTable3_5
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000012   0x.... 0x....      BL       int2BCD
    243            
    244            Sing=0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4681             MOV      R9,R0
    245            decString[0]=0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x....             LDR.N    R1,??DataTable3_6
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
    246            if(u8MinDigs > 5) u8MinDigs = 5;
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D06             CMP      R5,#+6
   \   00000024   0xDB01             BLT.N    ??PrintWordOnDecimalFormatBlocking_0
   \   00000026   0x2005             MOVS     R0,#+5
   \   00000028   0x0005             MOVS     R5,R0
    247            while((0 == decString[Sing+1]) && (Sing < 5-u8MinDigs)){
   \                     ??PrintWordOnDecimalFormatBlocking_0: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable3_6
   \   0000002C   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000030   0xEB19 0x0000      ADDS     R0,R9,R0
   \   00000034   0x7840             LDRB     R0,[R0, #+1]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD109             BNE.N    ??PrintWordOnDecimalFormatBlocking_1
   \   0000003A   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0xF1D5 0x0005      RSBS     R0,R5,#+5
   \   00000044   0x4581             CMP      R9,R0
   \   00000046   0xDA02             BGE.N    ??PrintWordOnDecimalFormatBlocking_1
    248              Sing++; 
   \   00000048   0xF119 0x0901      ADDS     R9,R9,#+1
   \   0000004C   0xE7ED             B.N      ??PrintWordOnDecimalFormatBlocking_0
    249            }
    250            for(ind=Sing;ind<6;ind++){
   \                     ??PrintWordOnDecimalFormatBlocking_1: (+1)
   \   0000004E   0x46C8             MOV      R8,R9
   \                     ??PrintWordOnDecimalFormatBlocking_2: (+1)
   \   00000050   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000054   0xF1B8 0x0F06      CMP      R8,#+6
   \   00000058   0xDA0D             BGE.N    ??PrintWordOnDecimalFormatBlocking_3
    251              decString[ind] += '0';  
   \   0000005A   0x....             LDR.N    R0,??DataTable3_6
   \   0000005C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000060   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   00000064   0x3030             ADDS     R0,R0,#+48
   \   00000066   0x....             LDR.N    R1,??DataTable3_6
   \   00000068   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000006C   0xF808 0x0001      STRB     R0,[R8, R1]
    252            }
   \   00000070   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000074   0xE7EC             B.N      ??PrintWordOnDecimalFormatBlocking_2
    253            if(bNegative){
   \                     ??PrintWordOnDecimalFormatBlocking_3: (+1)
   \   00000076   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000078   0x2E00             CMP      R6,#+0
   \   0000007A   0xD006             BEQ.N    ??PrintWordOnDecimalFormatBlocking_4
    254              decString[Sing] = '-';
   \   0000007C   0x202D             MOVS     R0,#+45
   \   0000007E   0x....             LDR.N    R1,??DataTable3_6
   \   00000080   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000084   0xF809 0x0001      STRB     R0,[R9, R1]
   \   00000088   0xE001             B.N      ??PrintWordOnDecimalFormatBlocking_5
    255            }else{
    256              Sing++;
   \                     ??PrintWordOnDecimalFormatBlocking_4: (+1)
   \   0000008A   0xF119 0x0901      ADDS     R9,R9,#+1
    257            }
    258            CommUtil_Print((char*)&decString[Sing], gAllowToBlock_d);
   \                     ??PrintWordOnDecimalFormatBlocking_5: (+1)
   \   0000008E   0x2101             MOVS     R1,#+1
   \   00000090   0x....             LDR.N    R0,??DataTable3_6
   \   00000092   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000096   0xEB19 0x0000      ADDS     R0,R9,R0
   \   0000009A   0x.... 0x....      BL       CommUtil_Print
    259          }
   \   0000009E   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .bss, align 4
   \                     ??decString:
   \   00000000                      DS8 8
    260          
    261          /**************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    262          void int2BCD(uint16_t u16Num, uint8_t * pu8BCDOut)
    263          {
   \                     int2BCD: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    264            uint8_t cont=16;
   \   00000002   0x2210             MOVS     R2,#+16
    265            uint8_t aux=0;
   \   00000004   0x2300             MOVS     R3,#+0
    266          
    267            for (aux=0;aux<5;aux++){
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x0023             MOVS     R3,R4
   \                     ??int2BCD_0: (+1)
   \   0000000A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000000C   0x2B05             CMP      R3,#+5
   \   0000000E   0xDA04             BGE.N    ??int2BCD_1
    268              pu8BCDOut[aux]=0;
   \   00000010   0x2400             MOVS     R4,#+0
   \   00000012   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000014   0x545C             STRB     R4,[R3, R1]
    269            }
   \   00000016   0x1C5B             ADDS     R3,R3,#+1
   \   00000018   0xE7F7             B.N      ??int2BCD_0
    270            do{
    271              for(aux=0;aux<5;aux++) {
   \                     ??int2BCD_1: (+1)
   \   0000001A   0x2400             MOVS     R4,#+0
   \   0000001C   0x0023             MOVS     R3,R4
   \                     ??int2BCD_2: (+1)
   \   0000001E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000020   0x2B05             CMP      R3,#+5
   \   00000022   0xDA06             BGE.N    ??int2BCD_3
    272                pu8BCDOut[aux]<<=1;
   \   00000024   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000026   0x5C5C             LDRB     R4,[R3, R1]
   \   00000028   0x0064             LSLS     R4,R4,#+1
   \   0000002A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000002C   0x545C             STRB     R4,[R3, R1]
    273              }
   \   0000002E   0x1C5B             ADDS     R3,R3,#+1
   \   00000030   0xE7F5             B.N      ??int2BCD_2
    274              if(u16Num&0x8000){
   \                     ??int2BCD_3: (+1)
   \   00000032   0x0404             LSLS     R4,R0,#+16
   \   00000034   0xD502             BPL.N    ??int2BCD_4
    275                pu8BCDOut[4]+=1;
   \   00000036   0x790C             LDRB     R4,[R1, #+4]
   \   00000038   0x1C64             ADDS     R4,R4,#+1
   \   0000003A   0x710C             STRB     R4,[R1, #+4]
    276              }
    277              u16Num<<=1;
   \                     ??int2BCD_4: (+1)
   \   0000003C   0x0040             LSLS     R0,R0,#+1
    278              for(aux=4;aux>0;aux--){
   \   0000003E   0x2404             MOVS     R4,#+4
   \   00000040   0x0023             MOVS     R3,R4
   \                     ??int2BCD_5: (+1)
   \   00000042   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000044   0x2B00             CMP      R3,#+0
   \   00000046   0xD013             BEQ.N    ??int2BCD_6
    279                if (pu8BCDOut[aux]>=10){
   \   00000048   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000004A   0x5C5C             LDRB     R4,[R3, R1]
   \   0000004C   0x2C0A             CMP      R4,#+10
   \   0000004E   0xDB0D             BLT.N    ??int2BCD_7
    280                  pu8BCDOut[aux-1]++;
   \   00000050   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000052   0x185C             ADDS     R4,R3,R1
   \   00000054   0xF814 0x4C01      LDRB     R4,[R4, #-1]
   \   00000058   0x1C64             ADDS     R4,R4,#+1
   \   0000005A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000005C   0x185D             ADDS     R5,R3,R1
   \   0000005E   0xF805 0x4C01      STRB     R4,[R5, #-1]
    281                  pu8BCDOut[aux]-=10;
   \   00000062   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000064   0x5C5C             LDRB     R4,[R3, R1]
   \   00000066   0x3C0A             SUBS     R4,R4,#+10
   \   00000068   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000006A   0x545C             STRB     R4,[R3, R1]
    282                }
    283              }
   \                     ??int2BCD_7: (+1)
   \   0000006C   0x1E5B             SUBS     R3,R3,#+1
   \   0000006E   0xE7E8             B.N      ??int2BCD_5
    284              cont--;
   \                     ??int2BCD_6: (+1)
   \   00000070   0x1E52             SUBS     R2,R2,#+1
    285            }while(cont);
   \   00000072   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000074   0x2A00             CMP      R2,#+0
   \   00000076   0xD1D0             BNE.N    ??int2BCD_1
    286          }
   \   00000078   0xBC30             POP      {R4,R5}
   \   0000007A   0x4770             BX       LR               ;; return
    287          
    288          /**************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    289          uint16_t HexString2Dec16(uint8_t * au8String)
    290          {
   \                     HexString2Dec16: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0001             MOVS     R1,R0
    291            uint8_t u8LocIndex=0;
   \   00000004   0x2300             MOVS     R3,#+0
    292            uint8_t u8LocIndex2=0;
   \   00000006   0x2200             MOVS     R2,#+0
    293            uint16_t u16DecValue = 0;
   \   00000008   0x2000             MOVS     R0,#+0
    294            
    295            while(au8String[u8LocIndex]){
   \                     ??HexString2Dec16_0: (+1)
   \   0000000A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000000C   0x5C5C             LDRB     R4,[R3, R1]
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD001             BEQ.N    ??HexString2Dec16_1
    296              u8LocIndex++;
   \   00000012   0x1C5B             ADDS     R3,R3,#+1
   \   00000014   0xE7F9             B.N      ??HexString2Dec16_0
    297            }
    298            
    299            while(u8LocIndex--){
   \                     ??HexString2Dec16_1: (+1)
   \   00000016   0x001C             MOVS     R4,R3
   \   00000018   0x1E63             SUBS     R3,R4,#+1
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD02B             BEQ.N    ??HexString2Dec16_2
    300              if((au8String[u8LocIndex] >= '0') && (au8String[u8LocIndex] <= '9'))
   \   00000020   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000022   0x5C5C             LDRB     R4,[R3, R1]
   \   00000024   0x2C30             CMP      R4,#+48
   \   00000026   0xDB0C             BLT.N    ??HexString2Dec16_3
   \   00000028   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000002A   0x5C5C             LDRB     R4,[R3, R1]
   \   0000002C   0x2C3A             CMP      R4,#+58
   \   0000002E   0xDA08             BGE.N    ??HexString2Dec16_3
    301               u16DecValue |= ((uint16_t)(au8String[u8LocIndex] - '0'))<<(u8LocIndex2*4);
   \   00000030   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000032   0x5C5C             LDRB     R4,[R3, R1]
   \   00000034   0x3C30             SUBS     R4,R4,#+48
   \   00000036   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000038   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000003A   0x0095             LSLS     R5,R2,#+2
   \   0000003C   0x40AC             LSLS     R4,R4,R5
   \   0000003E   0x4320             ORRS     R0,R4,R0
   \   00000040   0xE018             B.N      ??HexString2Dec16_4
    302              else if((au8String[u8LocIndex] >= 'A') && (au8String[u8LocIndex] <= 'F')){
   \                     ??HexString2Dec16_3: (+1)
   \   00000042   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000044   0x5C5C             LDRB     R4,[R3, R1]
   \   00000046   0x2C41             CMP      R4,#+65
   \   00000048   0xDB0C             BLT.N    ??HexString2Dec16_5
   \   0000004A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000004C   0x5C5C             LDRB     R4,[R3, R1]
   \   0000004E   0x2C47             CMP      R4,#+71
   \   00000050   0xDA08             BGE.N    ??HexString2Dec16_5
    303               u16DecValue |= ((uint16_t)(au8String[u8LocIndex] - 'A' + 0x0A))<<(u8LocIndex2*4);    
   \   00000052   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000054   0x5C5C             LDRB     R4,[R3, R1]
   \   00000056   0x3C37             SUBS     R4,R4,#+55
   \   00000058   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000005A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000005C   0x0095             LSLS     R5,R2,#+2
   \   0000005E   0x40AC             LSLS     R4,R4,R5
   \   00000060   0x4320             ORRS     R0,R4,R0
   \   00000062   0xE007             B.N      ??HexString2Dec16_4
    304              }else{
    305               u16DecValue |= ((uint16_t)(au8String[u8LocIndex] - 'a' + 0x0A))<<(u8LocIndex2*4);        
   \                     ??HexString2Dec16_5: (+1)
   \   00000064   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000066   0x5C5C             LDRB     R4,[R3, R1]
   \   00000068   0x3C57             SUBS     R4,R4,#+87
   \   0000006A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000006C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000006E   0x0095             LSLS     R5,R2,#+2
   \   00000070   0x40AC             LSLS     R4,R4,R5
   \   00000072   0x4320             ORRS     R0,R4,R0
    306              }
    307              u8LocIndex2++;
   \                     ??HexString2Dec16_4: (+1)
   \   00000074   0x1C52             ADDS     R2,R2,#+1
   \   00000076   0xE7CE             B.N      ??HexString2Dec16_1
    308            }
    309            
    310            return u16DecValue;
   \                     ??HexString2Dec16_2: (+1)
   \   00000078   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000007A   0xBC30             POP      {R4,R5}
   \   0000007C   0x4770             BX       LR               ;; return
    311            
    312          }
    313          /**************************************************************************************/
    314          

   \                                 In section .text, align 2, keep-with-next
    315          void MCU_InitClock(void)
    316          {
   \                     MCU_InitClock: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    317              gMCG_coreClkMHz = MCG_PLLInit();
   \   00000002   0x.... 0x....      BL       MCG_PLLInit
   \   00000006   0x....             LDR.N    R1,??DataTable3_7
   \   00000008   0x6008             STR      R0,[R1, #+0]
    318             /*
    319             * Use the value obtained from the pll_init function to define variables
    320             * for the core clock in kHz and also the peripheral clock. These
    321             * variables can be used by other functions that need awareness of the
    322             * system frequency.
    323             */
    324            gMCG_coreClkKHz = gMCG_coreClkMHz * 1000;
   \   0000000A   0x....             LDR.N    R0,??DataTable3_7
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF44F 0x717A      MOV      R1,#+1000
   \   00000012   0x4348             MULS     R0,R1,R0
   \   00000014   0x....             LDR.N    R1,??DataTable3_8
   \   00000016   0x6008             STR      R0,[R1, #+0]
    325            gMCG_periphClkKHz = gMCG_coreClkKHz / (((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV2_MASK) >> 24)+ 1);
   \   00000018   0x....             LDR.N    R0,??DataTable3_8
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x....             LDR.N    R1,??DataTable3_9  ;; 0x40048044
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0xF3C1 0x6103      UBFX     R1,R1,#+24,#+4
   \   00000024   0x1C49             ADDS     R1,R1,#+1
   \   00000026   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000002A   0x....             LDR.N    R1,??DataTable3_10
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    326          
    327          }
   \   0000002E   0xBD01             POP      {R0,PC}          ;; return
    328          
    329          /************************************************************************************
    330          * This function copies the specified number of bytes from the
    331          * source address to the destination address.  No attempt is made
    332          * to handle overlapping copies to prevent loss of data.
    333          * The copying is optimized to avoid alignment problems, and attempts
    334          * to copy 32bit numbers optimally.
    335          *   
    336          * Interface assumptions:
    337          *   None
    338          *   
    339          * Return value:
    340          *   None
    341          * 
    342          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    343          void FLib_MemCpyAligned32bit
    344            (
    345               /* [IN] address to copy data from */
    346               void*  from_ptr,
    347          
    348               /* [IN] address to copy data to */
    349               void*  to_ptr,
    350          
    351               /* [IN] number of bytes to copy */
    352               register uint32_t number_of_bytes
    353            )
    354          {
   \                     FLib_MemCpyAligned32bit: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    355          
    356             uint8_t*  	from8_ptr = (uint8_t*) from_ptr;
   \   00000004   0x4684             MOV      R12,R0
    357             uint8_t*  	to8_ptr = (uint8_t*) to_ptr;
   \   00000006   0x468E             MOV      LR,R1
    358             uint16_t* 	from16_ptr = (uint16_t*) from_ptr;
   \   00000008   0x0003             MOVS     R3,R0
    359             uint16_t* 	to16_ptr = (uint16_t*) to_ptr;
   \   0000000A   0x000C             MOVS     R4,R1
    360             register 	uint32_t* from32_ptr = (uint32_t*) from_ptr;
   \   0000000C   0x0005             MOVS     R5,R0
    361             register 	uint32_t* to32_ptr = (uint32_t*) to_ptr;
   \   0000000E   0x000E             MOVS     R6,R1
    362             
    363             register 	uint32_t loops;
    364          
    365             if (number_of_bytes > 3) 
   \   00000010   0x2A04             CMP      R2,#+4
   \   00000012   0xD330             BCC.N    ??FLib_MemCpyAligned32bit_0
    366             {
    367                /* Try to align source on word */
    368                if ((uint32_t)from_ptr & 1) 
   \   00000014   0x4680             MOV      R8,R0
   \   00000016   0xEA5F 0x78C8      LSLS     R8,R8,#+31
   \   0000001A   0xD50C             BPL.N    ??FLib_MemCpyAligned32bit_1
    369                {
    370                   from8_ptr = (uint8_t* ) from_ptr;
   \   0000001C   0x4684             MOV      R12,R0
    371                   to8_ptr = (uint8_t* ) to_ptr;
   \   0000001E   0x468E             MOV      LR,R1
    372          
    373                   *to8_ptr++ = *from8_ptr++;
   \   00000020   0xF89C 0x8000      LDRB     R8,[R12, #+0]
   \   00000024   0xF88E 0x8000      STRB     R8,[LR, #+0]
   \   00000028   0xF11C 0x0C01      ADDS     R12,R12,#+1
   \   0000002C   0xF11E 0x0E01      ADDS     LR,LR,#+1
    374          
    375                   from_ptr = from8_ptr;
   \   00000030   0x4660             MOV      R0,R12
    376                   to_ptr = to8_ptr;
   \   00000032   0x4671             MOV      R1,LR
    377                   --number_of_bytes;
   \   00000034   0x1E52             SUBS     R2,R2,#+1
    378                }
    379          
    380                /* Try to align source on longword */
    381                if ((uint32_t)from_ptr & 2) 
   \                     ??FLib_MemCpyAligned32bit_1: (+1)
   \   00000036   0x4680             MOV      R8,R0
   \   00000038   0xEA5F 0x7888      LSLS     R8,R8,#+30
   \   0000003C   0xD50A             BPL.N    ??FLib_MemCpyAligned32bit_2
    382                {
    383                   from16_ptr = (uint16_t*) from_ptr;
   \   0000003E   0x0003             MOVS     R3,R0
    384                   to16_ptr = (uint16_t*) to_ptr;
   \   00000040   0x000C             MOVS     R4,R1
    385          
    386                   *to16_ptr++ = *from16_ptr++;
   \   00000042   0xF8B3 0x8000      LDRH     R8,[R3, #+0]
   \   00000046   0xF8A4 0x8000      STRH     R8,[R4, #+0]
   \   0000004A   0x1C9B             ADDS     R3,R3,#+2
   \   0000004C   0x1CA4             ADDS     R4,R4,#+2
    387          
    388                   from_ptr = from16_ptr;
   \   0000004E   0x0018             MOVS     R0,R3
    389                   to_ptr = to16_ptr;
   \   00000050   0x0021             MOVS     R1,R4
    390                   number_of_bytes -= 2;
   \   00000052   0x1E92             SUBS     R2,R2,#+2
    391                }
    392          
    393                from32_ptr = (uint32_t*) from_ptr;
   \                     ??FLib_MemCpyAligned32bit_2: (+1)
   \   00000054   0x0005             MOVS     R5,R0
    394                to32_ptr = (uint32_t*) to_ptr;
   \   00000056   0x000E             MOVS     R6,R1
    395          
    396                for (loops = number_of_bytes >> 2; loops != 0; loops--) 
   \   00000058   0xEA5F 0x0892      LSRS     R8,R2,#+2
   \   0000005C   0x4647             MOV      R7,R8
   \                     ??FLib_MemCpyAligned32bit_3: (+1)
   \   0000005E   0x2F00             CMP      R7,#+0
   \   00000060   0xD007             BEQ.N    ??FLib_MemCpyAligned32bit_4
    397                {
    398                   *to32_ptr++ = *from32_ptr++;
   \   00000062   0xF8D5 0x8000      LDR      R8,[R5, #+0]
   \   00000066   0xF8C6 0x8000      STR      R8,[R6, #+0]
   \   0000006A   0x1D2D             ADDS     R5,R5,#+4
   \   0000006C   0x1D36             ADDS     R6,R6,#+4
    399                }
   \   0000006E   0x1E7F             SUBS     R7,R7,#+1
   \   00000070   0xE7F5             B.N      ??FLib_MemCpyAligned32bit_3
    400          
    401                from_ptr = from32_ptr;
   \                     ??FLib_MemCpyAligned32bit_4: (+1)
   \   00000072   0x0028             MOVS     R0,R5
    402                to_ptr = to32_ptr;
   \   00000074   0x0031             MOVS     R1,R6
    403             } 
    404          
    405             /* Copy all remaining bytes */
    406             if (number_of_bytes & 2) 
   \                     ??FLib_MemCpyAligned32bit_0: (+1)
   \   00000076   0xEA5F 0x7882      LSLS     R8,R2,#+30
   \   0000007A   0xD509             BPL.N    ??FLib_MemCpyAligned32bit_5
    407             {
    408                from16_ptr = (uint16_t*) from_ptr;
   \   0000007C   0x0003             MOVS     R3,R0
    409                to16_ptr = (uint16_t*) to_ptr;
   \   0000007E   0x000C             MOVS     R4,R1
    410          
    411                *to16_ptr++ = *from16_ptr++;
   \   00000080   0xF8B3 0x8000      LDRH     R8,[R3, #+0]
   \   00000084   0xF8A4 0x8000      STRH     R8,[R4, #+0]
   \   00000088   0x1C9B             ADDS     R3,R3,#+2
   \   0000008A   0x1CA4             ADDS     R4,R4,#+2
    412          
    413                from_ptr = from16_ptr;
   \   0000008C   0x0018             MOVS     R0,R3
    414                to_ptr = to16_ptr;
   \   0000008E   0x0021             MOVS     R1,R4
    415             } 
    416          
    417             if (number_of_bytes & 1) 
   \                     ??FLib_MemCpyAligned32bit_5: (+1)
   \   00000090   0xEA5F 0x78C2      LSLS     R8,R2,#+31
   \   00000094   0xD503             BPL.N    ??FLib_MemCpyAligned32bit_6
    418             {
    419                * (uint8_t* ) to_ptr = * (uint8_t* ) from_ptr;
   \   00000096   0xF890 0x8000      LDRB     R8,[R0, #+0]
   \   0000009A   0xF881 0x8000      STRB     R8,[R1, #+0]
    420             }
    421          }
   \                     ??FLib_MemCpyAligned32bit_6: (+1)
   \   0000009E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x40048038         DC32     0x40048038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x40040000         DC32     0x40040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x40040008         DC32     0x40040008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x40040004         DC32     0x40040004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     ??HexString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x........         DC32     ??decString+0x1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x........         DC32     ??decString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x........         DC32     gMCG_coreClkMHz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x........         DC32     gMCG_coreClkKHz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \   00000000   0x40048044         DC32     0x40048044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \   00000000   0x........         DC32     gMCG_periphClkKHz
    422          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   FLib_MemCpyAligned32bit
       8   HexString2Dec16
       0   HexToAscii
       0   HexaToAscii
       8   MCU_InitClock
         8   -> MCG_PLLInit
       0   MemoryCpy
       0   MemorySet
      16   PrintByteOnHexFormatBlocking
        16   -> CommUtil_Print
        16   -> HexToAscii
      32   PrintWordOnDecimalFormatBlocking
        32   -> CommUtil_Print
        32   -> int2BCD
       4   convert_2_bcd
       0   delayMs
       8   int2BCD
       4   stringComp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
     162  FLib_MemCpyAligned32bit
       4  HexString
     126  HexString2Dec16
      22  HexToAscii
      22  HexaToAscii
      48  MCU_InitClock
      20  MemoryCpy
      16  MemorySet
      68  PrintByteOnHexFormatBlocking
     162  PrintWordOnDecimalFormatBlocking
     310  convert_2_bcd
       8  decString
     108  delayMs
     124  int2BCD
      44  stringComp

 
    12 bytes in section .bss
 1 276 bytes in section .text
 
 1 276 bytes of CODE memory
    12 bytes of DATA memory

Errors: none
Warnings: none
