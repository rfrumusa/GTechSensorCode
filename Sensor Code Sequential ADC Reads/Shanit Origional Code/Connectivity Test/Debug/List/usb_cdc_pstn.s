///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM       02/Sep/2018  14:19:43
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\Class\usb_cdc_pstn.c
//    Command line =  
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\Class\usb_cdc_pstn.c" -D IAR --preprocess
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\" -lC
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\" -lB
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\"
//        --diag_suppress Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\Obj\" --no_cse
//        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
//        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\APP\CDC\" -I "F:\Guardrail Work\Sensor Code\Git
//        Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\USB\APP\Descriptor\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Class\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Sys Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
//    List file    =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\Debug\List\usb_cdc_pstn.s
//
///////////////////////////////////////////////////////////////////////////////

        #define SHT_PROGBITS 0x1

        EXTERN USB_CDC_Desc_GetAbstractState
        EXTERN USB_CDC_Desc_GetCountrySetting
        EXTERN USB_CDC_Desc_GetLineCoding
        EXTERN USB_CDC_Desc_SetAbstractState
        EXTERN USB_CDC_Desc_SetCountrySetting
        EXTERN USB_CDC_Desc_SetLineCoding
        EXTERN USB_ClassSendData_
        EXTERN USB_DeviceCancelTransfer
        EXTERN USB_IsrEvent
        EXTERN gpaUsbClassDescriptor

        PUBLIC USB_Class_CDC_PSTN_GetCommFeature
        PUBLIC USB_Class_CDC_PSTN_GetLineCoding
        PUBLIC USB_Class_CDC_PSTN_SendBreak
        PUBLIC USB_Class_CDC_PSTN_SendSerialState
        PUBLIC USB_Class_CDC_PSTN_SetCommFeature
        PUBLIC USB_Class_CDC_PSTN_SetCtrlLineState
        PUBLIC USB_Class_CDC_PSTN_SetLineCoding
        PUBLIC gDTEStatus
        PUBLIC gNotifyEndpoint

// F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Class\usb_cdc_pstn.c
//    1 /******************************************************************************
//    2  *
//    3  * Freescale Semiconductor Inc.
//    4  * (c) Copyright 2004-2009 Freescale Semiconductor, Inc.
//    5  * ALL RIGHTS RESERVED.
//    6  *
//    7  ******************************************************************************
//    8  *
//    9  * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR 
//   10  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
//   11  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
//   12  * IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
//   13  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
//   14  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
//   15  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
//   16  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
//   17  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
//   18  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
//   19  * THE POSSIBILITY OF SUCH DAMAGE.
//   20  *
//   21  **************************************************************************//*!
//   22  *
//   23  * @file usb_cdc_pstn.c
//   24  *
//   25  * @author
//   26  *
//   27  * @version
//   28  *
//   29  * @date May-28-2009
//   30  *
//   31  * @brief The file contains USB CDC_PSTN Sub Class implementation.
//   32  *
//   33  *****************************************************************************/
//   34 
//   35 /******************************************************************************
//   36  * Includes
//   37  *****************************************************************************/
//   38  #include "USB.h" 
//   39  #include "usb_cdc_pstn.h"  /* USB CDC PSTN Sub Class Header File */
//   40 #if gUsbCdcEnabled_d
//   41 
//   42 #if (gUsbIncluded_d == FALSE)
//   43  #error If gUsbCdcEnabled_d == TRUE, gUsbIncluded_d must be TRUE
//   44 #endif
//   45  /*****************************************************************************
//   46  * Constant and Macro's
//   47  *****************************************************************************/
//   48 #define USB_Class_CDC_Interface_CIC_Send_Data(controllerId, pBuff,size)  \ 
//   49         USB_ClassSendData( controllerId , gNotifyEndpoint , pBuff, size)
//   50 
//   51 /*****************************************************************************
//   52  * Global Functions Prototypes
//   53  *****************************************************************************/
//   54 
//   55 /****************************************************************************
//   56  * Global Variables
//   57  ****************************************************************************/
//   58 #if gUSB_CDC_CIC_NotifElemSupport_d

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   59 uint8_t gNotifyEndpoint;
gNotifyEndpoint:
        DS8 1
//   60 #endif
//   61 /*****************************************************************************
//   62  * Local Types - None
//   63  *****************************************************************************/
//   64 
//   65 /*****************************************************************************
//   66  * Local Functions Prototypes
//   67  *****************************************************************************/
//   68 
//   69 /*****************************************************************************
//   70  * Local Variables
//   71  *****************************************************************************/
//   72 /* data terminal equipment present or not */

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//   73 uint8_t gDTEStatus = (uint8_t)gUninitialisedVal_d; /* Status of DATA TERMINAL EQUIPMENT */
gDTEStatus:
        DATA
        DC8 255

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   74 static uint8_t gCurrentInterface = 0;
gCurrentInterface:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   75 static uartBitmap_t gUARTBitmap;
gUARTBitmap:
        DS8 4
//   76 
//   77 #if gUSB_CDC_CIC_NotifElemSupport_d

        SECTION `.data`:DATA:REORDER:NOROOT(2)
//   78 static uint8_t gSerialState[gUSB_CDC_Size_NotifPacketSize_d+gUSB_CDC_UARTBitmapSize_d] =
gSerialState:
        DATA
        DC8 161, 32, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0
//   79 {
//   80   gUSB_CDC_NotifRequestType_d,gUSB_CDC_ClassNotifCodes_SerialState_d,
//   81   0x00,0x00,/*wValue*/
//   82   0x00,0x00,/*interface - modifies*/
//   83   gUSB_CDC_UARTBitmapSize_d,0x00,/* wlength*/
//   84   0x00,0x00 /*data initialized - modifies*/
//   85 };/*uart bitmap*/
//   86 #endif
//   87  /*****************************************************************************
//   88  * Local Functions
//   89  *****************************************************************************/
//   90 
//   91 /*****************************************************************************
//   92  * Global Functions
//   93  *****************************************************************************/
//   94 
//   95 /**************************************************************************//*!
//   96  *
//   97  * @name  USB_Class_CDC_PSTN_GetLineCoding
//   98  *
//   99  * @brief  This function is called in response to GetLineCoding request
//  100  *
//  101  * @param controller_ID   : Controller ID
//  102  * @param setup_packet    : Pointer to setup packet
//  103  * @param data            : Pointer to Data to be send
//  104  * @param size            : Pointer to Size of Data
//  105  *
//  106  * @return status:
//  107  *          gUsbErr_NoError_c : When Successfull
//  108  *          gUsbErr_InvalidReqType_c: When  request for
//  109  *                                   invalid Interface is presented
//  110  ******************************************************************************
//  111  * Calls application to receive Line Coding Information
//  112  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  113 uint8_t USB_Class_CDC_PSTN_GetLineCoding
//  114 (
//  115   uint8_t controllerId,               /* [IN] Controller ID */
//  116   usbSetupPacket_t * pSetupPacket,    /* [IN] Pointer to setup packet */
//  117   uint8_t* *pData,                   /* [OUT] Pointer to Data to be send */
//  118   usbPacketSize_t *pSize               /* [OUT] Pointer to Size of Data */
//  119 )
//  120 {
USB_Class_CDC_PSTN_GetLineCoding:
        PUSH     {R4-R8,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
        MOVS     R7,R3
//  121   uint8_t status;
//  122   (void)(pSize);
//  123   gCurrentInterface = (uint8_t)pSetupPacket->index ;
        LDRH     R0,[R5, #+4]
        LDR.N    R1,??DataTable5
        STRB     R0,[R1, #+0]
//  124   status = USB_CDC_Desc_GetLineCoding(controllerId, gCurrentInterface, pData);
        MOVS     R2,R6
        LDR.N    R0,??DataTable5
        LDRB     R1,[R0, #+0]
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_CDC_Desc_GetLineCoding
        MOV      R8,R0
//  125   return status;
        MOV      R0,R8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R4-R8,PC}       ;; return
//  126 }
//  127 
//  128 /**************************************************************************//*!
//  129  *
//  130  * @name  USB_Class_CDC_PSTN_SetLineCoding
//  131  *
//  132  * @brief  This function is called in response to SetLineCoding request
//  133  *
//  134  * @param controller_ID   : Controller ID
//  135  * @param setup_packet    : Pointer to setup packet
//  136  * @param data            : Pointer to Data
//  137  * @param size            : Pointer to Size of Data
//  138  *
//  139  * @return status:
//  140  *      gUsbErr_NoError_c                  : When Successfull
//  141  *      gUsbErr_InvalidReqType_c : When  request for invalid
//  142  *                                Interface is presented
//  143  ******************************************************************************
//  144  * Calls Applciation to update Line Coding Information
//  145  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  146 uint8_t USB_Class_CDC_PSTN_SetLineCoding
//  147 (
//  148   uint8_t controllerId,               /* [IN] Controller ID */
//  149   usbSetupPacket_t * pSetupPacket,    /* [IN] Pointer to setup packet */
//  150   uint8_t* *pData,                   /* [OUT] Pointer to Data */
//  151   usbPacketSize_t *pSize               /* [OUT] Pointer to Size of Data */
//  152 )
//  153 {
USB_Class_CDC_PSTN_SetLineCoding:
        PUSH     {R4-R8,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
        MOVS     R7,R3
//  154   uint8_t status;
//  155   *pData = (uint8_t*)pSetupPacket + gUsbSetupPacketSize_d;
        ADDS     R0,R5,#+8
        STR      R0,[R6, #+0]
//  156   *pSize = 0;
        MOVS     R0,#+0
        STRH     R0,[R7, #+0]
//  157   gCurrentInterface = (uint8_t)pSetupPacket->index ;
        LDRH     R0,[R5, #+4]
        LDR.N    R1,??DataTable5
        STRB     R0,[R1, #+0]
//  158   status = USB_CDC_Desc_SetLineCoding(controllerId, gCurrentInterface, pData);
        MOVS     R2,R6
        LDR.N    R0,??DataTable5
        LDRB     R1,[R0, #+0]
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_CDC_Desc_SetLineCoding
        MOV      R8,R0
//  159   return status;
        MOV      R0,R8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R4-R8,PC}       ;; return
//  160 }
//  161 
//  162 /**************************************************************************//*!
//  163  *
//  164  * @name  USB_Class_CDC_PSTN_SetCtrlLineState
//  165  *
//  166  * @brief  This function is called in response to Set Control Line State
//  167  *
//  168  * @param controller_ID   : Controller ID
//  169  * @param setup_packet    : Pointer to setup packet
//  170  * @param data            : Pointer to Data
//  171  * @param size            : Pointer to Size of Data
//  172  *
//  173  * @return status:
//  174  *                        gUsbErr_NoError_c : Always
//  175  ******************************************************************************
//  176  * Updates Control Line State
//  177  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  178 uint8_t USB_Class_CDC_PSTN_SetCtrlLineState 
//  179 (
//  180   uint8_t controllerId,               /* [IN] Controller ID */
//  181   usbSetupPacket_t * pSetupPacket,    /* [IN] Pointer to setup packet */
//  182   uint8_t* *pData,                   /* [OUT] Pointer to Data  */
//  183   usbPacketSize_t *pSize               /* [OUT] Pointer to Size of Data */
//  184 )
//  185 {
USB_Class_CDC_PSTN_SetCtrlLineState:
        PUSH     {R0-R8,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
        MOVS     R7,R3
//  186 #if gUSB_CDC_SendEventToAppOnCOMOpen_d 
//  187   pfUsbToAppEventHandler_t pstnCallback;
//  188 #endif  
//  189   (void)(pData);
//  190   *pSize = 0;
        MOVS     R0,#+0
        STRH     R0,[R7, #+0]
//  191   if(gDTEStatus == (uint8_t)pSetupPacket->value)
        LDR.N    R0,??DataTable5_1
        LDRB     R0,[R0, #+0]
        LDRH     R1,[R5, #+2]
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R0,R1
        BNE.N    ??USB_Class_CDC_PSTN_SetCtrlLineState_0
//  192   {
//  193     return gUsbErr_NoError_c;    
        MOVS     R0,#+0
        B.N      ??USB_Class_CDC_PSTN_SetCtrlLineState_1
//  194   }
//  195   gDTEStatus = (uint8_t)pSetupPacket->value ;
??USB_Class_CDC_PSTN_SetCtrlLineState_0:
        LDRH     R0,[R5, #+2]
        LDR.N    R1,??DataTable5_1
        STRB     R0,[R1, #+0]
//  196   gCurrentInterface = (uint8_t)pSetupPacket->index ;
        LDRH     R0,[R5, #+4]
        LDR.N    R1,??DataTable5
        STRB     R0,[R1, #+0]
//  197   gUARTBitmap.byte = 0x00; /* initialize */
        MOVS     R0,#+0
        LDR.N    R1,??DataTable5_2
        STRB     R0,[R1, #+0]
//  198   /* activate/deactivate Tx carrier */
//  199   gUARTBitmap.bitmapUart.bTxCarrier = (gDTEStatus & gDTEStatus_CarrierActivation_d) ? 1 : 0 ;
        LDR.N    R0,??DataTable5_1
        LDRB     R0,[R0, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LSRS     R0,R0,#+1
        LDR.N    R1,??DataTable5_2
        LDRB     R1,[R1, #+0]
        BFI      R1,R0,#+1,#+1
        LDR.N    R0,??DataTable5_2
        STRB     R1,[R0, #+0]
//  200    /* activate carrier and DTE */
//  201   gUARTBitmap.bitmapUart.bRxCarrier = 1;
        LDR.N    R0,??DataTable5_2
        LDRB     R0,[R0, #+0]
        ORRS     R0,R0,#0x1
        LDR.N    R1,??DataTable5_2
        STRB     R0,[R1, #+0]
//  202 
//  203 #if gUSB_CDC_CIC_NotifElemSupport_d
//  204   /* Send Notification to Host - Parameter on Device side has changed */
//  205   USB_Class_CDC_PSTN_SendSerialState(controllerId);
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_Class_CDC_PSTN_SendSerialState
//  206 #endif
//  207 
//  208 #if gUSB_CDC_SendEventToAppOnCOMOpen_d 
//  209   pstnCallback = gpaUsbClassDescriptor[controllerId]->pfUsbToAppEventHandler;
        LDR.N    R0,??DataTable5_3
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDR      R0,[R0, R4, LSL #+2]
        LDR      R0,[R0, #+4]
        MOV      R8,R0
//  210   if(pstnCallback != NULL)
        MOV      R0,R8
        CMP      R0,#+0
        BEQ.N    ??USB_Class_CDC_PSTN_SetCtrlLineState_2
//  211   {
//  212     usbMsg_t usbMsg;
//  213     usbMsg.controllerId = controllerId;
        STRB     R4,[SP, #+0]
//  214     if((gDTEStatus & gDTEStatus_COM_Open_d) == gDTEStatus_COM_Open_d)
        LDR.N    R0,??DataTable5_1
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+31
        BPL.N    ??USB_Class_CDC_PSTN_SetCtrlLineState_3
//  215     {
//  216       usbMsg.eventType = (gUsbToAppEvent_t)gUsbToAppEvent_CDC_COM_Open_c;       //@SMAC cast added
        MOVS     R0,#+37
        STRB     R0,[SP, #+1]
        B.N      ??USB_Class_CDC_PSTN_SetCtrlLineState_4
//  217     }
//  218     else
//  219     {
//  220       usbMsg.eventType = (gUsbToAppEvent_t)gUsbToAppEvent_CDC_COM_Closed_c;    //@SMAC cast added
??USB_Class_CDC_PSTN_SetCtrlLineState_3:
        MOVS     R0,#+38
        STRB     R0,[SP, #+1]
//  221     }
//  222     USB_IsrEvent(&usbMsg);  
??USB_Class_CDC_PSTN_SetCtrlLineState_4:
        ADD      R0,SP,#+0
        BL       USB_IsrEvent
//  223   }
//  224 #endif  
//  225   return gUsbErr_NoError_c;
??USB_Class_CDC_PSTN_SetCtrlLineState_2:
        MOVS     R0,#+0
??USB_Class_CDC_PSTN_SetCtrlLineState_1:
        ADD      SP,SP,#+16
        POP      {R4-R8,PC}       ;; return
//  226 }
//  227 
//  228 /**************************************************************************//*!
//  229  *
//  230  * @name  USB_Class_CDC_PSTN_SendBreak
//  231  *
//  232  * @brief  This function is called in response to Set Config request
//  233  *
//  234  * @param controller_ID   : Controller ID
//  235  * @param setup_packet    : Pointer to setup packet
//  236  * @param data            : Pointer to Data
//  237  * @param size            : Pointer to Size of Data
//  238  *
//  239  * @return status:
//  240  *                        gUsbErr_NoError_c : Always
//  241  ******************************************************************************
//  242  * Updates Break Duration Information from Host
//  243  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  244 uint8_t USB_Class_CDC_PSTN_SendBreak
//  245 (
//  246   uint8_t controllerId,               /* [IN] Controller ID */
//  247   usbSetupPacket_t * pSetupPacket,    /* [IN] Pointer to setup packet */
//  248   uint8_t* *pData,                   /* [OUT] Pointer to Data  */
//  249   usbPacketSize_t *pSize               /* [OUT] Pointer to Size of Data */
//  250 )
//  251 {
USB_Class_CDC_PSTN_SendBreak:
        PUSH     {R4}
        MOVS     R4,R0
//  252     (void)(controllerId);
//  253     (void)(pData);
//  254     *pSize = 0;
        MOVS     R0,#+0
        STRH     R0,[R3, #+0]
//  255     return gUsbErr_NoError_c;
        MOVS     R0,#+0
        POP      {R4}
        BX       LR               ;; return
//  256 }
//  257 
//  258 /**************************************************************************//*!
//  259  *
//  260  * @name  USB_Class_CDC_PSTN_GetCommFeature
//  261  *
//  262  * @brief  This function is called in response to GetCommFeature request
//  263  *
//  264  * @param controller_ID   : Controller ID
//  265  * @param setup_packet    : Pointer to setup packet
//  266  * @param data            : Pointer to Data to be send
//  267  * @param size            : Pointer to Size of Data
//  268  *
//  269  * @return status:
//  270  *      gUsbErr_NoError_c                  : When Successfull
//  271  *      gUsbErr_InvalidReqType_c : When  request for invalid
//  272  *                                Interface is presented
//  273  ******************************************************************************
//  274  * Returns the status of the get comm feature request
//  275  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  276 uint8_t USB_Class_CDC_PSTN_GetCommFeature 
//  277 (
//  278   uint8_t controllerId,               /* [IN] Controller ID */
//  279   usbSetupPacket_t * pSetupPacket,    /* [IN] Pointer to setup packet */
//  280   uint8_t* *pData,                   /* [OUT] Pointer to Data to send */
//  281   usbPacketSize_t *pSize               /* [OUT] Pointer to Size of Data */
//  282 )
//  283 { 
USB_Class_CDC_PSTN_GetCommFeature:
        PUSH     {R4-R8,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
        MOVS     R7,R3
//  284   uint8_t status;
//  285   status = gUsbErr_InvalidReqType_c;
        MOVS     R0,#+205
        MOV      R8,R0
//  286   *pSize = gUSB_CDC_CommFeatureDataSize_d;
        MOVS     R0,#+2
        STRH     R0,[R7, #+0]
//  287   gCurrentInterface = (uint8_t)pSetupPacket->index ;
        LDRH     R0,[R5, #+4]
        LDR.N    R1,??DataTable5
        STRB     R0,[R1, #+0]
//  288   if(pSetupPacket->value == gPSTN_CommFeature_AbstractStateFeature_d)
        LDRH     R0,[R5, #+2]
        CMP      R0,#+1
        BNE.N    ??USB_Class_CDC_PSTN_GetCommFeature_0
//  289   {
//  290     status = USB_CDC_Desc_GetAbstractState(controllerId, gCurrentInterface, pData);
        MOVS     R2,R6
        LDR.N    R0,??DataTable5
        LDRB     R1,[R0, #+0]
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_CDC_Desc_GetAbstractState
        MOV      R8,R0
        B.N      ??USB_Class_CDC_PSTN_GetCommFeature_1
//  291   }
//  292   else if(pSetupPacket->value == gPSTN_CommFeature_CountrySettingFeature_d)
??USB_Class_CDC_PSTN_GetCommFeature_0:
        LDRH     R0,[R5, #+2]
        CMP      R0,#+2
        BNE.N    ??USB_Class_CDC_PSTN_GetCommFeature_1
//  293   {
//  294     status = USB_CDC_Desc_GetCountrySetting(controllerId, gCurrentInterface, pData);
        MOVS     R2,R6
        LDR.N    R0,??DataTable5
        LDRB     R1,[R0, #+0]
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_CDC_Desc_GetCountrySetting
        MOV      R8,R0
//  295   }
//  296   return status;
??USB_Class_CDC_PSTN_GetCommFeature_1:
        MOV      R0,R8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R4-R8,PC}       ;; return
//  297 }
//  298 
//  299 /**************************************************************************//*!
//  300  *
//  301  * @name  USB_Class_CDC_PSTN_SetCommFeature
//  302  *
//  303  * @brief  This function is called in response to SetCommFeature request
//  304  *
//  305  * @param controller_ID   : Controller ID
//  306  * @param setup_packet    : Pointer to setup packet
//  307  * @param data            : Pointer to Data
//  308  * @param size            : Pointer to Size of Data
//  309  *
//  310  * @return status:
//  311  *      gUsbErr_NoError_c                  : When Successfull
//  312  *      gUsbErr_InvalidReqType_c : When  request for invalid
//  313  *                                Interface is presented
//  314  ******************************************************************************
//  315  * Sets the comm feature specified by Host
//  316  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  317 uint8_t USB_Class_CDC_PSTN_SetCommFeature
//  318 (
//  319   uint8_t controllerId,               /* [IN] Controller ID */
//  320   usbSetupPacket_t * pSetupPacket,    /* [IN] Pointer to setup packet */
//  321   uint8_t* *pData,                   /* [OUT] Pointer to Data */
//  322   usbPacketSize_t *pSize               /* [OUT] Pointer to Size of Data */
//  323 )
//  324 {
USB_Class_CDC_PSTN_SetCommFeature:
        PUSH     {R4-R8,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
        MOVS     R7,R3
//  325   uint8_t status;
//  326   status = gUsbErr_InvalidReqType_c;
        MOVS     R0,#+205
        MOV      R8,R0
//  327   *pSize = 0;
        MOVS     R0,#+0
        STRH     R0,[R7, #+0]
//  328   gCurrentInterface = (uint8_t)pSetupPacket->index ;
        LDRH     R0,[R5, #+4]
        LDR.N    R1,??DataTable5
        STRB     R0,[R1, #+0]
//  329     
//  330   if(pSetupPacket->value == gPSTN_CommFeature_AbstractStateFeature_d)
        LDRH     R0,[R5, #+2]
        CMP      R0,#+1
        BNE.N    ??USB_Class_CDC_PSTN_SetCommFeature_0
//  331   {
//  332     status = USB_CDC_Desc_SetAbstractState(controllerId, gCurrentInterface, pData);
        MOVS     R2,R6
        LDR.N    R0,??DataTable5
        LDRB     R1,[R0, #+0]
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_CDC_Desc_SetAbstractState
        MOV      R8,R0
        B.N      ??USB_Class_CDC_PSTN_SetCommFeature_1
//  333   }
//  334   else if(pSetupPacket->value == gPSTN_CommFeature_CountrySettingFeature_d)
??USB_Class_CDC_PSTN_SetCommFeature_0:
        LDRH     R0,[R5, #+2]
        CMP      R0,#+2
        BNE.N    ??USB_Class_CDC_PSTN_SetCommFeature_1
//  335   {
//  336     status = USB_CDC_Desc_SetCountrySetting(controllerId, gCurrentInterface, pData);
        MOVS     R2,R6
        LDR.N    R0,??DataTable5
        LDRB     R1,[R0, #+0]
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_CDC_Desc_SetCountrySetting
        MOV      R8,R0
//  337   }
//  338   return status;
??USB_Class_CDC_PSTN_SetCommFeature_1:
        MOV      R0,R8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R4-R8,PC}       ;; return
//  339 }
//  340 
//  341 #if gUSB_CDC_CIC_NotifElemSupport_d
//  342 /**************************************************************************//*!
//  343  *
//  344  * @name  USB_Class_CDC_PSTN_SendSerialState
//  345  *
//  346  * @brief  This function is called to send serial state notification
//  347  *
//  348  * @param controller_ID : Controller ID
//  349  *
//  350  * @return NONE
//  351  ******************************************************************************
//  352  * Returns the Serial State
//  353  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  354 void USB_Class_CDC_PSTN_SendSerialState
//  355 (
//  356   uint8_t controllerId               /* [IN] Controller ID */
//  357 )
//  358 {
USB_Class_CDC_PSTN_SendSerialState:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
//  359   /* update array for current interface */
//  360   gSerialState[4] = gCurrentInterface;
        LDR.N    R0,??DataTable5
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable5_4
        STRB     R0,[R1, #+4]
//  361   /* Lower byte of UART BITMAP */
//  362   gSerialState[gUSB_CDC_Size_NotifPacketSize_d+gUSB_CDC_UARTBitmapSize_d-2] = gUARTBitmap.byte;
        LDR.N    R0,??DataTable5_2
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable5_4
        STRB     R0,[R1, #+8]
//  363   if(gNotifyEndpoint)
        LDR.N    R0,??DataTable5_5
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??USB_Class_CDC_PSTN_SendSerialState_0
//  364   {
//  365     (void)USB_DeviceCancelTransfer (controllerId, gNotifyEndpoint, gUsbEpDirection_In_c);
        MOVS     R2,#+1
        LDR.N    R0,??DataTable5_5
        LDRB     R1,[R0, #+0]
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceCancelTransfer
        MOVS     R5,R0
//  366     (void)USB_Class_CDC_Interface_CIC_Send_Data(controllerId, gSerialState, (gUSB_CDC_Size_NotifPacketSize_d + gUSB_CDC_UARTBitmapSize_d));    
        MOVS     R0,#+0
        STR      R0,[SP, #+0]
        MOVS     R3,#+10
        LDR.N    R2,??DataTable5_4
        LDR.N    R0,??DataTable5_5
        LDRB     R1,[R0, #+0]
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_ClassSendData_
//  367   }
//  368   
//  369 }
??USB_Class_CDC_PSTN_SendSerialState_0:
        POP      {R0,R4,R5,PC}    ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5:
        DC32     gCurrentInterface

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_1:
        DC32     gDTEStatus

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_2:
        DC32     gUARTBitmap

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_3:
        DC32     gpaUsbClassDescriptor

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_4:
        DC32     gSerialState

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_5:
        DC32     gNotifyEndpoint

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        END
//  370 #endif
//  371 
//  372 #endif//gUsbCdcEnabled_d
// 
//   6 bytes in section .bss
//  13 bytes in section .data
// 506 bytes in section .text
// 
// 506 bytes of CODE memory
//  19 bytes of DATA memory
//
//Errors: none
//Warnings: none
