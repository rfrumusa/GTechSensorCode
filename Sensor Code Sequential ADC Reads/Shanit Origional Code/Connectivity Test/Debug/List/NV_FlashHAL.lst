###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        02/Sep/2018  14:19:40
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\NVM\NV_FlashHAL.c
#    Command line =  
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\NVM\NV_FlashHAL.c" -D IAR --preprocess "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\List\" -lC "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\List\" -lB "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\List\" --diag_suppress
#        Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\Obj\" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\CDC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\Descriptor\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\USB\Class\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Sys Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
#    List file    =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\Debug\List\NV_FlashHAL.lst
#    Object file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\Obj\NV_FlashHAL.o
#
###############################################################################

F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\NV_FlashHAL.c
      1          /******************************************************************************
      2          * Filename: NV_FlashHAL.c
      3          *
      4          * Description: Implementation of the non-volatile storage module flash
      5          *              controller HAL for Cortex-M4 processor
      6          *
      7          * Copyright (c) 2014, Freescale Semiconductor, Inc.
      8          * All rights reserved.
      9          *
     10          * Redistribution and use in source and binary forms, with or without modification,
     11          * are permitted provided that the following conditions are met:
     12          *
     13          * o Redistributions of source code must retain the above copyright notice, this list
     14          *   of conditions and the following disclaimer.
     15          *
     16          * o Redistributions in binary form must reproduce the above copyright notice, this
     17          *   list of conditions and the following disclaimer in the documentation and/or
     18          *   other materials provided with the distribution.
     19          *
     20          * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     21          *   contributors may be used to endorse or promote products derived from this
     22          *   software without specific prior written permission.
     23          *
     24          * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     25          * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     26          * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     27          * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     28          * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     29          * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     30          * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     31          * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     32          * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     33          * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     34          *
     35          ***************************************************************************/
     36          
     37          #include "EmbeddedTypes.h"
     38          #include "PortConfig.h"
     39          #include "NV_FlashHAL.h"
     40          #include "Interrupt.h"
     41          
     42          
     43          /*****************************************************************************
     44           *****************************************************************************
     45           * Private memory definitions
     46           *****************************************************************************
     47           *****************************************************************************/
     48          
     49          /*****************************************************************************
     50           ******************************************************************************
     51           * Public memory definitions
     52           ******************************************************************************
     53           *****************************************************************************/
     54          
     55          /*
     56           * Name: effective number of bytes written
     57           * Description: EffectiveWrBytesCnt;
     58           */

   \                                 In section .bss, align 4
     59          uint32_t EffectiveWrBytesCnt;
   \                     EffectiveWrBytesCnt:
   \   00000000                      DS8 4
     60          
     61          /*****************************************************************************
     62           *****************************************************************************
     63           * Private prototypes
     64           *****************************************************************************
     65           *****************************************************************************/
     66          
     67          /************************************************************************
     68           *
     69           *  Function Name    : NvFlashCommandSequence
     70           *  Description      : Perform command write sequence for flash operation
     71           *  Arguments        : [IN] pConfig - pointer to NV configuration
     72           *                     [IN] index - command index
     73           *                     [IN] pCommandArray - command parameters
     74           *  Return Value     : uint32_t
     75           *
     76           *************************************************************************/
     77          static uint32_t NvFlashCommandSequence
     78          (
     79                  pNvConfig_t pConfig,
     80                  uint8_t index,
     81                  uint8_t* pCommandArray
     82          );
     83          
     84          /*****************************************************************************
     85           *****************************************************************************
     86           * Private functions
     87           *****************************************************************************
     88           *****************************************************************************/
     89          
     90          /************************************************************************
     91           *
     92           *  Function Name    : NvFlashCommandSequence
     93           *  Description      : Perform command write sequence for flash operation
     94           *  Arguments        : [IN] pConfig - pointer to NV configuration
     95           *                     [IN] index - command index
     96           *                     [IN] pCommandArray - command parameters
     97           *  Return Value     : uint32_t
     98           *
     99           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    100          static uint32_t NvFlashCommandSequence
    101          (
    102                  pNvConfig_t pConfig,
    103                  uint8_t index,
    104                  uint8_t* pCommandArray
    105          )
    106          {
   \                     NvFlashCommandSequence: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0003             MOVS     R3,R0
    107              uint8_t  counter;          /* for loop counter variable */
    108              uint8_t  registerValue;    /* store data read from flash register */
    109              uint32_t returnCode;       /* return code variable */
    110          #if gNvDisableIntCmdSeq_c
    111              uint32_t iRet = 0;
    112          #endif
    113          
    114          
    115              /* set the default return as gNV_OK_c */
    116              returnCode = gNV_OK_c;
   \   00000004   0x2600             MOVS     R6,#+0
   \   00000006   0x0030             MOVS     R0,R6
    117          
    118              /* check CCIF bit of the flash status register */
    119              while(FALSE == (gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c)))
   \                     ??NvFlashCommandSequence_0: (+1)
   \   00000008   0x681E             LDR      R6,[R3, #+0]
   \   0000000A   0x7836             LDRB     R6,[R6, #+0]
   \   0000000C   0x0636             LSLS     R6,R6,#+24
   \   0000000E   0xD5FB             BPL.N    ??NvFlashCommandSequence_0
    120              {
    121                  /* wait till CCIF bit is set */
    122              };
    123          
    124              /* clear RDCOLERR & ACCERR & FPVIOL flag in flash status register */
    125              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, \
    126                      (gNV_FSTAT_RDCOLERR_c | gNV_FSTAT_ACCERR_c | gNV_FSTAT_FPVIOL_c));
   \   00000010   0x2670             MOVS     R6,#+112
   \   00000012   0x681F             LDR      R7,[R3, #+0]
   \   00000014   0x703E             STRB     R6,[R7, #+0]
    127          
    128              /* load FCCOB registers */
    129              for(counter=0; counter<=index; counter++)
   \   00000016   0x2600             MOVS     R6,#+0
   \   00000018   0x0034             MOVS     R4,R6
   \                     ??NvFlashCommandSequence_1: (+1)
   \   0000001A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x42A1             CMP      R1,R4
   \   00000020   0xD352             BCC.N    ??NvFlashCommandSequence_2
    130              {
    131                  switch (counter)
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD011             BEQ.N    ??NvFlashCommandSequence_3
   \   00000028   0x2C02             CMP      R4,#+2
   \   0000002A   0xD019             BEQ.N    ??NvFlashCommandSequence_4
   \   0000002C   0xD313             BCC.N    ??NvFlashCommandSequence_5
   \   0000002E   0x2C04             CMP      R4,#+4
   \   00000030   0xD020             BEQ.N    ??NvFlashCommandSequence_6
   \   00000032   0xD31A             BCC.N    ??NvFlashCommandSequence_7
   \   00000034   0x2C06             CMP      R4,#+6
   \   00000036   0xD027             BEQ.N    ??NvFlashCommandSequence_8
   \   00000038   0xD321             BCC.N    ??NvFlashCommandSequence_9
   \   0000003A   0x2C08             CMP      R4,#+8
   \   0000003C   0xD02E             BEQ.N    ??NvFlashCommandSequence_10
   \   0000003E   0xD328             BCC.N    ??NvFlashCommandSequence_11
   \   00000040   0x2C0A             CMP      R4,#+10
   \   00000042   0xD035             BEQ.N    ??NvFlashCommandSequence_12
   \   00000044   0xD32F             BCC.N    ??NvFlashCommandSequence_13
   \   00000046   0x2C0B             CMP      R4,#+11
   \   00000048   0xD037             BEQ.N    ??NvFlashCommandSequence_14
   \   0000004A   0xE03B             B.N      ??NvFlashCommandSequence_15
    132                  {
    133                  case 0: gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB0_OFFSET_c, pCommandArray[counter]);
   \                     ??NvFlashCommandSequence_3: (+1)
   \   0000004C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004E   0x5CA6             LDRB     R6,[R4, R2]
   \   00000050   0x681F             LDR      R7,[R3, #+0]
   \   00000052   0x71FE             STRB     R6,[R7, #+7]
    134                  break;
   \   00000054   0xE036             B.N      ??NvFlashCommandSequence_16
    135                  case 1: gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB1_OFFSET_c, pCommandArray[counter]);
   \                     ??NvFlashCommandSequence_5: (+1)
   \   00000056   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000058   0x5CA6             LDRB     R6,[R4, R2]
   \   0000005A   0x681F             LDR      R7,[R3, #+0]
   \   0000005C   0x71BE             STRB     R6,[R7, #+6]
    136                  break;
   \   0000005E   0xE031             B.N      ??NvFlashCommandSequence_16
    137                  case 2: gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB2_OFFSET_c, pCommandArray[counter]);
   \                     ??NvFlashCommandSequence_4: (+1)
   \   00000060   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000062   0x5CA6             LDRB     R6,[R4, R2]
   \   00000064   0x681F             LDR      R7,[R3, #+0]
   \   00000066   0x717E             STRB     R6,[R7, #+5]
    138                  break;
   \   00000068   0xE02C             B.N      ??NvFlashCommandSequence_16
    139                  case 3: gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB3_OFFSET_c, pCommandArray[counter]);
   \                     ??NvFlashCommandSequence_7: (+1)
   \   0000006A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006C   0x5CA6             LDRB     R6,[R4, R2]
   \   0000006E   0x681F             LDR      R7,[R3, #+0]
   \   00000070   0x713E             STRB     R6,[R7, #+4]
    140                  break;
   \   00000072   0xE027             B.N      ??NvFlashCommandSequence_16
    141                  case 4: gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB4_OFFSET_c, pCommandArray[counter]);
   \                     ??NvFlashCommandSequence_6: (+1)
   \   00000074   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000076   0x5CA6             LDRB     R6,[R4, R2]
   \   00000078   0x681F             LDR      R7,[R3, #+0]
   \   0000007A   0x72FE             STRB     R6,[R7, #+11]
    142                  break;
   \   0000007C   0xE022             B.N      ??NvFlashCommandSequence_16
    143                  case 5: gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB5_OFFSET_c, pCommandArray[counter]);
   \                     ??NvFlashCommandSequence_9: (+1)
   \   0000007E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000080   0x5CA6             LDRB     R6,[R4, R2]
   \   00000082   0x681F             LDR      R7,[R3, #+0]
   \   00000084   0x72BE             STRB     R6,[R7, #+10]
    144                  break;
   \   00000086   0xE01D             B.N      ??NvFlashCommandSequence_16
    145                  case 6: gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB6_OFFSET_c, pCommandArray[counter]);
   \                     ??NvFlashCommandSequence_8: (+1)
   \   00000088   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000008A   0x5CA6             LDRB     R6,[R4, R2]
   \   0000008C   0x681F             LDR      R7,[R3, #+0]
   \   0000008E   0x727E             STRB     R6,[R7, #+9]
    146                  break;
   \   00000090   0xE018             B.N      ??NvFlashCommandSequence_16
    147                  case 7: gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB7_OFFSET_c, pCommandArray[counter]);
   \                     ??NvFlashCommandSequence_11: (+1)
   \   00000092   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000094   0x5CA6             LDRB     R6,[R4, R2]
   \   00000096   0x681F             LDR      R7,[R3, #+0]
   \   00000098   0x723E             STRB     R6,[R7, #+8]
    148                  break;
   \   0000009A   0xE013             B.N      ??NvFlashCommandSequence_16
    149                  case 8: gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB8_OFFSET_c, pCommandArray[counter]);
   \                     ??NvFlashCommandSequence_10: (+1)
   \   0000009C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009E   0x5CA6             LDRB     R6,[R4, R2]
   \   000000A0   0x681F             LDR      R7,[R3, #+0]
   \   000000A2   0x73FE             STRB     R6,[R7, #+15]
    150                  break;
   \   000000A4   0xE00E             B.N      ??NvFlashCommandSequence_16
    151                  case 9: gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB9_OFFSET_c, pCommandArray[counter]);
   \                     ??NvFlashCommandSequence_13: (+1)
   \   000000A6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A8   0x5CA6             LDRB     R6,[R4, R2]
   \   000000AA   0x681F             LDR      R7,[R3, #+0]
   \   000000AC   0x73BE             STRB     R6,[R7, #+14]
    152                  break;
   \   000000AE   0xE009             B.N      ??NvFlashCommandSequence_16
    153                  case 10: gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOBA_OFFSET_c, pCommandArray[counter]);
   \                     ??NvFlashCommandSequence_12: (+1)
   \   000000B0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B2   0x5CA6             LDRB     R6,[R4, R2]
   \   000000B4   0x681F             LDR      R7,[R3, #+0]
   \   000000B6   0x737E             STRB     R6,[R7, #+13]
    154                  break;
   \   000000B8   0xE004             B.N      ??NvFlashCommandSequence_16
    155                  case 11: gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOBB_OFFSET_c, pCommandArray[counter]);
   \                     ??NvFlashCommandSequence_14: (+1)
   \   000000BA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BC   0x5CA6             LDRB     R6,[R4, R2]
   \   000000BE   0x681F             LDR      R7,[R3, #+0]
   \   000000C0   0x733E             STRB     R6,[R7, #+12]
    156                  break;
   \   000000C2   0xE7FF             B.N      ??NvFlashCommandSequence_16
    157                  default: break;
    158                  }
    159              }
   \                     ??NvFlashCommandSequence_15: (+1)
   \                     ??NvFlashCommandSequence_16: (+1)
   \   000000C4   0x1C64             ADDS     R4,R4,#+1
   \   000000C6   0xE7A8             B.N      ??NvFlashCommandSequence_1
    160          #if gNvDisableIntCmdSeq_c    
    161                /* disable interrupts */
    162                iRet = IntDisableAll();   
    163          #endif
    164          
    165              /* clear CCIF bit */
    166              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c);
   \                     ??NvFlashCommandSequence_2: (+1)
   \   000000C8   0x2680             MOVS     R6,#+128
   \   000000CA   0x681F             LDR      R7,[R3, #+0]
   \   000000CC   0x703E             STRB     R6,[R7, #+0]
    167          
    168              /* check CCIF bit */
    169              while(FALSE == (gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c)))
   \                     ??NvFlashCommandSequence_17: (+1)
   \   000000CE   0x681E             LDR      R6,[R3, #+0]
   \   000000D0   0x7836             LDRB     R6,[R6, #+0]
   \   000000D2   0x0636             LSLS     R6,R6,#+24
   \   000000D4   0xD5FB             BPL.N    ??NvFlashCommandSequence_17
    170              {
    171                  /* wait till CCIF bit is set */
    172              }
    173              
    174          #if gNvDisableIntCmdSeq_c
    175                /* enable interrupts */
    176                IntRestoreAll(iRet);  
    177          #endif
    178          
    179              /* Check error bits */
    180          
    181              /* Get flash status register value */
    182              registerValue = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c);
   \   000000D6   0x681E             LDR      R6,[R3, #+0]
   \   000000D8   0x7836             LDRB     R6,[R6, #+0]
   \   000000DA   0x0035             MOVS     R5,R6
    183          
    184              /* checking access error */
    185              if(0 != (registerValue & gNV_FSTAT_ACCERR_c))
   \   000000DC   0x06AE             LSLS     R6,R5,#+26
   \   000000DE   0xD502             BPL.N    ??NvFlashCommandSequence_18
    186              {
    187                  /* return an error code gNV_ERR_ACCERR_c */
    188                  returnCode = gNV_ERR_ACCERR_c;
   \   000000E0   0x2604             MOVS     R6,#+4
   \   000000E2   0x0030             MOVS     R0,R6
   \   000000E4   0xE008             B.N      ??NvFlashCommandSequence_19
    189              }
    190              /* checking protection error */
    191              else if(0 != (registerValue & gNV_FSTAT_FPVIOL_c))
   \                     ??NvFlashCommandSequence_18: (+1)
   \   000000E6   0x06EE             LSLS     R6,R5,#+27
   \   000000E8   0xD502             BPL.N    ??NvFlashCommandSequence_20
    192              {
    193                  /* return an error code gNV_ERR_PVIOL_c */
    194                  returnCode = gNV_ERR_PVIOL_c;
   \   000000EA   0x2608             MOVS     R6,#+8
   \   000000EC   0x0030             MOVS     R0,R6
   \   000000EE   0xE003             B.N      ??NvFlashCommandSequence_19
    195              }
    196              /* checking MGSTAT0 non-correctable error */
    197              else if(0 != (registerValue & gNV_FSTAT_MGSTAT0_c))
   \                     ??NvFlashCommandSequence_20: (+1)
   \   000000F0   0x07EE             LSLS     R6,R5,#+31
   \   000000F2   0xD501             BPL.N    ??NvFlashCommandSequence_19
    198              {
    199                  /* return an error code gNV_ERR_MGSTAT0_c */
    200                  returnCode = gNV_ERR_MGSTAT0_c;
   \   000000F4   0x2610             MOVS     R6,#+16
   \   000000F6   0x0030             MOVS     R0,R6
    201              }
    202          
    203              return(returnCode);
   \                     ??NvFlashCommandSequence_19: (+1)
   \   000000F8   0xBCF0             POP      {R4-R7}
   \   000000FA   0x4770             BX       LR               ;; return
    204          }
    205          
    206          
    207          /*****************************************************************************
    208           *****************************************************************************
    209           * Public functions
    210           *****************************************************************************
    211           *****************************************************************************/
    212          
    213          /************************************************************************
    214           *
    215           *  Function Name    : NV_FlashInit
    216           *  Description      : Initialize the Flash memory controller (FTFL)
    217           *  Arguments        : [IN] pConfig - pointer to NV configuration
    218           *  Return Value     : -
    219           *
    220           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    221          void NV_FlashInit
    222          (
    223                  pNvConfig_t pConfig
    224          )
    225          {
    226          #if (gNV_DEBLOCK_SIZE_c != 0)
    227              uint8_t  EEEDataSetSize;     /* store EEE Data Set Size */
    228              uint8_t  DEPartitionCode;    /* store D/E-Flash Partition Code */
    229          #endif
    230          
    231              /* set the flash clock */
    232              gFTFL_SIM_CLKDIV_c |= gSIM_CLKDIV_OUTDIV(gCLKDIV_VALUE_c);
   \                     NV_FlashInit: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable2  ;; 0x40048044
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable2  ;; 0x40048044
   \   0000000A   0x6011             STR      R1,[R2, #+0]
    233              /* enable clock gating for the FTFL module */
    234              gFTFL_SIM_SCGC_c |= gSIM_SCGC_FTFL_MASK_c;
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable2_1  ;; 0x4004803c
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000016   0x.... 0x....      LDR.W    R2,??DataTable2_1  ;; 0x4004803c
   \   0000001A   0x6011             STR      R1,[R2, #+0]
    235          
    236          #if (gNV_DEBLOCK_SIZE_c != 0)
    237              /* check CCIF bit of the flash status register */
    238              while(FALSE == (gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c)))
    239              {
    240                  /* wait till CCIF bit is set */
    241              }
    242          
    243              /* clear RDCOLERR & ACCERR & FPVIOL flag in flash status register */
    244              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, \
    245                      (gNV_FSTAT_RDCOLERR_c | gNV_FSTAT_ACCERR_c | gNV_FSTAT_FPVIOL_c));
    246          
    247              /* Write Command Code to FCCOB0 */
    248              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB0_OFFSET_c, gNV_READ_RESOURCE_c);
    249              /* Write address to FCCOB1/2/3 */
    250              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB1_OFFSET_c, ((uint8_t)(gNV_DFLASH_IFR_READRESOURCE_ADDRESS_c >> 16)));
    251              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB2_OFFSET_c, ((uint8_t)((gNV_DFLASH_IFR_READRESOURCE_ADDRESS_c >> 8) & 0xFF)));
    252              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB3_OFFSET_c, ((uint8_t)(gNV_DFLASH_IFR_READRESOURCE_ADDRESS_c & 0xFF)));
    253          
    254              /* Write Resource Select Code of 0 to FCCOB8 to select IFR. Without this, */
    255              /* an access error may occur if the register contains data from a previous command. */
    256          #if (gNV_512K_512K_16K_4K_4K_c == gNV_Derivative_c)
    257              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB4_OFFSET_c, 0);
    258          #else
    259              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB8_OFFSET_c, 0);
    260          #endif
    261              /* clear CCIF bit */
    262              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c);
    263          
    264              /* check CCIF bit */
    265              while((gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c)) == FALSE)
    266              {
    267                  /* wait till CCIF bit is set */
    268              }
    269          
    270              /* Read returned value of FCCOB6/7 or FCCOBA,B to the variables */
    271          #if (gNV_512K_512K_16K_4K_4K_c == gNV_Derivative_c)
    272              EEEDataSetSize = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOBA_OFFSET_c);
    273              DEPartitionCode = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOBB_OFFSET_c);
    274          #else
    275              EEEDataSetSize = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB6_OFFSET_c);
    276              DEPartitionCode = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB7_OFFSET_c);
    277          #endif
    278              /* Calculate D-Flash size and EEE size */
    279              switch (DEPartitionCode & 0x0F)
    280              {
    281              case 0: pConfig->DFlashBlockSize = gNV_DEPART_0000_c; break;
    282              case 1: pConfig->DFlashBlockSize = gNV_DEPART_0001_c; break;
    283              case 2: pConfig->DFlashBlockSize = gNV_DEPART_0010_c; break;
    284              case 3: pConfig->DFlashBlockSize = gNV_DEPART_0011_c; break;
    285              case 4: pConfig->DFlashBlockSize = gNV_DEPART_0100_c; break;
    286              case 5: pConfig->DFlashBlockSize = gNV_DEPART_0101_c; break;
    287              case 6: pConfig->DFlashBlockSize = gNV_DEPART_0110_c; break;
    288              case 7: pConfig->DFlashBlockSize = gNV_DEPART_0111_c; break;
    289              case 8: pConfig->DFlashBlockSize = gNV_DEPART_1000_c; break;
    290              case 9: pConfig->DFlashBlockSize = gNV_DEPART_1001_c; break;
    291              case 10: pConfig->DFlashBlockSize = gNV_DEPART_1010_c; break;
    292              case 11: pConfig->DFlashBlockSize = gNV_DEPART_1011_c; break;
    293              case 12: pConfig->DFlashBlockSize = gNV_DEPART_1100_c; break;
    294              case 13: pConfig->DFlashBlockSize = gNV_DEPART_1101_c; break;
    295              case 14: pConfig->DFlashBlockSize = gNV_DEPART_1110_c; break;
    296              case 15: pConfig->DFlashBlockSize = gNV_DEPART_1111_c; break;
    297              default: break;
    298              }
    299          
    300              switch (EEEDataSetSize & 0x0F)
    301              {
    302              case 0: pConfig->EEEBlockSize = gNV_EEESIZE_0000_c; break;
    303              case 1: pConfig->EEEBlockSize = gNV_EEESIZE_0001_c; break;
    304              case 2: pConfig->EEEBlockSize = gNV_EEESIZE_0010_c; break;
    305              case 3: pConfig->EEEBlockSize = gNV_EEESIZE_0011_c; break;
    306              case 4: pConfig->EEEBlockSize = gNV_EEESIZE_0100_c; break;
    307              case 5: pConfig->EEEBlockSize = gNV_EEESIZE_0101_c; break;
    308              case 6: pConfig->EEEBlockSize = gNV_EEESIZE_0110_c; break;
    309              case 7: pConfig->EEEBlockSize = gNV_EEESIZE_0111_c; break;
    310              case 8: pConfig->EEEBlockSize = gNV_EEESIZE_1000_c; break;
    311              case 9: pConfig->EEEBlockSize = gNV_EEESIZE_1001_c; break;
    312              case 10: pConfig->EEEBlockSize = gNV_EEESIZE_1010_c; break;
    313              case 11: pConfig->EEEBlockSize = gNV_EEESIZE_1011_c; break;
    314              case 12: pConfig->EEEBlockSize = gNV_EEESIZE_1100_c; break;
    315              case 13: pConfig->EEEBlockSize = gNV_EEESIZE_1101_c; break;
    316              case 14: pConfig->EEEBlockSize = gNV_EEESIZE_1110_c; break;
    317              case 15: pConfig->EEEBlockSize = gNV_EEESIZE_1111_c; break;
    318              default: break;
    319              }
    320          #else /* gNV_DEBLOCK_SIZE_c == 0 */
    321          /* If size of D/E-Flash = 0 */
    322              pConfig->DFlashBlockSize = 0;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x6101             STR      R1,[R0, #+16]
    323              pConfig->EEEBlockSize = 0;
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x61C1             STR      R1,[R0, #+28]
    324          #endif /* of gNV_DEBLOCK_SIZE_c */
    325          }
   \   00000024   0x4770             BX       LR               ;; return
    326          
    327          
    328          /************************************************************************
    329           *
    330           *  Function Name    : NV_DEFlashPartition
    331           *  Description      : This function prepares the D/E-Flash block for use
    332           *                     as D-Flash, E-Flash or a combination of both and
    333           *                     initializes the EERAM.
    334           *  Arguments        : [IN] pConfig - pointer to NV configuration
    335           *                   : [IN] EEEDataSizeCode - EEPROM data set size code
    336           *                   : [IN] DEPartitionCode - FlexNVM partition code
    337           *  Return Value     : see NV return codes
    338           *
    339           *************************************************************************/
    340          #if (defined(__IAR_SYSTEMS_ICC__))

   \                                 In section .textrw, align 2, keep-with-next
    341          __ramfunc uint32_t NV_DEFlashPartition
    342          (
    343                  pNvConfig_t pConfig,
    344                  uint8_t EEEDataSizeCode,
    345                  uint8_t DEPartitionCode
    346          )
    347          #else
    348          uint32_t NV_DEFlashPartition
    349          (
    350                  pNvConfig_t pConfig,
    351                  uint8_t EEEDataSizeCode,
    352                  uint8_t DEPartitionCode
    353          )
    354          #endif
    355          {
   \                     NV_DEFlashPartition: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0003             MOVS     R3,R0
    356              uint32_t returnCode;      /* return code variable */
    357              uint8_t registerValue;
    358          
    359              /* set the default return code as gNV_OK_c */
    360              returnCode = gNV_OK_c;
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0x0028             MOVS     R0,R5
    361          
    362              /* check CCIF bit of the flash status register */
    363              while(FALSE == (gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c)))
   \                     ??NV_DEFlashPartition_0: (+1)
   \   00000008   0x681D             LDR      R5,[R3, #+0]
   \   0000000A   0x782D             LDRB     R5,[R5, #+0]
   \   0000000C   0x062D             LSLS     R5,R5,#+24
   \   0000000E   0xD5FB             BPL.N    ??NV_DEFlashPartition_0
    364              {
    365                  /* wait till CCIF bit is set */
    366              };
    367          
    368              /* clear RDCOLERR & ACCERR & FPVIOL flag in flash status register */
    369              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, \
    370                      (gNV_FSTAT_RDCOLERR_c | gNV_FSTAT_ACCERR_c | gNV_FSTAT_FPVIOL_c));
   \   00000010   0x2570             MOVS     R5,#+112
   \   00000012   0x681E             LDR      R6,[R3, #+0]
   \   00000014   0x7035             STRB     R5,[R6, #+0]
    371          
    372              /* load the FCCOB registers */
    373              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB0_OFFSET_c, gNV_PROGRAM_PARTITION_c);
   \   00000016   0x2580             MOVS     R5,#+128
   \   00000018   0x681E             LDR      R6,[R3, #+0]
   \   0000001A   0x71F5             STRB     R5,[R6, #+7]
    374              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB1_OFFSET_c, 0);
   \   0000001C   0x2500             MOVS     R5,#+0
   \   0000001E   0x681E             LDR      R6,[R3, #+0]
   \   00000020   0x71B5             STRB     R5,[R6, #+6]
    375              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB2_OFFSET_c, 0);
   \   00000022   0x2500             MOVS     R5,#+0
   \   00000024   0x681E             LDR      R6,[R3, #+0]
   \   00000026   0x7175             STRB     R5,[R6, #+5]
    376              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB3_OFFSET_c, 0);
   \   00000028   0x2500             MOVS     R5,#+0
   \   0000002A   0x681E             LDR      R6,[R3, #+0]
   \   0000002C   0x7135             STRB     R5,[R6, #+4]
    377              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB4_OFFSET_c, EEEDataSizeCode);
   \   0000002E   0x681D             LDR      R5,[R3, #+0]
   \   00000030   0x72E9             STRB     R1,[R5, #+11]
    378              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB5_OFFSET_c, DEPartitionCode);
   \   00000032   0x681D             LDR      R5,[R3, #+0]
   \   00000034   0x72AA             STRB     R2,[R5, #+10]
    379          
    380              /* clear CCIF bit */
    381              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c);
   \   00000036   0x2580             MOVS     R5,#+128
   \   00000038   0x681E             LDR      R6,[R3, #+0]
   \   0000003A   0x7035             STRB     R5,[R6, #+0]
    382          
    383              /* check CCIF bit */
    384              while(FALSE == (gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c)))
   \                     ??NV_DEFlashPartition_1: (+1)
   \   0000003C   0x681D             LDR      R5,[R3, #+0]
   \   0000003E   0x782D             LDRB     R5,[R5, #+0]
   \   00000040   0x062D             LSLS     R5,R5,#+24
   \   00000042   0xD5FB             BPL.N    ??NV_DEFlashPartition_1
    385              {
    386                  /* wait till CCIF bit is set */
    387              };
    388          
    389              /* Check error bits */
    390              /* Get flash status register value */
    391              registerValue = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c);
   \   00000044   0x681D             LDR      R5,[R3, #+0]
   \   00000046   0x782D             LDRB     R5,[R5, #+0]
   \   00000048   0x002C             MOVS     R4,R5
    392          
    393              /* checking access error */
    394              if(0 != (registerValue & gNV_FSTAT_ACCERR_c))
   \   0000004A   0x06A5             LSLS     R5,R4,#+26
   \   0000004C   0xD502             BPL.N    ??NV_DEFlashPartition_2
    395              {
    396                  /* return an error code gNV_ERR_ACCERR_c */
    397                  returnCode = gNV_ERR_ACCERR_c;
   \   0000004E   0x2504             MOVS     R5,#+4
   \   00000050   0x0028             MOVS     R0,R5
   \   00000052   0xE008             B.N      ??NV_DEFlashPartition_3
    398              }
    399              /* checking protection error */
    400              else if(0 != (registerValue & gNV_FSTAT_FPVIOL_c))
   \                     ??NV_DEFlashPartition_2: (+1)
   \   00000054   0x06E5             LSLS     R5,R4,#+27
   \   00000056   0xD502             BPL.N    ??NV_DEFlashPartition_4
    401              {
    402                  /* return an error code gNV_ERR_PVIOL_c */
    403                  returnCode = gNV_ERR_PVIOL_c;
   \   00000058   0x2508             MOVS     R5,#+8
   \   0000005A   0x0028             MOVS     R0,R5
   \   0000005C   0xE003             B.N      ??NV_DEFlashPartition_3
    404              }
    405              /* checking MGSTAT0 non-correctable error */
    406              else if(0 != (registerValue & gNV_FSTAT_MGSTAT0_c))
   \                     ??NV_DEFlashPartition_4: (+1)
   \   0000005E   0x07E5             LSLS     R5,R4,#+31
   \   00000060   0xD501             BPL.N    ??NV_DEFlashPartition_3
    407              {
    408                  /* return an error code gNV_ERR_MGSTAT0_c */
    409                  returnCode = gNV_ERR_MGSTAT0_c;
   \   00000062   0x2510             MOVS     R5,#+16
   \   00000064   0x0028             MOVS     R0,R5
    410              }
    411          
    412              return(returnCode);
   \                     ??NV_DEFlashPartition_3: (+1)
   \   00000066   0xBC70             POP      {R4-R6}
   \   00000068   0x4770             BX       LR               ;; return
    413          }
    414          
    415          
    416          /*************************************************************************
    417           *
    418           *  Function Name    : NV_DFlashGetProtection
    419           *  Description      : This function retrieves current D-Flash protection status.
    420           *  Arguments        : [IN] pConfig - pointer to NV configuration
    421           *                   : [OUT] protectStatus - pointer to a memory location where
    422           *                                           the protection status will be stored.
    423           *  Return Value     : uint32_t
    424           *
    425           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    426          uint32_t NV_DFlashGetProtection
    427          (
    428                  pNvConfig_t pConfig,
    429                  uint8_t* protectStatus
    430          )
    431          {
   \                     NV_DFlashGetProtection: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    432              /* Check if size of DFlash = 0 */
    433              if(pConfig->DFlashBlockSize == 0)
   \   00000002   0x6910             LDR      R0,[R2, #+16]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD102             BNE.N    ??NV_DFlashGetProtection_0
    434              {
    435                  return(gNV_ERR_EFLASHONLY_c);
   \   00000008   0xF44F 0x6080      MOV      R0,#+1024
   \   0000000C   0xE003             B.N      ??NV_DFlashGetProtection_1
    436              }
    437          
    438              *protectStatus = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FDPROT_OFFSET_c);
   \                     ??NV_DFlashGetProtection_0: (+1)
   \   0000000E   0x6810             LDR      R0,[R2, #+0]
   \   00000010   0x7DC0             LDRB     R0,[R0, #+23]
   \   00000012   0x7008             STRB     R0,[R1, #+0]
    439          
    440              return(gNV_OK_c);
   \   00000014   0x2000             MOVS     R0,#+0
   \                     ??NV_DFlashGetProtection_1: (+1)
   \   00000016   0x4770             BX       LR               ;; return
    441          }
    442          
    443          
    444          /************************************************************************
    445           *
    446           *  Function Name    : NV_DFlashSetProtection
    447           *  Description      : This function sets the D-Flash protection to the
    448           *                     intended protection status
    449           *  Arguments        : [IN] pConfig - pointer to NV configuration
    450           *                     [IN] protectStatus - protection status to be set
    451           *  Return Value     : uint32_t
    452           *
    453           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    454          uint32_t NV_DFlashSetProtection
    455          (
    456                  pNvConfig_t pConfig,
    457                  uint8_t protectStatus
    458          )
    459          {
   \                     NV_DFlashSetProtection: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
    460              uint8_t  registerValue;    /* store data read from flash register */
    461              uint8_t  temp;
    462          
    463              /* check CCIF bit of the flash status register, it's impossible to write to DPROT if command is in progress */
    464              if(FALSE == (gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c)))
   \   00000004   0x6810             LDR      R0,[R2, #+0]
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x0600             LSLS     R0,R0,#+24
   \   0000000A   0xD401             BMI.N    ??NV_DFlashSetProtection_0
    465              {
    466                  return(gNV_ERR_CHANGEPROT_c);
   \   0000000C   0x2020             MOVS     R0,#+32
   \   0000000E   0xE01F             B.N      ??NV_DFlashSetProtection_1
    467              }
    468              /* Check if size of DFlash = 0 */
    469              if(pConfig->DFlashBlockSize == 0)
   \                     ??NV_DFlashSetProtection_0: (+1)
   \   00000010   0x6910             LDR      R0,[R2, #+16]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD102             BNE.N    ??NV_DFlashSetProtection_2
    470              {
    471                  return(gNV_ERR_EFLASHONLY_c);
   \   00000016   0xF44F 0x6080      MOV      R0,#+1024
   \   0000001A   0xE019             B.N      ??NV_DFlashSetProtection_1
    472              }
    473          
    474              /* Read the value of FDPROT register */
    475              registerValue = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FDPROT_OFFSET_c);
   \                     ??NV_DFlashSetProtection_2: (+1)
   \   0000001C   0x6810             LDR      R0,[R2, #+0]
   \   0000001E   0x7DC0             LDRB     R0,[R0, #+23]
   \   00000020   0x0003             MOVS     R3,R0
    476          
    477              /* Check if normal mode */
    478              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FDPROT_OFFSET_c, 0xFF);
   \   00000022   0x20FF             MOVS     R0,#+255
   \   00000024   0x6815             LDR      R5,[R2, #+0]
   \   00000026   0x75E8             STRB     R0,[R5, #+23]
    479          
    480              if(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FDPROT_OFFSET_c) != 0xFF)
   \   00000028   0x6810             LDR      R0,[R2, #+0]
   \   0000002A   0x7DC0             LDRB     R0,[R0, #+23]
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x28FF             CMP      R0,#+255
   \   00000030   0xD00B             BEQ.N    ??NV_DFlashSetProtection_3
    481              {
    482                  /* if normal mode */
    483                  temp = (uint8_t)(protectStatus ^ registerValue);
   \   00000032   0xEA93 0x0001      EORS     R0,R3,R1
   \   00000036   0x0004             MOVS     R4,R0
    484                  if(!(temp & protectStatus))
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x4208             TST      R0,R1
   \   0000003E   0xD102             BNE.N    ??NV_DFlashSetProtection_4
    485                  {
    486                      gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FDPROT_OFFSET_c, protectStatus);
   \   00000040   0x6810             LDR      R0,[R2, #+0]
   \   00000042   0x75C1             STRB     R1,[R0, #+23]
   \   00000044   0xE001             B.N      ??NV_DFlashSetProtection_3
    487                  }
    488                  else
    489                  {
    490                      return(gNV_ERR_CHANGEPROT_c);
   \                     ??NV_DFlashSetProtection_4: (+1)
   \   00000046   0x2020             MOVS     R0,#+32
   \   00000048   0xE002             B.N      ??NV_DFlashSetProtection_1
    491                  }
    492              }
    493              /* if unprotected or special mode */
    494              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FDPROT_OFFSET_c, protectStatus);
   \                     ??NV_DFlashSetProtection_3: (+1)
   \   0000004A   0x6810             LDR      R0,[R2, #+0]
   \   0000004C   0x75C1             STRB     R1,[R0, #+23]
    495          
    496              return(gNV_OK_c);
   \   0000004E   0x2000             MOVS     R0,#+0
   \                     ??NV_DFlashSetProtection_1: (+1)
   \   00000050   0xBC30             POP      {R4,R5}
   \   00000052   0x4770             BX       LR               ;; return
    497          }
    498          
    499          
    500          /************************************************************************
    501           *
    502           *  Function Name    : NV_EEEWrite
    503           *  Description      : This function is used to write data to EERAM
    504           *                     when it is used as EEPROM emulator
    505           *  Arguments        : [IN] pConfig - pointer to NV configuration
    506           *                     [IN] source - source address
    507           *                     [IN] destination - EERAM destination address
    508           *                     [IN] size - how many bytes to be written
    509           *
    510           *  Return Value     : uint32_t
    511           *
    512           ************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    513          uint32_t NV_EEEWrite
    514          (
    515                  pNvConfig_t pConfig,
    516                  uint32_t source,
    517                  uint32_t destination,
    518                  uint32_t size
    519          )
    520          {
   \                     NV_EEEWrite: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0004             MOVS     R4,R0
    521              uint32_t returnCode;           /* Return code variable */
    522              /* set the default return code as gNV_OK_c */
    523              returnCode = gNV_OK_c;
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0x0028             MOVS     R0,R5
    524              /* Check if EEE is enabled */
    525              if(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCNFG_OFFSET_c) & gNV_FCNFG_EEERDY_c)
   \   00000008   0x6825             LDR      R5,[R4, #+0]
   \   0000000A   0x786D             LDRB     R5,[R5, #+1]
   \   0000000C   0x07ED             LSLS     R5,R5,#+31
   \   0000000E   0xD51E             BPL.N    ??NV_EEEWrite_0
    526              {
    527                  if(destination < pConfig->EERAMBlockBase || \
    528                          ((destination + size) > (pConfig->EERAMBlockBase + pConfig->EEEBlockSize)))
   \   00000010   0x6965             LDR      R5,[R4, #+20]
   \   00000012   0x42AA             CMP      R2,R5
   \   00000014   0xD305             BCC.N    ??NV_EEEWrite_1
   \   00000016   0x6965             LDR      R5,[R4, #+20]
   \   00000018   0x69E6             LDR      R6,[R4, #+28]
   \   0000001A   0x1975             ADDS     R5,R6,R5
   \   0000001C   0x189E             ADDS     R6,R3,R2
   \   0000001E   0x42B5             CMP      R5,R6
   \   00000020   0xD202             BCS.N    ??NV_EEEWrite_2
    529                  {
    530                      returnCode = gNV_ERR_RANGE_c;
   \                     ??NV_EEEWrite_1: (+1)
   \   00000022   0x2502             MOVS     R5,#+2
   \   00000024   0x0028             MOVS     R0,R5
   \   00000026   0xE015             B.N      ??NV_EEEWrite_3
    531                  }
    532                  else
    533                  {
    534                      while(size > 0)
   \                     ??NV_EEEWrite_2: (+1)
   \   00000028   0x2B00             CMP      R3,#+0
   \   0000002A   0xD013             BEQ.N    ??NV_EEEWrite_3
    535                      {
    536                          while(FALSE == gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FCNFG_OFFSET_c, gNV_FCNFG_EEERDY_c))
   \                     ??NV_EEEWrite_4: (+1)
   \   0000002C   0x6825             LDR      R5,[R4, #+0]
   \   0000002E   0x786D             LDRB     R5,[R5, #+1]
   \   00000030   0x07ED             LSLS     R5,R5,#+31
   \   00000032   0xD5FB             BPL.N    ??NV_EEEWrite_4
    537                          {
    538                              /* wait till EEERDY bit is set */
    539                          }
    540                          gNV_WRITE8(destination,gNV_READ8(source));
   \   00000034   0x780D             LDRB     R5,[R1, #+0]
   \   00000036   0x7015             STRB     R5,[R2, #+0]
    541          
    542                          /* Check for protection violation error */
    543                          if(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c) & gNV_FSTAT_FPVIOL_c)
   \   00000038   0x6825             LDR      R5,[R4, #+0]
   \   0000003A   0x782D             LDRB     R5,[R5, #+0]
   \   0000003C   0x06ED             LSLS     R5,R5,#+27
   \   0000003E   0xD502             BPL.N    ??NV_EEEWrite_5
    544                          {
    545                              returnCode = gNV_ERR_PVIOL_c;
   \   00000040   0x2508             MOVS     R5,#+8
   \   00000042   0x0028             MOVS     R0,R5
    546                              break;
   \   00000044   0xE006             B.N      ??NV_EEEWrite_3
    547                          }
    548          
    549                          /* update destination address for next iteration */
    550                          destination += 1;
   \                     ??NV_EEEWrite_5: (+1)
   \   00000046   0x1C52             ADDS     R2,R2,#+1
    551                          /* update size for next iteration */
    552                          size -= 1;
   \   00000048   0x1E5B             SUBS     R3,R3,#+1
    553                          /* increment the source address by 1 */
    554                          source += 1;
   \   0000004A   0x1C49             ADDS     R1,R1,#+1
   \   0000004C   0xE7EC             B.N      ??NV_EEEWrite_2
    555                      }
    556                  }
    557              }
    558              else
    559              {
    560                  returnCode = gNV_ERR_NOEEE_c;
   \                     ??NV_EEEWrite_0: (+1)
   \   0000004E   0xF44F 0x7500      MOV      R5,#+512
   \   00000052   0x0028             MOVS     R0,R5
    561              }
    562          
    563              return(returnCode);
   \                     ??NV_EEEWrite_3: (+1)
   \   00000054   0xBC70             POP      {R4-R6}
   \   00000056   0x4770             BX       LR               ;; return
    564          }
    565          
    566          
    567          /************************************************************************
    568           *
    569           *  Function Name    : NV_EERAMGetProtection.c
    570           *  Description      : This function retrieves current EERAM protection status.
    571           *  Arguments        : [IN] pConfig - pointer to NV configuration
    572           *                     [IN] protectStatus - current protection status
    573           *  Return Value     : uint32_t
    574           *
    575           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    576          uint32_t NV_EERAMGetProtection
    577          (
    578                  pNvConfig_t pConfig,
    579                  uint8_t* protectStatus
    580          )
    581          {
   \                     NV_EERAMGetProtection: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    582              /* Check if EERAM is set for EEE */
    583              if(gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FCNFG_OFFSET_c, gNV_FCNFG_EEERDY_c))
   \   00000002   0x6810             LDR      R0,[R2, #+0]
   \   00000004   0x7840             LDRB     R0,[R0, #+1]
   \   00000006   0x07C0             LSLS     R0,R0,#+31
   \   00000008   0xD504             BPL.N    ??NV_EERAMGetProtection_0
    584              {
    585                  /* EERAM is set for EEE */
    586                  *protectStatus = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FEPROT_OFFSET_c);
   \   0000000A   0x6810             LDR      R0,[R2, #+0]
   \   0000000C   0x7D80             LDRB     R0,[R0, #+22]
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
    587              }
    588              else
    589              {
    590                  return(gNV_ERR_NOEEE_c);
    591              }
    592          
    593              return(gNV_OK_c);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE001             B.N      ??NV_EERAMGetProtection_1
   \                     ??NV_EERAMGetProtection_0: (+1)
   \   00000014   0xF44F 0x7000      MOV      R0,#+512
   \                     ??NV_EERAMGetProtection_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    594          }
    595          
    596          
    597          /************************************************************************
    598           *
    599           *  Function Name    : NV_EERAMSetProtection
    600           *  Description      : This function sets EERAM protection status.
    601           *  Arguments        : [IN] pConfig - pointer to NV configuration
    602           *                     [IN] protectStatus - protection status to be set
    603           *  Return Value     : uint32_t
    604           *
    605           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    606          uint32_t NV_EERAMSetProtection
    607          (
    608                  pNvConfig_t pConfig,
    609                  uint8_t protectStatus
    610          )
    611          {
   \                     NV_EERAMSetProtection: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0002             MOVS     R2,R0
    612              uint8_t  registerValue;    /* store data read from flash register */
    613              uint32_t returnCode;       /* return code variable */
    614              uint8_t  temp;
    615          
    616              /* set the default return as gNV_OK_c */
    617              returnCode = gNV_OK_c;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0004             MOVS     R4,R0
    618          
    619              /* check CCIF bit of the flash status register, it's impossible to write to FEPROT if command is in progress */
    620              if(FALSE == (gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c)))
   \   00000008   0x6810             LDR      R0,[R2, #+0]
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x0600             LSLS     R0,R0,#+24
   \   0000000E   0xD401             BMI.N    ??NV_EERAMSetProtection_0
    621              {
    622                  return(gNV_ERR_CHANGEPROT_c);
   \   00000010   0x2020             MOVS     R0,#+32
   \   00000012   0xE022             B.N      ??NV_EERAMSetProtection_1
    623          
    624              }
    625              /* Check if EERAM is set for EEE */
    626              if(!(gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FCNFG_OFFSET_c, gNV_FCNFG_EEERDY_c)))
   \                     ??NV_EERAMSetProtection_0: (+1)
   \   00000014   0x6810             LDR      R0,[R2, #+0]
   \   00000016   0x7840             LDRB     R0,[R0, #+1]
   \   00000018   0x07C0             LSLS     R0,R0,#+31
   \   0000001A   0xD402             BMI.N    ??NV_EERAMSetProtection_2
    627              {
    628                  /* EERAM is not set for EEE */
    629                  return(gNV_ERR_NOEEE_c);
   \   0000001C   0xF44F 0x7000      MOV      R0,#+512
   \   00000020   0xE01B             B.N      ??NV_EERAMSetProtection_1
    630              }
    631          
    632              /* Read the value of FDPROT register */
    633              registerValue = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FEPROT_OFFSET_c);
   \                     ??NV_EERAMSetProtection_2: (+1)
   \   00000022   0x6810             LDR      R0,[R2, #+0]
   \   00000024   0x7D80             LDRB     R0,[R0, #+22]
   \   00000026   0x0003             MOVS     R3,R0
    634          
    635              /* Check if normal mode */
    636              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FEPROT_OFFSET_c, 0xFF);
   \   00000028   0x20FF             MOVS     R0,#+255
   \   0000002A   0x6816             LDR      R6,[R2, #+0]
   \   0000002C   0x75B0             STRB     R0,[R6, #+22]
    637          
    638              if(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FEPROT_OFFSET_c) != 0xFF)
   \   0000002E   0x6810             LDR      R0,[R2, #+0]
   \   00000030   0x7D80             LDRB     R0,[R0, #+22]
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x28FF             CMP      R0,#+255
   \   00000036   0xD00D             BEQ.N    ??NV_EERAMSetProtection_3
    639              {
    640                  /* if normal mode */
    641                  temp = (uint8_t)(protectStatus ^ registerValue);
   \   00000038   0xEA93 0x0001      EORS     R0,R3,R1
   \   0000003C   0x0005             MOVS     R5,R0
    642                  if(!(temp & protectStatus))
   \   0000003E   0x0028             MOVS     R0,R5
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0x4208             TST      R0,R1
   \   00000044   0xD102             BNE.N    ??NV_EERAMSetProtection_4
    643                  {
    644                      gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FEPROT_OFFSET_c, protectStatus);
   \   00000046   0x6810             LDR      R0,[R2, #+0]
   \   00000048   0x7581             STRB     R1,[R0, #+22]
   \   0000004A   0xE001             B.N      ??NV_EERAMSetProtection_5
    645                  }
    646                  else
    647                  {
    648                      returnCode = gNV_ERR_CHANGEPROT_c;
   \                     ??NV_EERAMSetProtection_4: (+1)
   \   0000004C   0x2020             MOVS     R0,#+32
   \   0000004E   0x0004             MOVS     R4,R0
    649                  }
    650                  return(returnCode);
   \                     ??NV_EERAMSetProtection_5: (+1)
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0xE002             B.N      ??NV_EERAMSetProtection_1
    651              }
    652              /* if unprotected or special mode */
    653              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FEPROT_OFFSET_c, protectStatus);
   \                     ??NV_EERAMSetProtection_3: (+1)
   \   00000054   0x6810             LDR      R0,[R2, #+0]
   \   00000056   0x7581             STRB     R1,[R0, #+22]
    654          
    655              return(returnCode);
   \   00000058   0x0020             MOVS     R0,R4
   \                     ??NV_EERAMSetProtection_1: (+1)
   \   0000005A   0xBC70             POP      {R4-R6}
   \   0000005C   0x4770             BX       LR               ;; return
    656          }
    657          
    658          
    659          /***********************************************************************
    660           *
    661           *  Function Name    : NV_FlashCheckSum
    662           *  Description      : This function is used to calculate checksum value
    663           *                     for the specified flash range.
    664           *  Arguments        : [IN] pConfig - pointer to NV configuration
    665           *                     [IN] destination - destination address
    666           *                     [IN] size - length of data
    667           *                     [OUT] pSum - pointer to the location where the
    668           *                                  calculated checksum will be place
    669           *  Return Value     : uint32_t
    670           *
    671           ************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    672          uint32_t NV_FlashCheckSum
    673          (
    674                  pNvConfig_t pConfig,
    675                  uint32_t destination,
    676                  uint32_t size,
    677                  uint32_t* pSum
    678          )
    679          {
   \                     NV_FlashCheckSum: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0004             MOVS     R4,R0
    680              uint32_t data;             /* Data read from Flash address */
    681              uint32_t endAddress;       /* P Flash end address */
    682          
    683              /* calculating Flash end address */
    684              endAddress = destination + size;
   \   00000004   0x1850             ADDS     R0,R2,R1
   \   00000006   0x0006             MOVS     R6,R0
    685          
    686              /* check for valid range of the target addresses */
    687              if((destination < pConfig->PFlashBlockBase) || \
    688                      (endAddress > (pConfig->PFlashBlockBase + pConfig->PFlashBlockSize)))
   \   00000008   0x6860             LDR      R0,[R4, #+4]
   \   0000000A   0x4281             CMP      R1,R0
   \   0000000C   0xD304             BCC.N    ??NV_FlashCheckSum_0
   \   0000000E   0x6860             LDR      R0,[R4, #+4]
   \   00000010   0x68A7             LDR      R7,[R4, #+8]
   \   00000012   0x1838             ADDS     R0,R7,R0
   \   00000014   0x42B0             CMP      R0,R6
   \   00000016   0xD209             BCS.N    ??NV_FlashCheckSum_1
    689              {
    690                  if((destination < pConfig->DFlashBlockBase) || \
    691                          (endAddress > (pConfig->DFlashBlockBase + pConfig->DFlashBlockSize)))
   \                     ??NV_FlashCheckSum_0: (+1)
   \   00000018   0x68E0             LDR      R0,[R4, #+12]
   \   0000001A   0x4281             CMP      R1,R0
   \   0000001C   0xD304             BCC.N    ??NV_FlashCheckSum_2
   \   0000001E   0x68E0             LDR      R0,[R4, #+12]
   \   00000020   0x6927             LDR      R7,[R4, #+16]
   \   00000022   0x1838             ADDS     R0,R7,R0
   \   00000024   0x42B0             CMP      R0,R6
   \   00000026   0xD201             BCS.N    ??NV_FlashCheckSum_1
    692                  {
    693                      /* return an error code gNV_ERR_RANGE_c */
    694                      return(gNV_ERR_RANGE_c);
   \                     ??NV_FlashCheckSum_2: (+1)
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xE00C             B.N      ??NV_FlashCheckSum_3
    695                  }
    696              }
    697          
    698              *pSum = 0;
   \                     ??NV_FlashCheckSum_1: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x6018             STR      R0,[R3, #+0]
    699              /* doing sum operation */
    700              while(destination < endAddress)
   \                     ??NV_FlashCheckSum_4: (+1)
   \   00000030   0x42B1             CMP      R1,R6
   \   00000032   0xD207             BCS.N    ??NV_FlashCheckSum_5
    701              {
    702                  data = gNV_READ8(destination);
   \   00000034   0x7808             LDRB     R0,[R1, #+0]
   \   00000036   0x0005             MOVS     R5,R0
    703                  *pSum += (uint32_t)data;
   \   00000038   0x6818             LDR      R0,[R3, #+0]
   \   0000003A   0x1828             ADDS     R0,R5,R0
   \   0000003C   0x6018             STR      R0,[R3, #+0]
    704                  destination += 1;
   \   0000003E   0x1C49             ADDS     R1,R1,#+1
    705                  size -= 1;
   \   00000040   0x1E52             SUBS     R2,R2,#+1
   \   00000042   0xE7F5             B.N      ??NV_FlashCheckSum_4
    706              }
    707          
    708              return(gNV_OK_c);
   \                     ??NV_FlashCheckSum_5: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \                     ??NV_FlashCheckSum_3: (+1)
   \   00000046   0xBCF0             POP      {R4-R7}
   \   00000048   0x4770             BX       LR               ;; return
    709          }
    710          
    711          
    712          /************************************************************************
    713           *
    714           *  Function Name    : NV_FlashEraseAllBlock
    715           *  Description      : The Erase All Blocks operation will erase all Flash
    716           *                     memory, initialize the EERAM, verify all memory
    717           *                     contents, then release MCU security.
    718           *  Arguments        : [IN] pConfig - pointer to NV configuration
    719           *  Return Value     : uint32_t
    720           *
    721           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    722          uint32_t NV_FlashEraseAllBlock
    723          (
    724                  pNvConfig_t pConfig
    725          )
    726          {
   \                     NV_FlashEraseAllBlock: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    727              uint8_t commandArray[1];     /* command sequence array */
    728          
    729              /* preparing passing parameter to erase all flash blocks */
    730              /* 1st element for the FCCOB register */
    731              commandArray[0] = gNV_ERASE_ALL_BLOCK_c;
   \   00000006   0x2044             MOVS     R0,#+68
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
    732          
    733              /* calling flash command sequence function to execute the command */
    734              return(NvFlashCommandSequence(pConfig, 0, commandArray));
   \   0000000C   0xAA00             ADD      R2,SP,#+0
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       NvFlashCommandSequence
   \   00000016   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    735          }
    736          
    737          
    738          /************************************************************************
    739           *
    740           *  Function Name    : NV_FlashEraseBlock
    741           *  Description      : The Erase Flash Block operation will erase all
    742           *                     addresses in a single P-Flash or D-Flash block.
    743           *  Arguments        : [IN] pConfig - pointer to NV configuration
    744           *                     [IN] destination - destination address
    745           *  Return Value     : uint32_t
    746           *
    747           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    748          uint32_t NV_FlashEraseBlock
    749          (
    750                  pNvConfig_t pConfig,
    751                  uint32_t destination
    752          )
    753          {
   \                     NV_FlashEraseBlock: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    754              uint8_t pCommandArray[4]; /* command sequence array */
    755          
    756              /* check if the destination is longword aligned or not */
    757              if (0 != (destination % gNV_ERSBLK_ALIGN_SIZE_c))
   \   00000006   0x2004             MOVS     R0,#+4
   \   00000008   0xFBB5 0xF1F0      UDIV     R1,R5,R0
   \   0000000C   0xFB01 0x5110      MLS      R1,R1,R0,R5
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD002             BEQ.N    ??NV_FlashEraseBlock_0
    758              {
    759                  /* return an error code gNV_ERR_ADDR */
    760                  return(gNV_ERR_ADDR_c);
   \   00000014   0xF44F 0x7080      MOV      R0,#+256
   \   00000018   0xE029             B.N      ??NV_FlashEraseBlock_1
    761              }
    762          
    763              /* check for valid range of the target addresses */
    764              if((destination < pConfig->PFlashBlockBase) || \
    765                      (destination >= (pConfig->PFlashBlockBase + pConfig->PFlashBlockSize)))
   \                     ??NV_FlashEraseBlock_0: (+1)
   \   0000001A   0x6860             LDR      R0,[R4, #+4]
   \   0000001C   0x4285             CMP      R5,R0
   \   0000001E   0xD304             BCC.N    ??NV_FlashEraseBlock_2
   \   00000020   0x6860             LDR      R0,[R4, #+4]
   \   00000022   0x68A1             LDR      R1,[R4, #+8]
   \   00000024   0x1808             ADDS     R0,R1,R0
   \   00000026   0x4285             CMP      R5,R0
   \   00000028   0xD30E             BCC.N    ??NV_FlashEraseBlock_3
    766              {
    767                  if((destination < pConfig->DFlashBlockBase) || \
    768                          (destination >= (pConfig->DFlashBlockBase + pConfig->DFlashBlockSize)))
   \                     ??NV_FlashEraseBlock_2: (+1)
   \   0000002A   0x68E0             LDR      R0,[R4, #+12]
   \   0000002C   0x4285             CMP      R5,R0
   \   0000002E   0xD304             BCC.N    ??NV_FlashEraseBlock_4
   \   00000030   0x68E0             LDR      R0,[R4, #+12]
   \   00000032   0x6921             LDR      R1,[R4, #+16]
   \   00000034   0x1808             ADDS     R0,R1,R0
   \   00000036   0x4285             CMP      R5,R0
   \   00000038   0xD301             BCC.N    ??NV_FlashEraseBlock_5
    769                  {
    770                      /* return an error code gNV_ERR_RANGE_c */
    771                      return(gNV_ERR_RANGE_c);
   \                     ??NV_FlashEraseBlock_4: (+1)
   \   0000003A   0x2002             MOVS     R0,#+2
   \   0000003C   0xE017             B.N      ??NV_FlashEraseBlock_1
    772                  }
    773                  else
    774                  {
    775                      /* Convert System memory address to FTFx internal memory address */
    776                      destination = destination - pConfig->DFlashBlockBase + 0x800000;
   \                     ??NV_FlashEraseBlock_5: (+1)
   \   0000003E   0x68E0             LDR      R0,[R4, #+12]
   \   00000040   0x1A28             SUBS     R0,R5,R0
   \   00000042   0xF510 0x0500      ADDS     R5,R0,#+8388608
   \   00000046   0xE001             B.N      ??NV_FlashEraseBlock_6
    777                  }
    778              }
    779              else
    780              {
    781                  /* Convert System memory address to FTFx internal memory address */
    782                  destination -= pConfig->PFlashBlockBase;
   \                     ??NV_FlashEraseBlock_3: (+1)
   \   00000048   0x6860             LDR      R0,[R4, #+4]
   \   0000004A   0x1A2D             SUBS     R5,R5,R0
    783              }
    784          
    785              /* preparing passing parameter to erase a flash block */
    786              pCommandArray[0] = gNV_ERASE_BLOCK_c;
   \                     ??NV_FlashEraseBlock_6: (+1)
   \   0000004C   0x2008             MOVS     R0,#+8
   \   0000004E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    787              pCommandArray[1] = (uint8_t)(destination >> 16);
   \   00000052   0x0C28             LSRS     R0,R5,#+16
   \   00000054   0xF88D 0x0001      STRB     R0,[SP, #+1]
    788              pCommandArray[2] = (uint8_t)((destination >> 8) & 0xFF);
   \   00000058   0x0A28             LSRS     R0,R5,#+8
   \   0000005A   0xF88D 0x0002      STRB     R0,[SP, #+2]
    789              pCommandArray[3] = (uint8_t)(destination & 0xFF);
   \   0000005E   0x0028             MOVS     R0,R5
   \   00000060   0xF88D 0x0003      STRB     R0,[SP, #+3]
    790          
    791              /* calling flash command sequence function to execute the command */
    792              return(NvFlashCommandSequence(pConfig, 3, pCommandArray));
   \   00000064   0xAA00             ADD      R2,SP,#+0
   \   00000066   0x2103             MOVS     R1,#+3
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0x.... 0x....      BL       NvFlashCommandSequence
   \                     ??NV_FlashEraseBlock_1: (+1)
   \   0000006E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    793          }
    794          
    795          
    796          /************************************************************************
    797           *
    798           *  Function Name    : NV_FlashEraseSuspend
    799           *  Description      : This function is used to suspend a current operation
    800           *                     of flash erase sector command.
    801           *  Arguments        : [IN] pConfig - pointer to NV configuration
    802           *  Return Value     : uint32_t
    803           *
    804           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    805          uint32_t NV_FlashEraseSuspend
    806          (
    807                  pNvConfig_t pConfig
    808          )
    809          {
   \                     NV_FlashEraseSuspend: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    810          
    811              /* check CCIF bit of the flash status register */
    812              if(FALSE == (gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c)))
   \   00000002   0x6808             LDR      R0,[R1, #+0]
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x0600             LSLS     R0,R0,#+24
   \   00000008   0xD405             BMI.N    ??NV_FlashEraseSuspend_0
    813              {
    814                  /* If the command write sequence in progressing, */
    815                  /* Set ERSSUSP bit in FCNFG register */
    816                  gNV_REG_BIT_SET(pConfig->ftfxRegBase + gNV_FCNFG_OFFSET_c, gNV_FCNFG_ERSSUSP_c);
   \   0000000A   0x6808             LDR      R0,[R1, #+0]
   \   0000000C   0x7840             LDRB     R0,[R0, #+1]
   \   0000000E   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000012   0x680A             LDR      R2,[R1, #+0]
   \   00000014   0x7050             STRB     R0,[R2, #+1]
    817              }
    818          
    819              return(gNV_OK_c);
   \                     ??NV_FlashEraseSuspend_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR               ;; return
    820          }
    821          
    822          
    823          /************************************************************************
    824           *
    825           *  Function Name    : NV_FlashEraseResume
    826           *  Description      : This function is used to resume a previous suspended
    827           *                     operation of flash erase sector command.
    828           *  Arguments        : [IN] pConfig - pointer to NV configuration
    829           *  Return Value     : uint32_t
    830           *
    831           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    832          uint32_t NV_FlashEraseResume
    833          (
    834                  pNvConfig_t pConfig
    835          )
    836          {
   \                     NV_FlashEraseResume: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    837          
    838              /* check ERSSUSP bit of the flash configuration register */
    839              if(TRUE == (gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FCNFG_OFFSET_c, gNV_FCNFG_ERSSUSP_c)))
   \   00000002   0x6808             LDR      R0,[R1, #+0]
   \   00000004   0x7842             LDRB     R2,[R0, #+1]
    840              {
    841                  /* If the ERSSUSP bit is set, */
    842                  /* Clear CCIF bit to resumimg the previous suspended Erasing */
    843                  gNV_REG_BIT_CLEAR(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c);
    844              }
    845          
    846              return(gNV_OK_c);
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x4770             BX       LR               ;; return
    847          }
    848          
    849          
    850          /****************************************************************************
    851           *
    852           *  Function Name    : NV_FlashEraseSector
    853           *  Description      : Perform erase operation on Flash
    854           *  Arguments        : [IN] pConfig - pointer to NV configuration
    855           *                     [IN] destination - destination address
    856           *                     [IN] size - data size
    857           *  Return Value     : uint32_t
    858           *
    859           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    860          uint32_t NV_FlashEraseSector
    861          (
    862                  pNvConfig_t pConfig,
    863                  uint32_t destination,
    864                  uint32_t size
    865          )
    866          {
   \                     NV_FlashEraseSector: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x0015             MOVS     R5,R2
    867              uint8_t pCommandArray[4]; /* command sequence array */
    868              uint32_t returnCode;      /* return code variable */
    869              uint32_t endAddress;      /* storing end address */
    870              uint32_t sectorSize;      /* size of one sector */
    871                  
    872              /* set the default return code as gNV_OK_c */
    873              returnCode = gNV_OK_c;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0006             MOVS     R6,R0
    874          
    875              /* calculating Flash end address */
    876              endAddress = destination + size;
   \   0000000E   0xEB15 0x0009      ADDS     R0,R5,R9
   \   00000012   0x0007             MOVS     R7,R0
    877          
    878              /* check for valid range of the target addresses */
    879              if((destination < pConfig->PFlashBlockBase) || \
    880                      (endAddress > (pConfig->PFlashBlockBase + pConfig->PFlashBlockSize)))
   \   00000014   0x6860             LDR      R0,[R4, #+4]
   \   00000016   0x4581             CMP      R9,R0
   \   00000018   0xD304             BCC.N    ??NV_FlashEraseSector_0
   \   0000001A   0x6860             LDR      R0,[R4, #+4]
   \   0000001C   0x68A1             LDR      R1,[R4, #+8]
   \   0000001E   0x1808             ADDS     R0,R1,R0
   \   00000020   0x42B8             CMP      R0,R7
   \   00000022   0xD211             BCS.N    ??NV_FlashEraseSector_1
    881              {
    882                  if((destination < pConfig->DFlashBlockBase) || \
    883                          (endAddress > (pConfig->DFlashBlockBase + pConfig->DFlashBlockSize)))
   \                     ??NV_FlashEraseSector_0: (+1)
   \   00000024   0x68E0             LDR      R0,[R4, #+12]
   \   00000026   0x4581             CMP      R9,R0
   \   00000028   0xD304             BCC.N    ??NV_FlashEraseSector_2
   \   0000002A   0x68E0             LDR      R0,[R4, #+12]
   \   0000002C   0x6921             LDR      R1,[R4, #+16]
   \   0000002E   0x1808             ADDS     R0,R1,R0
   \   00000030   0x42B8             CMP      R0,R7
   \   00000032   0xD201             BCS.N    ??NV_FlashEraseSector_3
    884                  {
    885                      /* return an error code gNV_ERR_RANGE_c */
    886                      return(gNV_ERR_RANGE_c);
   \                     ??NV_FlashEraseSector_2: (+1)
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0xE03C             B.N      ??NV_FlashEraseSector_4
    887                  }
    888                  else
    889                  {
    890                      /* Convert System memory address to FTFx internal memory address */
    891                      destination = destination - pConfig->DFlashBlockBase + 0x800000;
   \                     ??NV_FlashEraseSector_3: (+1)
   \   00000038   0x68E0             LDR      R0,[R4, #+12]
   \   0000003A   0xEBB9 0x0000      SUBS     R0,R9,R0
   \   0000003E   0xF510 0x0900      ADDS     R9,R0,#+8388608
    892                      sectorSize = gNV_DSECTOR_SIZE_c;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x4680             MOV      R8,R0
   \   00000046   0xE005             B.N      ??NV_FlashEraseSector_5
    893                  }
    894              }
    895              else
    896              {
    897                  /* Convert System memory address to FTFx internal memory address */
    898                  destination -= pConfig->PFlashBlockBase;
   \                     ??NV_FlashEraseSector_1: (+1)
   \   00000048   0x6860             LDR      R0,[R4, #+4]
   \   0000004A   0xEBB9 0x0900      SUBS     R9,R9,R0
    899                  sectorSize = gNV_PSECTOR_SIZE_c;
   \   0000004E   0xF44F 0x6000      MOV      R0,#+2048
   \   00000052   0x4680             MOV      R8,R0
    900              }
    901          
    902              /* check if the destination is sector aligned or not */
    903              if (0 != (destination % sectorSize))
   \                     ??NV_FlashEraseSector_5: (+1)
   \   00000054   0xFBB9 0xF0F8      UDIV     R0,R9,R8
   \   00000058   0xFB08 0x9010      MLS      R0,R8,R0,R9
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD002             BEQ.N    ??NV_FlashEraseSector_6
    904              {
    905                  /* return an error code gNV_ERR_ADDR */
    906                  return(gNV_ERR_ADDR_c);
   \   00000060   0xF44F 0x7080      MOV      R0,#+256
   \   00000064   0xE025             B.N      ??NV_FlashEraseSector_4
    907              }
    908          
    909              /* check if the size is sector alignment or not */
    910              if(0 != (size % sectorSize))
   \                     ??NV_FlashEraseSector_6: (+1)
   \   00000066   0xFBB5 0xF0F8      UDIV     R0,R5,R8
   \   0000006A   0xFB08 0x5010      MLS      R0,R8,R0,R5
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD001             BEQ.N    ??NV_FlashEraseSector_7
    911              {
    912                  /* return an error code gNV_ERR_SIZE */
    913                  return(gNV_ERR_SIZE_c);
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0xE01D             B.N      ??NV_FlashEraseSector_4
    914              }
    915          
    916              while(size > 0)
   \                     ??NV_FlashEraseSector_7: (+1)
   \   00000076   0x2D00             CMP      R5,#+0
   \   00000078   0xD01A             BEQ.N    ??NV_FlashEraseSector_8
    917              {
    918                  /* preparing passing parameter to erase a flash block */
    919                  pCommandArray[0] = gNV_ERASE_SECTOR_c;
   \   0000007A   0x2009             MOVS     R0,#+9
   \   0000007C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    920                  pCommandArray[1] = (uint8_t)(destination >> 16);
   \   00000080   0xEA5F 0x4019      LSRS     R0,R9,#+16
   \   00000084   0xF88D 0x0001      STRB     R0,[SP, #+1]
    921                  pCommandArray[2] = (uint8_t)((destination >> 8) & 0xFF);
   \   00000088   0xEA5F 0x2019      LSRS     R0,R9,#+8
   \   0000008C   0xF88D 0x0002      STRB     R0,[SP, #+2]
    922                  pCommandArray[3] = (uint8_t)(destination & 0xFF);
   \   00000090   0x4648             MOV      R0,R9
   \   00000092   0xF88D 0x0003      STRB     R0,[SP, #+3]
    923                          
    924                  /* calling flash command sequence function to execute the command */
    925                  returnCode = NvFlashCommandSequence(pConfig, 3, pCommandArray);
   \   00000096   0xAA00             ADD      R2,SP,#+0
   \   00000098   0x2103             MOVS     R1,#+3
   \   0000009A   0x0020             MOVS     R0,R4
   \   0000009C   0x.... 0x....      BL       NvFlashCommandSequence
   \   000000A0   0x0006             MOVS     R6,R0
    926          
    927                  /* checking the success of command execution */
    928                  if(gNV_OK_c != returnCode)
   \   000000A2   0x2E00             CMP      R6,#+0
   \   000000A4   0xD104             BNE.N    ??NV_FlashEraseSector_8
    929                  {
    930                      break;
    931                  }
    932                  else
    933                  {
    934                      /* update size and destination address */
    935                      size -= sectorSize;
   \                     ??NV_FlashEraseSector_9: (+1)
   \   000000A6   0xEBB5 0x0508      SUBS     R5,R5,R8
    936                      destination += sectorSize;
   \   000000AA   0xEB18 0x0909      ADDS     R9,R8,R9
   \   000000AE   0xE7E2             B.N      ??NV_FlashEraseSector_7
    937                  }
    938              }
    939          
    940              return(returnCode);
   \                     ??NV_FlashEraseSector_8: (+1)
   \   000000B0   0x0030             MOVS     R0,R6
   \                     ??NV_FlashEraseSector_4: (+1)
   \   000000B2   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    941          }
    942          
    943          
    944          /************************************************************************
    945           *
    946           *  Function Name    : NV_FlashGetInterruptEnable
    947           *  Description      : This function will read the FCNFG register and
    948           *                     return the interrupt enable states for Flash
    949           *                     interrupt types.
    950           *  Arguments        : [IN] pConfig - pointer to NV configuration
    951           *                     [OUT] interruptState - pointer to a memory location
    952           *                           where the interrupt state shall be placed
    953           *  Return Value     : uint32_t
    954           *
    955           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    956          uint32_t NV_FlashGetInterruptEnable
    957          (
    958                  pNvConfig_t pConfig,
    959                  uint8_t* interruptState
    960          )
    961          {
   \                     NV_FlashGetInterruptEnable: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
    962              /* store data read from flash register */
    963              uint8_t  registerValue;
    964          
    965              /* Initial interrupt state value */
    966              *interruptState = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    967          
    968              /*Get flash configuration register value */
    969              registerValue = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCNFG_OFFSET_c);
   \   00000008   0x6810             LDR      R0,[R2, #+0]
   \   0000000A   0x7840             LDRB     R0,[R0, #+1]
   \   0000000C   0x0003             MOVS     R3,R0
    970          
    971              /* Add command complete interrupt enable bit value */
    972              /* CCIE bit of the FCNFG register */
    973              *interruptState |= (registerValue & (gNV_FCNFG_CCIE_c | gNV_FCNFG_RDCOLLIE_c));
   \   0000000E   0x7808             LDRB     R0,[R1, #+0]
   \   00000010   0xF013 0x04C0      ANDS     R4,R3,#0xC0
   \   00000014   0x4320             ORRS     R0,R4,R0
   \   00000016   0x7008             STRB     R0,[R1, #+0]
    974          
    975              return(gNV_OK_c);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBC10             POP      {R4}
   \   0000001C   0x4770             BX       LR               ;; return
    976          }
    977          
    978          
    979          /************************************************************************
    980           *
    981           *  Function Name    : NV_FlashGetSecurityState
    982           *  Description      : This function retrieves the current Flash security
    983           *                     status, including the security enabling state and
    984           *                     the backdoor key enabling state.
    985           *  Arguments        : [IN] pConfig - pointer to NV configuration
    986           *                     [OUT] securityState - pointer to a memory location
    987           *                           where the security state will be placed
    988           *  Return Value     : uint32_t
    989           *
    990           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    991          uint32_t NV_FlashGetSecurityState
    992          (
    993                  pNvConfig_t pConfig,
    994                  uint8_t* securityState
    995          )
    996          {
   \                     NV_FlashGetSecurityState: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    997              /* store data read from flash register */
    998              uint8_t  registerValue;
    999          
   1000              /*Get flash security register value */
   1001              registerValue = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FSEC_OFFSET_c);
   \   00000002   0x6810             LDR      R0,[R2, #+0]
   \   00000004   0x7880             LDRB     R0,[R0, #+2]
   \   00000006   0x0003             MOVS     R3,R0
   1002          
   1003              /* check the status of the flash security bits in the security register */
   1004              if(gNV_FLASH_SECURITY_STATE_UNSECURED_c == (registerValue & gNV_FSEC_SEC_c))
   \   00000008   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000000A   0xF013 0x0003      ANDS     R0,R3,#0x3
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD102             BNE.N    ??NV_FlashGetSecurityState_0
   1005              {
   1006                  /* Flash in unsecured state */
   1007                  *securityState = gNV_FLASH_NOT_SECURE_c;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7008             STRB     R0,[R1, #+0]
   \   00000016   0xE009             B.N      ??NV_FlashGetSecurityState_1
   1008              }
   1009              else
   1010              {
   1011                  /* Flash in secured state */
   1012                  /* check for backdoor key security enable bit */
   1013                  if(gNV_FLASH_SECURITY_STATE_KEYEN_c == (registerValue & gNV_FSEC_KEYEN_c))
   \                     ??NV_FlashGetSecurityState_0: (+1)
   \   00000018   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000001A   0xF013 0x00C0      ANDS     R0,R3,#0xC0
   \   0000001E   0x2880             CMP      R0,#+128
   \   00000020   0xD102             BNE.N    ??NV_FlashGetSecurityState_2
   1014                  {
   1015                      /* Backdoor key security enabled */
   1016                      *securityState = gNV_FLASH_SECURE_BACKDOOR_ENABLED_c;
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0x7008             STRB     R0,[R1, #+0]
   \   00000026   0xE001             B.N      ??NV_FlashGetSecurityState_1
   1017                  }
   1018                  else
   1019                  {
   1020                      /* Backdoor key security disabled */
   1021                      *securityState = gNV_FLASH_SECURE_BACKDOOR_DISABLED_c;
   \                     ??NV_FlashGetSecurityState_2: (+1)
   \   00000028   0x2004             MOVS     R0,#+4
   \   0000002A   0x7008             STRB     R0,[R1, #+0]
   1022                  }
   1023              }
   1024          
   1025              return(gNV_OK_c);
   \                     ??NV_FlashGetSecurityState_1: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x4770             BX       LR               ;; return
   1026          }
   1027          
   1028          
   1029          /************************************************************************
   1030           *
   1031           *  Function Name    : NV_FlashProgramCheck
   1032           *  Description      : The Program Check command tests a previously
   1033           *                     programmed P-Flash or D-Flash longword to see
   1034           *                     if it reads correctly at the specified margin level.
   1035           *  Arguments        : [IN] pConfig - pointer to NV configuration
   1036           *                     [IN] destination - destination address
   1037           *                     [IN] size - block size to be checked
   1038           *                     [IN] pExpectedData - pointer to a memory location where
   1039           *                          the expected data is stored
   1040           *                     [IN] pFailAddr - pointer to a memory location where the
   1041           *                          failed address will be stored
   1042           *                     [IN] pFailData - pointer to a memory location where
   1043           *                          failed data will be stored
   1044           *                     [IN] marginLevel - read margin level
   1045           *
   1046           *  Return Value     : uint32_t
   1047           *
   1048           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1049          uint32_t NV_FlashProgramCheck
   1050          (
   1051                  pNvConfig_t pConfig,
   1052                  uint32_t  destination,
   1053                  uint32_t  size,
   1054                  uint8_t*  pExpectedData,
   1055                  uint8_t   marginLevel
   1056          )
   1057          {
   \                     NV_FlashProgramCheck: (+1)
   \   00000000   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0x9C0A             LDR      R4,[SP, #+40]
   1058              uint8_t pCommandArray[12]; /* command sequence array */
   1059              uint32_t returnCode;       /* return code variable */
   1060          
   1061              /* set the default return code as gNV_OK_c */
   1062              returnCode = gNV_OK_c;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4680             MOV      R8,R0
   1063          
   1064              /* check if the destination is Longword aligned or not */
   1065              if (0 != (destination % gNV_PGMCHK_ALIGN_SIZE_c))
   \   00000012   0x2004             MOVS     R0,#+4
   \   00000014   0xFBB9 0xF1F0      UDIV     R1,R9,R0
   \   00000018   0xFB01 0x9110      MLS      R1,R1,R0,R9
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD002             BEQ.N    ??NV_FlashProgramCheck_0
   1066              {
   1067                  /* return an error code gNV_ERR_ADDR */
   1068                  return(gNV_ERR_ADDR_c);
   \   00000020   0xF44F 0x7080      MOV      R0,#+256
   \   00000024   0xE056             B.N      ??NV_FlashProgramCheck_1
   1069              }
   1070          
   1071              /* check if the size is Longword aligned or not */
   1072              if (0 != size % gNV_PGMCHK_ALIGN_SIZE_c)
   \                     ??NV_FlashProgramCheck_0: (+1)
   \   00000026   0x2004             MOVS     R0,#+4
   \   00000028   0xFBB6 0xF1F0      UDIV     R1,R6,R0
   \   0000002C   0xFB01 0x6110      MLS      R1,R1,R0,R6
   \   00000030   0x2900             CMP      R1,#+0
   \   00000032   0xD001             BEQ.N    ??NV_FlashProgramCheck_2
   1073              {
   1074                  /* return an error code gNV_ERR_ADDR */
   1075                  return(gNV_ERR_SIZE_c);
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xE04D             B.N      ??NV_FlashProgramCheck_1
   1076              }
   1077          
   1078              /* check for valid range of the target addresses */
   1079              if((destination < pConfig->PFlashBlockBase) || \
   1080                      ((destination+size) > (pConfig->PFlashBlockBase + pConfig->PFlashBlockSize)))
   \                     ??NV_FlashProgramCheck_2: (+1)
   \   00000038   0x6868             LDR      R0,[R5, #+4]
   \   0000003A   0x4581             CMP      R9,R0
   \   0000003C   0xD306             BCC.N    ??NV_FlashProgramCheck_3
   \   0000003E   0x6868             LDR      R0,[R5, #+4]
   \   00000040   0x68A9             LDR      R1,[R5, #+8]
   \   00000042   0x1808             ADDS     R0,R1,R0
   \   00000044   0xEB16 0x0109      ADDS     R1,R6,R9
   \   00000048   0x4288             CMP      R0,R1
   \   0000004A   0xD211             BCS.N    ??NV_FlashProgramCheck_4
   1081              {
   1082                  if((destination < pConfig->DFlashBlockBase) || \
   1083                          ((destination+size) > (pConfig->DFlashBlockBase + pConfig->DFlashBlockSize)))
   \                     ??NV_FlashProgramCheck_3: (+1)
   \   0000004C   0x68E8             LDR      R0,[R5, #+12]
   \   0000004E   0x4581             CMP      R9,R0
   \   00000050   0xD306             BCC.N    ??NV_FlashProgramCheck_5
   \   00000052   0x68E8             LDR      R0,[R5, #+12]
   \   00000054   0x6929             LDR      R1,[R5, #+16]
   \   00000056   0x1808             ADDS     R0,R1,R0
   \   00000058   0xEB16 0x0109      ADDS     R1,R6,R9
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD201             BCS.N    ??NV_FlashProgramCheck_6
   1084                  {
   1085                      /* return an error code gNV_ERR_RANGE_c */
   1086                      return(gNV_ERR_RANGE_c);
   \                     ??NV_FlashProgramCheck_5: (+1)
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0xE037             B.N      ??NV_FlashProgramCheck_1
   1087                  }
   1088                  else
   1089                  {
   1090                      /* Convert System memory address to FTFx internal memory address */
   1091                      destination = destination - pConfig->DFlashBlockBase + 0x800000;
   \                     ??NV_FlashProgramCheck_6: (+1)
   \   00000064   0x68E8             LDR      R0,[R5, #+12]
   \   00000066   0xEBB9 0x0000      SUBS     R0,R9,R0
   \   0000006A   0xF510 0x0900      ADDS     R9,R0,#+8388608
   \   0000006E   0xE002             B.N      ??NV_FlashProgramCheck_7
   1092                  }
   1093              }
   1094              else
   1095              {
   1096                  /* Convert System memory address to FTFx internal memory address */
   1097                  destination -= pConfig->PFlashBlockBase;
   \                     ??NV_FlashProgramCheck_4: (+1)
   \   00000070   0x6868             LDR      R0,[R5, #+4]
   \   00000072   0xEBB9 0x0900      SUBS     R9,R9,R0
   1098              }
   1099              while (size)
   \                     ??NV_FlashProgramCheck_7: (+1)
   \   00000076   0x2E00             CMP      R6,#+0
   \   00000078   0xD02B             BEQ.N    ??NV_FlashProgramCheck_8
   1100              {
   1101          
   1102                  /* preparing passing parameter to program check the flash block */
   1103                  pCommandArray[0] = gNV_PROGRAM_CHECK_c;
   \   0000007A   0x2002             MOVS     R0,#+2
   \   0000007C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1104                  pCommandArray[1] = (uint8_t)(destination >> 16);
   \   00000080   0xEA5F 0x4019      LSRS     R0,R9,#+16
   \   00000084   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1105                  pCommandArray[2] = (uint8_t)((destination >> 8) & 0xFF);
   \   00000088   0xEA5F 0x2019      LSRS     R0,R9,#+8
   \   0000008C   0xF88D 0x0002      STRB     R0,[SP, #+2]
   1106                  pCommandArray[3] = (uint8_t)(destination & 0xFF);
   \   00000090   0x4648             MOV      R0,R9
   \   00000092   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1107                  pCommandArray[4] = marginLevel;
   \   00000096   0xF88D 0x4004      STRB     R4,[SP, #+4]
   1108          
   1109                  pCommandArray[8] = *(pExpectedData+3);
   \   0000009A   0x78F8             LDRB     R0,[R7, #+3]
   \   0000009C   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1110                  pCommandArray[9] = *(pExpectedData+2);
   \   000000A0   0x78B8             LDRB     R0,[R7, #+2]
   \   000000A2   0xF88D 0x0009      STRB     R0,[SP, #+9]
   1111                  pCommandArray[10] = *(pExpectedData+1);
   \   000000A6   0x7878             LDRB     R0,[R7, #+1]
   \   000000A8   0xF88D 0x000A      STRB     R0,[SP, #+10]
   1112                  pCommandArray[11] = *pExpectedData;
   \   000000AC   0x7838             LDRB     R0,[R7, #+0]
   \   000000AE   0xF88D 0x000B      STRB     R0,[SP, #+11]
   1113          
   1114                  /* calling flash command sequence function to execute the command */
   1115                  returnCode = NvFlashCommandSequence(pConfig, 11, pCommandArray);
   \   000000B2   0xAA00             ADD      R2,SP,#+0
   \   000000B4   0x210B             MOVS     R1,#+11
   \   000000B6   0x0028             MOVS     R0,R5
   \   000000B8   0x.... 0x....      BL       NvFlashCommandSequence
   \   000000BC   0x4680             MOV      R8,R0
   1116          
   1117                  /* checking for the success of command execution */
   1118                  if(gNV_OK_c != returnCode)
   \   000000BE   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000C2   0xD001             BEQ.N    ??NV_FlashProgramCheck_9
   1119                  {
   1120                      return(returnCode);
   \   000000C4   0x4640             MOV      R0,R8
   \   000000C6   0xE005             B.N      ??NV_FlashProgramCheck_1
   1121                  }
   1122          
   1123                  size-=gNV_LONGWORD_SIZE_c;
   \                     ??NV_FlashProgramCheck_9: (+1)
   \   000000C8   0x1F36             SUBS     R6,R6,#+4
   1124                  pExpectedData+=gNV_LONGWORD_SIZE_c;
   \   000000CA   0x1D3F             ADDS     R7,R7,#+4
   1125                  destination+= gNV_LONGWORD_SIZE_c;
   \   000000CC   0xF119 0x0904      ADDS     R9,R9,#+4
   \   000000D0   0xE7D1             B.N      ??NV_FlashProgramCheck_7
   1126              }
   1127          
   1128              return(returnCode);
   \                     ??NV_FlashProgramCheck_8: (+1)
   \   000000D2   0x4640             MOV      R0,R8
   \                     ??NV_FlashProgramCheck_1: (+1)
   \   000000D4   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
   1129          }
   1130          
   1131          
   1132          /************************************************************************
   1133           *
   1134           *  Function Name    : NV_FlashProgramLongword
   1135           *  Description      : Program data into Flash
   1136           *  Arguments        : [IN] pConfig - pointer to NV configuration
   1137           *                     [IN] destination - destination address
   1138           *                     [IN] size - data set size
   1139           *                     [IN] source - source address
   1140           *  Return Value     : uint32_t
   1141           *
   1142           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1143          uint32_t NV_FlashProgramLongword
   1144          (
   1145                  pNvConfig_t pConfig,
   1146                  uint32_t destination,
   1147                  uint32_t size,
   1148                  uint32_t source
   1149          )
   1150          {
   \                     NV_FlashProgramLongword: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x468B             MOV      R11,R1
   \   00000008   0x4692             MOV      R10,R2
   \   0000000A   0x001D             MOVS     R5,R3
   1151              uint8_t pCommandArray[8]; /* command sequence array */
   1152              uint32_t returnCode;      /* return code variable */
   1153              uint32_t endAddress;      /* storing end address */
   1154              uint8_t loopCnt;          /* loop counter */
   1155          
   1156              uint8_t paddingBytes[4] = {0xFF, 0xFF, 0xFF, 0xFF};
   \   0000000C   0xA802             ADD      R0,SP,#+8
   \   0000000E   0x....             LDR.N    R1,??DataTable2_2
   \   00000010   0x680A             LDR      R2,[R1, #0]
   \   00000012   0x6002             STR      R2,[R0, #+0]
   1157              uint8_t paddingBytesCnt = 0;
   \   00000014   0xF05F 0x0900      MOVS     R9,#+0
   1158              
   1159              /* set the default return code as gNV_OK_c */
   1160              returnCode = gNV_OK_c;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x0006             MOVS     R6,R0
   1161          
   1162              /* calculating Flash end address */
   1163              endAddress = destination + size;
   \   0000001C   0xEB1A 0x000B      ADDS     R0,R10,R11
   \   00000020   0x0007             MOVS     R7,R0
   1164          
   1165              /* check if the destination is longword aligned or not */
   1166              if((destination & (~0x03uL)) != destination)
   \   00000022   0xEA5F 0x009B      LSRS     R0,R11,#+2
   \   00000026   0x0080             LSLS     R0,R0,#+2
   \   00000028   0x4558             CMP      R0,R11
   \   0000002A   0xD005             BEQ.N    ??NV_FlashProgramLongword_0
   1167              {
   1168                  /* align to next 32 bit boundary */
   1169                  destination &= ~0x03uL;
   \   0000002C   0xEA5F 0x0B9B      LSRS     R11,R11,#+2
   \   00000030   0xEA5F 0x0B8B      LSLS     R11,R11,#+2
   1170                  destination += gNV_LONGWORD_SIZE_c;
   \   00000034   0xF11B 0x0B04      ADDS     R11,R11,#+4
   1171              }
   1172          
   1173              paddingBytesCnt = size % gNV_LONGWORD_SIZE_c;
   \                     ??NV_FlashProgramLongword_0: (+1)
   \   00000038   0x2004             MOVS     R0,#+4
   \   0000003A   0xFBBA 0xF1F0      UDIV     R1,R10,R0
   \   0000003E   0xFB01 0xA110      MLS      R1,R1,R0,R10
   \   00000042   0x4689             MOV      R9,R1
   1174          
   1175              /* check if the size is Longword alignment or not */
   1176          
   1177              if(0 != paddingBytesCnt)
   \   00000044   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000048   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000004C   0xD008             BEQ.N    ??NV_FlashProgramLongword_1
   1178              {
   1179                  size -= paddingBytesCnt;
   \   0000004E   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000052   0xEBBA 0x0A09      SUBS     R10,R10,R9
   1180                  EffectiveWrBytesCnt = size + gNV_LONGWORD_SIZE_c;
   \   00000056   0xF11A 0x0004      ADDS     R0,R10,#+4
   \   0000005A   0x....             LDR.N    R1,??DataTable2_3
   \   0000005C   0x6008             STR      R0,[R1, #+0]
   \   0000005E   0xE002             B.N      ??NV_FlashProgramLongword_2
   1181              }
   1182              else
   1183              {
   1184                  EffectiveWrBytesCnt = size;
   \                     ??NV_FlashProgramLongword_1: (+1)
   \   00000060   0x....             LDR.N    R0,??DataTable2_3
   \   00000062   0xF8C0 0xA000      STR      R10,[R0, #+0]
   1185              }
   1186          
   1187              /* check for valid range of the target addresses */
   1188              if((destination < pConfig->PFlashBlockBase) || \
   1189                      (endAddress > (pConfig->PFlashBlockBase + pConfig->PFlashBlockSize)))
   \                     ??NV_FlashProgramLongword_2: (+1)
   \   00000066   0x6860             LDR      R0,[R4, #+4]
   \   00000068   0x4583             CMP      R11,R0
   \   0000006A   0xD304             BCC.N    ??NV_FlashProgramLongword_3
   \   0000006C   0x6860             LDR      R0,[R4, #+4]
   \   0000006E   0x68A1             LDR      R1,[R4, #+8]
   \   00000070   0x1808             ADDS     R0,R1,R0
   \   00000072   0x42B8             CMP      R0,R7
   \   00000074   0xD20F             BCS.N    ??NV_FlashProgramLongword_4
   1190              {
   1191                  if((destination < pConfig->DFlashBlockBase) || \
   1192                          (endAddress > (pConfig->DFlashBlockBase + pConfig->DFlashBlockSize)))
   \                     ??NV_FlashProgramLongword_3: (+1)
   \   00000076   0x68E0             LDR      R0,[R4, #+12]
   \   00000078   0x4583             CMP      R11,R0
   \   0000007A   0xD304             BCC.N    ??NV_FlashProgramLongword_5
   \   0000007C   0x68E0             LDR      R0,[R4, #+12]
   \   0000007E   0x6921             LDR      R1,[R4, #+16]
   \   00000080   0x1808             ADDS     R0,R1,R0
   \   00000082   0x42B8             CMP      R0,R7
   \   00000084   0xD201             BCS.N    ??NV_FlashProgramLongword_6
   1193                  {
   1194                      /* return an error code gNV_ERR_RANGE_c */
   1195                      return(gNV_ERR_RANGE_c);
   \                     ??NV_FlashProgramLongword_5: (+1)
   \   00000086   0x2002             MOVS     R0,#+2
   \   00000088   0xE06F             B.N      ??NV_FlashProgramLongword_7
   1196                  }
   1197                  else
   1198                  {
   1199                      /* Convert System memory address to FTFx internal memory address */
   1200                      destination = destination - pConfig->DFlashBlockBase + 0x800000;
   \                     ??NV_FlashProgramLongword_6: (+1)
   \   0000008A   0x68E0             LDR      R0,[R4, #+12]
   \   0000008C   0xEBBB 0x0000      SUBS     R0,R11,R0
   \   00000090   0xF510 0x0B00      ADDS     R11,R0,#+8388608
   \   00000094   0xE002             B.N      ??NV_FlashProgramLongword_8
   1201                  }
   1202              }
   1203              else
   1204              {
   1205                  /* Convert System memory address to FTFx internal memory address */
   1206                  destination -= pConfig->PFlashBlockBase;
   \                     ??NV_FlashProgramLongword_4: (+1)
   \   00000096   0x6860             LDR      R0,[R4, #+4]
   \   00000098   0xEBBB 0x0B00      SUBS     R11,R11,R0
   1207              }
   1208          
   1209              while(size > 0)
   \                     ??NV_FlashProgramLongword_8: (+1)
   \   0000009C   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000A0   0xD027             BEQ.N    ??NV_FlashProgramLongword_9
   1210              {
   1211                  /* preparing passing parameter to program the flash block */
   1212                  pCommandArray[0] = gNV_PROGRAM_LONGWORD_c;
   \   000000A2   0x2006             MOVS     R0,#+6
   \   000000A4   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1213                  pCommandArray[1] = (uint8_t)(destination >> 16);
   \   000000A8   0xEA5F 0x401B      LSRS     R0,R11,#+16
   \   000000AC   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1214                  pCommandArray[2] = (uint8_t)((destination >> 8) & 0xFF);
   \   000000B0   0xEA5F 0x201B      LSRS     R0,R11,#+8
   \   000000B4   0xF88D 0x0002      STRB     R0,[SP, #+2]
   1215                  pCommandArray[3] = (uint8_t)(destination & 0xFF);
   \   000000B8   0x4658             MOV      R0,R11
   \   000000BA   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1216          
   1217                  pCommandArray[4] = gNV_READ8(source + 3);
   \   000000BE   0x78E8             LDRB     R0,[R5, #+3]
   \   000000C0   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1218                  pCommandArray[5] = gNV_READ8(source + 2);
   \   000000C4   0x78A8             LDRB     R0,[R5, #+2]
   \   000000C6   0xF88D 0x0005      STRB     R0,[SP, #+5]
   1219                  pCommandArray[6] = gNV_READ8(source + 1);
   \   000000CA   0x7868             LDRB     R0,[R5, #+1]
   \   000000CC   0xF88D 0x0006      STRB     R0,[SP, #+6]
   1220                  pCommandArray[7] = gNV_READ8(source);
   \   000000D0   0x7828             LDRB     R0,[R5, #+0]
   \   000000D2   0xF88D 0x0007      STRB     R0,[SP, #+7]
   1221                        
   1222                  /* calling flash command sequence function to execute the command */
   1223                  returnCode = NvFlashCommandSequence(pConfig, 7, pCommandArray);
   \   000000D6   0xAA00             ADD      R2,SP,#+0
   \   000000D8   0x2107             MOVS     R1,#+7
   \   000000DA   0x0020             MOVS     R0,R4
   \   000000DC   0x.... 0x....      BL       NvFlashCommandSequence
   \   000000E0   0x0006             MOVS     R6,R0
   1224          
   1225                  /* checking for the success of command execution */
   1226                  if(gNV_OK_c != returnCode)
   \   000000E2   0x2E00             CMP      R6,#+0
   \   000000E4   0xD105             BNE.N    ??NV_FlashProgramLongword_9
   1227                  {
   1228                      break;
   1229                  }
   1230                  else
   1231                  {
   1232                      /* update destination address for next iteration */
   1233                      destination += gNV_LONGWORD_SIZE_c;
   \                     ??NV_FlashProgramLongword_10: (+1)
   \   000000E6   0xF11B 0x0B04      ADDS     R11,R11,#+4
   1234                      /* update size for next iteration */
   1235                      size -= gNV_LONGWORD_SIZE_c;
   \   000000EA   0xF1BA 0x0A04      SUBS     R10,R10,#+4
   1236                      /* increment the source address */
   1237                      source += gNV_LONGWORD_SIZE_c;
   \   000000EE   0x1D2D             ADDS     R5,R5,#+4
   \   000000F0   0xE7D4             B.N      ??NV_FlashProgramLongword_8
   1238                  }
   1239              }
   1240          
   1241              if(0 != paddingBytesCnt)
   \                     ??NV_FlashProgramLongword_9: (+1)
   \   000000F2   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000F6   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000FA   0xD035             BEQ.N    ??NV_FlashProgramLongword_11
   1242              {
   1243                  /* add padding bytes */
   1244          
   1245                  for(loopCnt = 0; loopCnt < paddingBytesCnt; loopCnt++)
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0x4680             MOV      R8,R0
   \                     ??NV_FlashProgramLongword_12: (+1)
   \   00000100   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000104   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000108   0x45C8             CMP      R8,R9
   \   0000010A   0xD209             BCS.N    ??NV_FlashProgramLongword_13
   1246                  {
   1247                      paddingBytes[loopCnt] = gNV_READ8(source++);
   \   0000010C   0x7828             LDRB     R0,[R5, #+0]
   \   0000010E   0x1C6D             ADDS     R5,R5,#+1
   \   00000110   0xA902             ADD      R1,SP,#+8
   \   00000112   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000116   0xF808 0x0001      STRB     R0,[R8, R1]
   1248                  }
   \   0000011A   0xF118 0x0801      ADDS     R8,R8,#+1
   \   0000011E   0xE7EF             B.N      ??NV_FlashProgramLongword_12
   1249          
   1250                  /* preparing passing parameter to program the flash block */
   1251                  pCommandArray[0] = gNV_PROGRAM_LONGWORD_c;
   \                     ??NV_FlashProgramLongword_13: (+1)
   \   00000120   0x2006             MOVS     R0,#+6
   \   00000122   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1252                  pCommandArray[1] = (uint8_t)(destination >> 16);
   \   00000126   0xEA5F 0x401B      LSRS     R0,R11,#+16
   \   0000012A   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1253                  pCommandArray[2] = (uint8_t)((destination >> 8) & 0xFF);
   \   0000012E   0xEA5F 0x201B      LSRS     R0,R11,#+8
   \   00000132   0xF88D 0x0002      STRB     R0,[SP, #+2]
   1254                  pCommandArray[3] = (uint8_t)(destination & 0xFF);
   \   00000136   0x4658             MOV      R0,R11
   \   00000138   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1255          
   1256                  pCommandArray[4] = paddingBytes[3];
   \   0000013C   0xF89D 0x000B      LDRB     R0,[SP, #+11]
   \   00000140   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1257                  pCommandArray[5] = paddingBytes[2];
   \   00000144   0xF89D 0x000A      LDRB     R0,[SP, #+10]
   \   00000148   0xF88D 0x0005      STRB     R0,[SP, #+5]
   1258                  pCommandArray[6] = paddingBytes[1];
   \   0000014C   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   00000150   0xF88D 0x0006      STRB     R0,[SP, #+6]
   1259                  pCommandArray[7] = paddingBytes[0];
   \   00000154   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000158   0xF88D 0x0007      STRB     R0,[SP, #+7]
   1260                  
   1261                  /* calling flash command sequence function to execute the command */
   1262                  returnCode = NvFlashCommandSequence(pConfig, 7, pCommandArray);
   \   0000015C   0xAA00             ADD      R2,SP,#+0
   \   0000015E   0x2107             MOVS     R1,#+7
   \   00000160   0x0020             MOVS     R0,R4
   \   00000162   0x.... 0x....      BL       NvFlashCommandSequence
   \   00000166   0x0006             MOVS     R6,R0
   1263              }
   1264          
   1265              return(returnCode);
   \                     ??NV_FlashProgramLongword_11: (+1)
   \   00000168   0x0030             MOVS     R0,R6
   \                     ??NV_FlashProgramLongword_7: (+1)
   \   0000016A   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   1266          }
   1267          
   1268          /************************************************************************
   1269           *
   1270           *  Function Name    : NV_FlashProgramUnalignedLongword
   1271           *  Description      : Program data into Flash. The address can be unaligned
   1272           *  Arguments        : [IN] pConfig - pointer to NV configuration
   1273           *                     [IN] destination - destination address
   1274           *                     [IN] size - data set size
   1275           *                     [IN] source - source address
   1276           *  Return Value     : uint32_t
   1277           *
   1278           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1279          uint32_t NV_FlashProgramUnalignedLongword
   1280          (
   1281                  pNvConfig_t pConfig,
   1282                  uint32_t destination,
   1283                  uint32_t size,
   1284                  uint32_t source
   1285          )
   1286          {
   \                     NV_FlashProgramUnalignedLongword: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x468B             MOV      R11,R1
   \   00000008   0x0015             MOVS     R5,R2
   \   0000000A   0x001E             MOVS     R6,R3
   1287            uint8_t i, bytes = destination & 0x03;
   \   0000000C   0xF01B 0x0803      ANDS     R8,R11,#0x3
   1288            uint32_t tmp;
   1289            uint8_t alignWord[4] = {0xFF, 0xFF, 0xFF, 0xFF};
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x....             LDR.N    R1,??DataTable2_4
   \   00000014   0x680A             LDR      R2,[R1, #0]
   \   00000016   0x6002             STR      R2,[R0, #+0]
   1290          
   1291            if (bytes)
   \   00000018   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000001C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000020   0xD028             BEQ.N    ??NV_FlashProgramUnalignedLongword_0
   1292            {
   1293          	uint32_t *pAddress;  
   1294          	  
   1295              /* Go to previous aligned address */
   1296              destination &= ~((uint32_t)0x03);
   \   00000022   0xEA5F 0x0B9B      LSRS     R11,R11,#+2
   \   00000026   0xEA5F 0x0B8B      LSLS     R11,R11,#+2
   1297          
   1298              /* Read LongWord from flash */
   1299              pAddress = (uint32_t*)alignWord; 
   \   0000002A   0xA800             ADD      R0,SP,#+0
   \   0000002C   0x4682             MOV      R10,R0
   1300              *pAddress = gNV_READ32(destination); // to suppress GCC compiler warning
   \   0000002E   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   00000032   0xF8CA 0x0000      STR      R0,[R10, #+0]
   1301             
   1302              /* Add the unaligned bytes */
   1303              for (i = (gNV_LONGWORD_SIZE_c - bytes); i < gNV_LONGWORD_SIZE_c; i++)
   \   00000036   0xF1D8 0x0004      RSBS     R0,R8,#+4
   \   0000003A   0x0007             MOVS     R7,R0
   \                     ??NV_FlashProgramUnalignedLongword_1: (+1)
   \   0000003C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003E   0x2F04             CMP      R7,#+4
   \   00000040   0xDA06             BGE.N    ??NV_FlashProgramUnalignedLongword_2
   1304                alignWord[i] = gNV_READ8(source++);
   \   00000042   0x7830             LDRB     R0,[R6, #+0]
   \   00000044   0x1C76             ADDS     R6,R6,#+1
   \   00000046   0xA900             ADD      R1,SP,#+0
   \   00000048   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000004A   0x5478             STRB     R0,[R7, R1]
   \   0000004C   0x1C7F             ADDS     R7,R7,#+1
   \   0000004E   0xE7F5             B.N      ??NV_FlashProgramUnalignedLongword_1
   1305          
   1306              /* Write the new LongWord */
   1307              tmp = NV_FlashProgramLongword(pConfig, destination, gNV_LONGWORD_SIZE_c, (uint32_t)&alignWord);
   \                     ??NV_FlashProgramUnalignedLongword_2: (+1)
   \   00000050   0xAB00             ADD      R3,SP,#+0
   \   00000052   0x2204             MOVS     R2,#+4
   \   00000054   0x4659             MOV      R1,R11
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x.... 0x....      BL       NV_FlashProgramLongword
   \   0000005C   0x4681             MOV      R9,R0
   1308          
   1309              if (gNV_OK_c != tmp)
   \   0000005E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000062   0xD001             BEQ.N    ??NV_FlashProgramUnalignedLongword_3
   1310                return tmp;
   \   00000064   0x4648             MOV      R0,R9
   \   00000066   0xE00B             B.N      ??NV_FlashProgramUnalignedLongword_4
   1311          
   1312              destination += gNV_LONGWORD_SIZE_c;
   \                     ??NV_FlashProgramUnalignedLongword_3: (+1)
   \   00000068   0xF11B 0x0B04      ADDS     R11,R11,#+4
   1313              size -= bytes;
   \   0000006C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000070   0xEBB5 0x0508      SUBS     R5,R5,R8
   1314            }
   1315          
   1316            return NV_FlashProgramLongword(pConfig, destination, size, source);
   \                     ??NV_FlashProgramUnalignedLongword_0: (+1)
   \   00000074   0x0033             MOVS     R3,R6
   \   00000076   0x002A             MOVS     R2,R5
   \   00000078   0x4659             MOV      R1,R11
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x.... 0x....      BL       NV_FlashProgramLongword
   \                     ??NV_FlashProgramUnalignedLongword_4: (+1)
   \   00000080   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1317          }
   1318          
   1319          /************************************************************************
   1320           *
   1321           *  Function Name    : NV_FlashRead
   1322           *  Description      : Read data stored in flash memory
   1323           *  Arguments        : [IN] address - flash memory address
   1324           *                     [OUT] pData - pointer to a memory location
   1325           *                                   where the data will be stored
   1326           *                     [IN] len - data length to be read
   1327           *  Return Value     : -
   1328           *
   1329           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1330          void NV_FlashRead
   1331          (
   1332                  uint32_t address,
   1333                  uint8_t* pData,
   1334                  uint32_t len
   1335          )
   1336          {
   1337              while(len--)
   \                     NV_FlashRead: (+1)
   \                     ??NV_FlashRead_0: (+1)
   \   00000000   0x0013             MOVS     R3,R2
   \   00000002   0x1E5A             SUBS     R2,R3,#+1
   \   00000004   0x2B00             CMP      R3,#+0
   \   00000006   0xD004             BEQ.N    ??NV_FlashRead_1
   1338              {
   1339                  *pData++ = ((uint8_t)(*(vuint8_t*)(address++)));
   \   00000008   0x7803             LDRB     R3,[R0, #+0]
   \   0000000A   0x1C40             ADDS     R0,R0,#+1
   \   0000000C   0x700B             STRB     R3,[R1, #+0]
   \   0000000E   0x1C49             ADDS     R1,R1,#+1
   \   00000010   0xE7F6             B.N      ??NV_FlashRead_0
   1340              }
   1341          }
   \                     ??NV_FlashRead_1: (+1)
   \   00000012   0x4770             BX       LR               ;; return
   1342          
   1343          /************************************************************************
   1344           *
   1345           *  Function Name    : NV_FlashProgramOnce
   1346           *  Description      : Program data into a dedicated 64 bytes region in
   1347           *                     the P-Flash IFR which stores critical information
   1348           *                     for the user
   1349           *  Arguments        : [IN] pConfig - pointer to NV configuration
   1350           *                     [IN] pDataArray - pointer to a memory location
   1351           *                                       where the data is stored
   1352           *  Return Value     : uint32_t
   1353           *
   1354           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1355          uint32_t NV_FlashProgramOnce
   1356          (
   1357                  pNvConfig_t pConfig,
   1358                  uint8_t* pDataArray
   1359          )
   1360          {
   \                     NV_FlashProgramOnce: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1361              uint8_t  counter;          /* outer loop counter */
   1362              uint8_t  pCommandArray[8]; /* command sequence array */
   1363              uint32_t returnCode;       /* return code variable */
   1364              uint8_t i;                 /* variable to store record number index */
   1365          
   1366              /* set the default return code as gNV_OK_c */
   1367              returnCode = gNV_OK_c;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0007             MOVS     R7,R0
   1368              /* set the counter value for 0 */
   1369              counter = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x0006             MOVS     R6,R0
   1370              /* calculate record number index */
   1371              i = (64 / (gNV_RDONCE_INDEX_MAX_c + 1));
   \   00000010   0x2004             MOVS     R0,#+4
   \   00000012   0x4680             MOV      R8,R0
   1372          
   1373              /* preparing passing parameter for program once command */
   1374              /* 1st element for the FCCOB register */
   1375              pCommandArray[0] = gNV_PROGRAM_ONCE_c;
   \   00000014   0x2043             MOVS     R0,#+67
   \   00000016   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1376          
   1377              while (counter <= gNV_RDONCE_INDEX_MAX_c)
   \                     ??NV_FlashProgramOnce_0: (+1)
   \   0000001A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001C   0x2E10             CMP      R6,#+16
   \   0000001E   0xDA33             BGE.N    ??NV_FlashProgramOnce_1
   1378              {
   1379                  /* preparing the rest of the parameters to be passed for the FCCOB registers */
   1380                  pCommandArray[1] = counter;
   \   00000020   0xF88D 0x6001      STRB     R6,[SP, #+1]
   1381                  pCommandArray[2] = 0x00;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF88D 0x0002      STRB     R0,[SP, #+2]
   1382                  pCommandArray[3] = 0x00;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1383                  pCommandArray[4] = pDataArray[counter*i];
   \   00000030   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000032   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000036   0xFB08 0x5006      MLA      R0,R8,R6,R5
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1384                  pCommandArray[5] = pDataArray[counter*i + 1];
   \   00000040   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000042   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000046   0xFB08 0x5006      MLA      R0,R8,R6,R5
   \   0000004A   0x7840             LDRB     R0,[R0, #+1]
   \   0000004C   0xF88D 0x0005      STRB     R0,[SP, #+5]
   1385                  pCommandArray[6] = pDataArray[counter*i + 2];
   \   00000050   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000052   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000056   0xFB08 0x5006      MLA      R0,R8,R6,R5
   \   0000005A   0x7880             LDRB     R0,[R0, #+2]
   \   0000005C   0xF88D 0x0006      STRB     R0,[SP, #+6]
   1386                  pCommandArray[7] = pDataArray[counter*i + 3];
   \   00000060   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000062   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000066   0xFB08 0x5006      MLA      R0,R8,R6,R5
   \   0000006A   0x78C0             LDRB     R0,[R0, #+3]
   \   0000006C   0xF88D 0x0007      STRB     R0,[SP, #+7]
   1387          #if ((gNV_512K_512K_16K_4K_4K_c == gNV_Derivative_c) || (gNV_1024K_0K_16K_4K_0K_c == gNV_Derivative_c))                 
   1388                  pCommandArray[8] = pDataArray[counter*i + 4];
   1389                  pCommandArray[9] = pDataArray[counter*i + 5];
   1390                  pCommandArray[10] = pDataArray[counter*i + 6];
   1391                  pCommandArray[11] = pDataArray[counter*i + 7];
   1392          #endif
   1393          
   1394                  /* calling flash command sequence API to execute the command */
   1395                  returnCode = NvFlashCommandSequence(pConfig, i + 3, pCommandArray);
   \   00000070   0xAA00             ADD      R2,SP,#+0
   \   00000072   0xF118 0x0103      ADDS     R1,R8,#+3
   \   00000076   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000078   0x0020             MOVS     R0,R4
   \   0000007A   0x.... 0x....      BL       NvFlashCommandSequence
   \   0000007E   0x0007             MOVS     R7,R0
   1396          
   1397                  /* checking for the success of command execution */
   1398                  if(gNV_OK_c != returnCode)
   \   00000080   0x2F00             CMP      R7,#+0
   \   00000082   0xD101             BNE.N    ??NV_FlashProgramOnce_1
   1399                  {
   1400                      break;
   1401                  }
   1402          
   1403                  /* decrement the counter value */
   1404                  counter++;
   \                     ??NV_FlashProgramOnce_2: (+1)
   \   00000084   0x1C76             ADDS     R6,R6,#+1
   \   00000086   0xE7C8             B.N      ??NV_FlashProgramOnce_0
   1405              }
   1406          
   1407              return(returnCode);
   \                     ??NV_FlashProgramOnce_1: (+1)
   \   00000088   0x0038             MOVS     R0,R7
   \   0000008A   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   1408          }
   1409          
   1410          
   1411          /************************************************************************
   1412           *
   1413           *  Function Name    : NV_FlashProgramPhrase
   1414           *  Description      : Program data into Flash
   1415           *  Arguments        : [IN] pConfig - pointer to NV configuration
   1416           *                     [IN] destination - destination address
   1417           *                     [IN] size - size to be written
   1418           *                     [IN] source - source address
   1419           *  Return Value     : uint32_t
   1420           *
   1421           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1422          uint32_t NV_FlashProgramPhrase
   1423          (
   1424                  pNvConfig_t pConfig,
   1425                  uint32_t destination,
   1426                  uint32_t size,
   1427                  uint32_t source
   1428          )
   1429          {
   \                     NV_FlashProgramPhrase: (+1)
   \   00000000   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x0015             MOVS     R5,R2
   \   0000000A   0x001E             MOVS     R6,R3
   1430              uint8_t pCommandArray[12]; /* command sequence array */
   1431              uint32_t returnCode;       /* return code variable */
   1432              uint32_t endAddress;       /* storing end address */
   1433          
   1434              /* set the default return code as gNV_OK_c */
   1435              returnCode = gNV_OK_c;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x0007             MOVS     R7,R0
   1436          
   1437              /* calculating Flash end address */
   1438              endAddress = destination + size;
   \   00000010   0xEB15 0x0009      ADDS     R0,R5,R9
   \   00000014   0x4680             MOV      R8,R0
   1439          
   1440              /* check if the destination is Longword aligned or not */
   1441              if (0 != (destination % gNV_PHRASE_SIZE_c))
   \   00000016   0x2008             MOVS     R0,#+8
   \   00000018   0xFBB9 0xF1F0      UDIV     R1,R9,R0
   \   0000001C   0xFB01 0x9110      MLS      R1,R1,R0,R9
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xD002             BEQ.N    ??NV_FlashProgramPhrase_0
   1442              {
   1443                  /* return an error code gNV_ERR_ADDR */
   1444                  return(gNV_ERR_ADDR_c);
   \   00000024   0xF44F 0x7080      MOV      R0,#+256
   \   00000028   0xE059             B.N      ??NV_FlashProgramPhrase_1
   1445              }
   1446          
   1447              /* check if the size is Longword alignment or not */
   1448              if(0 != (size % gNV_PHRASE_SIZE_c))
   \                     ??NV_FlashProgramPhrase_0: (+1)
   \   0000002A   0x2008             MOVS     R0,#+8
   \   0000002C   0xFBB5 0xF1F0      UDIV     R1,R5,R0
   \   00000030   0xFB01 0x5110      MLS      R1,R1,R0,R5
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xD001             BEQ.N    ??NV_FlashProgramPhrase_2
   1449              {
   1450                  /* return an error code gNV_ERR_SIZE */
   1451                  return(gNV_ERR_SIZE_c);
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xE050             B.N      ??NV_FlashProgramPhrase_1
   1452              }
   1453          
   1454              /* check for valid range of the target addresses */
   1455              if((destination < pConfig->PFlashBlockBase) || \
   1456                      (endAddress > (pConfig->PFlashBlockBase + pConfig->PFlashBlockSize)))
   \                     ??NV_FlashProgramPhrase_2: (+1)
   \   0000003C   0x6860             LDR      R0,[R4, #+4]
   \   0000003E   0x4581             CMP      R9,R0
   \   00000040   0xD304             BCC.N    ??NV_FlashProgramPhrase_3
   \   00000042   0x6860             LDR      R0,[R4, #+4]
   \   00000044   0x68A1             LDR      R1,[R4, #+8]
   \   00000046   0x1808             ADDS     R0,R1,R0
   \   00000048   0x4540             CMP      R0,R8
   \   0000004A   0xD20F             BCS.N    ??NV_FlashProgramPhrase_4
   1457              {
   1458                  if((destination < pConfig->DFlashBlockBase) || \
   1459                          (endAddress > (pConfig->DFlashBlockBase + pConfig->DFlashBlockSize)))
   \                     ??NV_FlashProgramPhrase_3: (+1)
   \   0000004C   0x68E0             LDR      R0,[R4, #+12]
   \   0000004E   0x4581             CMP      R9,R0
   \   00000050   0xD304             BCC.N    ??NV_FlashProgramPhrase_5
   \   00000052   0x68E0             LDR      R0,[R4, #+12]
   \   00000054   0x6921             LDR      R1,[R4, #+16]
   \   00000056   0x1808             ADDS     R0,R1,R0
   \   00000058   0x4540             CMP      R0,R8
   \   0000005A   0xD201             BCS.N    ??NV_FlashProgramPhrase_6
   1460                  {
   1461                      /* return an error code gNV_ERR_RANGE_c */
   1462                      return(gNV_ERR_RANGE_c);
   \                     ??NV_FlashProgramPhrase_5: (+1)
   \   0000005C   0x2002             MOVS     R0,#+2
   \   0000005E   0xE03E             B.N      ??NV_FlashProgramPhrase_1
   1463                  }
   1464                  else
   1465                  {
   1466                      /* Convert System memory address to FTFx internal memory address */
   1467                      destination = destination - pConfig->DFlashBlockBase + 0x800000;
   \                     ??NV_FlashProgramPhrase_6: (+1)
   \   00000060   0x68E0             LDR      R0,[R4, #+12]
   \   00000062   0xEBB9 0x0000      SUBS     R0,R9,R0
   \   00000066   0xF510 0x0900      ADDS     R9,R0,#+8388608
   \   0000006A   0xE002             B.N      ??NV_FlashProgramPhrase_7
   1468                  }
   1469              }
   1470              else
   1471              {
   1472                  /* Convert System memory address to FTFx internal memory address */
   1473                  destination -= pConfig->PFlashBlockBase;
   \                     ??NV_FlashProgramPhrase_4: (+1)
   \   0000006C   0x6860             LDR      R0,[R4, #+4]
   \   0000006E   0xEBB9 0x0900      SUBS     R9,R9,R0
   1474              }
   1475          
   1476              while(size > 0)
   \                     ??NV_FlashProgramPhrase_7: (+1)
   \   00000072   0x2D00             CMP      R5,#+0
   \   00000074   0xD032             BEQ.N    ??NV_FlashProgramPhrase_8
   1477              {
   1478                  /* preparing passing parameter to program the flash block */
   1479                  pCommandArray[0] = gNV_PROGRAM_PHRASE_c;
   \   00000076   0x2007             MOVS     R0,#+7
   \   00000078   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1480                  pCommandArray[1] = (uint8_t)(destination >> 16);
   \   0000007C   0xEA5F 0x4019      LSRS     R0,R9,#+16
   \   00000080   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1481                  pCommandArray[2] = (uint8_t)((destination >> 8) & 0xFF);
   \   00000084   0xEA5F 0x2019      LSRS     R0,R9,#+8
   \   00000088   0xF88D 0x0002      STRB     R0,[SP, #+2]
   1482                  pCommandArray[3] = (uint8_t)(destination & 0xFF);
   \   0000008C   0x4648             MOV      R0,R9
   \   0000008E   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1483          
   1484                  pCommandArray[4] = gNV_READ8(source + 3);
   \   00000092   0x78F0             LDRB     R0,[R6, #+3]
   \   00000094   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1485                  pCommandArray[5] = gNV_READ8(source + 2);
   \   00000098   0x78B0             LDRB     R0,[R6, #+2]
   \   0000009A   0xF88D 0x0005      STRB     R0,[SP, #+5]
   1486                  pCommandArray[6] = gNV_READ8(source + 1);
   \   0000009E   0x7870             LDRB     R0,[R6, #+1]
   \   000000A0   0xF88D 0x0006      STRB     R0,[SP, #+6]
   1487                  pCommandArray[7] = gNV_READ8(source);
   \   000000A4   0x7830             LDRB     R0,[R6, #+0]
   \   000000A6   0xF88D 0x0007      STRB     R0,[SP, #+7]
   1488                  pCommandArray[8] = gNV_READ8(source + 7);
   \   000000AA   0x79F0             LDRB     R0,[R6, #+7]
   \   000000AC   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1489                  pCommandArray[9] = gNV_READ8(source + 6);
   \   000000B0   0x79B0             LDRB     R0,[R6, #+6]
   \   000000B2   0xF88D 0x0009      STRB     R0,[SP, #+9]
   1490                  pCommandArray[10] = gNV_READ8(source + 5);
   \   000000B6   0x7970             LDRB     R0,[R6, #+5]
   \   000000B8   0xF88D 0x000A      STRB     R0,[SP, #+10]
   1491                  pCommandArray[11] = gNV_READ8(source + 4);
   \   000000BC   0x7930             LDRB     R0,[R6, #+4]
   \   000000BE   0xF88D 0x000B      STRB     R0,[SP, #+11]
   1492          
   1493                  /* calling flash command sequence function to execute the command */
   1494                  returnCode = NvFlashCommandSequence(pConfig, 11, pCommandArray);
   \   000000C2   0xAA00             ADD      R2,SP,#+0
   \   000000C4   0x210B             MOVS     R1,#+11
   \   000000C6   0x0020             MOVS     R0,R4
   \   000000C8   0x.... 0x....      BL       NvFlashCommandSequence
   \   000000CC   0x0007             MOVS     R7,R0
   1495          
   1496                  /* checking for the success of command execution */
   1497                  if(gNV_OK_c != returnCode)
   \   000000CE   0x2F00             CMP      R7,#+0
   \   000000D0   0xD104             BNE.N    ??NV_FlashProgramPhrase_8
   1498                  {
   1499                      break;
   1500                  }
   1501          
   1502                  /* update destination address for next iteration */
   1503                  destination += gNV_PHRASE_SIZE_c;
   \                     ??NV_FlashProgramPhrase_9: (+1)
   \   000000D2   0xF119 0x0908      ADDS     R9,R9,#+8
   1504                  /* update size for next iteration */
   1505                  size -= gNV_PHRASE_SIZE_c;
   \   000000D6   0x3D08             SUBS     R5,R5,#+8
   1506                  /* increment the source address by 1 */
   1507                  source += gNV_PHRASE_SIZE_c;
   \   000000D8   0x3608             ADDS     R6,R6,#+8
   \   000000DA   0xE7CA             B.N      ??NV_FlashProgramPhrase_7
   1508              }
   1509          
   1510              return(returnCode);
   \                     ??NV_FlashProgramPhrase_8: (+1)
   \   000000DC   0x0038             MOVS     R0,R7
   \                     ??NV_FlashProgramPhrase_1: (+1)
   \   000000DE   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
   1511          }
   1512          
   1513          
   1514          /************************************************************************
   1515           *
   1516           *  Function Name    : NV_FlashReadOnce
   1517           *  Description      : This function is used to read access to a reserved
   1518           *                     64 byte field located in the P-Flash IFR.
   1519           *  Arguments        : [IN] pConfig - pointer to NV configuration
   1520           *                     [IN] pDataArray - pointer to location where read data
   1521           *                                       will be placed
   1522           *  Return Value     : uint32_t
   1523           *
   1524           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1525          uint32_t NV_FlashReadOnce
   1526          (
   1527                  pNvConfig_t pConfig,
   1528                  uint8_t* pDataArray
   1529          )
   1530          {
   \                     NV_FlashReadOnce: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   1531              uint8_t  counter;          /* outer loop counter */
   1532              uint8_t  pCommandArray[2]; /* command sequence array */
   1533              uint32_t returnCode;       /* return code variable */
   1534              uint8_t  i;                /* variable to store record number index */
   1535          
   1536              /* initialize counter and returnCode */
   1537              counter = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0006             MOVS     R6,R0
   1538          
   1539              /* set the default return code as gNV_OK_c */
   1540              returnCode = gNV_OK_c;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x0007             MOVS     R7,R0
   1541              /* calculate record number index */
   1542              i = 64/(gNV_RDONCE_INDEX_MAX_c + 1);
   \   00000012   0x2004             MOVS     R0,#+4
   \   00000014   0x4680             MOV      R8,R0
   1543              /* preparing passing parameter for read once command */
   1544              /* 1st element for the FCCOB register */
   1545              pCommandArray[0] = gNV_READ_ONCE_c;
   \   00000016   0x2041             MOVS     R0,#+65
   \   00000018   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1546          
   1547              while (counter <= gNV_RDONCE_INDEX_MAX_c)
   \                     ??NV_FlashReadOnce_0: (+1)
   \   0000001C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001E   0x2E10             CMP      R6,#+16
   \   00000020   0xDA2B             BGE.N    ??NV_FlashReadOnce_1
   1548              {
   1549                  /* 2nd element for the FCCOB register */
   1550                  pCommandArray[1] = counter;
   \   00000022   0xF88D 0x6001      STRB     R6,[SP, #+1]
   1551          
   1552                  /* calling flash command sequence API to execute the command */
   1553                  returnCode = NvFlashCommandSequence(pConfig, 1, pCommandArray);
   \   00000026   0xAA00             ADD      R2,SP,#+0
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       NvFlashCommandSequence
   \   00000030   0x0007             MOVS     R7,R0
   1554          
   1555                  /* checking for the success of command execution */
   1556                  if(gNV_OK_c != returnCode)
   \   00000032   0x2F00             CMP      R7,#+0
   \   00000034   0xD121             BNE.N    ??NV_FlashReadOnce_1
   1557                  {
   1558                      break;
   1559                  }
   1560          
   1561                  /* Read the data from the FCCOB registers into the pDataArray */
   1562                  pDataArray[counter*i] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB4_OFFSET_c);
   \                     ??NV_FlashReadOnce_2: (+1)
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000003C   0xFB08 0x5006      MLA      R0,R8,R6,R5
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x7AC9             LDRB     R1,[R1, #+11]
   \   00000044   0x7001             STRB     R1,[R0, #+0]
   1563                  pDataArray[counter*i + 1] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB5_OFFSET_c);
   \   00000046   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000048   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000004C   0xFB08 0x5006      MLA      R0,R8,R6,R5
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x7A89             LDRB     R1,[R1, #+10]
   \   00000054   0x7041             STRB     R1,[R0, #+1]
   1564                  pDataArray[counter*i + 2] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB6_OFFSET_c);
   \   00000056   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000058   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000005C   0xFB08 0x5006      MLA      R0,R8,R6,R5
   \   00000060   0x6821             LDR      R1,[R4, #+0]
   \   00000062   0x7A49             LDRB     R1,[R1, #+9]
   \   00000064   0x7081             STRB     R1,[R0, #+2]
   1565                  pDataArray[counter*i + 3] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB7_OFFSET_c);
   \   00000066   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000068   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000006C   0xFB08 0x5006      MLA      R0,R8,R6,R5
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x7A09             LDRB     R1,[R1, #+8]
   \   00000074   0x70C1             STRB     R1,[R0, #+3]
   1566          #if ((gNV_512K_512K_16K_4K_4K_c == gNV_Derivative_c) || (gNV_1024K_0K_16K_4K_0K_c == gNV_Derivative_c))
   1567                  pDataArray[counter*i + 4] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB8_OFFSET_c);
   1568                  pDataArray[counter*i + 5] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB9_OFFSET_c);
   1569                  pDataArray[counter*i + 6] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOBA_OFFSET_c);
   1570                  pDataArray[counter*i + 7] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOBB_OFFSET_c);
   1571          #endif
   1572                  counter++;
   \   00000076   0x1C76             ADDS     R6,R6,#+1
   \   00000078   0xE7D0             B.N      ??NV_FlashReadOnce_0
   1573              }
   1574          
   1575              return(returnCode);
   \                     ??NV_FlashReadOnce_1: (+1)
   \   0000007A   0x0038             MOVS     R0,R7
   \   0000007C   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   1576          }
   1577          
   1578          
   1579          /************************************************************************
   1580           *
   1581           *  Function Name    : NV_FlashReadResource
   1582           *  Description      : This function is provided for the user to read data
   1583           *                     from P-Flash IFR and D-Flash IFR space.
   1584           *  Arguments        :[IN] pConfig - pointer to NV configuration
   1585           *                    [IN] destination - destination address
   1586           *                    [IN] pDataArray - pointer to location where read data
   1587           *                                      will be placed
   1588           *  Return Value     : uint32_t
   1589           *
   1590           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1591          uint32_t NV_FlashReadResource
   1592          (
   1593                  pNvConfig_t pConfig,
   1594                  uint32_t destination,
   1595                  uint8_t* pDataArray
   1596          )
   1597          {
   \                     NV_FlashReadResource: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0015             MOVS     R5,R2
   1598              uint8_t  pCommandArray[9]; /* command sequence array */
   1599              uint32_t returnCode;       /* return code variable */
   1600          
   1601              /* set the default return code as gNV_OK_c */
   1602              returnCode = gNV_OK_c;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0006             MOVS     R6,R0
   1603          
   1604              /* check if the destination is longword aligned or not */
   1605              if (0 != destination % gNV_RDRSRC_ALIGN_SIZE_c)
   \   0000000C   0x2004             MOVS     R0,#+4
   \   0000000E   0xFBB7 0xF1F0      UDIV     R1,R7,R0
   \   00000012   0xFB01 0x7110      MLS      R1,R1,R0,R7
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD002             BEQ.N    ??NV_FlashReadResource_0
   1606              {
   1607                  /* return an error code gNV_ERR_ADDR */
   1608                  return(gNV_ERR_ADDR_c);
   \   0000001A   0xF44F 0x7080      MOV      R0,#+256
   \   0000001E   0xE03E             B.N      ??NV_FlashReadResource_1
   1609              }
   1610          
   1611              /* check for valid range of the target addresses */
   1612              if((destination < ( pConfig->PFlashBlockBase + gNV_PFLASH_IFR_OFFSET_c )) || \
   1613                      (destination >= ( pConfig->PFlashBlockBase + gNV_PFLASH_IFR_SIZE_c )))
   \                     ??NV_FlashReadResource_0: (+1)
   \   00000020   0x6860             LDR      R0,[R4, #+4]
   \   00000022   0x4287             CMP      R7,R0
   \   00000024   0xD304             BCC.N    ??NV_FlashReadResource_2
   \   00000026   0x6860             LDR      R0,[R4, #+4]
   \   00000028   0xF510 0x7080      ADDS     R0,R0,#+256
   \   0000002C   0x4287             CMP      R7,R0
   \   0000002E   0xD30E             BCC.N    ??NV_FlashReadResource_3
   1614              {
   1615                  if((destination < ( pConfig->DFlashBlockBase + gNV_DFLASH_IFR_OFFSET_c )) || \
   1616                          (destination >= ( pConfig->DFlashBlockBase + gNV_DFLASH_IFR_SIZE_c )))
   \                     ??NV_FlashReadResource_2: (+1)
   \   00000030   0x68E0             LDR      R0,[R4, #+12]
   \   00000032   0x1E40             SUBS     R0,R0,#+1
   \   00000034   0x4287             CMP      R7,R0
   \   00000036   0xD303             BCC.N    ??NV_FlashReadResource_4
   \   00000038   0x68E0             LDR      R0,[R4, #+12]
   \   0000003A   0x1E40             SUBS     R0,R0,#+1
   \   0000003C   0x4287             CMP      R7,R0
   \   0000003E   0xD301             BCC.N    ??NV_FlashReadResource_5
   1617                  {
   1618                      /* return an error code gNV_ERR_RANGE_c */
   1619                      return(gNV_ERR_RANGE_c);
   \                     ??NV_FlashReadResource_4: (+1)
   \   00000040   0x2002             MOVS     R0,#+2
   \   00000042   0xE02C             B.N      ??NV_FlashReadResource_1
   1620                  }
   1621                  else
   1622                  {
   1623                      /* Convert System memory address to FTFx internal memory address */
   1624                      destination = destination - pConfig->DFlashBlockBase + 0x800000;
   \                     ??NV_FlashReadResource_5: (+1)
   \   00000044   0x68E0             LDR      R0,[R4, #+12]
   \   00000046   0x1A38             SUBS     R0,R7,R0
   \   00000048   0xF510 0x0700      ADDS     R7,R0,#+8388608
   \   0000004C   0xE001             B.N      ??NV_FlashReadResource_6
   1625                  }
   1626              }
   1627              else
   1628              {
   1629                  /* Convert System memory address to FTFx internal memory address */
   1630                  destination -= pConfig->PFlashBlockBase;
   \                     ??NV_FlashReadResource_3: (+1)
   \   0000004E   0x6860             LDR      R0,[R4, #+4]
   \   00000050   0x1A3F             SUBS     R7,R7,R0
   1631              }
   1632          
   1633              /* preparing passing parameter for read resource command */
   1634              /* 1st element for the FCCOB register */
   1635              pCommandArray[0] = gNV_READ_RESOURCE_c;
   \                     ??NV_FlashReadResource_6: (+1)
   \   00000052   0x2003             MOVS     R0,#+3
   \   00000054   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1636              pCommandArray[1] = (uint8_t)(destination >> 16);
   \   00000058   0x0C38             LSRS     R0,R7,#+16
   \   0000005A   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1637              pCommandArray[2] = (uint8_t)((destination >> 8) & 0xFF);
   \   0000005E   0x0A38             LSRS     R0,R7,#+8
   \   00000060   0xF88D 0x0002      STRB     R0,[SP, #+2]
   1638              pCommandArray[3] = (uint8_t)(destination & 0xFF);
   \   00000064   0x0038             MOVS     R0,R7
   \   00000066   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1639          #if ((gNV_512K_512K_16K_4K_4K_c == gNV_Derivative_c) || (gNV_1024K_0K_16K_4K_0K_c == gNV_Derivative_c))
   1640              pCommandArray[4] = 0x00;
   1641              /* calling flash command sequence API to execute the command */
   1642              returnCode = NvFlashCommandSequence(pConfig, 4, pCommandArray);
   1643          #else
   1644              pCommandArray[8] = 0x00;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1645              /* calling flash command sequence API to execute the command */
   1646              returnCode = NvFlashCommandSequence(pConfig, 8, pCommandArray);
   \   00000070   0xAA00             ADD      R2,SP,#+0
   \   00000072   0x2108             MOVS     R1,#+8
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       NvFlashCommandSequence
   \   0000007A   0x0006             MOVS     R6,R0
   1647          #endif
   1648          
   1649              /* checking for the success of command execution */
   1650              if(gNV_OK_c != returnCode)
   \   0000007C   0x2E00             CMP      R6,#+0
   \   0000007E   0xD001             BEQ.N    ??NV_FlashReadResource_7
   1651              {
   1652                  return(returnCode);
   \   00000080   0x0030             MOVS     R0,R6
   \   00000082   0xE00C             B.N      ??NV_FlashReadResource_1
   1653              }
   1654          
   1655              /* Read the data from the FCCOB registers into the pDataArray */
   1656              pDataArray[0] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB4_OFFSET_c);
   \                     ??NV_FlashReadResource_7: (+1)
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000088   0x7028             STRB     R0,[R5, #+0]
   1657              pDataArray[1] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB5_OFFSET_c);
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x7A80             LDRB     R0,[R0, #+10]
   \   0000008E   0x7068             STRB     R0,[R5, #+1]
   1658              pDataArray[2] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB6_OFFSET_c);
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x7A40             LDRB     R0,[R0, #+9]
   \   00000094   0x70A8             STRB     R0,[R5, #+2]
   1659              pDataArray[3] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB7_OFFSET_c);
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x7A00             LDRB     R0,[R0, #+8]
   \   0000009A   0x70E8             STRB     R0,[R5, #+3]
   1660          #if ((gNV_512K_512K_16K_4K_4K_c == gNV_Derivative_c) || (gNV_1024K_0K_16K_4K_0K_c == gNV_Derivative_c))
   1661              pDataArray[4] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB8_OFFSET_c);
   1662              pDataArray[5] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB9_OFFSET_c);
   1663              pDataArray[6] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOBA_OFFSET_c);
   1664              pDataArray[7] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOBB_OFFSET_c);
   1665          #endif
   1666          
   1667              return(returnCode);
   \   0000009C   0x0030             MOVS     R0,R6
   \                     ??NV_FlashReadResource_1: (+1)
   \   0000009E   0xBDFE             POP      {R1-R7,PC}       ;; return
   1668          }
   1669          
   1670          
   1671          /************************************************************************
   1672           *
   1673           *  Function Name    : NV_FlashSecurityBypass
   1674           *  Description      : If the MCU is secured state, this function will
   1675           *                     unsecure the MCU by comparing the provided backdoor
   1676           *                     key with ones in the Flash Configuration Field.
   1677           *  Arguments        : [IN] pConfig - pointer to NV configuration
   1678           *                     [IN] keyBuffer - pointer to a location where the key
   1679           *                                      is stored
   1680           *  Return Value     : uint32_t
   1681           *
   1682           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1683          uint32_t NV_FlashSecurityBypass
   1684          (
   1685                  pNvConfig_t pConfig,
   1686                  uint8_t* keyBuffer
   1687          )
   1688          {
   \                     NV_FlashSecurityBypass: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1689              uint8_t pCommandArray[12]; /* command sequence array */
   1690              uint8_t registerValue;    /* registerValue */
   1691              uint32_t returnCode;      /* return code variable */
   1692          
   1693              /* set the default return code as gNV_OK_c */
   1694              returnCode = gNV_OK_c;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x0007             MOVS     R7,R0
   1695          
   1696              /*Get flash security register value */
   1697              registerValue = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FSEC_OFFSET_c);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x7880             LDRB     R0,[R0, #+2]
   \   0000000E   0x0006             MOVS     R6,R0
   1698          
   1699              if (0x02 != (registerValue & 0x03))
   \   00000010   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000012   0xF016 0x0003      ANDS     R0,R6,#0x3
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD020             BEQ.N    ??NV_FlashSecurityBypass_0
   1700              {
   1701                  /* preparing passing parameter to erase a flash block */
   1702                  pCommandArray[0] = gNV_SECURITY_BY_PASS_c;
   \   0000001A   0x2045             MOVS     R0,#+69
   \   0000001C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1703                  pCommandArray[4] = keyBuffer[0];
   \   00000020   0x7828             LDRB     R0,[R5, #+0]
   \   00000022   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1704                  pCommandArray[5] = keyBuffer[1];
   \   00000026   0x7868             LDRB     R0,[R5, #+1]
   \   00000028   0xF88D 0x0005      STRB     R0,[SP, #+5]
   1705                  pCommandArray[6] = keyBuffer[2];
   \   0000002C   0x78A8             LDRB     R0,[R5, #+2]
   \   0000002E   0xF88D 0x0006      STRB     R0,[SP, #+6]
   1706                  pCommandArray[7] = keyBuffer[3];
   \   00000032   0x78E8             LDRB     R0,[R5, #+3]
   \   00000034   0xF88D 0x0007      STRB     R0,[SP, #+7]
   1707                  pCommandArray[8] = keyBuffer[4];
   \   00000038   0x7928             LDRB     R0,[R5, #+4]
   \   0000003A   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1708                  pCommandArray[9] = keyBuffer[5];
   \   0000003E   0x7968             LDRB     R0,[R5, #+5]
   \   00000040   0xF88D 0x0009      STRB     R0,[SP, #+9]
   1709                  pCommandArray[10] = keyBuffer[6];
   \   00000044   0x79A8             LDRB     R0,[R5, #+6]
   \   00000046   0xF88D 0x000A      STRB     R0,[SP, #+10]
   1710                  pCommandArray[11] = keyBuffer[7];
   \   0000004A   0x79E8             LDRB     R0,[R5, #+7]
   \   0000004C   0xF88D 0x000B      STRB     R0,[SP, #+11]
   1711          
   1712                  /* calling flash command sequence function to execute the command */
   1713                  returnCode = NvFlashCommandSequence(pConfig, 11, pCommandArray);
   \   00000050   0xAA00             ADD      R2,SP,#+0
   \   00000052   0x210B             MOVS     R1,#+11
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x.... 0x....      BL       NvFlashCommandSequence
   \   0000005A   0x0007             MOVS     R7,R0
   1714              }
   1715          
   1716              return(returnCode);
   \                     ??NV_FlashSecurityBypass_0: (+1)
   \   0000005C   0x0038             MOVS     R0,R7
   \   0000005E   0xBDFE             POP      {R1-R7,PC}       ;; return
   1717          }
   1718          
   1719          
   1720          /************************************************************************
   1721           *
   1722           *  Function Name    : NV_FlashSetInterruptEnable
   1723           *  Description      : This function sets the Flash interrupt enable
   1724           *                     bits in the Flash module configuration register.
   1725           *                     Other bits in the FCNFG register wont be affected.
   1726           *  Arguments        : [IN] pConfig - pointer to NV configuration
   1727           *                     [IN] interruptState - interrupt state to be set
   1728           *  Return Value     : uint32_t
   1729           *
   1730           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1731          uint32_t NV_FlashSetInterruptEnable
   1732          (
   1733                  pNvConfig_t pConfig,
   1734                  uint8_t interruptState
   1735          )
   1736          {
   \                     NV_FlashSetInterruptEnable: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   1737              /* store data read from flash register */
   1738              uint8_t  registerValue;
   1739          
   1740              /* Mask off unused bits in interruptState */
   1741              interruptState &= (gNV_FCNFG_CCIE_c | gNV_FCNFG_RDCOLLIE_c);
   \   00000002   0xF011 0x01C0      ANDS     R1,R1,#0xC0
   1742          
   1743              /*Get flash configuration register value */
   1744              registerValue = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCNFG_OFFSET_c);
   \   00000006   0x6810             LDR      R0,[R2, #+0]
   \   00000008   0x7840             LDRB     R0,[R0, #+1]
   \   0000000A   0x0003             MOVS     R3,R0
   1745          
   1746              /* Set register value with desired interrupt state */
   1747              registerValue &= ~(gNV_FCNFG_CCIE_c | gNV_FCNFG_CCIE_c);
   \   0000000C   0xF013 0x037F      ANDS     R3,R3,#0x7F
   1748              registerValue |= interruptState;
   \   00000010   0x430B             ORRS     R3,R1,R3
   1749              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCNFG_OFFSET_c, registerValue);
   \   00000012   0x6810             LDR      R0,[R2, #+0]
   \   00000014   0x7043             STRB     R3,[R0, #+1]
   1750          
   1751              return(gNV_OK_c);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR               ;; return
   1752          }
   1753          
   1754          
   1755          /************************************************************************
   1756           *
   1757           *  Function Name    : NV_FlashVerifyAllBlock
   1758           *  Description      : This function will check to see if the P-Flash
   1759           *                     and D-Flash blocks as well as EERAM, E-Flash records
   1760           *                     and D-Flash IFR have been erased to the specified read
   1761           *                     margin level, if applicable, and will release security
   1762           *                     if the readout passes.
   1763           *  Arguments        : [IN] pConfig - pointer to NV configuration
   1764           *                     [IN] marginLevel - margin level
   1765           *  Return Value     : uint32_t
   1766           *
   1767           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1768          uint32_t NV_FlashVerifyAllBlock
   1769          (
   1770                  pNvConfig_t pConfig,
   1771                  uint8_t marginLevel
   1772          )
   1773          {
   \                     NV_FlashVerifyAllBlock: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1774              uint8_t pCommandArray[2]; /* command sequence array */
   1775              uint32_t returnCode;      /* return code variable */
   1776          
   1777              /* set the default return code as gNV_OK_c */
   1778              returnCode = gNV_OK_c;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0006             MOVS     R6,R0
   1779          
   1780              /* preparing passing parameter to verify all block command*/
   1781              pCommandArray[0] = gNV_VERIFY_ALL_BLOCK_c;
   \   0000000C   0x2040             MOVS     R0,#+64
   \   0000000E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1782              pCommandArray[1] = marginLevel;
   \   00000012   0xF88D 0x5001      STRB     R5,[SP, #+1]
   1783          
   1784              /* calling flash command sequence function to execute the command */
   1785              returnCode = NvFlashCommandSequence(pConfig, 1, pCommandArray);
   \   00000016   0xAA00             ADD      R2,SP,#+0
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       NvFlashCommandSequence
   \   00000020   0x0006             MOVS     R6,R0
   1786          
   1787              return(returnCode);
   \   00000022   0x0030             MOVS     R0,R6
   \   00000024   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1788          }
   1789          
   1790          
   1791          /************************************************************************
   1792           *
   1793           *  Function Name    : NV_FlashVerifyBlock
   1794           *  Description      : This function will check to see if an entire
   1795           *                     P-Flash or D-Flash block has been erased to the
   1796           *                     specified margin level.
   1797           *  Arguments        : [IN] pConfig - pointer to NV configuration
   1798           *                     [IN] destination - destination address
   1799           *                     [IN] marginLevel - margin level
   1800           *  Return Value     : uint32_t
   1801           *
   1802           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1803          uint32_t NV_FlashVerifyBlock
   1804          (
   1805                  pNvConfig_t pConfig,
   1806                  uint32_t destination,
   1807                  uint8_t marginLevel
   1808          )
   1809          {
   \                     NV_FlashVerifyBlock: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x0015             MOVS     R5,R2
   1810              uint8_t pCommandArray[5]; /* command sequence array */
   1811              uint32_t returnCode;      /* return code variable */
   1812          
   1813              /* set the default return code as gNV_OK_c */
   1814              returnCode = gNV_OK_c;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0006             MOVS     R6,R0
   1815          
   1816              /* check if the destination is longword aligned or not */
   1817              if (0 != (destination % gNV_RD1BLK_ALIGN_SIZE_c))
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0xFBB7 0xF1F0      UDIV     R1,R7,R0
   \   00000014   0xFB01 0x7110      MLS      R1,R1,R0,R7
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD002             BEQ.N    ??NV_FlashVerifyBlock_0
   1818              {
   1819                  /* return an error code gNV_ERR_ADDR */
   1820                  return(gNV_ERR_ADDR_c);
   \   0000001C   0xF44F 0x7080      MOV      R0,#+256
   \   00000020   0xE02D             B.N      ??NV_FlashVerifyBlock_1
   1821              }
   1822          
   1823              /* check for valid range of the target addresses */
   1824              if((destination < pConfig->PFlashBlockBase) || \
   1825                      (destination >= (pConfig->PFlashBlockBase + pConfig->PFlashBlockSize)))
   \                     ??NV_FlashVerifyBlock_0: (+1)
   \   00000022   0x6860             LDR      R0,[R4, #+4]
   \   00000024   0x4287             CMP      R7,R0
   \   00000026   0xD304             BCC.N    ??NV_FlashVerifyBlock_2
   \   00000028   0x6860             LDR      R0,[R4, #+4]
   \   0000002A   0x68A1             LDR      R1,[R4, #+8]
   \   0000002C   0x1808             ADDS     R0,R1,R0
   \   0000002E   0x4287             CMP      R7,R0
   \   00000030   0xD30E             BCC.N    ??NV_FlashVerifyBlock_3
   1826              {
   1827                  if((destination < pConfig->DFlashBlockBase) || \
   1828                          (destination >= (pConfig->DFlashBlockBase + pConfig->DFlashBlockSize)))
   \                     ??NV_FlashVerifyBlock_2: (+1)
   \   00000032   0x68E0             LDR      R0,[R4, #+12]
   \   00000034   0x4287             CMP      R7,R0
   \   00000036   0xD304             BCC.N    ??NV_FlashVerifyBlock_4
   \   00000038   0x68E0             LDR      R0,[R4, #+12]
   \   0000003A   0x6921             LDR      R1,[R4, #+16]
   \   0000003C   0x1808             ADDS     R0,R1,R0
   \   0000003E   0x4287             CMP      R7,R0
   \   00000040   0xD301             BCC.N    ??NV_FlashVerifyBlock_5
   1829                  {
   1830                      /* return an error code gNV_ERR_RANGE_c */
   1831                      return(gNV_ERR_RANGE_c);
   \                     ??NV_FlashVerifyBlock_4: (+1)
   \   00000042   0x2002             MOVS     R0,#+2
   \   00000044   0xE01B             B.N      ??NV_FlashVerifyBlock_1
   1832                  }
   1833                  else
   1834                  {
   1835                      /* Convert System memory address to FTFx internal memory address */
   1836                      destination = destination - pConfig->DFlashBlockBase + 0x800000;
   \                     ??NV_FlashVerifyBlock_5: (+1)
   \   00000046   0x68E0             LDR      R0,[R4, #+12]
   \   00000048   0x1A38             SUBS     R0,R7,R0
   \   0000004A   0xF510 0x0700      ADDS     R7,R0,#+8388608
   \   0000004E   0xE001             B.N      ??NV_FlashVerifyBlock_6
   1837                  }
   1838              }
   1839              else
   1840              {
   1841                  /* Convert System memory address to FTFx internal memory address */
   1842                  destination -= pConfig->PFlashBlockBase;
   \                     ??NV_FlashVerifyBlock_3: (+1)
   \   00000050   0x6860             LDR      R0,[R4, #+4]
   \   00000052   0x1A3F             SUBS     R7,R7,R0
   1843              }
   1844          
   1845              /* preparing passing parameter to verify block command */
   1846              pCommandArray[0] = gNV_VERIFY_BLOCK_c;
   \                     ??NV_FlashVerifyBlock_6: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1847              pCommandArray[1] = (uint8_t)(destination >> 16);
   \   0000005A   0x0C38             LSRS     R0,R7,#+16
   \   0000005C   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1848              pCommandArray[2] = (uint8_t)((destination >> 8) & 0xFF);
   \   00000060   0x0A38             LSRS     R0,R7,#+8
   \   00000062   0xF88D 0x0002      STRB     R0,[SP, #+2]
   1849              pCommandArray[3] = (uint8_t)(destination & 0xFF);
   \   00000066   0x0038             MOVS     R0,R7
   \   00000068   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1850              pCommandArray[4] = marginLevel;
   \   0000006C   0xF88D 0x5004      STRB     R5,[SP, #+4]
   1851          
   1852              /* calling flash command sequence function to execute the command */
   1853              returnCode = NvFlashCommandSequence(pConfig, 4, pCommandArray);
   \   00000070   0xAA00             ADD      R2,SP,#+0
   \   00000072   0x2104             MOVS     R1,#+4
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       NvFlashCommandSequence
   \   0000007A   0x0006             MOVS     R6,R0
   1854          
   1855              return(returnCode);
   \   0000007C   0x0030             MOVS     R0,R6
   \                     ??NV_FlashVerifyBlock_1: (+1)
   \   0000007E   0xBDFE             POP      {R1-R7,PC}       ;; return
   1856          }
   1857          
   1858          
   1859          /************************************************************************
   1860           *
   1861           *  Function Name    : NV_FlashVerifySection
   1862           *  Description      : This function will check to see if a section of
   1863           *                     P-Flash or D-Flash memory is erased to the specified
   1864           *                     read margin level.
   1865           *  Arguments        : [IN] pConfig - pointer to NV configuration
   1866           *                     [IN] destination - destination address
   1867           *                     [IN] Length - number of bytes to be verified
   1868           *                     [IN] marginLevel - margin level
   1869           *  Return Value     : uint32_t
   1870           *
   1871           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1872          uint32_t NV_FlashVerifySection
   1873          (
   1874                  pNvConfig_t pConfig,
   1875                  uint32_t destination,
   1876                  uint16_t Length,
   1877                  uint8_t marginLevel
   1878          )
   1879          {
   \                     NV_FlashVerifySection: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4692             MOV      R10,R2
   \   0000000A   0x001D             MOVS     R5,R3
   1880              uint8_t pCommandArray[7]; /* command sequence array */
   1881              uint32_t returnCode;      /* return code variable */
   1882              uint32_t endAddress;      /* storing end address. This is the starting point of the next block */
   1883              uint8_t misalignedBytes;
   1884              uint16_t Number;
   1885              uint8_t alignSize;
   1886          
   1887              /* set the default return code as gNV_OK_c */
   1888              returnCode = gNV_OK_c;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x0006             MOVS     R6,R0
   1889          
   1890              /* check for valid range of the destination */
   1891              if((destination >= pConfig->PFlashBlockBase) && \
   1892                      (destination < (pConfig->PFlashBlockBase + pConfig->PFlashBlockSize)))
   \   00000010   0x6860             LDR      R0,[R4, #+4]
   \   00000012   0x4580             CMP      R8,R0
   \   00000014   0xD30A             BCC.N    ??NV_FlashVerifySection_0
   \   00000016   0x6860             LDR      R0,[R4, #+4]
   \   00000018   0x68A1             LDR      R1,[R4, #+8]
   \   0000001A   0x1808             ADDS     R0,R1,R0
   \   0000001C   0x4580             CMP      R8,R0
   \   0000001E   0xD205             BCS.N    ??NV_FlashVerifySection_0
   1893              {
   1894                  /* calculating Flash end address */
   1895              	endAddress = destination + Length;
   \   00000020   0xFA18 0xF08A      UXTAH    R0,R8,R10
   \   00000024   0x4681             MOV      R9,R0
   1896                  alignSize = gNV_PRD1SEC_ALIGN_SIZE_c;
   \   00000026   0x2008             MOVS     R0,#+8
   \   00000028   0x0007             MOVS     R7,R0
   \   0000002A   0xE00F             B.N      ??NV_FlashVerifySection_1
   1897              }
   1898              else if((destination >= pConfig->DFlashBlockBase) && \
   1899                      (destination < (pConfig->DFlashBlockBase + pConfig->DFlashBlockSize)))
   \                     ??NV_FlashVerifySection_0: (+1)
   \   0000002C   0x68E0             LDR      R0,[R4, #+12]
   \   0000002E   0x4580             CMP      R8,R0
   \   00000030   0xD30A             BCC.N    ??NV_FlashVerifySection_2
   \   00000032   0x68E0             LDR      R0,[R4, #+12]
   \   00000034   0x6921             LDR      R1,[R4, #+16]
   \   00000036   0x1808             ADDS     R0,R1,R0
   \   00000038   0x4580             CMP      R8,R0
   \   0000003A   0xD205             BCS.N    ??NV_FlashVerifySection_2
   1900              {
   1901                  /* calculating Flash end address */
   1902              	endAddress = destination + Length;
   \   0000003C   0xFA18 0xF08A      UXTAH    R0,R8,R10
   \   00000040   0x4681             MOV      R9,R0
   1903                  alignSize = gNV_DRD1SEC_ALIGN_SIZE_c;    	
   \   00000042   0x2008             MOVS     R0,#+8
   \   00000044   0x0007             MOVS     R7,R0
   \   00000046   0xE001             B.N      ??NV_FlashVerifySection_1
   1904              }
   1905              else
   1906              {
   1907                  /* return an error code gNV_ERR_RANGE_c */
   1908                  return(gNV_ERR_RANGE_c);
   \                     ??NV_FlashVerifySection_2: (+1)
   \   00000048   0x2002             MOVS     R0,#+2
   \   0000004A   0xE075             B.N      ??NV_FlashVerifySection_3
   1909              }
   1910          
   1911              /* check for valid range of end address */
   1912              if((endAddress >= pConfig->PFlashBlockBase) && \
   1913                      (endAddress <= (pConfig->PFlashBlockBase + pConfig->PFlashBlockSize)))
   \                     ??NV_FlashVerifySection_1: (+1)
   \   0000004C   0x6860             LDR      R0,[R4, #+4]
   \   0000004E   0x4581             CMP      R9,R0
   \   00000050   0xD308             BCC.N    ??NV_FlashVerifySection_4
   \   00000052   0x6860             LDR      R0,[R4, #+4]
   \   00000054   0x68A1             LDR      R1,[R4, #+8]
   \   00000056   0x1808             ADDS     R0,R1,R0
   \   00000058   0x4548             CMP      R0,R9
   \   0000005A   0xD303             BCC.N    ??NV_FlashVerifySection_4
   1914              {
   1915                  /* Convert System memory address to FTFx internal memory address */
   1916                  destination -= pConfig->PFlashBlockBase;
   \   0000005C   0x6860             LDR      R0,[R4, #+4]
   \   0000005E   0xEBB8 0x0800      SUBS     R8,R8,R0
   \   00000062   0xE00F             B.N      ??NV_FlashVerifySection_5
   1917              }
   1918              else if((endAddress >= pConfig->DFlashBlockBase) || \
   1919                      (endAddress <= (pConfig->DFlashBlockBase + pConfig->DFlashBlockSize)))
   \                     ??NV_FlashVerifySection_4: (+1)
   \   00000064   0x68E0             LDR      R0,[R4, #+12]
   \   00000066   0x4581             CMP      R9,R0
   \   00000068   0xD204             BCS.N    ??NV_FlashVerifySection_6
   \   0000006A   0x68E0             LDR      R0,[R4, #+12]
   \   0000006C   0x6921             LDR      R1,[R4, #+16]
   \   0000006E   0x1808             ADDS     R0,R1,R0
   \   00000070   0x4548             CMP      R0,R9
   \   00000072   0xD305             BCC.N    ??NV_FlashVerifySection_7
   1920              {
   1921                  /* Convert System memory address to FTFx internal memory address */
   1922                  destination = destination - pConfig->DFlashBlockBase + 0x800000;
   \                     ??NV_FlashVerifySection_6: (+1)
   \   00000074   0x68E0             LDR      R0,[R4, #+12]
   \   00000076   0xEBB8 0x0000      SUBS     R0,R8,R0
   \   0000007A   0xF510 0x0800      ADDS     R8,R0,#+8388608
   \   0000007E   0xE001             B.N      ??NV_FlashVerifySection_5
   1923              }
   1924              else
   1925              {
   1926                  /* return an error code gNV_ERR_RANGE_c */
   1927                  return(gNV_ERR_RANGE_c);
   \                     ??NV_FlashVerifySection_7: (+1)
   \   00000080   0x2002             MOVS     R0,#+2
   \   00000082   0xE059             B.N      ??NV_FlashVerifySection_3
   1928              }
   1929          
   1930              /* align destination (if misaligned) and blank check the misaligned addresses */
   1931              misalignedBytes = destination - (destination & (~0x07uL));
   \                     ??NV_FlashVerifySection_5: (+1)
   \   00000084   0xF018 0x00F8      ANDS     R0,R8,#0xF8
   \   00000088   0xEBB8 0x0000      SUBS     R0,R8,R0
   \   0000008C   0x4683             MOV      R11,R0
   1932              while(misalignedBytes)
   \                     ??NV_FlashVerifySection_8: (+1)
   \   0000008E   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000092   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000096   0xD00E             BEQ.N    ??NV_FlashVerifySection_9
   1933              {
   1934                uint8_t pData;
   1935                pData = ((uint8_t)(*(vuint8_t*)(destination)));
   \   00000098   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   0000009C   0x0001             MOVS     R1,R0
   1936                if(pData != 0xFF)
   \   0000009E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A0   0x29FF             CMP      R1,#+255
   \   000000A2   0xD001             BEQ.N    ??NV_FlashVerifySection_10
   1937                {
   1938                  return(gNV_ERR_ACCERR_c);
   \   000000A4   0x2004             MOVS     R0,#+4
   \   000000A6   0xE047             B.N      ??NV_FlashVerifySection_3
   1939                }
   1940                destination++;
   \                     ??NV_FlashVerifySection_10: (+1)
   \   000000A8   0xF118 0x0801      ADDS     R8,R8,#+1
   1941                Length--;
   \   000000AC   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   1942                misalignedBytes--;
   \   000000B0   0xF1BB 0x0B01      SUBS     R11,R11,#+1
   \   000000B4   0xE7EB             B.N      ??NV_FlashVerifySection_8
   1943              }
   1944          
   1945              /* align end address (if misaligned) and blank check the misaligned addresses */
   1946              misalignedBytes = endAddress - (endAddress & (~0x07uL));
   \                     ??NV_FlashVerifySection_9: (+1)
   \   000000B6   0xF019 0x00F8      ANDS     R0,R9,#0xF8
   \   000000BA   0xEBB9 0x0000      SUBS     R0,R9,R0
   \   000000BE   0x4683             MOV      R11,R0
   1947              while(misalignedBytes)
   \                     ??NV_FlashVerifySection_11: (+1)
   \   000000C0   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000C4   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000C8   0xD00E             BEQ.N    ??NV_FlashVerifySection_12
   1948              {
   1949                uint8_t pData;
   1950                pData = ((uint8_t)(*(vuint8_t*)(endAddress)));
   \   000000CA   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   000000CE   0x0001             MOVS     R1,R0
   1951                if(pData != 0xFF)
   \   000000D0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000D2   0x29FF             CMP      R1,#+255
   \   000000D4   0xD001             BEQ.N    ??NV_FlashVerifySection_13
   1952                {
   1953                  return(gNV_ERR_ACCERR_c);
   \   000000D6   0x2004             MOVS     R0,#+4
   \   000000D8   0xE02E             B.N      ??NV_FlashVerifySection_3
   1954                }
   1955                endAddress--;
   \                     ??NV_FlashVerifySection_13: (+1)
   \   000000DA   0xF1B9 0x0901      SUBS     R9,R9,#+1
   1956                Length--;
   \   000000DE   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   1957                misalignedBytes--;
   \   000000E2   0xF1BB 0x0B01      SUBS     R11,R11,#+1
   \   000000E6   0xE7EB             B.N      ??NV_FlashVerifySection_11
   1958              }
   1959          
   1960              /* calculate the number of phrases needed by the verify section command */
   1961              Number = Length / alignSize;
   \                     ??NV_FlashVerifySection_12: (+1)
   \   000000E8   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000000EC   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000EE   0xFB9A 0xF0F7      SDIV     R0,R10,R7
   \   000000F2   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   1962          
   1963              /* preparing passing parameter to verify section command */
   1964              pCommandArray[0] = gNV_VERIFY_SECTION_c;
   \   000000F6   0x2001             MOVS     R0,#+1
   \   000000F8   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1965              pCommandArray[1] = (uint8_t)(destination >> 16);
   \   000000FC   0xEA5F 0x4018      LSRS     R0,R8,#+16
   \   00000100   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1966              pCommandArray[2] = (uint8_t)((destination >> 8) & 0xFF);
   \   00000104   0xEA5F 0x2018      LSRS     R0,R8,#+8
   \   00000108   0xF88D 0x0002      STRB     R0,[SP, #+2]
   1967              pCommandArray[3] = (uint8_t)(destination & 0xFF);
   \   0000010C   0x4640             MOV      R0,R8
   \   0000010E   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1968              pCommandArray[4] = (uint8_t)(Number >> 8);
   \   00000112   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000116   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000118   0x0A00             LSRS     R0,R0,#+8
   \   0000011A   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1969              pCommandArray[5] = (uint8_t)(Number & 0xFF);
   \   0000011E   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000122   0xF88D 0x0005      STRB     R0,[SP, #+5]
   1970              pCommandArray[6] = marginLevel;
   \   00000126   0xF88D 0x5006      STRB     R5,[SP, #+6]
   1971          
   1972              /* calling flash command sequence function to execute the command */
   1973              returnCode = NvFlashCommandSequence(pConfig, 6, pCommandArray);
   \   0000012A   0xAA00             ADD      R2,SP,#+0
   \   0000012C   0x2106             MOVS     R1,#+6
   \   0000012E   0x0020             MOVS     R0,R4
   \   00000130   0x.... 0x....      BL       NvFlashCommandSequence
   \   00000134   0x0006             MOVS     R6,R0
   1974          
   1975              return(returnCode);
   \   00000136   0x0030             MOVS     R0,R6
   \                     ??NV_FlashVerifySection_3: (+1)
   \   00000138   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   1976          }
   1977          
   1978          
   1979          /************************************************************************
   1980           *
   1981           *  Function Name    : NV_PFlashSetProtection
   1982           *  Description      : This function sets the P-Flash protection to the
   1983           *                     intended protection status
   1984           *  Arguments        : [IN] pConfig - pointer to NV configuration
   1985           *                     [IN] protectStatus - protection status to be set
   1986           *  Return Value     : uint32_t
   1987           *
   1988           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1989          uint32_t NV_PFlashSetProtection
   1990          (
   1991                  pNvConfig_t pConfig,
   1992                  uint32_t protectStatus
   1993          )
   1994          {
   \                     NV_PFlashSetProtection: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0002             MOVS     R2,R0
   1995              uint32_t registerValue;    /* store data read from flash register */
   1996              uint32_t returnCode;       /* return code variable */
   1997              uint32_t temp;
   1998              uint32_t registerValue0;
   1999              uint32_t registerValue1;
   2000              uint32_t registerValue2;
   2001              uint32_t registerValue3;
   2002          
   2003              /* set the default return as gNV_OK_c */
   2004              returnCode = gNV_OK_c;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x0004             MOVS     R4,R0
   2005              /* check CCIF bit of the flash status register, it's impossible to write to FPROT if command is in progress */
   2006              if(FALSE == (gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c)))
   \   0000000A   0x6810             LDR      R0,[R2, #+0]
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x0600             LSLS     R0,R0,#+24
   \   00000010   0xD401             BMI.N    ??NV_PFlashSetProtection_0
   2007              {
   2008                  return(gNV_ERR_CHANGEPROT_c);
   \   00000012   0x2020             MOVS     R0,#+32
   \   00000014   0xE093             B.N      ??NV_PFlashSetProtection_1
   2009              }
   2010              /* Read the value of FPPROT registers */
   2011              registerValue0=(uint32_t)(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FPROT0_OFFSET_c));
   \                     ??NV_PFlashSetProtection_0: (+1)
   \   00000016   0x6810             LDR      R0,[R2, #+0]
   \   00000018   0x7CC0             LDRB     R0,[R0, #+19]
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x0006             MOVS     R6,R0
   2012              registerValue1=(uint32_t)(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FPROT1_OFFSET_c));
   \   0000001E   0x6810             LDR      R0,[R2, #+0]
   \   00000020   0x7C80             LDRB     R0,[R0, #+18]
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0x0007             MOVS     R7,R0
   2013              registerValue2=(uint32_t)(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FPROT2_OFFSET_c));
   \   00000026   0x6810             LDR      R0,[R2, #+0]
   \   00000028   0x7C40             LDRB     R0,[R0, #+17]
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x4684             MOV      R12,R0
   2014              registerValue3=(uint32_t)(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FPROT3_OFFSET_c));
   \   0000002E   0x6810             LDR      R0,[R2, #+0]
   \   00000030   0x7C00             LDRB     R0,[R0, #+16]
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x4686             MOV      LR,R0
   2015          
   2016              registerValue = ((registerValue0 << 24 ) | \
   2017                      (registerValue1 << 16 ) | \
   2018                      (registerValue2 << 8 ) | \
   2019                      registerValue3);
   \   00000036   0x0438             LSLS     R0,R7,#+16
   \   00000038   0xEA50 0x6006      ORRS     R0,R0,R6, LSL #+24
   \   0000003C   0xEA50 0x200C      ORRS     R0,R0,R12, LSL #+8
   \   00000040   0xEA5E 0x0000      ORRS     R0,LR,R0
   \   00000044   0x0003             MOVS     R3,R0
   2020          
   2021              /* Check if normal mode */
   2022              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FPROT0_OFFSET_c, 0xFF);
   \   00000046   0x20FF             MOVS     R0,#+255
   \   00000048   0xF8D2 0x8000      LDR      R8,[R2, #+0]
   \   0000004C   0xF888 0x0013      STRB     R0,[R8, #+19]
   2023              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FPROT1_OFFSET_c, 0xFF);
   \   00000050   0x20FF             MOVS     R0,#+255
   \   00000052   0xF8D2 0x8000      LDR      R8,[R2, #+0]
   \   00000056   0xF888 0x0012      STRB     R0,[R8, #+18]
   2024              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FPROT2_OFFSET_c, 0xFF);
   \   0000005A   0x20FF             MOVS     R0,#+255
   \   0000005C   0xF8D2 0x8000      LDR      R8,[R2, #+0]
   \   00000060   0xF888 0x0011      STRB     R0,[R8, #+17]
   2025              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FPROT3_OFFSET_c, 0xFF);
   \   00000064   0x20FF             MOVS     R0,#+255
   \   00000066   0xF8D2 0x8000      LDR      R8,[R2, #+0]
   \   0000006A   0xF888 0x0010      STRB     R0,[R8, #+16]
   2026          
   2027              /* Read the value of FPPROT registers */
   2028              registerValue0=(uint32_t)(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FPROT0_OFFSET_c));
   \   0000006E   0x6810             LDR      R0,[R2, #+0]
   \   00000070   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000074   0x0006             MOVS     R6,R0
   2029              registerValue1=(uint32_t)(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FPROT1_OFFSET_c));
   \   00000076   0x6810             LDR      R0,[R2, #+0]
   \   00000078   0x7C80             LDRB     R0,[R0, #+18]
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0x0007             MOVS     R7,R0
   2030              registerValue2=(uint32_t)(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FPROT2_OFFSET_c));
   \   0000007E   0x6810             LDR      R0,[R2, #+0]
   \   00000080   0x7C40             LDRB     R0,[R0, #+17]
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0x4684             MOV      R12,R0
   2031              registerValue3=(uint32_t)(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FPROT3_OFFSET_c));
   \   00000086   0x6810             LDR      R0,[R2, #+0]
   \   00000088   0x7C00             LDRB     R0,[R0, #+16]
   \   0000008A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008C   0x4686             MOV      LR,R0
   2032          
   2033              if((registerValue0 != 0xFF) | (registerValue1 != 0xFF) | \
   2034                      (registerValue2 != 0xFF) | (registerValue3 != 0xFF))
   \   0000008E   0x2EFF             CMP      R6,#+255
   \   00000090   0xD002             BEQ.N    ??NV_PFlashSetProtection_2
   \   00000092   0xF05F 0x0801      MOVS     R8,#+1
   \   00000096   0xE001             B.N      ??NV_PFlashSetProtection_3
   \                     ??NV_PFlashSetProtection_2: (+1)
   \   00000098   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??NV_PFlashSetProtection_3: (+1)
   \   0000009C   0x2FFF             CMP      R7,#+255
   \   0000009E   0xD002             BEQ.N    ??NV_PFlashSetProtection_4
   \   000000A0   0xF05F 0x0901      MOVS     R9,#+1
   \   000000A4   0xE001             B.N      ??NV_PFlashSetProtection_5
   \                     ??NV_PFlashSetProtection_4: (+1)
   \   000000A6   0xF05F 0x0900      MOVS     R9,#+0
   \                     ??NV_PFlashSetProtection_5: (+1)
   \   000000AA   0xF1BC 0x0FFF      CMP      R12,#+255
   \   000000AE   0xD002             BEQ.N    ??NV_PFlashSetProtection_6
   \   000000B0   0xF05F 0x0A01      MOVS     R10,#+1
   \   000000B4   0xE001             B.N      ??NV_PFlashSetProtection_7
   \                     ??NV_PFlashSetProtection_6: (+1)
   \   000000B6   0xF05F 0x0A00      MOVS     R10,#+0
   \                     ??NV_PFlashSetProtection_7: (+1)
   \   000000BA   0xF1BE 0x0FFF      CMP      LR,#+255
   \   000000BE   0xD001             BEQ.N    ??NV_PFlashSetProtection_8
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0xE000             B.N      ??NV_PFlashSetProtection_9
   \                     ??NV_PFlashSetProtection_8: (+1)
   \   000000C4   0x2000             MOVS     R0,#+0
   \                     ??NV_PFlashSetProtection_9: (+1)
   \   000000C6   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000CA   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000CE   0xEA59 0x0808      ORRS     R8,R9,R8
   \   000000D2   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000D6   0xEA5A 0x0808      ORRS     R8,R10,R8
   \   000000DA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DC   0xEA50 0x0008      ORRS     R0,R0,R8
   \   000000E0   0x2800             CMP      R0,#+0
   \   000000E2   0xD01A             BEQ.N    ??NV_PFlashSetProtection_10
   2035              {
   2036                  /* if normal mode */
   2037                  temp = protectStatus ^ registerValue;
   \   000000E4   0xEA93 0x0001      EORS     R0,R3,R1
   \   000000E8   0x0005             MOVS     R5,R0
   2038                  if(!(temp & protectStatus))
   \   000000EA   0x420D             TST      R5,R1
   \   000000EC   0xD111             BNE.N    ??NV_PFlashSetProtection_11
   2039                  {
   2040                      gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FPROT0_OFFSET_c, (uint8_t)(protectStatus >> 24));
   \   000000EE   0x0E08             LSRS     R0,R1,#+24
   \   000000F0   0xF8D2 0x8000      LDR      R8,[R2, #+0]
   \   000000F4   0xF888 0x0013      STRB     R0,[R8, #+19]
   2041                      gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FPROT1_OFFSET_c, (uint8_t)(protectStatus >> 16));
   \   000000F8   0x0C08             LSRS     R0,R1,#+16
   \   000000FA   0xF8D2 0x8000      LDR      R8,[R2, #+0]
   \   000000FE   0xF888 0x0012      STRB     R0,[R8, #+18]
   2042                      gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FPROT2_OFFSET_c, (uint8_t)(protectStatus >> 8));
   \   00000102   0x0A08             LSRS     R0,R1,#+8
   \   00000104   0xF8D2 0x8000      LDR      R8,[R2, #+0]
   \   00000108   0xF888 0x0011      STRB     R0,[R8, #+17]
   2043                      gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FPROT3_OFFSET_c, (uint8_t)protectStatus);
   \   0000010C   0x6810             LDR      R0,[R2, #+0]
   \   0000010E   0x7401             STRB     R1,[R0, #+16]
   \   00000110   0xE001             B.N      ??NV_PFlashSetProtection_12
   2044                  }
   2045                  else
   2046                  {
   2047                      returnCode = gNV_ERR_CHANGEPROT_c;
   \                     ??NV_PFlashSetProtection_11: (+1)
   \   00000112   0x2020             MOVS     R0,#+32
   \   00000114   0x0004             MOVS     R4,R0
   2048                  }
   2049                  return(returnCode);
   \                     ??NV_PFlashSetProtection_12: (+1)
   \   00000116   0x0020             MOVS     R0,R4
   \   00000118   0xE011             B.N      ??NV_PFlashSetProtection_1
   2050              }
   2051              /* if unprotected or special mode */
   2052              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FPROT0_OFFSET_c, (uint8_t)(protectStatus >> 24));
   \                     ??NV_PFlashSetProtection_10: (+1)
   \   0000011A   0x0E08             LSRS     R0,R1,#+24
   \   0000011C   0xF8D2 0x8000      LDR      R8,[R2, #+0]
   \   00000120   0xF888 0x0013      STRB     R0,[R8, #+19]
   2053              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FPROT1_OFFSET_c, (uint8_t)(protectStatus >> 16));
   \   00000124   0x0C08             LSRS     R0,R1,#+16
   \   00000126   0xF8D2 0x8000      LDR      R8,[R2, #+0]
   \   0000012A   0xF888 0x0012      STRB     R0,[R8, #+18]
   2054              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FPROT2_OFFSET_c, (uint8_t)(protectStatus >> 8));
   \   0000012E   0x0A08             LSRS     R0,R1,#+8
   \   00000130   0xF8D2 0x8000      LDR      R8,[R2, #+0]
   \   00000134   0xF888 0x0011      STRB     R0,[R8, #+17]
   2055              gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FPROT3_OFFSET_c, (uint8_t)protectStatus);
   \   00000138   0x6810             LDR      R0,[R2, #+0]
   \   0000013A   0x7401             STRB     R1,[R0, #+16]
   2056          
   2057              return(returnCode);
   \   0000013C   0x0020             MOVS     R0,R4
   \                     ??NV_PFlashSetProtection_1: (+1)
   \   0000013E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   2058          }
   2059          
   2060          
   2061          /************************************************************************
   2062           *
   2063           *  Function Name    : NV_PFlashGetProtection
   2064           *  Description      : This function retrieves current P-Flash protection status.
   2065           *  Arguments        : [IN] pConfig - pointer to NV configuration
   2066           *                     [IN] protectStatus - pointer to a memory location where
   2067           *                          the protection status will be stored
   2068           *
   2069           *  Return Value     : uint32_t
   2070           *
   2071           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2072          uint32_t NV_PFlashGetProtection
   2073          (
   2074                  pNvConfig_t pConfig,
   2075                  uint32_t* protectStatus
   2076          )
   2077          {
   \                     NV_PFlashGetProtection: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0002             MOVS     R2,R0
   2078              uint32_t registerValue0;
   2079              uint32_t registerValue1;
   2080              uint32_t registerValue2;
   2081              uint32_t registerValue3;
   2082          
   2083              registerValue0=(uint32_t)(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FPROT0_OFFSET_c));
   \   00000004   0x6810             LDR      R0,[R2, #+0]
   \   00000006   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x0003             MOVS     R3,R0
   2084              registerValue1=(uint32_t)(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FPROT1_OFFSET_c));
   \   0000000C   0x6810             LDR      R0,[R2, #+0]
   \   0000000E   0x7C80             LDRB     R0,[R0, #+18]
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x0004             MOVS     R4,R0
   2085              registerValue2=(uint32_t)(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FPROT2_OFFSET_c));
   \   00000014   0x6810             LDR      R0,[R2, #+0]
   \   00000016   0x7C40             LDRB     R0,[R0, #+17]
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x0005             MOVS     R5,R0
   2086              registerValue3=(uint32_t)(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FPROT3_OFFSET_c));
   \   0000001C   0x6810             LDR      R0,[R2, #+0]
   \   0000001E   0x7C00             LDRB     R0,[R0, #+16]
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x0006             MOVS     R6,R0
   2087          
   2088              *protectStatus = ((registerValue0 << 24 ) | \
   2089                      (registerValue1 << 16 ) | \
   2090                      (registerValue2 << 8 ) | \
   2091                      registerValue3);
   \   00000024   0x0420             LSLS     R0,R4,#+16
   \   00000026   0xEA50 0x6003      ORRS     R0,R0,R3, LSL #+24
   \   0000002A   0xEA50 0x2005      ORRS     R0,R0,R5, LSL #+8
   \   0000002E   0x4330             ORRS     R0,R6,R0
   \   00000030   0x6008             STR      R0,[R1, #+0]
   2092          
   2093              return(gNV_OK_c);
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBC70             POP      {R4-R6}
   \   00000036   0x4770             BX       LR               ;; return
   2094          }
   2095          
   2096          
   2097          /************************************************************************
   2098           *
   2099           *  Function Name    : NV_SetEEEEnable
   2100           *  Description      : This function is used to change the function of
   2101           *                     the EERAM. When not partitioned for EEE, the EERAM
   2102           *                     is typically used as traditional RAM. When partitioned
   2103           *                     for EEE, the EERAM is typically used to store EEE data.
   2104           *  Arguments        : [IN] pConfig - pointer to NV configuration
   2105           *                     [IN] EEEEnable - EERAM Enable
   2106           *  Return Value     : uint32_t
   2107           *
   2108           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2109          uint32_t NV_SetEEEEnable
   2110          (
   2111                  pNvConfig_t pConfig,
   2112                  uint8_t EEEEnable
   2113          )
   2114          {
   \                     NV_SetEEEEnable: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   2115              uint8_t pCommandArray[2]; /* command sequence array */
   2116              uint32_t returnCode;      /* return code variable */
   2117          
   2118              /* set the default return code as gNV_OK_c */
   2119              returnCode = gNV_OK_c;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0006             MOVS     R6,R0
   2120          
   2121              /* preparing passing parameter to set EEPROM Enabled command */
   2122              pCommandArray[0] = gNV_SET_EERAM_c;
   \   0000000C   0x2081             MOVS     R0,#+129
   \   0000000E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2123              pCommandArray[1] = EEEEnable;
   \   00000012   0xF88D 0x5001      STRB     R5,[SP, #+1]
   2124          
   2125              /* calling flash command sequence function to execute the command */
   2126              returnCode = NvFlashCommandSequence(pConfig, 1, pCommandArray);
   \   00000016   0xAA00             ADD      R2,SP,#+0
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       NvFlashCommandSequence
   \   00000020   0x0006             MOVS     R6,R0
   2127          
   2128              return(returnCode);
   \   00000022   0x0030             MOVS     R0,R6
   \   00000024   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   2129          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x40048044         DC32     0x40048044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     EffectiveWrBytesCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0xFF 0xFF          DC8 255, 255, 255, 255
   \              0xFF 0xFF    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0xFF 0xFF          DC8 255, 255, 255, 255
   \              0xFF 0xFF    
   2130          
   2131          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   NV_DEFlashPartition
       0   NV_DFlashGetProtection
       8   NV_DFlashSetProtection
      12   NV_EEEWrite
       0   NV_EERAMGetProtection
      12   NV_EERAMSetProtection
      16   NV_FlashCheckSum
      16   NV_FlashEraseAllBlock
        16   -> NvFlashCommandSequence
      16   NV_FlashEraseBlock
        16   -> NvFlashCommandSequence
       0   NV_FlashEraseResume
      32   NV_FlashEraseSector
        32   -> NvFlashCommandSequence
       0   NV_FlashEraseSuspend
       4   NV_FlashGetInterruptEnable
       0   NV_FlashGetSecurityState
       0   NV_FlashInit
      40   NV_FlashProgramCheck
        40   -> NvFlashCommandSequence
      48   NV_FlashProgramLongword
        48   -> NvFlashCommandSequence
      32   NV_FlashProgramOnce
        32   -> NvFlashCommandSequence
      40   NV_FlashProgramPhrase
        40   -> NvFlashCommandSequence
      40   NV_FlashProgramUnalignedLongword
        40   -> NV_FlashProgramLongword
       0   NV_FlashRead
      32   NV_FlashReadOnce
        32   -> NvFlashCommandSequence
      32   NV_FlashReadResource
        32   -> NvFlashCommandSequence
      32   NV_FlashSecurityBypass
        32   -> NvFlashCommandSequence
       0   NV_FlashSetInterruptEnable
      24   NV_FlashVerifyAllBlock
        24   -> NvFlashCommandSequence
      32   NV_FlashVerifyBlock
        32   -> NvFlashCommandSequence
      48   NV_FlashVerifySection
        48   -> NvFlashCommandSequence
      12   NV_PFlashGetProtection
      32   NV_PFlashSetProtection
      24   NV_SetEEEEnable
        24   -> NvFlashCommandSequence
      16   NvFlashCommandSequence


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ?_0
       4  ?_1
       4  EffectiveWrBytesCnt
     106  NV_DEFlashPartition
      24  NV_DFlashGetProtection
      84  NV_DFlashSetProtection
      88  NV_EEEWrite
      26  NV_EERAMGetProtection
      94  NV_EERAMSetProtection
      74  NV_FlashCheckSum
      24  NV_FlashEraseAllBlock
     112  NV_FlashEraseBlock
      10  NV_FlashEraseResume
     182  NV_FlashEraseSector
      26  NV_FlashEraseSuspend
      30  NV_FlashGetInterruptEnable
      48  NV_FlashGetSecurityState
      38  NV_FlashInit
     216  NV_FlashProgramCheck
     366  NV_FlashProgramLongword
     142  NV_FlashProgramOnce
     226  NV_FlashProgramPhrase
     132  NV_FlashProgramUnalignedLongword
      20  NV_FlashRead
     128  NV_FlashReadOnce
     160  NV_FlashReadResource
      96  NV_FlashSecurityBypass
      26  NV_FlashSetInterruptEnable
      38  NV_FlashVerifyAllBlock
     128  NV_FlashVerifyBlock
     316  NV_FlashVerifySection
      56  NV_PFlashGetProtection
     322  NV_PFlashSetProtection
      38  NV_SetEEEEnable
     252  NvFlashCommandSequence

 
     4 bytes in section .bss
     8 bytes in section .rodata
 3 542 bytes in section .text
   106 bytes in section .textrw
 
 3 648 bytes of CODE  memory
     8 bytes of CONST memory
     4 bytes of DATA  memory

Errors: none
Warnings: none
