###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        02/Sep/2018  13:33:16
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Sys
#        Common\crt0.c
#    Command line =  
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Sys
#        Common\crt0.c" -D IAR --preprocess "F:\Guardrail Work\Sensor Code\Git
#        Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\Debug\List\" -lC "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\Debug\List\" -lB "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\Debug\List\" --diag_suppress
#        Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\Obj\" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\CDC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\Descriptor\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\USB\Class\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Sys Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
#    List file    =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\List\crt0.lst
#    Object file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\Obj\crt0.o
#
###############################################################################

F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Sys Common\crt0.c
      1          /******************************************************************************
      2           * Filename: crt0.c
      3           *
      4           * Description: Startup routines for ARM CORTEX-M4 processor
      5           *
      6           * Copyright (c) 2012, Freescale Semiconductor, Inc. All rights reserved.
      7           *
      8           ******************************************************************************
      9           *
     10           * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
     11           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
     12           * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
     13           * IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
     14           * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     15           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     16           * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     17           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
     18           * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
     19           * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
     20           * THE POSSIBILITY OF SUCH DAMAGE.
     21           *
     22           *****************************************************************************/
     23          
     24          #include "EmbeddedTypes.h"
     25          #include "PortConfig.h"
     26          #include "crt0.h"
     27          #include "Interrupt.h"
     28          #include "wdog.h"
     29          #include "mcg.h"
     30          #include "Utilities_Interface.h"
     31          #include "vectors.h"
     32          
     33          /******************************************************************************
     34           *******************************************************************************
     35           * Private macros
     36           *******************************************************************************
     37           ******************************************************************************/
     38          
     39          /******************************************************************************
     40           *******************************************************************************
     41           * Private type definitions
     42           *******************************************************************************
     43           ******************************************************************************/
     44          
     45          /******************************************************************************
     46           ******************************************************************************
     47           * Public memory definitions
     48           ******************************************************************************
     49           ******************************************************************************/
     50          
     51          /******************************************************************************
     52           *******************************************************************************
     53           * Private function prototypes
     54           *******************************************************************************
     55           ******************************************************************************/
     56          
     57          #if gCRT0_DEBUG_TRACE_CLK_d
     58          
     59          /******************************************************************************
     60           * Name: trace_clk_init
     61           * Description: enables the trace clock
     62           * Parameter(s): -
     63           * Return: -
     64           ******************************************************************************/
     65          static void trace_clk_init
     66          (
     67                  void
     68          );
     69          
     70          /******************************************************************************
     71           * Name: fb_clk_init
     72           * Description: enables the FlexBus clock
     73           * Parameter(s): -
     74           * Return: -
     75           ******************************************************************************/
     76          #if defined(__GNUC__)
     77          static void fb_clk_init
     78          (
     79                  void
     80          );
     81          #endif	// __GNUC__
     82          #endif /* gCRT0_DEBUG_TRACE_CLK_d */
     83          
     84          
     85          /******************************************************************************
     86           ******************************************************************************
     87           * Public functions
     88           ******************************************************************************
     89           *****************************************************************************/
     90          #if (defined(__IAR_SYSTEMS_ICC__))
     91          
     92          #if STACK_FILL
     93          extern uint32_t __size_cstack__[];
     94          #endif
     95          

   \                                 In section .text, align 4, keep-with-next
     96          uint32_t __low_level_init(void)
     97          { 
     98            uint8_t *pStack = (uint8_t*)__BOOT_STACK_ADDRESS;
   \                     __low_level_init: (+1)
   \   00000000   0x4910             LDR.N    R1,??__low_level_init_0
     99            pStack -= 20; // do not fill the first bytes of the stack
   \   00000002   0x3914             SUBS     R1,R1,#+20
    100            
    101            SCB_VTOR = (uint32_t)__vector_table; /* Set the interrupt vector table position */   
   \   00000004   0x4810             LDR.N    R0,??__low_level_init_0+0x4
   \   00000006   0x4A11             LDR.N    R2,??__low_level_init_0+0x8  ;; 0xe000ed08
   \   00000008   0x6010             STR      R0,[R2, #+0]
    102            
    103            /*
    104            * Enable all of the port clocks. These have to be enabled to configure
    105            * pin muxing options, so most code will need all of these on anyway.
    106            */
    107            SIM_SCGC5 |= (  SIM_SCGC5_PORTA_MASK
    108                          | SIM_SCGC5_PORTB_MASK
    109                          | SIM_SCGC5_PORTC_MASK
    110                          | SIM_SCGC5_PORTD_MASK
    111                          | SIM_SCGC5_PORTE_MASK );  
   \   0000000A   0x4811             LDR.N    R0,??__low_level_init_0+0xC  ;; 0x40048038
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF450 0x5078      ORRS     R0,R0,#0x3E00
   \   00000012   0x4A0F             LDR.N    R2,??__low_level_init_0+0xC  ;; 0x40048038
   \   00000014   0x6010             STR      R0,[R2, #+0]
    112            
    113            /*
    114            Disable the Watchdog because it may reset the core before entering main().
    115            There are 2 unlock words which shall be provided in sequence before
    116            accessing the control register.
    117            */
    118            *(volatile unsigned short *)gCRT0_WDOG_UnlockAddr_c = gCRT0_WDOG_UnlockSeq1_c;
   \   00000016   0xF24C 0x5020      MOVW     R0,#+50464
   \   0000001A   0x4A0E             LDR.N    R2,??__low_level_init_0+0x10  ;; 0x4005200e
   \   0000001C   0x8010             STRH     R0,[R2, #+0]
    119            *(volatile unsigned short *)gCRT0_WDOG_UnlockAddr_c = gCRT0_WDOG_UnlockSeq2_c;
   \   0000001E   0xF64D 0x1028      MOVW     R0,#+55592
   \   00000022   0x4A0C             LDR.N    R2,??__low_level_init_0+0x10  ;; 0x4005200e
   \   00000024   0x8010             STRH     R0,[R2, #+0]
    120            *(volatile unsigned short *)gCRT0_WDOG_STCTRLH_Addr_c = gCRT0_WDOG_Disabled_Ctrl_c;
   \   00000026   0x20D2             MOVS     R0,#+210
   \   00000028   0x4A0B             LDR.N    R2,??__low_level_init_0+0x14  ;; 0x40052000
   \   0000002A   0x8010             STRH     R0,[R2, #+0]
    121            
    122          #if STACK_FILL
    123          
    124            while (pStack > (uint8_t*)((uint32_t)__BOOT_STACK_ADDRESS - (uint32_t)__size_cstack__))
    125            {
    126              *pStack-- = STACK_INIT_VALUE;
    127            }
    128          #endif
    129            
    130            /* For debugging purposes, enable the trace clock and/or FB_CLK so that
    131            * we'll be able to monitor clocks and know the PLL is at the frequency
    132            * that we expect.
    133            */
    134            
    135          #if gCRT0_DEBUG_TRACE_CLK_d    
    136            trace_clk_init();
    137          #endif
    138            
    139          /* enable clock to LLWU module */
    140          #if (MCU_MK60N512VMD100 == 1)	
    141            SIM_SCGC4 |= SIM_SCGC4_LLWU_MASK;
    142          #elif (MCU_MK60D10 == 1)
    143            SIM_SCGC4 |= (uint32_t) (1 << 28);
    144          #endif
    145          
    146          #if (MCU_MK60N512VMD100 == 1)	  
    147            if (LLWU_CS & LLWU_CS_ACKISO_MASK)
    148            {
    149              LLWU_CS |= LLWU_CS_ACKISO_MASK;
    150            }
    151          #elif ((MCU_MK60D10 == 1) || (MCU_MK21DN512 == 1) || (MCU_MK21DX256 == 1))
    152            if (PMC_REGSC & PMC_REGSC_ACKISO_MASK)
   \   0000002C   0x480B             LDR.N    R0,??__low_level_init_0+0x18  ;; 0x4007d002
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x0700             LSLS     R0,R0,#+28
   \   00000032   0xD505             BPL.N    ??__low_level_init_1
    153            {
    154              PMC_REGSC |= PMC_REGSC_ACKISO_MASK;
   \   00000034   0x4809             LDR.N    R0,??__low_level_init_0+0x18  ;; 0x4007d002
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000003C   0x4A07             LDR.N    R2,??__low_level_init_0+0x18  ;; 0x4007d002
   \   0000003E   0x7010             STRB     R0,[R2, #+0]
    155            }
    156          #endif
    157            
    158            return 1;
   \                     ??__low_level_init_1: (+1)
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x4770             BX       LR               ;; return
   \                     ??__low_level_init_0:
   \   00000044   0x........         DC32     __BOOT_STACK_ADDRESS
   \   00000048   0x........         DC32     __vector_table
   \   0000004C   0xE000ED08         DC32     0xe000ed08
   \   00000050   0x40048038         DC32     0x40048038
   \   00000054   0x4005200E         DC32     0x4005200e
   \   00000058   0x40052000         DC32     0x40052000
   \   0000005C   0x4007D002         DC32     0x4007d002
    159          }
    160          #endif
    161          
    162          /******************************************************************************
    163           * Name: __init_hardware
    164           * Description: performs the hardware initialization of system 
    165           * Parameters: -
    166           * Return: -
    167           ******************************************************************************/
    168          #if (defined(__GNUC__))
    169          
    170          #if SUPPORT_SEMIHOST_ARGC_ARGV
    171          	#define __MAX_CMDLINE_ARGS 10
    172          	static char *argv[__MAX_CMDLINE_ARGS] = { 0 };
    173          #else
    174          	static char *argv[] = { 0 };
    175          #endif
    176          
    177          #if SUPPORT_SEMIHOST_ARGC_ARGV
    178          	extern int __argc_argv(char **, int);		// SUPPORT_SEMIHOST_ARGC_ARGV
    179          #endif  
    180          
    181          extern int main(int, char **);
    182          
    183          #ifdef __VFPV4__
    184          	extern void __fp_init(void);				// __VFPV4__ 
    185          #endif 
    186          
    187          extern void __init_registers();
    188          
    189          extern void __init_hardware();
    190          
    191          extern void __init_user();
    192          
    193          #if defined(__APCS_ROPI)
    194          	extern void __init_pic();
    195          #endif
    196          
    197          #if defined(__APCS_RWPI)
    198          	extern void __init_pid();
    199          #endif
    200          
    201          #if defined(__APCS_ROPI) || defined(__APCS_RWPI)
    202          	extern void __load_static_base();
    203          #endif
    204          
    205          #if defined(__SEMIHOSTING)
    206          	extern void __init_semihost(void) _EWL_WEAK;
    207          	extern void sys_exit(int status);
    208          #endif
    209          
    210          	extern void __copy_rom_sections_to_ram(void);
    211          	extern char __S_romp[];
    212          
    213          static void zero_fill_bss(void)
    214          {
    215          	extern char __START_BSS[];
    216          	extern char __END_BSS[];
    217          
    218          	MemorySet(__START_BSS, 0, (__END_BSS - __START_BSS));	
    219          }
    220          
    221          extern void _ExitProcess(int status) __attribute__ ((naked));		// _ExitProcess
    222          extern void _ExitProcess(int status)
    223          {
    224          #if defined(__SEMIHOSTING)
    225          	sys_exit(status);
    226          #endif
    227          
    228          	while (1);
    229          }
    230          
    231          #if STACK_FILL
    232          extern uint32_t __stack_size[];
    233          #endif
    234          
    235          void __init_hardware()
    236          {
    237          
    238          	  uint8_t *pStack = (uint8_t*)__SP_INIT;
    239          	  pStack -= 20; // do not fill the first bytes of the stack
    240          	  
    241          	/* Set the interrupt vector table position */
    242          	SCB_VTOR = (uint32_t)__vector_table; 
    243          
    244          	/*
    245                  Disable the Watchdog because it may reset the core before entering main().
    246                  There are 2 unlock words which shall be provided in sequence before
    247                  accessing the control register.
    248          	 */
    249          	*(volatile unsigned short *)gCRT0_WDOG_UnlockAddr_c = gCRT0_WDOG_UnlockSeq1_c;
    250          	*(volatile unsigned short *)gCRT0_WDOG_UnlockAddr_c = gCRT0_WDOG_UnlockSeq2_c;
    251          	*(volatile unsigned short *)gCRT0_WDOG_STCTRLH_Addr_c = gCRT0_WDOG_Disabled_Ctrl_c;
    252          
    253          	/*
    254          	 * Enable all of the port clocks. These have to be enabled to configure
    255          	 * pin muxing options, so most code will need all of these on anyway.
    256          	 */
    257          	SIM_SCGC5 |= (SIM_SCGC5_PORTA_MASK
    258          			| SIM_SCGC5_PORTB_MASK
    259          			| SIM_SCGC5_PORTC_MASK
    260          			| SIM_SCGC5_PORTD_MASK
    261          			| SIM_SCGC5_PORTE_MASK );
    262          
    263          #if STACK_FILL
    264            while (pStack > (uint8_t*)((uint32_t)__SP_INIT - (uint32_t)__stack_size))
    265            {
    266              *pStack-- = STACK_INIT_VALUE;
    267            }
    268          #endif	
    269          	
    270          #if gCRT0_DEBUG_TRACE_CLK_d    
    271          	trace_clk_init();
    272          	fb_clk_init();
    273          #endif // gCRT0_DEBUG_TRACE_CLK_d
    274          	
    275          	/* enable clock to LLWU module */
    276          	#if (MCU_MK60N512VMD100 == 1)	
    277          	  SIM_SCGC4 |= SIM_SCGC4_LLWU_MASK;
    278          	#elif (MCU_MK60D10 == 1)
    279          	  SIM_SCGC4 |= (uint32_t) (1 << 28);
    280          	#endif
    281          
    282          	#if (MCU_MK60N512VMD100 == 1)	  
    283          	  if (LLWU_CS & LLWU_CS_ACKISO_MASK)
    284          	  {
    285          	    LLWU_CS |= LLWU_CS_ACKISO_MASK;
    286          	  }
    287          	#elif ((MCU_MK60D10 == 1) || (MCU_MK21DN512 == 1) || (MCU_MK21DX256 == 1))
    288          	  if (PMC_REGSC & PMC_REGSC_ACKISO_MASK)
    289          	  {
    290          	    PMC_REGSC |= PMC_REGSC_ACKISO_MASK;
    291          	  }
    292          	#endif	
    293          }
    294          
    295          
    296          
    297          void __thumb_startup(void) __attribute__ ((naked));
    298          void __thumb_startup(void)
    299          {
    300          		__init_registers();				// Setup registers
    301          		
    302          		__init_hardware();				// setup hardware
    303          
    304          #if defined(__APCS_ROPI) || defined(__APCS_RWPI)
    305          		__load_static_base();			//	static base register initialization
    306          #endif
    307          
    308          #if defined(__APCS_RWPI)
    309          		__init_pid();					//	-pid
    310          										//	setup static base for SB relative position independent data
    311          										//	perform runtime relocation
    312          #endif
    313          
    314          #if defined(__APCS_ROPI)
    315          		__init_pic();					//	-pic
    316          										//	perform runtime relocation for position independent code
    317          #endif
    318          
    319          		zero_fill_bss();				//	zero-fill the .bss section
    320          
    321          		if (__S_romp != 0L)
    322          			__copy_rom_sections_to_ram();
    323          
    324          #ifdef __VFPV4__
    325          		__fp_init();					//      initialize the floating-point library
    326          #endif
    327          
    328          		__init_user();					// initializations before main, user specific
    329          
    330          #if defined(__SEMIHOSTING)
    331          		__init_semihost();				// semihost initializations
    332          #endif
    333          
    334          #if SUPPORT_SEMIHOST_ARGC_ARGV
    335          		exit(main(__argc_argv(argv, __MAX_CMDLINE_ARGS), argv));
    336          #else
    337          //		exit(main(0, argv));			//	call main(argc, &argv)
    338          		main(0, argv);					//	call main(argc, &argv)		
    339          #endif
    340          
    341          		while (1);						//	should never get here
    342          }
    343          
    344          
    345          #endif // __GNUC__
    346          
    347          
    348          
    349          /******************************************************************************
    350           *******************************************************************************
    351           * Private functions
    352           *******************************************************************************
    353           ******************************************************************************/
    354          
    355          #if gCRT0_DEBUG_TRACE_CLK_d
    356          
    357          /******************************************************************************
    358           * Name: trace_clk_init
    359           * Description: enables the trace clock
    360           * Parameter(s): -
    361           * Return: -
    362           ******************************************************************************/
    363          static void trace_clk_init(void)
    364          {
    365          #if (defined(MCU_MK60N512VMD100))
    366              /* Set the trace clock to the core clock frequency */
    367              SIM_SOPT2 |= SIM_SOPT2_TRACECLKSEL_MASK;
    368          
    369              /* Enable the TRACE_CLKOUT pin function on PTA6 (alt7 function) */
    370              PORTA_PCR6 = ( PORT_PCR_MUX(0x7));
    371          #endif
    372          }
    373          
    374          /******************************************************************************
    375           * Name: fb_clk_init
    376           * Description: enables the FlexBus clock
    377           * Parameter(s): -
    378           * Return: -
    379           ******************************************************************************/
    380          #if defined(__GNUC__)
    381          static void fb_clk_init(void)
    382          {
    383          #if (defined(MCU_MK60N512VMD100))
    384              /* Enable the clock to the FlexBus module */
    385              SIM_SCGC7 |= SIM_SCGC7_FLEXBUS_MASK;
    386          
    387              /* Enable the FB_CLKOUT function on PTC3 (alt5 function) */
    388              PORTC_PCR3 = ( PORT_PCR_MUX(0x5));
    389          #endif
    390          }
    391          #endif	// __GNUC__
    392          /********************************************************************/
    393          
    394          #endif /* gCRT0_DEBUG_TRACE_CLK_d */
    395          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   __low_level_init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      96  __low_level_init

 
 96 bytes in section .text
 
 96 bytes of CODE memory

Errors: none
Warnings: none
