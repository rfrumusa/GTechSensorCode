///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM       02/Sep/2018  13:33:18
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\NVM\NV_Flash.c
//    Command line =  
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\NVM\NV_Flash.c" -D IAR --preprocess "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\List\" -lC "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\List\" -lB "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\List\" --diag_suppress
//        Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\Obj\" --no_cse --no_unroll
//        --no_inline --no_code_motion --no_tbaa --no_clustering
//        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\APP\CDC\" -I "F:\Guardrail Work\Sensor Code\Git
//        Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\USB\APP\Descriptor\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Class\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Sys Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
//    List file    =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\NV_Flash.s
//
///////////////////////////////////////////////////////////////////////////////

        #define SHT_PROGBITS 0x1

        EXTERN NV_FlashEraseSector
        EXTERN NV_FlashInit
        EXTERN NV_FlashProgramLongword
        EXTERN NV_FlashRead
        EXTERN NV_FlashVerifySection
        EXTERN NV_STORAGE_END_ADDRESS
        EXTERN NV_STORAGE_MAX_SECTORS
        EXTERN NV_STORAGE_SECTOR_SIZE
        EXTERN RNG_GetRandomNo
        EXTERN TMR_AllocateTimer
        EXTERN TMR_IsTimerActive
        EXTERN TMR_StartSingleShotTimer
        EXTERN __aeabi_memcpy
        EXTERN pNVM_DataTable

        PUBLIC NvAtomicSave
        PUBLIC NvClearCriticalSection
        PUBLIC NvEraseEntryFromStorage
        PUBLIC NvFormat
        PUBLIC NvGetPagesStatistics
        PUBLIC NvIdle
        PUBLIC NvIsDataSetDirty
        PUBLIC NvModuleInit
        PUBLIC NvRegisterTableEntry
        PUBLIC NvRestoreDataSet
        PUBLIC NvSaveOnCount
        PUBLIC NvSaveOnIdle
        PUBLIC NvSaveOnInterval
        PUBLIC NvSetCountsBetweenSaves
        PUBLIC NvSetCriticalSection
        PUBLIC NvSetMinimumTicksBetweenSaves
        PUBLIC NvSyncSave
        PUBLIC NvTimerTick
        PUBLIC mNvConfig

// F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\NV_Flash.c
//    1 /******************************************************************************
//    2 * Filename: NV_Flash.c
//    3 *
//    4 * Description: Implementation of the non-volatile storage module 
//    5 *              for CORTEX-M4 processor     
//    6 *
//    7 *
//    8 * Copyright (c) 2014, Freescale Semiconductor, Inc.
//    9 * All rights reserved.
//   10 *
//   11 * Redistribution and use in source and binary forms, with or without modification,
//   12 * are permitted provided that the following conditions are met:
//   13 *
//   14 * o Redistributions of source code must retain the above copyright notice, this list
//   15 *   of conditions and the following disclaimer.
//   16 *
//   17 * o Redistributions in binary form must reproduce the above copyright notice, this
//   18 *   list of conditions and the following disclaimer in the documentation and/or
//   19 *   other materials provided with the distribution.
//   20 *
//   21 * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
//   22 *   contributors may be used to endorse or promote products derived from this
//   23 *   software without specific prior written permission.
//   24 *
//   25 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
//   26 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
//   27 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//   28 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
//   29 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//   30 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//   31 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
//   32 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//   33 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
//   34 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//   35 *
//   36 ***************************************************************************/
//   37 
//   38 #include "EmbeddedTypes.h"
//   39 #include "NV_Flash.h"
//   40 #include "NV_FlashHAL.h"
//   41 #include "TMR_Interface.h"
//   42 #include "RNG_Interface.h"
//   43 
//   44 #if (gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c != 0) /* FlexNVM */
//   45 #include "FunctionLib.h"
//   46 #endif
//   47 
//   48 /*****************************************************************************
//   49  *****************************************************************************
//   50  * Private macros
//   51  *****************************************************************************
//   52  *****************************************************************************/
//   53 #if gNvStorageIncluded_d
//   54 
//   55 /*
//   56  * Name: gNvVirtualPagesCount_c
//   57  * Description: the count of virtual pages used
//   58  */
//   59 #define gNvVirtualPagesCount_c         2 /* DO NOT MODIFY */
//   60 
//   61 
//   62 #endif /* gNvStorageIncluded_d */
//   63 
//   64 /*****************************************************************************
//   65  *****************************************************************************
//   66  * Private type definitions
//   67  *****************************************************************************
//   68  *****************************************************************************/
//   69 
//   70 /*****************************************************************************
//   71  *****************************************************************************
//   72  * Private prototypes
//   73  *****************************************************************************
//   74  *****************************************************************************/
//   75 
//   76 #if gNvStorageIncluded_d
//   77 
//   78 /******************************************************************************
//   79  * Name: NvInitPendingSavesQueue
//   80  * Description: Initialize the pending saves queue
//   81  * Parameters: [IN] pQueue - pointer to queue
//   82  * Return: TRUE if the pointer is valid, FALSE otherwise
//   83  ******************************************************************************/
//   84 static bool_t NvInitPendingSavesQueue
//   85 (
//   86   NVM_SaveQueue_t *pQueue
//   87 );
//   88 
//   89 
//   90 /******************************************************************************
//   91  * Name: NvPushPendingSave
//   92  * Description: Add a new pending save to the queue
//   93  * Parameters: [IN] pQueue - pointer to queue
//   94  *             [IN] data - data to be saved
//   95  * Return: TRUE if the push operation succeeded, FALSE otherwise
//   96  ******************************************************************************/
//   97 static bool_t NvPushPendingSave
//   98 (
//   99   NVM_SaveQueue_t *pQueue, 
//  100   NVM_TableEntryInfo_t data    
//  101 );
//  102 
//  103 
//  104 /******************************************************************************
//  105  * Name: NvPopPendingSave
//  106  * Description: Retrieves the head element from the pending saves queue
//  107  * Parameters: [IN] pQueue - pointer to queue
//  108  *             [OUT] pData - pointer to the location where data will be placed
//  109  * Return: TRUE if the pop operation succeeded, FALSE otherwise
//  110  ******************************************************************************/
//  111 static bool_t NvPopPendingSave
//  112 (
//  113   NVM_SaveQueue_t *pQueue, 
//  114   NVM_TableEntryInfo_t *pData
//  115 );
//  116 
//  117 /******************************************************************************
//  118  * Name: NvGetPendingSavesCount
//  119  * Description: self explanatory
//  120  * Parameters: [IN] pQueue - pointer to queue
//  121  * Return: Number of pending saves
//  122  ******************************************************************************/
//  123 static uint8_t NvGetPendingSavesCount
//  124 (
//  125   NVM_SaveQueue_t *pQueue 
//  126 );
//  127 
//  128 /*****************************************************************
//  129  * The below functions are compiled only if FlexNVM is NOT used 
//  130  *****************************************************************/
//  131 
//  132 #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */
//  133 
//  134 /******************************************************************************
//  135  * Name: NvEraseVirtualPage
//  136  * Description: erase the specified page
//  137  * Parameter(s): [IN] pageID - the ID of the page to be erased
//  138  * Return: gNVM_InvalidPageID_c - if the page ID is not valid
//  139  *         gNVM_SectorEraseFail_c - if the page cannot be erased
//  140  *         gNVM_OK_c - if operation completed successfully
//  141  *****************************************************************************/
//  142 static NVM_Status_t NvEraseVirtualPage
//  143 (
//  144   NVM_VirtualPageID_t pageID
//  145 );
//  146 
//  147 
//  148 /******************************************************************************
//  149  * Name: NvInitStorageSystem
//  150  * Description: Initialize the storage system, retrieve the active page and
//  151  *              the page counter. Called once by NvModuleInit() function.
//  152  * Parameter(s): - 
//  153  * Return: -
//  154  *****************************************************************************/
//  155 static void NvInitStorageSystem
//  156 (
//  157   void
//  158 );
//  159 
//  160 
//  161 /******************************************************************************
//  162  * Name: NvVirtualPageBlankCheck
//  163  * Description: checks if the specified page is blank (erased) 
//  164  * Parameter(s): [IN] pageID - the ID of the page to be checked
//  165  * Return: gNVM_InvalidPageID_c - if the page ID is not valid 
//  166  *         gNVM_PageIsNotBlank_c - if the page is not blank
//  167  *         gNVM_OK_c - if the page is blank (erased)
//  168  *****************************************************************************/
//  169 static NVM_Status_t NvVirtualPageBlankCheck
//  170 (
//  171   NVM_VirtualPageID_t pageID
//  172 );
//  173 
//  174 
//  175 /******************************************************************************
//  176  * Name: NvGetLastMetaInfoAddress
//  177  * Description: retrieve and store (update) the last meta information address 
//  178  * Parameter(s): -
//  179  * Return: gNVM_MetaNotFound_c - if no meta information has been found
//  180  *         gNVM_OK_c - if the meta was found and stored (updated)
//  181  *****************************************************************************/
//  182 static NVM_Status_t NvGetLastMetaInfoAddress
//  183 (    
//  184   void
//  185 );
//  186 
//  187 
//  188 /******************************************************************************
//  189  * Name: NvGetMetaInfo
//  190  * Description: get meta information based on the meta information address
//  191  * Parameter(s): [IN] pageID - the ID of the page
//  192  *               [IN] metaInfoAddress - meta information address
//  193  *               [OUT] pMetaInfo - a pointer to a memory location where the 
//  194  *                                 requested meta information will be stored
//  195  * Return: gNVM_InvalidPageID_c - if the active page is not valid
//  196  *         gNVM_NullPointer_c - if the provided pointer is NULL
//  197  *         gNVM_AddressOutOfRange_c - if the provided address is out of range
//  198  *         gNVM_OK_c - if the operation completed successfully
//  199  *****************************************************************************/
//  200 static NVM_Status_t NvGetMetaInfo
//  201 (
//  202   NVM_VirtualPageID_t pageId,
//  203   uint32_t metaInfoAddress,
//  204   NVM_RecordMetaInfo_t* pMetaInfo
//  205 );
//  206 
//  207 
//  208 /******************************************************************************
//  209  * Name: NvGetPageFreeSpace
//  210  * Description: return the page free space, in bytes
//  211  * Parameter(s): [OUT] ptrFreeSpace - a pointer to a memory location where the
//  212  *                                    page free space will be stored
//  213  * Return: gNVM_InvalidPageID_c - if the active page is not valid
//  214  *         gNVM_NullPointer_c - if the provided pointer is NULL
//  215  *         gNVM_PageIsEmpty_c - if the page is empty
//  216  *         gNVM_OK_c - if the operation completed successfully
//  217  *****************************************************************************/
//  218 static NVM_Status_t NvGetPageFreeSpace
//  219 (    
//  220   uint32_t* ptrFreeSpace
//  221 );
//  222 
//  223 
//  224 /******************************************************************************
//  225  * Name: NvIsMemoryAreaAvailable
//  226  * Description: checks if the specified memory area is blank (erased)
//  227  * Parameter(s): [IN] address - start address
//  228  *               [IN] len - length to be verified
//  229  * Return: TRUE if the area is available (blank), FALSE otherwise
//  230  *****************************************************************************/
//  231 static bool_t NvIsMemoryAreaAvailable
//  232 (
//  233   uint32_t address,
//  234   uint32_t len
//  235 );
//  236 
//  237 
//  238 /******************************************************************************
//  239  * Name: NvIsRecordCopied
//  240  * Description: Checks if a record or an entire table entry is already copied. 
//  241  *              Called by page copy function.
//  242  * Parameter(s): [IN] pageId - the ID of the page where to perform the check
//  243  *               [IN] metaInf - a pointer to source page meta information tag
//  244  * Return: TRUE if the element is already copied, FALSE otherwise
//  245  *****************************************************************************/
//  246 static bool_t NvIsRecordCopied
//  247 (
//  248   NVM_VirtualPageID_t pageId,
//  249   NVM_RecordMetaInfo_t* metaInf
//  250 );
//  251 
//  252 
//  253 /******************************************************************************
//  254  * Name: NvInternalCopy
//  255  * Description: Performs a copy of an record / entire table entry
//  256  * Parameter(s): [IN] dstAddress - destination record address
//  257  *               [IN] dstMetaAddress - destination meta address
//  258  *               [IN] srcMetaInfo - source meta information
//  259  *               [IN] srcTblEntryIdx - source table entry index
//  260  *               [IN] size - bytes to copy
//  261  * Return: gNVM_InvalidPageID_c - if the source or destination page is not 
//  262  *                                valid
//  263  *         gNVM_MetaInfoWriteError_c - if the meta information couldn't be 
//  264  *                                     written
//  265  *         gNVM_RecordWriteError_c - if the record couldn't be written
//  266  *         gNVM_Error_c - in case of error(s)
//  267  *         gNVM_OK_c - page copy completed successfully
//  268  *****************************************************************************/
//  269 static NVM_Status_t NvInternalCopy
//  270 (
//  271   uint32_t dstAddress,
//  272   uint32_t dstMetaAddress,
//  273   NVM_RecordMetaInfo_t* srcMetaInfo,
//  274   uint16_t srcTblEntryIdx,
//  275   uint16_t size
//  276 );
//  277 
//  278 
//  279 /******************************************************************************
//  280  * Name: NvGetRecordFullSize
//  281  * Description: Computes the size of the specified table entry that will 
//  282  *              be written on FLASH memory
//  283  * Parameter(s): [IN] tableEntryIndex - table entry index               
//  284  * Return: the computed size
//  285  *****************************************************************************/
//  286 static uint32_t NvGetRecordFullSize
//  287 (    
//  288   NvTableEntryId_t tableEntryIndex    
//  289 );
//  290 
//  291 
//  292 /******************************************************************************
//  293  * Name: NvGetTblEntryMetaAddrFromId
//  294  * Description: Gets the table entry meta address based on table entry ID
//  295  * Parameter(s): [IN] searchStartAddress - the search start address
//  296  *               [IN] dataEntryId - table entry ID
//  297  * Return: the value of the meta address
//  298  *****************************************************************************/
//  299 #if gNvFragmentation_Enabled_d
//  300 static uint32_t NvGetTblEntryMetaAddrFromId
//  301 (
//  302   uint32_t searchStartAddress,
//  303   uint16_t dataEntryId
//  304 );
//  305 #endif /* gNvFragmentation_Enabled_d */
//  306 
//  307 
//  308 /******************************************************************************
//  309  * Name: NvInternalDefragmentedCopy
//  310  * Description: Performs defragmentation and copy from the source page to 
//  311  *              the destination one
//  312  * Parameter(s): [IN] srcMetaAddr - source page meta address
//  313  *               [IN] pSrcMetaInf - pointer to source page meta information
//  314  *               [IN] srcTblEntryIdx - source page table entry index
//  315  *               [IN] dstMetaAddr - destination meta address
//  316  *               [IN] dstRecordAddr - destination record address (to copy to)
//  317  * Return: the status of the operation
//  318  *****************************************************************************/
//  319 #if gNvFragmentation_Enabled_d
//  320 static NVM_Status_t NvInternalDefragmentedCopy
//  321 (
//  322   uint32_t srcMetaAddr,  
//  323   NVM_RecordMetaInfo_t* pSrcMetaInf,
//  324   uint16_t srcTblEntryIdx,
//  325   uint32_t dstMetaAddr,
//  326   uint32_t dstRecordAddr
//  327 );
//  328 #endif /* #if gNvFragmentation_Enabled_d */
//  329 
//  330 
//  331 /******************************************************************************
//  332  * Name: NvCopyPage
//  333  * Description: Copy the active page content to the mirror page. Only the 
//  334  *              latest table entries / elements are copied. A merge operation
//  335  *              is performed before copy if an entry has single elements 
//  336  *              saved priori and newer than the table entry. If one or more
//  337  *              elements were singular saved and the NV page doesn't has a
//  338  *              full table entry saved, then the elements are copied as they
//  339  *              are.  
//  340  * Parameter(s): [IN] skipEntryId - the entry ID to be skipped when page
//  341  *                                  copy is performed
//  342  * Return: gNVM_InvalidPageID_c - if the source or destination page is not 
//  343  *                                valid
//  344  *         gNVM_MetaInfoWriteError_c - if the meta information couldn't be 
//  345  *                                     written
//  346  *         gNVM_RecordWriteError_c - if the record couldn't be written
//  347  *         gNVM_Error_c - in case of error(s)
//  348  *         gNVM_OK_c - page copy completed successfully
//  349  *****************************************************************************/
//  350 static NVM_Status_t NvCopyPage
//  351 (    
//  352 #if gNvUseExtendedFeatureSet_d		
//  353   NvTableEntryId_t skipEntryId
//  354 #else
//  355   void
//  356 #endif
//  357 );
//  358 
//  359 
//  360 /******************************************************************************
//  361  * Name: NvWritePageCounter
//  362  * Description: Write the page counter value              
//  363  * Parameter(s): [IN] pageId - the ID of the page 
//  364  *               [IN] value - the page counter value that will written to 
//  365  *                            the specified page
//  366  *               
//  367  * Return: gNVM_OK_c - if the operation completes successfully
//  368  *         gNVM_Error_c - if the format operation fails
//  369  *****************************************************************************/
//  370 static NVM_Status_t NvWritePageCounter
//  371 (
//  372   NVM_VirtualPageID_t pageId,
//  373   uint32_t value    
//  374 );
//  375 
//  376 
//  377 /******************************************************************************
//  378  * Name: NvInternalFormat
//  379  * Description: Format the NV storage system. The function erases in place both
//  380  *              virtual pages and then writes the page counter value to first  
//  381  *              virtual page. The provided page counter value is automatically 
//  382  *              incremented and then written to first (active) virtual page.              
//  383  * Parameter(s): [IN] pageCounterValue - the page counter value that will
//  384  *                                       be incremented and then written to
//  385  *                                       active page
//  386  * Return: gNVM_OK_c - if the operation completes successfully
//  387  *         gNVM_FormatFailure_c - if the format operation fails
//  388  *****************************************************************************/
//  389 static NVM_Status_t NvInternalFormat
//  390 (
//  391   uint32_t pageCounterValue
//  392 );
//  393 
//  394 
//  395 #if gNvUseExtendedFeatureSet_d
//  396 
//  397 /******************************************************************************
//  398  * Name: NvSaveRamTable
//  399  * Description: Saves the NV table
//  400  * Parameter(s): [IN] pageId - the virtual page ID where the table will be 
//  401  *                             saved 
//  402  * Return: TRUE if table saved successfully, FALSE otherwise
//  403  ******************************************************************************/
//  404 static bool_t NvSaveRamTable
//  405 (
//  406     NVM_VirtualPageID_t pageId
//  407 );
//  408 
//  409 /******************************************************************************
//  410  * Name: NvGetTableSize
//  411  * Description: Retrieves the size of the NV table
//  412  * Parameter(s): [IN] location - specifies if the size shall be the NV FLASH 
//  413  *                               table size (gFLASHTable_c) or the NV RAM table 
//  414  *                               size (gRAMTable_c) 
//  415  * Return: the NV table size
//  416  ******************************************************************************/
//  417 static uint32_t NvGetTableSize
//  418 (
//  419   uint8_t location
//  420 );
//  421 
//  422 
//  423 /******************************************************************************
//  424  * Name: NvIsRamTableUpdated
//  425  * Description: Checks if the the NV table from RAM memory has changed since
//  426  *              last system reset (e.g. via an OTAP transfer)
//  427  * Parameter(s): -
//  428  * Return: TRUE if the NV RAM table has been changed / FALSE otherwise
//  429  ******************************************************************************/
//  430 static bool_t NvIsRamTableUpdated
//  431 (
//  432   void
//  433 );
//  434 
//  435 /******************************************************************************
//  436  * Name: NvGetTableEntry
//  437  * Description: get the NV table entry information stored on FLASH memory
//  438  * Parameter(s): [IN] tblEntryId - table entry ID
//  439  *               [OUT] pDataEntry - a pointer to a memory location where the 
//  440  *                                  entry information will be stored
//  441  * Return: TRUE if the has been found / FALSE otherwise
//  442  ******************************************************************************/
//  443 static bool_t NvGetTableEntry
//  444 (
//  445   uint16_t tblEntryId,
//  446   NVM_DataEntry_t* pDataEntry
//  447 );
//  448 
//  449 #endif /* gNvUseExtendedFeatureSet_d */
//  450 
//  451 #endif /* no FlexNVM */
//  452 
//  453 
//  454 /******************************************************************************
//  455  * Name: NvGetEntryFromDataPtr
//  456  * Description: get table and element indexes based on a generic pointer address
//  457  * Parameter(s): [IN] pData - a pointer to a NVM RAM table
//  458  *               [OUT] pIndex - a pointer to a memory location where the 
//  459  *                              requested indexed will be stored
//  460  * Return: gNVM_NullPointer_c - if the provided pointer is NULL
//  461  *         gNVM_PointerOutOfRange_c - if the provided pointer cannot be founded
//  462  *                                    within the RAM table
//  463  *         gNVM_OK_c - if the operation completed successfully
//  464  *****************************************************************************/
//  465 static NVM_Status_t NvGetEntryFromDataPtr
//  466 (
//  467   void* pData,
//  468   NVM_TableEntryInfo_t* pIndex
//  469 );
//  470 
//  471 
//  472 /******************************************************************************
//  473  * Name: NvWriteRecord
//  474  * Description: writes a record
//  475  * Parameter(s): [IN] tblIndexes - a pointer to table and element indexes
//  476  * Return: gNVM_InvalidPageID_c - if the active page is not valid
//  477  *         gNVM_NullPointer_c - if the provided pointer is NULL
//  478  *         gNVM_MetaInfoWriteError_c - if the meta information couldn't be 
//  479  *                                     written
//  480  *         gNVM_RecordWriteError_c - if the record couldn't be written
//  481  *         gNVM_OK_c - if the operation completed successfully
//  482  *****************************************************************************/
//  483 static NVM_Status_t NvWriteRecord
//  484 (        
//  485   NVM_TableEntryInfo_t* tblIndexes
//  486 );
//  487 
//  488 
//  489 /******************************************************************************
//  490  * Name: NvRestoreData
//  491  * Description: restore an element from NVM storage to its original RAM location
//  492  * Parameter(s): [IN] tblIdx - pointer to table and element indexes
//  493  * Return: gNVM_NullPointer_c - if the provided pointer is NULL
//  494  *         gNVM_PageIsEmpty_c - if page is empty
//  495  *         gNVM_Error_c - in case of error(s)
//  496  *         gNVM_OK_c - if the operation completed successfully
//  497  *****************************************************************************/
//  498 static NVM_Status_t NvRestoreData
//  499 (        
//  500   NVM_TableEntryInfo_t* tblIdx
//  501 );
//  502 
//  503 
//  504 /******************************************************************************
//  505  * Name: NvGetTableEntryIndex
//  506  * Description: get the table entry index from the provided ID
//  507  * Parameter(s): [IN] entryId - the ID of the table entry
//  508  * Return: table entry index of gNvInvalidTableEntryIndex_c
//  509  *****************************************************************************/
//  510 static uint16_t NvGetTableEntryIndexFromId
//  511 (
//  512   NvTableEntryId_t entryId 
//  513 );
//  514 
//  515 
//  516 /******************************************************************************
//  517  * Name: NvAddSaveRequestToQueue
//  518  * Description: Add save request to save requests queue; if the request is 
//  519  *              already stored, ignore the current request  
//  520  * Parameter(s): [IN] ptrTblIdx - pointer to table index
//  521  * Return: gNVM_OK_c - if operation completed successfully
//  522  *         gNVM_SaveRequestRejected_c - if the request couldn't be queued         
//  523  ******************************************************************************/
//  524 static NVM_Status_t NvAddSaveRequestToQueue
//  525 (
//  526   NVM_TableEntryInfo_t* ptrTblIdx
//  527 );
//  528 
//  529 /******************************************************************************
//  530  * Name: NvIntervalTimerCallback
//  531  * Description: Callback function of the timer used by the NvSaveOnInterval()
//  532  * Parameter(s): [IN] timerID - timer ID
//  533  * Return: -
//  534  ******************************************************************************/
//  535 static void NvIntervalTimerCallback
//  536 (
//  537   tmrTimerID_t timerID
//  538 );
//  539 
//  540 /******************************************************************************
//  541  * Name: NvGetRandomRange
//  542  * Description: Returns a random number between 'low' and 'high'
//  543  * Parameter(s): [IN] low, high - generated number range
//  544  * Return: 0..255
//  545  ******************************************************************************/
//  546 static uint8_t NvGetRandomRange
//  547 (
//  548   uint8_t low, 
//  549   uint8_t high
//  550 );
//  551 
//  552 #if (gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c != 0) /*** FlexNVM ***/
//  553 
//  554 /******************************************************************************
//  555  * Name: NvGetFlexLastMetaInfo
//  556  * Description: Get FlexRAM last meta information address 
//  557  * Parameter(s): -
//  558  * Return: the address of the last valid meta information       
//  559  ******************************************************************************/
//  560 static uint32_t NvGetFlexLastMetaInfo
//  561 (
//  562   void
//  563 );
//  564 
//  565 /******************************************************************************
//  566  * Name: NvGetFlexMetaInfoFromId
//  567  * Description: Get FlexRAM meta information tag from table entry ID 
//  568  * Parameter(s): [IN] tblEntryId - table entry ID
//  569  *               [OUT] pMetaInfo - a pointer to a memory location where the
//  570  *                                 meta information tag will be stored
//  571  * Return: -
//  572  ******************************************************************************/
//  573 static void NvGetFlexMetaInfoFromId
//  574 (
//  575   NvTableEntryId_t tblEntryId,
//  576   NVM_FlexMetaInfo_t* pMetaInfo
//  577 );
//  578 
//  579 /******************************************************************************
//  580  * Name: NvCheckNvmTableForFlexRAMUsage
//  581  * Description: Check if the existing NVM table fits within the FlexRAM window 
//  582  * Parameter(s): -
//  583  * Return: gNVM_NvTableExceedFlexRAMSize_c - the table exceed the size of
//  584  *                                           FlexRAM window
//  585  *         gNVM_OK_c - the table fits within the size of window FlexRAM window                                  
//  586  ******************************************************************************/
//  587 static NVM_Status_t NvCheckNvmTableForFlexRAMUsage
//  588 (
//  589   void
//  590 );
//  591 
//  592 #endif /* gNvUseFlexNVM_d */
//  593 #endif /* gNvStorageIncluded_d */
//  594 
//  595 
//  596 /*****************************************************************************
//  597  *****************************************************************************
//  598  * Private memory declarations
//  599  *****************************************************************************
//  600  *****************************************************************************/
//  601 
//  602 #if gNvStorageIncluded_d
//  603 
//  604 #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */
//  605 
//  606 /*
//  607  * Name: mNvActivePageId
//  608  * Description: variable that holds the ID of the active page
//  609  */

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  610 static NVM_VirtualPageID_t mNvActivePageId;
mNvActivePageId:
        DS8 1
//  611 
//  612 /*
//  613  * Name: mNvPageCounter
//  614  * Description: page counter, used to validate the entire virtual page
//  615  *              and also to provide statistical information about
//  616  *              how many times the virtual page was erased
//  617  */

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  618 static uint32_t mNvPageCounter = 0;
mNvPageCounter:
        DS8 4
//  619 
//  620 /*
//  621  * Name: mNvVirtualPageProperty
//  622  * Description: virtual page properties
//  623  */

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  624 static NVM_VirtualPageProperties_t mNvVirtualPageProperty[gNvVirtualPagesCount_c];
mNvVirtualPageProperty:
        DS8 40
//  625 
//  626 /*
//  627  * Name: mNvCopyOperationIsPending
//  628  * Description: a flag that a indicates that a page copy operation is requested
//  629  */

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  630 static bool_t mNvCopyOperationIsPending = FALSE;
mNvCopyOperationIsPending:
        DS8 1
//  631 
//  632 /*
//  633  * Name: mNvSkipTableEntryId
//  634  * Description: table entry ID to be skipped when a page copy is requested
//  635  */
//  636 #if gNvUseExtendedFeatureSet_d
//  637 static NvTableEntryId_t mNvSkipTableEntryId;
//  638 #endif
//  639 
//  640 /*
//  641  * Name: mNvErasePgCmdStatus
//  642  * Description: a data structure used to erase a virtual page. The erase of a 
//  643  *              virtual page is performed in idle task, in a sector-by-sector
//  644  *              manner. When the idle task runs, if the erase pending flag is 
//  645  *              set, only one flash sector will be erased. Therefore, the
//  646  *              virtual page will be entirely erased after several runs of 
//  647  *              idle task
//  648  */

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  649 static NVM_ErasePageCmdStatus_t mNvErasePgCmdStatus;
mNvErasePgCmdStatus:
        DS8 8
//  650 
//  651 /*
//  652  * Name: maNvRecordsCpyIdx
//  653  * Description: An array that stores the indexes of the records already copied; 
//  654  *              Used by the defragmentation process.
//  655  */
//  656 #if gNvFragmentation_Enabled_d
//  657 static uint16_t maNvRecordsCpyIdx[gNvRecordsCopiedBufferSize_c];
//  658 #endif /* gNvFragmentation_Enabled_d */
//  659 
//  660 
//  661 #if gNvUseExtendedFeatureSet_d
//  662 /*
//  663  * Name: mNvTableSizeInRAM
//  664  * Description: the size of the NV table stored in RAM memory
//  665  */
//  666 static uint32_t mNvTableSizeInRAM;
//  667 
//  668 /*
//  669  * Name: mNvTableSizeInFlash
//  670  * Description: the size of the NV table stored in the FLASH memory
//  671  */
//  672 static uint32_t mNvTableSizeInFlash;
//  673 
//  674 /*
//  675  * Name: mNvTableMarker 
//  676  * Description: FLASH NV table marker, used only for code readability 
//  677  *              (when applying the sizeof() operator to it) 
//  678  */
//  679 static uint32_t mNvTableMarker = gNvTableMarker_c;
//  680 
//  681 /*
//  682  * Name: mNvTableUpdated
//  683  * Description: boolean flag used to mark if the NV table from the RAM memory
//  684  *              has been changed. Set (or left untouched) only at module initialization,
//  685  *              when the existing NV FLASH table (if any) is compared against
//  686  *              the NV RAM table.  
//  687  */
//  688 static bool_t mNvTableUpdated;
//  689 
//  690 #endif /* gNvUseExtendedFeatureSet_d */
//  691 
//  692 #endif /* no FlexNVM */
//  693 
//  694 /*
//  695  * Name: mNvModuleInitialized
//  696  * Description: variable that holds the NVM initialisation status
//  697  */

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  698 static bool_t mNvModuleInitialized = FALSE;
mNvModuleInitialized:
        DS8 1
//  699 
//  700 /*
//  701  * Name: mNvCriticalSectionFlag
//  702  * Description: If this counter is != 0, do not save to NV Storage
//  703  */

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  704 static uint8_t mNvCriticalSectionFlag = 0;
mNvCriticalSectionFlag:
        DS8 1
//  705 
//  706 /*
//  707  * Name: gNvMinimumTicksBetweenSaves
//  708  * Description: Minimum number of calls to NvTimerTick() between saves of a given data set 
//  709  */

        SECTION `.data`:DATA:REORDER:NOROOT(1)
//  710 static NvSaveInterval_t gNvMinimumTicksBetweenSaves = gNvMinimumTicksBetweenSaves_c;
gNvMinimumTicksBetweenSaves:
        DATA
        DC16 4
//  711 
//  712 /*
//  713  * Name: gNvCountsBetweenSaves
//  714  * Description: Minimum number of calls to NvSaveOnIdle() between saves of a given data set
//  715  */

        SECTION `.data`:DATA:REORDER:NOROOT(1)
//  716 static NvSaveCounter_t gNvCountsBetweenSaves = gNvCountsBetweenSaves_c;
gNvCountsBetweenSaves:
        DATA
        DC16 256
//  717 
//  718 /*
//  719  * Name: mNvPendingSavesQueue
//  720  * Description: a queue used for storing information about the pending saves
//  721  */

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  722 static NVM_SaveQueue_t mNvPendingSavesQueue;
mNvPendingSavesQueue:
        DS8 196
//  723 
//  724 /*
//  725  * Name: maDatasetInfo
//  726  * Description: Data set info table
//  727  */

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  728 static NVM_DatasetInfo_t maDatasetInfo[gNvTableEntriesCountMax_c];
maDatasetInfo:
        DS8 192
//  729 
//  730 /*
//  731  * Name: mNvSaveOnIntervalEvent
//  732  * Description: flag used to signal an 'SaveOnInterval' event
//  733  */

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  734 static bool_t mNvSaveOnIntervalEvent;
mNvSaveOnIntervalEvent:
        DS8 1
//  735 
//  736 /*
//  737  * Name: mNvSaveOnIntervalTimerID
//  738  * Description: the ID of timer used by the Save-On-Interval functionality
//  739  */

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  740 static tmrTimerID_t mNvSaveOnIntervalTimerID;
mNvSaveOnIntervalTimerID:
        DS8 1
//  741 
//  742 #endif /* gNvStorageIncluded_d */
//  743 
//  744 /*****************************************************************************
//  745  *****************************************************************************
//  746  * Public memory declarations
//  747  *****************************************************************************
//  748  *****************************************************************************/
//  749 
//  750 #if gNvStorageIncluded_d
//  751 
//  752 #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */
//  753 
//  754 /*
//  755  * Name: NV_STORAGE_END_ADDRESS
//  756  * Description: NV_STORAGE_END_ADDRESS from linker command file is used by this code
//  757  *              as Raw Sector Start Address. This should not be misleading because 
//  758  *              ENVM module writes meta information in address-ascending order 
//  759  *              and records in address-descending order.
//  760  */
//  761 extern uint32_t NV_STORAGE_END_ADDRESS[];
//  762 
//  763 /*
//  764  * Name: NV_STORAGE_SECTOR_SIZE
//  765  * Description: external symbol from linker command file, it represents the size
//  766  *              of a FLASH sector 
//  767  */
//  768 extern uint32_t NV_STORAGE_SECTOR_SIZE[];
//  769 
//  770 /*
//  771  * Name:  NV_STORAGE_MAX_SECTORS
//  772  * Description: external symbol from linker command file, it represents the sectors
//  773  *              count used by the ENVM storage system; it has to be a multiple of 2 
//  774  */
//  775 extern uint32_t  NV_STORAGE_MAX_SECTORS[];
//  776 
//  777 #endif /* no FlexNVM */
//  778 
//  779 /*
//  780  * Name: mNvConfig
//  781  * Description: configuration variable used to initialize and control the FTFL HAL driver
//  782  */

        SECTION `.data`:DATA:REORDER:NOROOT(2)
//  783 NvConfig_t mNvConfig = {
mNvConfig:
        DATA
        DC32 1073872896, 0, 524288, 0, 0, 0, 0, 0
//  784     gNV_FTFX_REG_BASE_c,
//  785     gNV_PFLASH_BLOCK_BASE_c,
//  786     gNV_PFLASH_BLOCK_SIZE_c,
//  787     gNV_DFLASH_BLOCK_BASE_c,
//  788     gNV_DFLASH_BLOCK_SIZE_c,
//  789     gNV_EERAM_BLOCK_BASE_c,
//  790     gNV_EERAM_BLOCK_SIZE_c,
//  791     gNV_EEE_BLOCK_SIZE_c
//  792 };
//  793 
//  794 #endif /* gNvStorageIncluded_d */
//  795 
//  796 
//  797 /*****************************************************************************
//  798  *****************************************************************************
//  799  * Private functions
//  800  *****************************************************************************
//  801  *****************************************************************************/
//  802 
//  803 #if gNvStorageIncluded_d
//  804 
//  805 /******************************************************************************
//  806  * Name: NvInitPendingSavesQueue
//  807  * Description: Initialize the pending saves queue
//  808  * Parameters: [IN] pQueue - pointer to queue
//  809  * Return: TRUE if the pointer is valid, FALSE otherwise
//  810  ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  811 static bool_t NvInitPendingSavesQueue
//  812 (
//  813   NVM_SaveQueue_t *pQueue
//  814 )
//  815 {
NvInitPendingSavesQueue:
        MOVS     R1,R0
//  816   if(NULL == pQueue)
        CMP      R1,#+0
        BNE.N    ??NvInitPendingSavesQueue_0
//  817   {
//  818     return FALSE;
        MOVS     R0,#+0
        B.N      ??NvInitPendingSavesQueue_1
//  819   }
//  820 
//  821   pQueue->Head = 0;
??NvInitPendingSavesQueue_0:
        MOVS     R0,#+0
        STRB     R0,[R1, #+192]
//  822   pQueue->Tail = 0;
        MOVS     R0,#+0
        STRB     R0,[R1, #+193]
//  823   pQueue->EntriesCount = 0;
        MOVS     R0,#+0
        STRB     R0,[R1, #+194]
//  824 
//  825   return TRUE;
        MOVS     R0,#+1
??NvInitPendingSavesQueue_1:
        BX       LR               ;; return
//  826 }
//  827 
//  828 
//  829 /******************************************************************************
//  830  * Name: NvPushPendingSave
//  831  * Description: Add a new pending save to the queue
//  832  * Parameters: [IN] pQueue - pointer to queue
//  833  *             [IN] data - data to be saved
//  834  * Return: TRUE if the push operation succeeded, FALSE otherwise
//  835  ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  836 static bool_t NvPushPendingSave
//  837 (
//  838   NVM_SaveQueue_t *pQueue, 
//  839   NVM_TableEntryInfo_t data    
//  840 )
//  841 {
NvPushPendingSave:
        PUSH     {R1,R2,R4,LR}
        MOVS     R4,R0
//  842   if(NULL == pQueue)
        CMP      R4,#+0
        BNE.N    ??NvPushPendingSave_0
//  843   {
//  844     return FALSE;
        MOVS     R0,#+0
        B.N      ??NvPushPendingSave_1
//  845   }
//  846 
//  847   if((pQueue->Tail == pQueue->Head) && (pQueue->EntriesCount > 0))
??NvPushPendingSave_0:
        LDRB     R0,[R4, #+193]
        LDRB     R1,[R4, #+192]
        CMP      R0,R1
        BNE.N    ??NvPushPendingSave_2
        LDRB     R0,[R4, #+194]
        CMP      R0,#+0
        BEQ.N    ??NvPushPendingSave_2
//  848   {
//  849 #if gFifoOverwriteEnabled_c        
//  850     /* increment the head (read index) */
//  851     pQueue->Head = (pQueue->Head + 1) & ((unsigned char) (gNvPendigSavesQueueSize_c - 1));
//  852 #else
//  853     return FALSE;
        MOVS     R0,#+0
        B.N      ??NvPushPendingSave_1
//  854 #endif
//  855   }
//  856 
//  857   /* Add the item to queue */
//  858   pQueue->QData[pQueue->Tail] = data;
??NvPushPendingSave_2:
        LDRB     R0,[R4, #+193]
        MOVS     R1,#+6
        MLA      R0,R1,R0,R4
        ADD      R1,SP,#+0
        MOVS     R2,#+6
        BL       __aeabi_memcpy
//  859 
//  860   /* Reset the tail when it reach gNvPendigSavesQueueSize_c */
//  861   pQueue->Tail = (pQueue->Tail + 1) % ((unsigned char) (gNvPendigSavesQueueSize_c));
        LDRB     R0,[R4, #+193]
        ADDS     R0,R0,#+1
        MOVS     R1,#+32
        SDIV     R2,R0,R1
        MLS      R2,R2,R1,R0
        STRB     R2,[R4, #+193]
//  862 
//  863   /* Increment the entries count */
//  864   if(pQueue->EntriesCount < (unsigned char) (gNvPendigSavesQueueSize_c))
        LDRB     R0,[R4, #+194]
        CMP      R0,#+32
        BGE.N    ??NvPushPendingSave_3
//  865   {
//  866     pQueue->EntriesCount++;
        LDRB     R0,[R4, #+194]
        ADDS     R0,R0,#+1
        STRB     R0,[R4, #+194]
//  867   }
//  868 
//  869   return TRUE;
??NvPushPendingSave_3:
        MOVS     R0,#+1
??NvPushPendingSave_1:
        POP      {R1,R2,R4,PC}    ;; return
//  870 }
//  871 
//  872 
//  873 /******************************************************************************
//  874  * Name: NvPopPendingSave
//  875  * Description: Retrieves the head element from the pending saves queue
//  876  * Parameters: [IN] pQueue - pointer to queue
//  877  *             [OUT] pData - pointer to the location where data will be placed
//  878  * Return: TRUE if the pop operation succeeded, FALSE otherwise
//  879  ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  880 static bool_t NvPopPendingSave
//  881 (
//  882   NVM_SaveQueue_t *pQueue, 
//  883   NVM_TableEntryInfo_t *pData
//  884 )
//  885 {
NvPopPendingSave:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
        MOVS     R5,R1
//  886   if( (NULL == pQueue) || (pQueue->EntriesCount <= 0) || ((NULL == pData)) )
        CMP      R4,#+0
        BEQ.N    ??NvPopPendingSave_0
        LDRB     R0,[R4, #+194]
        CMP      R0,#+0
        BEQ.N    ??NvPopPendingSave_0
        CMP      R5,#+0
        BNE.N    ??NvPopPendingSave_1
//  887   {
//  888     return FALSE;
??NvPopPendingSave_0:
        MOVS     R0,#+0
        B.N      ??NvPopPendingSave_2
//  889   }
//  890 
//  891   *pData = pQueue->QData[pQueue->Head];
??NvPopPendingSave_1:
        MOVS     R0,R5
        LDRB     R1,[R4, #+192]
        MOVS     R2,#+6
        MLA      R1,R2,R1,R4
        MOVS     R2,#+6
        BL       __aeabi_memcpy
//  892 
//  893   /* Reset the head when it reach gNvPendigSavesQueueSize_c */
//  894   pQueue->Head = (pQueue->Head + 1) % ((unsigned char) (gNvPendigSavesQueueSize_c ));
        LDRB     R0,[R4, #+192]
        ADDS     R0,R0,#+1
        MOVS     R1,#+32
        SDIV     R2,R0,R1
        MLS      R2,R2,R1,R0
        STRB     R2,[R4, #+192]
//  895 
//  896   /* Decrement the entries count */
//  897   pQueue->EntriesCount--;
        LDRB     R0,[R4, #+194]
        SUBS     R0,R0,#+1
        STRB     R0,[R4, #+194]
//  898 
//  899   return TRUE;
        MOVS     R0,#+1
??NvPopPendingSave_2:
        POP      {R1,R4,R5,PC}    ;; return
//  900 }
//  901 
//  902 /******************************************************************************
//  903  * Name: NvGetPendingSavesCount
//  904  * Description: self explanatory
//  905  * Parameters: [IN] pQueue - pointer to queue
//  906  * Return: Number of pending saves
//  907  ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  908 static uint8_t NvGetPendingSavesCount
//  909 (
//  910   NVM_SaveQueue_t *pQueue 
//  911 )
//  912 {
NvGetPendingSavesCount:
        MOVS     R1,R0
//  913   if( NULL == pQueue ) 
        CMP      R1,#+0
        BNE.N    ??NvGetPendingSavesCount_0
//  914   {
//  915     return 0;
        MOVS     R0,#+0
        B.N      ??NvGetPendingSavesCount_1
//  916   }
//  917   return pQueue->EntriesCount;
??NvGetPendingSavesCount_0:
        LDRB     R0,[R1, #+194]
??NvGetPendingSavesCount_1:
        BX       LR               ;; return
//  918 }
//  919 
//  920 
//  921 /*****************************************************************
//  922  * The below functions are compiled only if FlexNVM is NOT used 
//  923  *****************************************************************/
//  924 
//  925 #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */
//  926 
//  927 /******************************************************************************
//  928  * Name: NvEraseVirtualPage
//  929  * Description: erase the specified page
//  930  * Parameter(s): [IN] pageID - the ID of the page to be erased
//  931  * Return: gNVM_InvalidPageID_c - if the page ID is not valid
//  932  *         gNVM_SectorEraseFail_c - if the page cannot be erased
//  933  *         gNVM_OK_c - if operation completed successfully
//  934  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  935 static NVM_Status_t NvEraseVirtualPage
//  936 (
//  937   NVM_VirtualPageID_t pageID
//  938 )
//  939 {    
NvEraseVirtualPage:
        PUSH     {R4,LR}
        MOVS     R4,R0
//  940   if(pageID > gSecondVirtualPage_c)
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+2
        BLT.N    ??NvEraseVirtualPage_0
//  941     return gNVM_InvalidPageID_c;
        MOVS     R0,#+2
        B.N      ??NvEraseVirtualPage_1
//  942 
//  943   /* erase virtual page */
//  944   if(gNV_OK_c == NV_FlashEraseSector(&mNvConfig, mNvVirtualPageProperty[pageID].NvRawSectorStartAddress,
//  945       mNvVirtualPageProperty[pageID].NvTotalPageSize))
??NvEraseVirtualPage_0:
        LDR.W    R0,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+20
        MLA      R0,R1,R4,R0
        LDR      R2,[R0, #+12]
        LDR.W    R0,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+20
        MLA      R0,R1,R4,R0
        LDR      R1,[R0, #+0]
        LDR.W    R0,??DataTable13_1
        BL       NV_FlashEraseSector
        CMP      R0,#+0
        BNE.N    ??NvEraseVirtualPage_2
//  946   {
//  947     return gNVM_OK_c;
        MOVS     R0,#+0
        B.N      ??NvEraseVirtualPage_1
//  948   }
//  949 
//  950   return gNVM_SectorEraseFail_c;
??NvEraseVirtualPage_2:
        MOVS     R0,#+4
??NvEraseVirtualPage_1:
        POP      {R4,PC}          ;; return
//  951 }
//  952 
//  953 
//  954 /******************************************************************************
//  955  * Name: NvInitStorageSystem
//  956  * Description: Initialize the storage system, retrieve the active page and
//  957  *              the page counter. Called once by NvModuleInit() function.
//  958  * Parameter(s): - 
//  959  * Return: -
//  960  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  961 static void NvInitStorageSystem
//  962 (
//  963   void
//  964 )
//  965 {
NvInitStorageSystem:
        PUSH     {LR}
        SUB      SP,SP,#+20
//  966   uint32_t firstPageCounterTopValue;
//  967   uint32_t firstPageCounterBottomValue;
//  968   uint32_t secondPageCounterTopValue;
//  969   uint32_t secondPageCounterBottomValue;
//  970 
//  971   /* read both pages counter values */
//  972   NV_FlashRead(mNvVirtualPageProperty[gFirstVirtualPage_c].NvRawSectorStartAddress, (uint8_t*)&firstPageCounterTopValue, 
//  973       sizeof(firstPageCounterTopValue));
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        LDR.W    R0,??DataTable13
        LDR      R0,[R0, #+0]
        BL       NV_FlashRead
//  974   NV_FlashRead(mNvVirtualPageProperty[gFirstVirtualPage_c].NvRawSectorEndAddress - sizeof(firstPageCounterBottomValue) + 1,  
//  975       (uint8_t*)&firstPageCounterBottomValue, sizeof(firstPageCounterBottomValue));
        MOVS     R2,#+4
        ADD      R1,SP,#+12
        LDR.W    R0,??DataTable13
        LDR      R0,[R0, #+4]
        SUBS     R0,R0,#+3
        BL       NV_FlashRead
//  976   NV_FlashRead(mNvVirtualPageProperty[gSecondVirtualPage_c].NvRawSectorStartAddress, (uint8_t*)&secondPageCounterTopValue, 
//  977       sizeof(secondPageCounterTopValue));
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        LDR.W    R0,??DataTable13
        LDR      R0,[R0, #+20]
        BL       NV_FlashRead
//  978   NV_FlashRead(mNvVirtualPageProperty[gSecondVirtualPage_c].NvRawSectorEndAddress - sizeof(secondPageCounterBottomValue) + 1, 
//  979       (uint8_t*)&secondPageCounterBottomValue, sizeof(secondPageCounterBottomValue));
        MOVS     R2,#+4
        ADD      R1,SP,#+8
        LDR.W    R0,??DataTable13
        LDR      R0,[R0, #+24]
        SUBS     R0,R0,#+3
        BL       NV_FlashRead
//  980 
//  981   mNvActivePageId = gVirtualPageNone_c;
        MOVS     R0,#+2
        LDR.W    R1,??DataTable13_2
        STRB     R0,[R1, #+0]
//  982 
//  983 
//  984   if((firstPageCounterTopValue == firstPageCounterBottomValue) && (gPageCounterMaxValue_c != firstPageCounterTopValue))
        LDR      R0,[SP, #+4]
        LDR      R1,[SP, #+12]
        CMP      R0,R1
        BNE.N    ??NvInitStorageSystem_0
        LDR      R0,[SP, #+4]
        CMN      R0,#+1
        BEQ.N    ??NvInitStorageSystem_0
//  985   {
//  986     if((secondPageCounterTopValue == secondPageCounterBottomValue) && (gPageCounterMaxValue_c != secondPageCounterTopValue))
        LDR      R0,[SP, #+0]
        LDR      R1,[SP, #+8]
        CMP      R0,R1
        BNE.N    ??NvInitStorageSystem_1
        LDR      R0,[SP, #+0]
        CMN      R0,#+1
        BEQ.N    ??NvInitStorageSystem_1
//  987     {
//  988       if(firstPageCounterTopValue >= secondPageCounterTopValue)
        LDR      R0,[SP, #+4]
        LDR      R1,[SP, #+0]
        CMP      R0,R1
        BCC.N    ??NvInitStorageSystem_2
//  989       {
//  990         /* first page is active */
//  991         mNvPageCounter = firstPageCounterTopValue;
        LDR      R0,[SP, #+4]
        LDR.W    R1,??DataTable13_3
        STR      R0,[R1, #+0]
//  992         mNvActivePageId = gFirstVirtualPage_c;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable13_2
        STRB     R0,[R1, #+0]
//  993         return;
        B.N      ??NvInitStorageSystem_3
//  994       }
//  995 
//  996       /* second page is active */
//  997       mNvPageCounter = secondPageCounterTopValue;
??NvInitStorageSystem_2:
        LDR      R0,[SP, #+0]
        LDR.W    R1,??DataTable13_3
        STR      R0,[R1, #+0]
//  998       mNvActivePageId = gSecondVirtualPage_c;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable13_2
        STRB     R0,[R1, #+0]
//  999       return;
        B.N      ??NvInitStorageSystem_3
// 1000     }
// 1001 
// 1002     if(secondPageCounterTopValue != secondPageCounterBottomValue)
??NvInitStorageSystem_1:
        LDR      R0,[SP, #+0]
        LDR      R1,[SP, #+8]
        CMP      R0,R1
        BEQ.N    ??NvInitStorageSystem_4
// 1003     {                
// 1004       /* first page is active */
// 1005       mNvPageCounter = firstPageCounterTopValue;
        LDR      R0,[SP, #+4]
        LDR.W    R1,??DataTable13_3
        STR      R0,[R1, #+0]
// 1006       mNvActivePageId = gFirstVirtualPage_c;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable13_2
        STRB     R0,[R1, #+0]
// 1007       /* request the erase of the second page */
// 1008       mNvErasePgCmdStatus.NvPageToErase = gSecondVirtualPage_c;            
        MOVS     R0,#+1
        LDR.W    R1,??DataTable13_4
        STRB     R0,[R1, #+1]
// 1009       mNvErasePgCmdStatus.NvSectorAddress = mNvVirtualPageProperty[gSecondVirtualPage_c].NvRawSectorStartAddress;
        LDR.W    R0,??DataTable13
        LDR      R0,[R0, #+20]
        LDR.W    R1,??DataTable13_4
        STR      R0,[R1, #+4]
// 1010       mNvErasePgCmdStatus.NvErasePending = TRUE;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable13_4
        STRB     R0,[R1, #+0]
// 1011       return;
        B.N      ??NvInitStorageSystem_3
// 1012     }
// 1013 
// 1014     if(gNVM_PageIsNotBlank_c == NvVirtualPageBlankCheck(gSecondVirtualPage_c))
??NvInitStorageSystem_4:
        MOVS     R0,#+1
        BL       NvVirtualPageBlankCheck
        CMP      R0,#+3
        BNE.N    ??NvInitStorageSystem_5
// 1015     {            
// 1016       /* second page is active */
// 1017       mNvPageCounter = secondPageCounterTopValue;
        LDR      R0,[SP, #+0]
        LDR.W    R1,??DataTable13_3
        STR      R0,[R1, #+0]
// 1018       mNvActivePageId = gSecondVirtualPage_c;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable13_2
        STRB     R0,[R1, #+0]
// 1019       return;
        B.N      ??NvInitStorageSystem_3
// 1020     }
// 1021     else
// 1022     {
// 1023       /* first page is active */
// 1024       mNvPageCounter = firstPageCounterTopValue;
??NvInitStorageSystem_5:
        LDR      R0,[SP, #+4]
        LDR.W    R1,??DataTable13_3
        STR      R0,[R1, #+0]
// 1025       mNvActivePageId = gFirstVirtualPage_c;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable13_2
        STRB     R0,[R1, #+0]
// 1026       return;
        B.N      ??NvInitStorageSystem_3
// 1027     }        
// 1028   }
// 1029 
// 1030   if(firstPageCounterTopValue != firstPageCounterBottomValue)
??NvInitStorageSystem_0:
        LDR      R0,[SP, #+4]
        LDR      R1,[SP, #+12]
        CMP      R0,R1
        BEQ.N    ??NvInitStorageSystem_6
// 1031   {
// 1032     if((secondPageCounterTopValue == secondPageCounterBottomValue) && (gPageCounterMaxValue_c != secondPageCounterTopValue))
        LDR      R0,[SP, #+0]
        LDR      R1,[SP, #+8]
        CMP      R0,R1
        BNE.N    ??NvInitStorageSystem_7
        LDR      R0,[SP, #+0]
        CMN      R0,#+1
        BEQ.N    ??NvInitStorageSystem_7
// 1033     {            
// 1034       /* second page is active */
// 1035       mNvPageCounter = secondPageCounterTopValue;
        LDR      R0,[SP, #+0]
        LDR.W    R1,??DataTable13_3
        STR      R0,[R1, #+0]
// 1036       mNvActivePageId = gSecondVirtualPage_c;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable13_2
        STRB     R0,[R1, #+0]
// 1037       /* request the erase of the first page */
// 1038       mNvErasePgCmdStatus.NvPageToErase = gFirstVirtualPage_c;            
        MOVS     R0,#+0
        LDR.W    R1,??DataTable13_4
        STRB     R0,[R1, #+1]
// 1039       mNvErasePgCmdStatus.NvSectorAddress = mNvVirtualPageProperty[gFirstVirtualPage_c].NvRawSectorStartAddress;
        LDR.W    R0,??DataTable13
        LDR      R0,[R0, #+0]
        LDR.W    R1,??DataTable13_4
        STR      R0,[R1, #+4]
// 1040       mNvErasePgCmdStatus.NvErasePending = TRUE;            
        MOVS     R0,#+1
        LDR.W    R1,??DataTable13_4
        STRB     R0,[R1, #+0]
// 1041       return;
        B.N      ??NvInitStorageSystem_3
// 1042     }
// 1043 
// 1044     if(secondPageCounterTopValue != secondPageCounterBottomValue)
??NvInitStorageSystem_7:
        LDR      R0,[SP, #+0]
        LDR      R1,[SP, #+8]
        CMP      R0,R1
        BEQ.N    ??NvInitStorageSystem_8
// 1045     {
// 1046       /* both pages are invalid, format the NV storage system */            
// 1047       (void)NvInternalFormat(0);
        MOVS     R0,#+0
        BL       NvInternalFormat
// 1048       return;
        B.N      ??NvInitStorageSystem_3
// 1049     }
// 1050 
// 1051     if(gNVM_PageIsNotBlank_c == NvVirtualPageBlankCheck(gSecondVirtualPage_c))
??NvInitStorageSystem_8:
        MOVS     R0,#+1
        BL       NvVirtualPageBlankCheck
        CMP      R0,#+3
        BNE.N    ??NvInitStorageSystem_9
// 1052     {            
// 1053       /* second page is active */
// 1054       mNvPageCounter = secondPageCounterTopValue;
        LDR      R0,[SP, #+0]
        LDR.W    R1,??DataTable13_3
        STR      R0,[R1, #+0]
// 1055       mNvActivePageId = gSecondVirtualPage_c;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable13_2
        STRB     R0,[R1, #+0]
// 1056       return;
        B.N      ??NvInitStorageSystem_3
// 1057     }
// 1058     else
// 1059     {
// 1060       /* first page is invalid and the second one is blank */
// 1061       /* format the NV storage system */            
// 1062       (void)NvInternalFormat(0);
??NvInitStorageSystem_9:
        MOVS     R0,#+0
        BL       NvInternalFormat
// 1063       return;
        B.N      ??NvInitStorageSystem_3
// 1064     }        
// 1065   }
// 1066 
// 1067   if(gNVM_PageIsNotBlank_c == NvVirtualPageBlankCheck(gFirstVirtualPage_c))
??NvInitStorageSystem_6:
        MOVS     R0,#+0
        BL       NvVirtualPageBlankCheck
        CMP      R0,#+3
        BNE.N    ??NvInitStorageSystem_10
// 1068   {
// 1069     /* first page is active */
// 1070     mNvPageCounter = firstPageCounterTopValue;
        LDR      R0,[SP, #+4]
        LDR.W    R1,??DataTable13_3
        STR      R0,[R1, #+0]
// 1071     mNvActivePageId = gFirstVirtualPage_c;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable13_2
        STRB     R0,[R1, #+0]
// 1072     return;
        B.N      ??NvInitStorageSystem_3
// 1073   }
// 1074   else
// 1075   {
// 1076     /* first page is blank */        
// 1077     if((secondPageCounterTopValue == secondPageCounterBottomValue) && (gPageCounterMaxValue_c != secondPageCounterTopValue))
??NvInitStorageSystem_10:
        LDR      R0,[SP, #+0]
        LDR      R1,[SP, #+8]
        CMP      R0,R1
        BNE.N    ??NvInitStorageSystem_11
        LDR      R0,[SP, #+0]
        CMN      R0,#+1
        BEQ.N    ??NvInitStorageSystem_11
// 1078     {
// 1079       /* second page is active */
// 1080       mNvPageCounter = secondPageCounterTopValue;
        LDR      R0,[SP, #+0]
        LDR.W    R1,??DataTable13_3
        STR      R0,[R1, #+0]
// 1081       mNvActivePageId = gSecondVirtualPage_c;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable13_2
        STRB     R0,[R1, #+0]
// 1082       return;
        B.N      ??NvInitStorageSystem_3
// 1083     }
// 1084 
// 1085     if(secondPageCounterTopValue != secondPageCounterBottomValue)
??NvInitStorageSystem_11:
        LDR      R0,[SP, #+0]
        LDR      R1,[SP, #+8]
        CMP      R0,R1
        BEQ.N    ??NvInitStorageSystem_12
// 1086     {
// 1087       /* first page is blank and the second one is not valid */
// 1088       /* format the NV storage system */
// 1089       (void)NvInternalFormat(0);
        MOVS     R0,#+0
        BL       NvInternalFormat
// 1090       return;
        B.N      ??NvInitStorageSystem_3
// 1091     }
// 1092 
// 1093     if(gNVM_PageIsNotBlank_c == NvVirtualPageBlankCheck(gSecondVirtualPage_c))
??NvInitStorageSystem_12:
        MOVS     R0,#+1
        BL       NvVirtualPageBlankCheck
        CMP      R0,#+3
        BNE.N    ??NvInitStorageSystem_13
// 1094     {            
// 1095       /* second page is active */
// 1096       mNvPageCounter = secondPageCounterTopValue;
        LDR      R0,[SP, #+0]
        LDR.W    R1,??DataTable13_3
        STR      R0,[R1, #+0]
// 1097       mNvActivePageId = gSecondVirtualPage_c;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable13_2
        STRB     R0,[R1, #+0]
// 1098       return;
        B.N      ??NvInitStorageSystem_3
// 1099     }
// 1100     else
// 1101     {
// 1102       /* both pages are blank */
// 1103       /* format the NV storage system */
// 1104       (void)NvInternalFormat(0);
??NvInitStorageSystem_13:
        MOVS     R0,#+0
        BL       NvInternalFormat
// 1105       return;
??NvInitStorageSystem_3:
        ADD      SP,SP,#+20
        POP      {PC}             ;; return
// 1106     }            
// 1107   }    
// 1108 }
// 1109 
// 1110 /******************************************************************************
// 1111  * Name: NvVirtualPageBlankCheck
// 1112  * Description: checks if the specified page is blank (erased) 
// 1113  * Parameter(s): [IN] pageID - the ID of the page to be checked
// 1114  * Return: gNVM_InvalidPageID_c - if the page ID is not valid 
// 1115  *         gNVM_PageIsNotBlank_c - if the page is not blank
// 1116  *         gNVM_OK_c - if the page is blank (erased)
// 1117  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1118 static NVM_Status_t NvVirtualPageBlankCheck
// 1119 (
// 1120   NVM_VirtualPageID_t pageID
// 1121 )
// 1122 {
NvVirtualPageBlankCheck:
        PUSH     {R4,LR}
        MOVS     R4,R0
// 1123   if(pageID > gSecondVirtualPage_c)
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+2
        BLT.N    ??NvVirtualPageBlankCheck_0
// 1124     return gNVM_InvalidPageID_c;
        MOVS     R0,#+2
        B.N      ??NvVirtualPageBlankCheck_1
// 1125 
// 1126   if(gNV_OK_c != NV_FlashVerifySection(&mNvConfig, mNvVirtualPageProperty[pageID].NvRawSectorStartAddress,
// 1127       mNvVirtualPageProperty[pageID].NvTotalPageSize, gNV_MARGIN_NORMAL_c))
??NvVirtualPageBlankCheck_0:
        MOVS     R3,#+0
        LDR.W    R0,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+20
        MLA      R0,R1,R4,R0
        LDR      R2,[R0, #+12]
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        LDR.W    R0,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+20
        MLA      R0,R1,R4,R0
        LDR      R1,[R0, #+0]
        LDR.W    R0,??DataTable13_1
        BL       NV_FlashVerifySection
        CMP      R0,#+0
        BEQ.N    ??NvVirtualPageBlankCheck_2
// 1128   {
// 1129     return gNVM_PageIsNotBlank_c;
        MOVS     R0,#+3
        B.N      ??NvVirtualPageBlankCheck_1
// 1130   }
// 1131 
// 1132   return gNVM_OK_c;    
??NvVirtualPageBlankCheck_2:
        MOVS     R0,#+0
??NvVirtualPageBlankCheck_1:
        POP      {R4,PC}          ;; return
// 1133 }
// 1134 
// 1135 
// 1136 /******************************************************************************
// 1137  * Name: NvGetLastMetaInfoAddress
// 1138  * Description: retrieve and store (update) the last meta information address 
// 1139  * Parameter(s): -
// 1140  * Return: gNVM_MetaNotFound_c - if no meta information has been found
// 1141  *         gNVM_OK_c - if the meta was found and stored (updated)
// 1142  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1143 static NVM_Status_t NvGetLastMetaInfoAddress
// 1144 (    
// 1145   void
// 1146 )
// 1147 {       
NvGetLastMetaInfoAddress:
        PUSH     {R4,LR}
        SUB      SP,SP,#+16
// 1148   uint32_t readAddress;  
// 1149   uint8_t metaFirstByte;
// 1150   NVM_RecordMetaInfo_t metaValue;
// 1151 
// 1152 #if gNvUseExtendedFeatureSet_d  
// 1153   readAddress = mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + sizeof(mNvPageCounter) + 
// 1154       mNvTableSizeInFlash + (2 * sizeof(mNvTableMarker));
// 1155 #else
// 1156   readAddress = mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + sizeof(mNvPageCounter);
        LDR.W    R0,??DataTable13
        LDR.W    R1,??DataTable13_2
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+4
        MOVS     R4,R0
// 1157 #endif /* gNvUseExtendedFeatureSet_d */
// 1158 
// 1159   while(readAddress < mNvVirtualPageProperty[mNvActivePageId].NvRawSectorEndAddress)
??NvGetLastMetaInfoAddress_0:
        LDR.W    R0,??DataTable13
        LDR.W    R1,??DataTable13_2
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+4]
        CMP      R4,R0
        BCS.N    ??NvGetLastMetaInfoAddress_1
// 1160   {
// 1161     NV_FlashRead(readAddress, (uint8_t*)&metaFirstByte, sizeof(metaFirstByte));
        MOVS     R2,#+1
        ADD      R1,SP,#+8
        MOVS     R0,R4
        BL       NV_FlashRead
// 1162 
// 1163     if(gNvErasedFlashCellValue_c == metaFirstByte)
        LDRB     R0,[SP, #+8]
        CMP      R0,#+255
        BNE.N    ??NvGetLastMetaInfoAddress_2
// 1164     {
// 1165       NV_FlashRead(readAddress, (uint8_t*)&metaValue, sizeof(metaValue));
        MOVS     R2,#+8
        ADD      R1,SP,#+0
        MOVS     R0,R4
        BL       NV_FlashRead
// 1166 
// 1167       if(metaValue.rawValue == 0xFFFFFFFFFFFFFFFF)
        ADD      R0,SP,#+0
        LDR      R2,[R0, #+0]
        LDR      R3,[R0, #+4]
        MOVS     R0,#-1
        MOVS     R1,#-1
        CMP      R3,R1
        BNE.N    ??NvGetLastMetaInfoAddress_3
        CMP      R2,R0
        BNE.N    ??NvGetLastMetaInfoAddress_3
// 1168       {
// 1169         if(readAddress == (mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + sizeof(mNvPageCounter)
// 1170 #if gNvUseExtendedFeatureSet_d        		
// 1171         		+ mNvTableSizeInFlash + (2 * sizeof(mNvTableMarker))
// 1172 #endif /* gNvUseExtendedFeatureSet_d */
// 1173         ))
        LDR.W    R0,??DataTable13
        LDR.W    R1,??DataTable13_2
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+4
        CMP      R4,R0
        BNE.N    ??NvGetLastMetaInfoAddress_4
// 1174         {
// 1175           mNvVirtualPageProperty[mNvActivePageId].NvLastMetaInfoAddress = gEmptyPageMetaAddress_c;
        LDR.W    R0,??DataTable14  ;; 0x3fff0000
        LDR.W    R1,??DataTable13
        LDR.W    R2,??DataTable13_2
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+20
        MLA      R1,R3,R2,R1
        STR      R0,[R1, #+16]
// 1176           return gNVM_OK_c;
        MOVS     R0,#+0
        B.N      ??NvGetLastMetaInfoAddress_5
// 1177         }
// 1178 
// 1179         readAddress -= sizeof(NVM_RecordMetaInfo_t);
??NvGetLastMetaInfoAddress_4:
        SUBS     R4,R4,#+8
// 1180 
// 1181         while(readAddress >= (mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + sizeof(mNvPageCounter)
// 1182 #if gNvUseExtendedFeatureSet_d
// 1183         		+ mNvTableSizeInFlash + (2 * sizeof(mNvTableMarker))
// 1184 #endif /* gNvUseExtendedFeatureSet_d */
// 1185         ))
??NvGetLastMetaInfoAddress_6:
        LDR.W    R0,??DataTable13
        LDR.W    R1,??DataTable13_2
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+4
        CMP      R4,R0
        BCC.N    ??NvGetLastMetaInfoAddress_7
// 1186         {
// 1187           NV_FlashRead(readAddress, (uint8_t*)&metaValue, sizeof(metaValue));
        MOVS     R2,#+8
        ADD      R1,SP,#+0
        MOVS     R0,R4
        BL       NV_FlashRead
// 1188 
// 1189           if((metaValue.fields.NvValidationStartByte == metaValue.fields.NvValidationEndByte) &&
// 1190               ((gValidationByteSingleRecord_c == metaValue.fields.NvValidationStartByte) || 
// 1191                   (gValidationByteAllRecords_c == metaValue.fields.NvValidationStartByte)))
        LDRB     R0,[SP, #+0]
        LDRB     R1,[SP, #+7]
        CMP      R0,R1
        BNE.N    ??NvGetLastMetaInfoAddress_8
        LDRB     R0,[SP, #+0]
        CMP      R0,#+170
        BEQ.N    ??NvGetLastMetaInfoAddress_9
        LDRB     R0,[SP, #+0]
        CMP      R0,#+85
        BNE.N    ??NvGetLastMetaInfoAddress_8
// 1192           {
// 1193             mNvVirtualPageProperty[mNvActivePageId].NvLastMetaInfoAddress = readAddress;
??NvGetLastMetaInfoAddress_9:
        LDR.W    R0,??DataTable13
        LDR.W    R1,??DataTable13_2
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        STR      R4,[R0, #+16]
// 1194             return gNVM_OK_c;
        MOVS     R0,#+0
        B.N      ??NvGetLastMetaInfoAddress_5
// 1195           }                    
// 1196           readAddress -= sizeof(NVM_RecordMetaInfo_t);
??NvGetLastMetaInfoAddress_8:
        SUBS     R4,R4,#+8
        B.N      ??NvGetLastMetaInfoAddress_6
// 1197         }
// 1198         return gNVM_MetaNotFound_c;
??NvGetLastMetaInfoAddress_7:
        MOVS     R0,#+11
        B.N      ??NvGetLastMetaInfoAddress_5
// 1199       }
// 1200       return gNVM_MetaNotFound_c;
??NvGetLastMetaInfoAddress_3:
        MOVS     R0,#+11
        B.N      ??NvGetLastMetaInfoAddress_5
// 1201     }
// 1202     else
// 1203     {
// 1204       readAddress += sizeof(NVM_RecordMetaInfo_t);
??NvGetLastMetaInfoAddress_2:
        ADDS     R4,R4,#+8
        B.N      ??NvGetLastMetaInfoAddress_0
// 1205     }
// 1206   }    
// 1207   return gNVM_MetaNotFound_c;
??NvGetLastMetaInfoAddress_1:
        MOVS     R0,#+11
??NvGetLastMetaInfoAddress_5:
        ADD      SP,SP,#+16
        POP      {R4,PC}          ;; return
// 1208 }
// 1209 
// 1210 
// 1211 /******************************************************************************
// 1212  * Name: NvGetMetaInfo
// 1213  * Description: get meta information based on the meta information address
// 1214  * Parameter(s): [IN] pageID - the ID of the page
// 1215  *               [IN] metaInfoAddress - meta information address
// 1216  *               [OUT] pMetaInfo - a pointer to a memory location where the 
// 1217  *                                 requested meta information will be stored
// 1218  * Return: gNVM_InvalidPageID_c - if the active page is not valid
// 1219  *         gNVM_NullPointer_c - if the provided pointer is NULL
// 1220  *         gNVM_AddressOutOfRange_c - if the provided address is out of range
// 1221  *         gNVM_OK_c - if the operation completed successfully
// 1222  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1223 static NVM_Status_t NvGetMetaInfo
// 1224 (
// 1225   NVM_VirtualPageID_t pageId,
// 1226   uint32_t metaInfoAddress,
// 1227   NVM_RecordMetaInfo_t* pMetaInfo
// 1228 )
// 1229 {
NvGetMetaInfo:
        PUSH     {R4-R6,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
// 1230   /* check address range */
// 1231   if(metaInfoAddress < (mNvVirtualPageProperty[pageId].NvRawSectorStartAddress + sizeof(mNvPageCounter)
// 1232 #if gNvUseExtendedFeatureSet_d		  
// 1233 		  + (mNvTableSizeInFlash + (2 * sizeof(mNvTableMarker)))
// 1234 #endif /* gNvUseExtendedFeatureSet_d */
// 1235 		  ) || metaInfoAddress > mNvVirtualPageProperty[pageId].NvRawSectorEndAddress)
        LDR.W    R0,??DataTable14_1
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+20
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+4
        CMP      R5,R0
        BCC.N    ??NvGetMetaInfo_0
        LDR.W    R0,??DataTable14_1
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+20
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        CMP      R0,R5
        BCS.N    ??NvGetMetaInfo_1
// 1236   {
// 1237     return gNVM_AddressOutOfRange_c;
??NvGetMetaInfo_0:
        MOVS     R0,#+7
        B.N      ??NvGetMetaInfo_2
// 1238   }
// 1239 
// 1240   /* read the meta information tag */
// 1241   NV_FlashRead(metaInfoAddress, (uint8_t*)pMetaInfo, sizeof(NVM_RecordMetaInfo_t));
??NvGetMetaInfo_1:
        MOVS     R2,#+8
        MOVS     R1,R6
        MOVS     R0,R5
        BL       NV_FlashRead
// 1242 
// 1243   return gNVM_OK_c;    
        MOVS     R0,#+0
??NvGetMetaInfo_2:
        POP      {R4-R6,PC}       ;; return
// 1244 }
// 1245 
// 1246 
// 1247 /******************************************************************************
// 1248  * Name: NvGetPageFreeSpace
// 1249  * Description: return the page free space, in bytes
// 1250  * Parameter(s): [OUT] ptrFreeSpace - a pointer to a memory location where the
// 1251  *                                    page free space will be stored
// 1252  * Return: gNVM_InvalidPageID_c - if the active page is not valid
// 1253  *         gNVM_NullPointer_c - if the provided pointer is NULL
// 1254  *         gNVM_PageIsEmpty_c - if the page is empty
// 1255  *         gNVM_OK_c - if the operation completed successfully
// 1256  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1257 static NVM_Status_t NvGetPageFreeSpace
// 1258 (    
// 1259   uint32_t* ptrFreeSpace
// 1260 )
// 1261 {
NvGetPageFreeSpace:
        PUSH     {R4,R5,LR}
        SUB      SP,SP,#+12
        MOVS     R4,R0
// 1262   NVM_RecordMetaInfo_t metaInfo;
// 1263   NVM_Status_t retVal;
// 1264 
// 1265   if(gEmptyPageMetaAddress_c == mNvVirtualPageProperty[mNvActivePageId].NvLastMetaInfoAddress)
        LDR.W    R0,??DataTable13
        LDR.W    R1,??DataTable13_2
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+16]
        LDR.W    R1,??DataTable14  ;; 0x3fff0000
        CMP      R0,R1
        BNE.N    ??NvGetPageFreeSpace_0
// 1266   {
// 1267 #if gNvUseExtendedFeatureSet_d	  
// 1268     *ptrFreeSpace = mNvVirtualPageProperty[mNvActivePageId].NvTotalPageSize - mNvTableSizeInFlash - 
// 1269         (2 * (sizeof(mNvPageCounter) + sizeof(mNvTableMarker)));
// 1270 #else
// 1271     *ptrFreeSpace = mNvVirtualPageProperty[mNvActivePageId].NvTotalPageSize - (2 * sizeof(mNvPageCounter));
        LDR.W    R0,??DataTable13
        LDR.W    R1,??DataTable13_2
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+12]
        SUBS     R0,R0,#+8
        STR      R0,[R4, #+0]
        B.N      ??NvGetPageFreeSpace_1
// 1272 #endif /* gNvUseExtendedFeatureSet_d */
// 1273   }
// 1274   else
// 1275   {        
// 1276     retVal = NvGetMetaInfo(mNvActivePageId, mNvVirtualPageProperty[mNvActivePageId].NvLastMetaInfoAddress, &metaInfo);
??NvGetPageFreeSpace_0:
        ADD      R2,SP,#+0
        LDR.W    R0,??DataTable13
        LDR.W    R1,??DataTable13_2
        LDRB     R1,[R1, #+0]
        MOVS     R3,#+20
        MLA      R0,R3,R1,R0
        LDR      R1,[R0, #+16]
        LDR.W    R0,??DataTable13_2
        LDRB     R0,[R0, #+0]
        BL       NvGetMetaInfo
        MOVS     R5,R0
// 1277 
// 1278     if(gNVM_OK_c == retVal)
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BNE.N    ??NvGetPageFreeSpace_2
// 1279     {
// 1280       *ptrFreeSpace = (mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + metaInfo.fields.NvmRecordOffset) - 
// 1281           (mNvVirtualPageProperty[mNvActivePageId].NvLastMetaInfoAddress + 
// 1282               sizeof(NVM_RecordMetaInfo_t));
        LDR.W    R0,??DataTable13
        LDR.W    R1,??DataTable13_2
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+0]
        LDRH     R1,[SP, #+5]
        UXTAH    R0,R0,R1
        LDR.W    R1,??DataTable13
        LDR.W    R2,??DataTable13_2
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+20
        MLA      R1,R3,R2,R1
        LDR      R1,[R1, #+16]
        SUBS     R0,R0,R1
        SUBS     R0,R0,#+8
        STR      R0,[R4, #+0]
        B.N      ??NvGetPageFreeSpace_1
// 1283     }
// 1284     else
// 1285     {            
// 1286       *ptrFreeSpace = 0;
??NvGetPageFreeSpace_2:
        MOVS     R0,#+0
        STR      R0,[R4, #+0]
// 1287     }
// 1288   }
// 1289   return retVal;
??NvGetPageFreeSpace_1:
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R1-R5,PC}       ;; return
// 1290 }
// 1291 
// 1292 
// 1293 /******************************************************************************
// 1294  * Name: NvIsMemoryAreaAvailable
// 1295  * Description: checks if the specified memory area is blank (erased)
// 1296  * Parameter(s): [IN] address - start address
// 1297  *               [IN] len - length to be verified
// 1298  * Return: TRUE if the area is available (blank), FALSE otherwise
// 1299  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1300 static bool_t NvIsMemoryAreaAvailable
// 1301 (
// 1302   uint32_t address,
// 1303   uint32_t len
// 1304 )
// 1305 {
NvIsMemoryAreaAvailable:
        PUSH     {R4-R6,LR}
        SUB      SP,SP,#+8
        MOVS     R4,R0
        MOVS     R5,R1
// 1306   uint8_t readBuffer[gNV_LONGWORD_SIZE_c];
// 1307   uint8_t loopCnt;
// 1308 
// 1309   if(len % (uint8_t)gNV_LONGWORD_SIZE_c != 0)
        MOVS     R0,#+4
        UDIV     R1,R5,R0
        MLS      R1,R1,R0,R5
        CMP      R1,#+0
        BEQ.N    ??NvIsMemoryAreaAvailable_0
// 1310   {
// 1311     return FALSE;
        MOVS     R0,#+0
        B.N      ??NvIsMemoryAreaAvailable_1
// 1312   }
// 1313 
// 1314 
// 1315   if(address < mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress ||
// 1316       address > mNvVirtualPageProperty[mNvActivePageId].NvRawSectorEndAddress)
??NvIsMemoryAreaAvailable_0:
        LDR.W    R0,??DataTable13
        LDR.W    R1,??DataTable13_2
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+0]
        CMP      R4,R0
        BCC.N    ??NvIsMemoryAreaAvailable_2
        LDR.W    R0,??DataTable13
        LDR.W    R1,??DataTable13_2
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+4]
        CMP      R0,R4
        BCS.N    ??NvIsMemoryAreaAvailable_3
// 1317   {
// 1318     return FALSE;
??NvIsMemoryAreaAvailable_2:
        MOVS     R0,#+0
        B.N      ??NvIsMemoryAreaAvailable_1
// 1319   }
// 1320 
// 1321   if((address + len) > mNvVirtualPageProperty[mNvActivePageId].NvRawSectorEndAddress + 1)
??NvIsMemoryAreaAvailable_3:
        LDR.W    R0,??DataTable13
        LDR.W    R1,??DataTable13_2
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+4]
        ADDS     R0,R0,#+1
        ADDS     R1,R5,R4
        CMP      R0,R1
        BCS.N    ??NvIsMemoryAreaAvailable_4
// 1322   {
// 1323     return FALSE;
        MOVS     R0,#+0
        B.N      ??NvIsMemoryAreaAvailable_1
// 1324   }
// 1325 
// 1326   while(len)
??NvIsMemoryAreaAvailable_4:
        CMP      R5,#+0
        BEQ.N    ??NvIsMemoryAreaAvailable_5
// 1327   {
// 1328 
// 1329     NV_FlashRead(address,(uint8_t*)&readBuffer[0], (uint8_t)gNV_LONGWORD_SIZE_c);
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOVS     R0,R4
        BL       NV_FlashRead
// 1330     loopCnt = (uint8_t)gNV_LONGWORD_SIZE_c;
        MOVS     R0,#+4
        MOVS     R6,R0
// 1331     while(loopCnt)
??NvIsMemoryAreaAvailable_6:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BEQ.N    ??NvIsMemoryAreaAvailable_7
// 1332     {
// 1333       if(readBuffer[--loopCnt] != gNvErasedFlashCellValue_c)
        SUBS     R6,R6,#+1
        ADD      R0,SP,#+0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        LDRB     R0,[R6, R0]
        CMP      R0,#+255
        BEQ.N    ??NvIsMemoryAreaAvailable_6
// 1334       {
// 1335         return FALSE;
        MOVS     R0,#+0
        B.N      ??NvIsMemoryAreaAvailable_1
// 1336       }            
// 1337     }        
// 1338     len-=(uint8_t)gNV_LONGWORD_SIZE_c;
??NvIsMemoryAreaAvailable_7:
        SUBS     R5,R5,#+4
// 1339     address+=(uint8_t)gNV_LONGWORD_SIZE_c;
        ADDS     R4,R4,#+4
        B.N      ??NvIsMemoryAreaAvailable_4
// 1340   }
// 1341   return TRUE;    
??NvIsMemoryAreaAvailable_5:
        MOVS     R0,#+1
??NvIsMemoryAreaAvailable_1:
        POP      {R1,R2,R4-R6,PC}  ;; return
// 1342 }
// 1343 
// 1344 
// 1345 /******************************************************************************
// 1346  * Name: NvIsRecordCopied
// 1347  * Description: Checks if a record or an entire table entry is already copied. 
// 1348  *              Called by page copy function.
// 1349  * Parameter(s): [IN] pageId - the ID of the page where to perform the check
// 1350  *               [IN] metaInf - a pointer to source page meta information tag
// 1351  * Return: TRUE if the element is already copied, FALSE otherwise
// 1352  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1353 static bool_t NvIsRecordCopied
// 1354 (
// 1355   NVM_VirtualPageID_t pageId,
// 1356   NVM_RecordMetaInfo_t* metaInf
// 1357 )
// 1358 {
NvIsRecordCopied:
        PUSH     {R2-R8,LR}
        MOVS     R4,R0
        MOVS     R5,R1
// 1359   uint32_t loopAddress;
// 1360   uint8_t dataRead[8];
// 1361   bool_t retVal;
// 1362   uint16_t tmp;
// 1363 
// 1364 #if gNvUseExtendedFeatureSet_d
// 1365   loopAddress = mNvVirtualPageProperty[pageId].NvRawSectorStartAddress + sizeof(mNvPageCounter) + 
// 1366       mNvTableSizeInFlash + (2 * sizeof(mNvTableMarker));
// 1367 #else
// 1368   loopAddress = mNvVirtualPageProperty[pageId].NvRawSectorStartAddress + sizeof(mNvPageCounter);         
        LDR.W    R0,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+20
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+4
        MOVS     R6,R0
// 1369 #endif /* gNvUseExtendedFeatureSet_d */
// 1370   
// 1371   retVal = FALSE;
        MOVS     R0,#+0
        MOVS     R7,R0
// 1372 
// 1373   do
// 1374   {
// 1375     /* read the meta information tag */
// 1376     NV_FlashRead(loopAddress, (uint8_t*)dataRead, sizeof(NVM_RecordMetaInfo_t));
??NvIsRecordCopied_0:
        MOVS     R2,#+8
        ADD      R1,SP,#+0
        MOVS     R0,R6
        BL       NV_FlashRead
// 1377 
// 1378     if(dataRead[0] == gNvErasedFlashCellValue_c)
        LDRB     R0,[SP, #+0]
        CMP      R0,#+255
        BEQ.N    ??NvIsRecordCopied_1
// 1379     {
// 1380       /* no meta starts with 0xFF */
// 1381       break;
// 1382     }
// 1383 
// 1384     if(dataRead[0] != dataRead[7])
??NvIsRecordCopied_2:
        LDRB     R0,[SP, #+0]
        LDRB     R1,[SP, #+7]
        CMP      R0,R1
        BEQ.N    ??NvIsRecordCopied_3
// 1385     {
// 1386       /* invalid meta */
// 1387       loopAddress += sizeof(NVM_RecordMetaInfo_t);
        ADDS     R6,R6,#+8
// 1388       continue;
        B.N      ??NvIsRecordCopied_4
// 1389     }
// 1390 
// 1391     /* get the table entry ID */
// 1392     tmp = (uint16_t)(((uint16_t)dataRead[2]<<8) + dataRead[1]);
??NvIsRecordCopied_3:
        LDRB     R0,[SP, #+2]
        LSLS     R0,R0,#+8
        LDRB     R1,[SP, #+1]
        UXTAB    R0,R0,R1
        MOV      R8,R0
// 1393 
// 1394     if(metaInf->fields.NvmDataEntryID == tmp)
        LDRH     R0,[R5, #+1]
        UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
        CMP      R0,R8
        BNE.N    ??NvIsRecordCopied_5
// 1395     {  
// 1396       if(metaInf->fields.NvValidationStartByte == gValidationByteSingleRecord_c)
        LDRB     R0,[R5, #+0]
        CMP      R0,#+170
        BNE.N    ??NvIsRecordCopied_6
// 1397       {
// 1398         if(dataRead[0] == gValidationByteSingleRecord_c)
        LDRB     R0,[SP, #+0]
        CMP      R0,#+170
        BNE.N    ??NvIsRecordCopied_7
// 1399         {
// 1400           /* get the element index */
// 1401           tmp = (uint16_t)(((uint16_t)dataRead[4]<<8) + dataRead[3]);                  
        LDRB     R0,[SP, #+4]
        LSLS     R0,R0,#+8
        LDRB     R1,[SP, #+3]
        UXTAB    R0,R0,R1
        MOV      R8,R0
// 1402           if(tmp == metaInf->fields.NvmElementIndex)
        LDRH     R0,[R5, #+3]
        UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
        CMP      R8,R0
        BNE.N    ??NvIsRecordCopied_8
// 1403           {
// 1404             retVal = TRUE;
        MOVS     R0,#+1
        MOVS     R7,R0
// 1405             break;
        B.N      ??NvIsRecordCopied_1
// 1406           }
// 1407 
// 1408           /* skip */
// 1409           loopAddress += sizeof(NVM_RecordMetaInfo_t);
??NvIsRecordCopied_8:
        ADDS     R6,R6,#+8
// 1410           continue;
        B.N      ??NvIsRecordCopied_4
// 1411         }              
// 1412         retVal = TRUE;
??NvIsRecordCopied_7:
        MOVS     R0,#+1
        MOVS     R7,R0
// 1413         break;
        B.N      ??NvIsRecordCopied_1
// 1414       }
// 1415 
// 1416       if(metaInf->fields.NvValidationStartByte == gValidationByteAllRecords_c)
??NvIsRecordCopied_6:
        LDRB     R0,[R5, #+0]
        CMP      R0,#+85
        BNE.N    ??NvIsRecordCopied_9
// 1417       {
// 1418         if(dataRead[0] == gValidationByteSingleRecord_c)
        LDRB     R0,[SP, #+0]
        CMP      R0,#+170
        BNE.N    ??NvIsRecordCopied_10
// 1419         {
// 1420           /* skip */
// 1421           loopAddress += sizeof(NVM_RecordMetaInfo_t);
        ADDS     R6,R6,#+8
// 1422           continue;
        B.N      ??NvIsRecordCopied_4
// 1423         }
// 1424         retVal = TRUE;
??NvIsRecordCopied_10:
        MOVS     R0,#+1
        MOVS     R7,R0
// 1425         break;
        B.N      ??NvIsRecordCopied_1
// 1426       }
// 1427 
// 1428       /* skip */
// 1429       loopAddress += sizeof(NVM_RecordMetaInfo_t);
??NvIsRecordCopied_9:
        ADDS     R6,R6,#+8
// 1430       continue;
        B.N      ??NvIsRecordCopied_4
// 1431     }      
// 1432 
// 1433     loopAddress += sizeof(NVM_RecordMetaInfo_t);
??NvIsRecordCopied_5:
        ADDS     R6,R6,#+8
// 1434 
// 1435   } while(loopAddress < mNvVirtualPageProperty[pageId].NvRawSectorEndAddress);
??NvIsRecordCopied_4:
        LDR.W    R0,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+20
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        CMP      R6,R0
        BCC.N    ??NvIsRecordCopied_0
// 1436 
// 1437   return retVal;
??NvIsRecordCopied_1:
        MOVS     R0,R7
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R1,R2,R4-R8,PC}  ;; return
// 1438 }
// 1439 
// 1440 
// 1441 /******************************************************************************
// 1442  * Name: NvInternalCopy
// 1443  * Description: Performs a copy of an record / entire table entry
// 1444  * Parameter(s): [IN] dstAddress - destination record address
// 1445  *               [IN] dstMetaAddress - destination meta address
// 1446  *               [IN] srcMetaInfo - source meta information
// 1447  *               [IN] srcTblEntryIdx - source table entry index
// 1448  *               [IN] size - bytes to copy
// 1449  * Return: gNVM_InvalidPageID_c - if the source or destination page is not 
// 1450  *                                valid
// 1451  *         gNVM_MetaInfoWriteError_c - if the meta information couldn't be 
// 1452  *                                     written
// 1453  *         gNVM_RecordWriteError_c - if the record couldn't be written
// 1454  *         gNVM_Error_c - in case of error(s)
// 1455  *         gNVM_OK_c - page copy completed successfully
// 1456  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1457 static NVM_Status_t NvInternalCopy
// 1458 (
// 1459   uint32_t dstAddress,
// 1460   uint32_t dstMetaAddress,
// 1461   NVM_RecordMetaInfo_t* srcMetaInfo,
// 1462   uint16_t srcTblEntryIdx,
// 1463   uint16_t size
// 1464 )
// 1465 {
NvInternalCopy:
        PUSH     {R1,R4-R11,LR}
        SUB      SP,SP,#+80
        MOVS     R5,R0
        MOVS     R6,R2
        MOVS     R7,R3
        LDR      R4,[SP, #+120]
// 1466   uint16_t innerOffset;
// 1467   uint8_t cacheBuffer[gNvCacheBufferSize_c];
// 1468   NVM_RecordMetaInfo_t dstMetaInfo;
// 1469   uint16_t diffSize = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+2]
// 1470   uint16_t diffIdx = 0;
        MOVS     R9,#+0
// 1471   uint16_t ramSize = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+0]
// 1472   uint8_t misalignedBytes;
// 1473   uint8_t loopIdx;
// 1474   uint16_t loopEnd;
// 1475 
// 1476   /* Initialize the inner offset*/
// 1477   innerOffset = 0;
        MOVS     R0,#+0
        MOV      R8,R0
// 1478 
// 1479   /* prepare destination page meta info tag and write if after the record is entirely written.
// 1480    * the preparation is made here because the 'dstAddress' may change afterwards
// 1481    */        
// 1482   
// 1483   dstMetaInfo.fields = srcMetaInfo->fields; 
        ADD      R0,SP,#+8
        MOVS     R1,R6
        MOVS     R2,#+8
        BL       __aeabi_memcpy
// 1484   dstMetaInfo.fields.NvmRecordOffset = dstAddress - mNvVirtualPageProperty[(mNvActivePageId+1)%2].NvRawSectorStartAddress;
        LDR.W    R0,??DataTable13
        LDR.W    R1,??DataTable13_2
        LDRB     R1,[R1, #+0]
        ADDS     R1,R1,#+1
        MOVS     R2,#+2
        SDIV     R3,R1,R2
        MLS      R3,R3,R2,R1
        MOVS     R1,#+20
        MLA      R0,R1,R3,R0
        LDR      R0,[R0, #+0]
        SUBS     R0,R5,R0
        STRH     R0,[SP, #+13]
// 1485   
// 1486   ramSize = pNVM_DataTable[srcTblEntryIdx].ElementsCount * pNVM_DataTable[srcTblEntryIdx].ElementSize;
        LDR.W    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R7,R0
        LDRH     R0,[R0, #+4]
        LDR.W    R1,??DataTable16
        LDR      R1,[R1, #+0]
        UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
        MOVS     R2,#+12
        MLA      R1,R2,R7,R1
        LDRH     R1,[R1, #+6]
        SMULBB   R0,R0,R1
        STRH     R0,[SP, #+0]
// 1487 
// 1488   /* if the bytes to copy are less then RAM table entry space, the supplementary bytes to write on the destination page
// 1489    * will be retrieved from RAM table entry. This is the case when the RAM table has been updated and the new
// 1490    * entry's elements count is greater then the one existing in the previous RAM table, now stored in the FLASH active page
// 1491    * (source page) */
// 1492   if(size < ramSize)
        LDRH     R0,[SP, #+0]
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        CMP      R4,R0
        BCS.N    ??NvInternalCopy_0
// 1493   {
// 1494     diffSize = ramSize - size;
        LDRH     R0,[SP, #+0]
        SUBS     R0,R0,R4
        STRH     R0,[SP, #+2]
// 1495     diffIdx = size / pNVM_DataTable[srcTblEntryIdx].ElementSize;
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        LDR.W    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R7,R0
        LDRH     R0,[R0, #+6]
        SDIV     R0,R4,R0
        MOV      R9,R0
// 1496   }
// 1497 
// 1498   while(size)
??NvInternalCopy_0:
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        CMP      R4,#+0
        BEQ.N    ??NvInternalCopy_1
// 1499   {
// 1500     if(size > (uint16_t)gNvCacheBufferSize_c)
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        CMP      R4,#+65
        BLT.N    ??NvInternalCopy_2
// 1501     {
// 1502       /* copy from FLASH to cache buffer */
// 1503       NV_FlashRead(mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + srcMetaInfo->fields.NvmRecordOffset + innerOffset, 
// 1504           (uint8_t*)&cacheBuffer[0], (uint16_t)gNvCacheBufferSize_c);                    
        MOVS     R2,#+64
        ADD      R1,SP,#+16
        LDR.W    R0,??DataTable13
        LDR.W    R3,??DataTable13_2
        LDRB     R3,[R3, #+0]
        MOVS     R12,#+20
        MLA      R0,R12,R3,R0
        LDR      R0,[R0, #+0]
        LDRH     R3,[R6, #+5]
        UXTAH    R0,R0,R3
        UXTAH    R0,R0,R8
        BL       NV_FlashRead
// 1505 
// 1506       /* write to destination page */
// 1507       if(gNV_OK_c == NV_FlashProgramLongword(&mNvConfig, dstAddress, (uint16_t)gNvCacheBufferSize_c, (uint32_t)(&cacheBuffer[0])))
        ADD      R3,SP,#+16
        MOVS     R2,#+64
        MOVS     R1,R5
        LDR.W    R0,??DataTable13_1
        BL       NV_FlashProgramLongword
        CMP      R0,#+0
        BNE.N    ??NvInternalCopy_3
// 1508       {
// 1509         /* update the destination record address copy */
// 1510         dstAddress += (uint16_t)gNvCacheBufferSize_c;
        ADDS     R5,R5,#+64
// 1511         /* update the record size */
// 1512         size -= (uint16_t)gNvCacheBufferSize_c;
        SUBS     R4,R4,#+64
// 1513         /* update the inner offset value */
// 1514         innerOffset += (uint16_t)gNvCacheBufferSize_c;
        ADDS     R8,R8,#+64
// 1515 
// 1516         continue;
        B.N      ??NvInternalCopy_0
// 1517       }
// 1518       return gNVM_RecordWriteError_c;
??NvInternalCopy_3:
        MOVS     R0,#+12
        B.N      ??NvInternalCopy_4
// 1519     }
// 1520     else
// 1521     {
// 1522       /* copy from FLASH to cache buffer */
// 1523       NV_FlashRead(mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + srcMetaInfo->fields.NvmRecordOffset + innerOffset, 
// 1524           (uint8_t*)&cacheBuffer[0], size);
??NvInternalCopy_2:
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        MOVS     R2,R4
        ADD      R1,SP,#+16
        LDR.W    R0,??DataTable13
        LDR.W    R3,??DataTable13_2
        LDRB     R3,[R3, #+0]
        MOVS     R12,#+20
        MLA      R0,R12,R3,R0
        LDR      R0,[R0, #+0]
        LDRH     R3,[R6, #+5]
        UXTAH    R0,R0,R3
        UXTAH    R0,R0,R8
        BL       NV_FlashRead
// 1525       /* write to destination page */
// 1526       if(gNV_OK_c == NV_FlashProgramLongword(&mNvConfig, dstAddress, (uint16_t)size, (uint32_t)(&cacheBuffer[0])))
        ADD      R3,SP,#+16
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        MOVS     R2,R4
        MOVS     R1,R5
        LDR.W    R0,??DataTable13_1
        BL       NV_FlashProgramLongword
        CMP      R0,#+0
        BEQ.N    ??NvInternalCopy_1
// 1527       {
// 1528         break;
// 1529       }
// 1530       return gNVM_RecordWriteError_c;
??NvInternalCopy_5:
        MOVS     R0,#+12
        B.N      ??NvInternalCopy_4
// 1531     }
// 1532   }
// 1533 
// 1534   if(diffSize)
??NvInternalCopy_1:
        LDRH     R0,[SP, #+2]
        CMP      R0,#+0
        BEQ.W    ??NvInternalCopy_6
// 1535   {
// 1536     /* update the destination record address copy */
// 1537     dstAddress += size;
        UXTAH    R5,R5,R4
// 1538     
// 1539     /* check alignment and adjust it if necessary */                            
// 1540     misalignedBytes = dstAddress - (dstAddress & (~0x03uL));
        ANDS     R0,R5,#0xFC
        SUBS     R0,R5,R0
        MOV      R10,R0
// 1541     
// 1542     /* initialise the inner offset */
// 1543     innerOffset = 0;
        MOVS     R0,#+0
        MOV      R8,R0
// 1544 
// 1545     /* check if the destination is longword aligned or not */
// 1546     if(misalignedBytes)
        UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
        CMP      R10,#+0
        BEQ.N    ??NvInternalCopy_7
// 1547     {
// 1548       /* align to previous 32 bit boundary */
// 1549       dstAddress &= ~0x03uL;
        LSRS     R5,R5,#+2
        LSLS     R5,R5,#+2
// 1550     	    	    	    	
// 1551       /* compute the loop end */
// 1552       if(pNVM_DataTable[srcTblEntryIdx].ElementSize < (4-misalignedBytes))
        LDR.W    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R7,R0
        LDRH     R0,[R0, #+6]
        UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
        RSBS     R1,R10,#+4
        CMP      R0,R1
        BGE.N    ??NvInternalCopy_8
// 1553       {
// 1554         loopEnd = pNVM_DataTable[srcTblEntryIdx].ElementSize; 
        LDR.W    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R7,R0
        LDRH     R0,[R0, #+6]
        STRH     R0,[SP, #+4]
        B.N      ??NvInternalCopy_9
// 1555       }
// 1556       else
// 1557       {
// 1558         loopEnd = 4 - misalignedBytes;
??NvInternalCopy_8:
        UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
        RSBS     R0,R10,#+4
        STRH     R0,[SP, #+4]
// 1559       }
// 1560     	
// 1561       /* read from destination page to cache buffer */
// 1562       NV_FlashRead(dstAddress, (uint8_t*)&cacheBuffer[0], 4);
??NvInternalCopy_9:
        MOVS     R2,#+4
        ADD      R1,SP,#+16
        MOVS     R0,R5
        BL       NV_FlashRead
// 1563     	    	
// 1564       /* update with data from RAM */
// 1565       for(loopIdx = 0; loopIdx < loopEnd; loopIdx++)
        MOVS     R0,#+0
        MOV      R11,R0
??NvInternalCopy_10:
        MOV      R0,R11
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDRH     R1,[SP, #+4]
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        CMP      R0,R1
        BCS.N    ??NvInternalCopy_11
// 1566       {
// 1567         cacheBuffer[misalignedBytes] = *((uint8_t*)pNVM_DataTable[srcTblEntryIdx].pData + 
// 1568     				(diffIdx * pNVM_DataTable[srcTblEntryIdx].ElementSize) + innerOffset);
        LDR.W    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R7,R0
        LDR      R0,[R0, #+0]
        UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
        LDR.W    R1,??DataTable16
        LDR      R1,[R1, #+0]
        UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
        MOVS     R2,#+12
        MLA      R1,R2,R7,R1
        LDRH     R1,[R1, #+6]
        MLA      R0,R1,R9,R0
        UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
        LDRB     R0,[R8, R0]
        ADD      R1,SP,#+16
        UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
        STRB     R0,[R10, R1]
// 1569         innerOffset++;
        ADDS     R8,R8,#+1
// 1570         misalignedBytes++;
        ADDS     R10,R10,#+1
// 1571       }
        ADDS     R11,R11,#+1
        B.N      ??NvInternalCopy_10
// 1572 
// 1573       /* write to Flash destination page */
// 1574       if(gNV_OK_c != NV_FlashProgramLongword(&mNvConfig, dstAddress, gNV_LONGWORD_SIZE_c, (uint32_t)(&cacheBuffer[0])))
??NvInternalCopy_11:
        ADD      R3,SP,#+16
        MOVS     R2,#+4
        MOVS     R1,R5
        LDR.W    R0,??DataTable13_1
        BL       NV_FlashProgramLongword
        CMP      R0,#+0
        BEQ.N    ??NvInternalCopy_12
// 1575       {
// 1576         return gNVM_RecordWriteError_c;
        MOVS     R0,#+12
        B.N      ??NvInternalCopy_4
// 1577       }
// 1578 
// 1579       /* align to next 32 bit boundary */    	
// 1580       dstAddress += gNV_LONGWORD_SIZE_c;
??NvInternalCopy_12:
        ADDS     R5,R5,#+4
// 1581     }
// 1582 
// 1583     /* write to Flash destination page */
// 1584     if(gNV_OK_c != NV_FlashProgramLongword(&mNvConfig, dstAddress, diffSize - innerOffset,
// 1585     		(uint32_t)(((uint8_t*)pNVM_DataTable[srcTblEntryIdx].pData + (diffIdx * pNVM_DataTable[srcTblEntryIdx].ElementSize) + innerOffset))))
??NvInternalCopy_7:
        LDR.W    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R7,R0
        LDR      R0,[R0, #+0]
        UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
        LDR.W    R1,??DataTable16
        LDR      R1,[R1, #+0]
        UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
        MOVS     R2,#+12
        MLA      R1,R2,R7,R1
        LDRH     R1,[R1, #+6]
        MLA      R0,R1,R9,R0
        UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
        ADDS     R3,R8,R0
        LDRH     R0,[SP, #+2]
        UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
        SUBS     R2,R0,R8
        MOVS     R1,R5
        LDR.W    R0,??DataTable13_1
        BL       NV_FlashProgramLongword
        CMP      R0,#+0
        BEQ.N    ??NvInternalCopy_6
// 1586     {
// 1587       return gNVM_RecordWriteError_c;
        MOVS     R0,#+12
        B.N      ??NvInternalCopy_4
// 1588     }
// 1589   }
// 1590 
// 1591   /* write the associated record meta information */                
// 1592   if(gNV_OK_c != NV_FlashProgramLongword(&mNvConfig, dstMetaAddress, sizeof(NVM_RecordMetaInfo_t), (uint32_t)(&dstMetaInfo)))
??NvInternalCopy_6:
        ADD      R3,SP,#+8
        MOVS     R2,#+8
        LDR      R1,[SP, #+80]
        LDR.W    R0,??DataTable13_1
        BL       NV_FlashProgramLongword
        CMP      R0,#+0
        BEQ.N    ??NvInternalCopy_13
// 1593   {
// 1594 	return gNVM_MetaInfoWriteError_c;                    
        MOVS     R0,#+13
        B.N      ??NvInternalCopy_4
// 1595   }    
// 1596   return gNVM_OK_c;
??NvInternalCopy_13:
        MOVS     R0,#+0
??NvInternalCopy_4:
        ADD      SP,SP,#+84
        POP      {R4-R11,PC}      ;; return
// 1597 }
// 1598 
// 1599 
// 1600 /******************************************************************************
// 1601  * Name: NvGetRecordFullSize
// 1602  * Description: Computes the size of the specified table entry that will 
// 1603  *              be written on FLASH memory
// 1604  * Parameter(s): [IN] tableEntryIndex - table entry index               
// 1605  * Return: the computed size
// 1606  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1607 static uint32_t NvGetRecordFullSize
// 1608 (    
// 1609   NvTableEntryId_t tableEntryIndex    
// 1610 )
// 1611 {
NvGetRecordFullSize:
        PUSH     {R4,R5}
        MOVS     R1,R0
// 1612   uint32_t size;
// 1613   uint8_t paddingBytes;
// 1614 
// 1615   /* compute the RAM size */
// 1616   size = pNVM_DataTable[tableEntryIndex].ElementSize * pNVM_DataTable[tableEntryIndex].ElementsCount;
        LDR.W    R3,??DataTable16
        LDR      R3,[R3, #+0]
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        MOVS     R4,#+12
        MLA      R3,R4,R1,R3
        LDRH     R3,[R3, #+6]
        LDR.W    R4,??DataTable16
        LDR      R4,[R4, #+0]
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        MOVS     R5,#+12
        MLA      R4,R5,R1,R4
        LDRH     R4,[R4, #+4]
        MULS     R3,R4,R3
        MOVS     R0,R3
// 1617 
// 1618   /* compute the size that will be actually written on FLASH memory */        
// 1619   paddingBytes = size % (uint8_t)gNV_LONGWORD_SIZE_c;   
        MOVS     R3,#+4
        UDIV     R4,R0,R3
        MLS      R4,R4,R3,R0
        MOVS     R2,R4
// 1620 
// 1621   if(paddingBytes)
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+0
        BEQ.N    ??NvGetRecordFullSize_0
// 1622   {
// 1623     size += (uint8_t)((uint8_t)gNV_LONGWORD_SIZE_c-paddingBytes);
        RSBS     R3,R2,#+4
        UXTAB    R0,R0,R3
// 1624   }
// 1625 
// 1626   return size;
??NvGetRecordFullSize_0:
        POP      {R4,R5}
        BX       LR               ;; return
// 1627 }
// 1628 
// 1629 
// 1630 /******************************************************************************
// 1631  * Name: NvGetTblEntryMetaAddrFromId
// 1632  * Description: Gets the table entry meta address based on table entry ID
// 1633  * Parameter(s): [IN] searchStartAddress - the search start address
// 1634  *               [IN] dataEntryId - table entry ID
// 1635  * Return: the value of the meta address
// 1636  *****************************************************************************/
// 1637 #if gNvFragmentation_Enabled_d
// 1638 static uint32_t NvGetTblEntryMetaAddrFromId
// 1639 (
// 1640   uint32_t searchStartAddress,
// 1641   uint16_t dataEntryId
// 1642 )
// 1643 {
// 1644   NVM_RecordMetaInfo_t metaInfo;
// 1645 
// 1646   while(searchStartAddress >= (mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + sizeof(mNvPageCounter))
// 1647 #if gNvUseExtendedFeatureSet_d
// 1648 		  + (mNvTableSizeInFlash + (2 * sizeof(mNvTableMarker)))
// 1649 #endif /* gNvUseExtendedFeatureSet_d */
// 1650        )
// 1651   {
// 1652     (void)NvGetMetaInfo(mNvActivePageId, searchStartAddress, &metaInfo);
// 1653 
// 1654     if((metaInfo.fields.NvValidationStartByte != gValidationByteAllRecords_c) || 
// 1655         (metaInfo.fields.NvValidationStartByte != metaInfo.fields.NvValidationEndByte))
// 1656     {
// 1657       searchStartAddress -= sizeof(NVM_RecordMetaInfo_t);
// 1658       continue;
// 1659     }
// 1660 
// 1661     if(metaInfo.fields.NvmDataEntryID == dataEntryId)
// 1662     {
// 1663       /* found it */
// 1664       return searchStartAddress;
// 1665     }
// 1666 
// 1667     searchStartAddress -= sizeof(NVM_RecordMetaInfo_t);
// 1668   }    
// 1669   return 0;
// 1670 }
// 1671 #endif /* gNvFragmentation_Enabled_d */
// 1672 
// 1673 
// 1674 /******************************************************************************
// 1675  * Name: NvInternalDefragmentedCopy
// 1676  * Description: Performs defragmentation and copy from the source page to 
// 1677  *              the destination one
// 1678  * Parameter(s): [IN] srcMetaAddr - source page meta address
// 1679  *               [IN] pSrcMetaInf - pointer to source page meta information
// 1680  *               [IN] srcTblEntryIdx - source page table entry index
// 1681  *               [IN] dstMetaAddr - destination meta address
// 1682  *               [IN] dstRecordAddr - destination record address (to copy to)
// 1683  * Return: the status of the operation
// 1684  *****************************************************************************/
// 1685 #if gNvFragmentation_Enabled_d
// 1686 static NVM_Status_t NvInternalDefragmentedCopy
// 1687 (
// 1688   uint32_t srcMetaAddr,  
// 1689   NVM_RecordMetaInfo_t* pSrcMetaInf,
// 1690   uint16_t srcTblEntryIdx,
// 1691   uint32_t dstMetaAddr,
// 1692   uint32_t dstRecordAddr
// 1693 )
// 1694 { 
// 1695   uint32_t metaAddress;
// 1696   uint32_t tblEntryMetaAddress;
// 1697   NVM_RecordMetaInfo_t dstMetaInfo;
// 1698   NVM_RecordMetaInfo_t metaInfo;
// 1699   uint32_t destination;
// 1700   uint16_t elemSize;
// 1701   uint16_t elemSizeCopy;
// 1702   uint16_t innerOffset;
// 1703   uint8_t misalignedBytes;                
// 1704   uint16_t recordsCopiedCurrentIdx;    
// 1705   uint16_t recordIdx;
// 1706   bool_t recordIsCopied;
// 1707   /* copy buffers */
// 1708   uint8_t srcBuffer[4];
// 1709   uint8_t dstBuffer[4];
// 1710   /* loop control variables */
// 1711   uint16_t loopIdx;    
// 1712   uint8_t loopEnd;
// 1713 #if gNvUseExtendedFeatureSet_d  
// 1714   NVM_DataEntry_t flashDataEntry;
// 1715   bool_t fillFromRAM = FALSE;
// 1716 #endif /* gNvUseExtendedFeatureSet_d */
// 1717   /* status variable */
// 1718   NVM_Status_t status = gNVM_OK_c;
// 1719 
// 1720   /* search for a full table entry that owns the record */
// 1721   tblEntryMetaAddress = NvGetTblEntryMetaAddrFromId(srcMetaAddr, pSrcMetaInf->fields.NvmDataEntryID);
// 1722 
// 1723   if(tblEntryMetaAddress != 0)
// 1724   {
// 1725     /* found it */                
// 1726     metaAddress = srcMetaAddr;        
// 1727 
// 1728     /* reset the copied records index */
// 1729     recordsCopiedCurrentIdx = 0;
// 1730 
// 1731     /* clear the records copied buffer */
// 1732     for(loopIdx = 0; loopIdx < (uint8_t)gNvRecordsCopiedBufferSize_c; loopIdx++)
// 1733     {            
// 1734       maNvRecordsCpyIdx[loopIdx] = (uint16_t)gNvInvalidElementIndex_c;        
// 1735     }
// 1736 
// 1737     while(metaAddress > tblEntryMetaAddress)
// 1738     {                    
// 1739       /* get meta information */
// 1740       NvGetMetaInfo(mNvActivePageId, metaAddress, &metaInfo);
// 1741 
// 1742       /* skip invalid entries and full table records */
// 1743       if((metaInfo.fields.NvValidationStartByte != metaInfo.fields.NvValidationEndByte) || 
// 1744           (metaInfo.fields.NvValidationStartByte != gValidationByteSingleRecord_c))
// 1745       {
// 1746         metaAddress -= sizeof(NVM_RecordMetaInfo_t);
// 1747         continue;
// 1748       }                        
// 1749 
// 1750       if(metaInfo.fields.NvmDataEntryID == pSrcMetaInf->fields.NvmDataEntryID) /* found it */
// 1751       {   
// 1752         /* check if record is already copied */
// 1753         recordIsCopied = FALSE;
// 1754 
// 1755         for(loopIdx = 0; loopIdx < (uint16_t)gNvRecordsCopiedBufferSize_c; loopIdx++)
// 1756         {
// 1757           if(metaInfo.fields.NvmElementIndex == maNvRecordsCpyIdx[loopIdx])
// 1758           {
// 1759             recordIsCopied = TRUE;
// 1760             break;
// 1761           }                
// 1762         }                                
// 1763         if(recordIsCopied)
// 1764         {
// 1765           /* skip elements already copied */
// 1766           metaAddress -= sizeof(NVM_RecordMetaInfo_t);                    
// 1767           continue;
// 1768         }                
// 1769 
// 1770         /* check if the element still belongs to an valid RAM table entry */
// 1771         if(metaInfo.fields.NvmElementIndex >= pNVM_DataTable[srcTblEntryIdx].ElementsCount)
// 1772         {
// 1773           /* the FLASH element is no longer a current RAM table entry element */
// 1774           metaAddress -= sizeof(NVM_RecordMetaInfo_t);
// 1775           continue;
// 1776         }
// 1777 
// 1778         /* get element size */
// 1779         elemSize = pNVM_DataTable[srcTblEntryIdx].ElementSize;
// 1780 
// 1781         /* make a copy not to alter the original value and compute destination address where the element will be written */
// 1782         destination = dstRecordAddr + (metaInfo.fields.NvmElementIndex * elemSize);
// 1783 
// 1784         /* check alignment and adjust it if necessary */                            
// 1785         misalignedBytes = destination - (destination & (~0x03uL));                            
// 1786 
// 1787         /* check if the destination is longword aligned or not */
// 1788         if(misalignedBytes)
// 1789         {
// 1790           /* align to previous 32 bit boundary */
// 1791           destination &= ~0x03uL;                    
// 1792         }
// 1793 
// 1794         innerOffset = 0;
// 1795         
// 1796         /* compute the loop end */
// 1797         if(elemSize < (4-misalignedBytes))
// 1798         {
// 1799           loopEnd = elemSize; 
// 1800         }
// 1801         else
// 1802         {
// 1803           loopEnd = 4 - misalignedBytes;
// 1804         }
// 1805 
// 1806         while(elemSize)
// 1807         {
// 1808           /* read (destination) */
// 1809           NV_FlashRead(destination, (uint8_t*)&dstBuffer[0], 4);
// 1810 
// 1811           /* read (source) */
// 1812           NV_FlashRead(mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + metaInfo.fields.NvmRecordOffset + innerOffset, 
// 1813         		  (uint8_t*)&srcBuffer[0], loopEnd);
// 1814 
// 1815           /* modify */
// 1816           for(loopIdx = 0; loopIdx < loopEnd; loopIdx++, misalignedBytes++)
// 1817           {
// 1818             dstBuffer[misalignedBytes] = srcBuffer[loopIdx];
// 1819           }
// 1820 
// 1821           /* write (destination) */
// 1822           if(gNV_OK_c == NV_FlashProgramLongword(&mNvConfig, destination, 4, (uint32_t)(&dstBuffer[0])))
// 1823           {                    
// 1824             elemSize -= loopEnd;
// 1825             innerOffset += loopEnd;
// 1826             destination += 4;
// 1827             misalignedBytes = 0;        	
// 1828             if(elemSize >= 4)
// 1829             {
// 1830               loopEnd = 4;                                    		
// 1831             }
// 1832             else
// 1833             {
// 1834               loopEnd = elemSize;
// 1835             }
// 1836           }
// 1837           else
// 1838           {
// 1839         	return gNVM_RecordWriteError_c; 
// 1840           }
// 1841         }
// 1842 
// 1843         /* save the copied record offset */
// 1844         maNvRecordsCpyIdx[recordsCopiedCurrentIdx] = metaInfo.fields.NvmElementIndex;
// 1845         /* increment (and wrap if necessary) the index */
// 1846         recordsCopiedCurrentIdx = (recordsCopiedCurrentIdx + 1) & ((unsigned char) (gNvRecordsCopiedBufferSize_c - 1));                        
// 1847       }
// 1848 
// 1849       /* continue searching */
// 1850       metaAddress -= sizeof(NVM_RecordMetaInfo_t);            
// 1851     }
// 1852 
// 1853     /* 
// 1854      * now copy the elements from table entry, except the one already copied from single records 
// 1855      */
// 1856 
// 1857     NvGetMetaInfo(mNvActivePageId, tblEntryMetaAddress, &metaInfo);
// 1858     
// 1859 #if gNvUseExtendedFeatureSet_d    
// 1860 
// 1861     fillFromRAM = FALSE;
// 1862 
// 1863     if(mNvTableUpdated) /* RAM table was updated */
// 1864     {                           
// 1865       if(NvGetTableEntry(pNVM_DataTable[srcTblEntryIdx].DataEntryID, &flashDataEntry))
// 1866       {
// 1867         if(pNVM_DataTable[srcTblEntryIdx].ElementsCount > flashDataEntry.ElementsCount)
// 1868         {
// 1869           /* fill the FLASH destination page with the default RAM value for the missing element(s) */                 
// 1870           fillFromRAM = TRUE;
// 1871         }
// 1872       }
// 1873     }
// 1874 #endif /* gNvUseExtendedFeatureSet_d */
// 1875 
// 1876     for(recordIdx = 0; recordIdx < pNVM_DataTable[srcTblEntryIdx].ElementsCount; recordIdx++)
// 1877     {
// 1878 #if gNvUseExtendedFeatureSet_d    	
// 1879       if(mNvTableUpdated)
// 1880       {
// 1881         if(recordIdx >= flashDataEntry.ElementsCount)
// 1882           break;
// 1883       }
// 1884 #endif
// 1885 
// 1886       recordIsCopied = FALSE;
// 1887 
// 1888       for(loopIdx = 0; loopIdx < (uint16_t)gNvRecordsCopiedBufferSize_c; loopIdx++)
// 1889       {
// 1890         if(recordIdx == maNvRecordsCpyIdx[loopIdx])
// 1891         {
// 1892           recordIsCopied = TRUE;
// 1893           break;
// 1894         }        
// 1895       }
// 1896       if(recordIsCopied)
// 1897       {
// 1898         /* skip already copied elements */
// 1899         continue;
// 1900       }                        
// 1901 
// 1902       /* 
// 1903        * copy the element 
// 1904        */
// 1905 
// 1906        /* refresh the element size */
// 1907        elemSizeCopy = elemSize = pNVM_DataTable[srcTblEntryIdx].ElementSize;
// 1908        /* make a copy not to alter the original value and compute destination address where the element will be written */
// 1909        destination = dstRecordAddr + (recordIdx * elemSize);
// 1910        /* check alignment and adjust it if necessary */                            
// 1911        misalignedBytes = destination - (destination & (~0x03uL));                            
// 1912        /* check if the destination is longword aligned or not */
// 1913        if(misalignedBytes)
// 1914        {
// 1915          /* align to previous 32 bit boundary */
// 1916          destination &= ~0x03uL;              
// 1917        }
// 1918 
// 1919        innerOffset = 0;
// 1920        
// 1921        /* compute the loop end */
// 1922        if(elemSizeCopy < (4-misalignedBytes))
// 1923        {
// 1924          loopEnd = elemSizeCopy; 
// 1925        }
// 1926        else
// 1927        {
// 1928          loopEnd = 4 - misalignedBytes;
// 1929        }
// 1930 
// 1931        while(elemSizeCopy)
// 1932        {
// 1933          /* read (destination) */
// 1934          NV_FlashRead(destination, (uint8_t*)&dstBuffer[0], 4);
// 1935 
// 1936          /* read (FLASH source) */
// 1937          NV_FlashRead(mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + metaInfo.fields.NvmRecordOffset + 
// 1938         		 (recordIdx * elemSize) + innerOffset, (uint8_t*)&srcBuffer[0], loopEnd);                                     
// 1939 
// 1940          /* modify */
// 1941          for(loopIdx = 0; loopIdx < loopEnd; loopIdx++, misalignedBytes++)
// 1942          {
// 1943            dstBuffer[misalignedBytes] = srcBuffer[loopIdx];
// 1944          }
// 1945 
// 1946          /* write (destination) */
// 1947          if(gNV_OK_c == NV_FlashProgramLongword(&mNvConfig, destination, 4, (uint32_t)(&dstBuffer[0])))
// 1948          {                    
// 1949            elemSizeCopy -= loopEnd;
// 1950            innerOffset += loopEnd;
// 1951            destination += 4;
// 1952            misalignedBytes = 0;
// 1953            if(elemSizeCopy >= 4)
// 1954            {
// 1955              loopEnd = 4;                                    		
// 1956            }
// 1957            else
// 1958            {
// 1959              loopEnd = elemSizeCopy;
// 1960            }
// 1961          }
// 1962          else
// 1963          {
// 1964            return gNVM_RecordWriteError_c;         
// 1965          }
// 1966        }
// 1967 
// 1968        /* save the copied record offset */
// 1969        maNvRecordsCpyIdx[recordsCopiedCurrentIdx] = recordIdx;
// 1970        /* increment (and wrap if necessary) the index */
// 1971        recordsCopiedCurrentIdx = (recordsCopiedCurrentIdx + 1) & ((unsigned char) (gNvRecordsCopiedBufferSize_c - 1));
// 1972     }
// 1973 
// 1974 #if gNvUseExtendedFeatureSet_d    
// 1975     /* append the elements that were not previously stored in FLASH memory, if any */
// 1976     if(fillFromRAM)
// 1977     {
// 1978       for(; recordIdx < pNVM_DataTable[srcTblEntryIdx].ElementsCount; recordIdx++)
// 1979       {           
// 1980         /* refresh the element size */
// 1981         elemSizeCopy = elemSize = pNVM_DataTable[srcTblEntryIdx].ElementSize;
// 1982         
// 1983         /* make a copy not to alter the original value and compute destination address where the element will be written */
// 1984         destination = dstRecordAddr + (recordIdx * elemSize);
// 1985 
// 1986         /* check alignment and adjust it, if necessary */                            
// 1987         misalignedBytes = destination - (destination & (~0x03uL));                            
// 1988 
// 1989         /* check if the destination is longword aligned or not */
// 1990         if(misalignedBytes)
// 1991         {
// 1992           /* align to previous 32 bit boundary */
// 1993           destination &= ~0x03uL;             
// 1994         }
// 1995 
// 1996         innerOffset = 0;
// 1997         
// 1998         /* compute the loop end */
// 1999         if(elemSizeCopy < (4-misalignedBytes))
// 2000         {
// 2001           loopEnd = elemSizeCopy; 
// 2002         }
// 2003         else
// 2004         {
// 2005           loopEnd = 4 - misalignedBytes;
// 2006         }
// 2007 
// 2008         while(elemSizeCopy)
// 2009         {
// 2010           /* read (destination) */
// 2011           NV_FlashRead(destination, (uint8_t*)&dstBuffer[0], 4);
// 2012 
// 2013           /* read (RAM source) */
// 2014           NV_FlashRead((uint32_t)((uint8_t*)pNVM_DataTable[srcTblEntryIdx].pData + (recordIdx * elemSize) + innerOffset), 
// 2015         			(uint8_t*)&srcBuffer[0], loopEnd);
// 2016 
// 2017           /* modify */
// 2018           for(loopIdx = 0; loopIdx < loopEnd; loopIdx++, misalignedBytes++)
// 2019           {
// 2020             dstBuffer[misalignedBytes] = srcBuffer[loopIdx];
// 2021           }
// 2022 
// 2023           /* write (destination) */
// 2024           if(gNV_OK_c == NV_FlashProgramLongword(&mNvConfig, destination, 4, (uint32_t)(&dstBuffer[0])))
// 2025           {                    
// 2026             elemSizeCopy -= loopEnd;
// 2027             innerOffset += loopEnd;
// 2028             destination += 4;
// 2029             misalignedBytes = 0;
// 2030             if(elemSizeCopy >= 4)
// 2031             {
// 2032               loopEnd = 4;                                    		
// 2033             }
// 2034             else
// 2035             {
// 2036               loopEnd = elemSizeCopy;
// 2037             }
// 2038           }
// 2039           else
// 2040           {
// 2041             return gNVM_RecordWriteError_c;                      
// 2042           }
// 2043         }
// 2044         /* save the copied record offset */
// 2045         maNvRecordsCpyIdx[recordsCopiedCurrentIdx] = recordIdx;
// 2046         /* increment (and wrap if necessary) the index */
// 2047         recordsCopiedCurrentIdx = (recordsCopiedCurrentIdx + 1) & ((unsigned char) (gNvRecordsCopiedBufferSize_c - 1));
// 2048       }
// 2049     }
// 2050 #endif /* gNvUseExtendedFeatureSet_d */    
// 2051     
// 2052     /* write meta information tag */
// 2053     dstMetaInfo.fields.NvValidationStartByte = gValidationByteAllRecords_c;
// 2054     dstMetaInfo.fields.NvmDataEntryID = pSrcMetaInf->fields.NvmDataEntryID;
// 2055     dstMetaInfo.fields.NvmElementIndex = 0;
// 2056     dstMetaInfo.fields.NvmRecordOffset = dstRecordAddr - mNvVirtualPageProperty[(mNvActivePageId+1)%2].NvRawSectorStartAddress;
// 2057     dstMetaInfo.fields.NvValidationEndByte = gValidationByteAllRecords_c;
// 2058 
// 2059     /* write the associated record meta information */                
// 2060     if(gNV_OK_c != NV_FlashProgramLongword(&mNvConfig, dstMetaAddr, sizeof(NVM_RecordMetaInfo_t), (uint32_t)(&dstMetaInfo)))
// 2061     {
// 2062       return gNVM_MetaInfoWriteError_c;                    
// 2063     }
// 2064   }
// 2065   else
// 2066   {
// 2067     /* an entire table entry was not found, so copy the record as it is */
// 2068     if((status = NvInternalCopy(dstRecordAddr, dstMetaAddr, pSrcMetaInf, srcTblEntryIdx, pNVM_DataTable[srcTblEntryIdx].ElementSize)) != gNVM_OK_c)
// 2069     {
// 2070       return status;
// 2071     }
// 2072   }
// 2073   return status;
// 2074 }
// 2075 #endif /* gNvFragmentation_Enabled_d */
// 2076 
// 2077 /******************************************************************************
// 2078  * Name: NvCopyPage
// 2079  * Description: Copy the active page content to the mirror page. Only the 
// 2080  *              latest table entries / elements are copied. A merge operation
// 2081  *              is performed before copy if an entry has single elements 
// 2082  *              saved priori and newer than the table entry. If one or more
// 2083  *              elements were singular saved and the NV page doesn't has a
// 2084  *              full table entry saved, then the elements are copied as they
// 2085  *              are.  
// 2086  * Parameter(s): [IN] skipEntryId - the entry ID to be skipped when page
// 2087  *                                  copy is performed
// 2088  * Return: gNVM_InvalidPageID_c - if the source or destination page is not 
// 2089  *                                valid
// 2090  *         gNVM_MetaInfoWriteError_c - if the meta information couldn't be 
// 2091  *                                     written
// 2092  *         gNVM_RecordWriteError_c - if the record couldn't be written
// 2093  *         gNVM_Error_c - in case of error(s)
// 2094  *         gNVM_OK_c - page copy completed successfully
// 2095  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2096 static NVM_Status_t NvCopyPage
// 2097 (    
// 2098 #if gNvUseExtendedFeatureSet_d		
// 2099   NvTableEntryId_t skipEntryId
// 2100 #else
// 2101   void
// 2102 #endif
// 2103 )
// 2104 {
NvCopyPage:
        PUSH     {R1-R11,LR}
// 2105   /* source page related variables */
// 2106   uint32_t srcMetaAddress;
// 2107   NVM_RecordMetaInfo_t srcMetaInfo;
// 2108   uint16_t srcTableEntryIdx;
// 2109 
// 2110   /* destination page related variables */    
// 2111   uint32_t dstMetaAddress;    
// 2112   NVM_VirtualPageID_t dstPageId;
// 2113   uint32_t dstRecordAddress;
// 2114 
// 2115 #if gNvUseExtendedFeatureSet_d
// 2116   uint16_t idx;  
// 2117   bool_t entryFound;
// 2118   NVM_DataEntry_t flashDataEntry;
// 2119 #endif /* gNvUseExtendedFeatureSet_d */  
// 2120   uint32_t bytesToCopy;
// 2121 
// 2122   /* status variable */
// 2123   NVM_Status_t status;
// 2124 
// 2125   dstPageId = (NVM_VirtualPageID_t)((mNvActivePageId+1)%2);
        LDR.N    R0,??DataTable13_2
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        MOVS     R1,#+2
        SDIV     R2,R0,R1
        MLS      R2,R2,R1,R0
        MOVS     R7,R2
// 2126 
// 2127   /* Check if the destination page is blank. If not, erase it. */
// 2128   if(gNVM_PageIsNotBlank_c == NvVirtualPageBlankCheck(dstPageId))
        MOVS     R0,R7
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       NvVirtualPageBlankCheck
        CMP      R0,#+3
        BNE.N    ??NvCopyPage_0
// 2129   {
// 2130     status = NvEraseVirtualPage(dstPageId);
        MOVS     R0,R7
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       NvEraseVirtualPage
        MOV      R10,R0
// 2131     if(gNVM_OK_c != status)
        UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
        CMP      R10,#+0
        BEQ.N    ??NvCopyPage_0
// 2132     {
// 2133       return status;        
        MOV      R0,R10
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        B.N      ??NvCopyPage_1
// 2134     }
// 2135   }
// 2136   
// 2137 #if gNvUseExtendedFeatureSet_d
// 2138   /* save the current RAM table */
// 2139   NvSaveRamTable(dstPageId);
// 2140 #endif
// 2141 
// 2142   /* start with the source page last record */
// 2143   srcMetaAddress = mNvVirtualPageProperty[mNvActivePageId].NvLastMetaInfoAddress;
??NvCopyPage_0:
        LDR.N    R0,??DataTable13
        LDR.N    R1,??DataTable13_2
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+16]
        MOVS     R4,R0
// 2144   /* initialise the destination page meta info start address */
// 2145 #if gNvUseExtendedFeatureSet_d  
// 2146   dstMetaAddress = mNvVirtualPageProperty[dstPageId].NvRawSectorStartAddress + sizeof(mNvPageCounter) +
// 2147       (mNvTableSizeInRAM + (2 * sizeof(mNvTableMarker)));
// 2148 #else
// 2149   dstMetaAddress = mNvVirtualPageProperty[dstPageId].NvRawSectorStartAddress + sizeof(mNvPageCounter);
        LDR.N    R0,??DataTable13
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R1,#+20
        MLA      R0,R1,R7,R0
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+4
        MOVS     R6,R0
// 2150 #endif /* gNvUseExtendedFeatureSet_d*/  
// 2151   /* initialise the destination page record start address */
// 2152   dstRecordAddress = mNvVirtualPageProperty[dstPageId].NvRawSectorEndAddress - sizeof(mNvPageCounter) + 1;
        LDR.N    R0,??DataTable13
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R1,#+20
        MLA      R0,R1,R7,R0
        LDR      R0,[R0, #+4]
        SUBS     R0,R0,#+3
        MOV      R8,R0
// 2153 
// 2154   while(srcMetaAddress >= (mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + sizeof(mNvPageCounter))
// 2155 #if gNvUseExtendedFeatureSet_d		  
// 2156 		  + (mNvTableSizeInFlash + (2 * sizeof(mNvTableMarker)))
// 2157 #endif 
// 2158        )
??NvCopyPage_2:
        LDR.N    R0,??DataTable13
        LDR.N    R1,??DataTable13_2
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+4
        CMP      R4,R0
        BCC.N    ??NvCopyPage_3
// 2159   {
// 2160     /* get current meta information */
// 2161     (void)NvGetMetaInfo(mNvActivePageId, srcMetaAddress, &srcMetaInfo);
        ADD      R2,SP,#+4
        MOVS     R1,R4
        LDR.N    R0,??DataTable13_2
        LDRB     R0,[R0, #+0]
        BL       NvGetMetaInfo
        MOV      R11,R0
// 2162 
// 2163 #if gNvUseExtendedFeatureSet_d    
// 2164     /* NV RAM table has been updated */
// 2165     if(mNvTableUpdated)
// 2166     {
// 2167       idx = 0;
// 2168       entryFound = FALSE;
// 2169 
// 2170       /* check if the saved entry is still present in the new RAM table */
// 2171       while(gNvEndOfTableId_c != pNVM_DataTable[idx].DataEntryID)
// 2172       {
// 2173         if(srcMetaInfo.fields.NvmDataEntryID == pNVM_DataTable[idx].DataEntryID)
// 2174         {
// 2175           entryFound = TRUE;
// 2176           break;
// 2177         }
// 2178         idx++;
// 2179       }
// 2180 
// 2181       if(!entryFound)
// 2182       {
// 2183         /* move to the next meta info */
// 2184         srcMetaAddress -= sizeof(NVM_RecordMetaInfo_t);
// 2185         continue;
// 2186       }
// 2187     }
// 2188 #endif /* gNvUseExtendedFeatureSet_d */
// 2189 
// 2190     /* get table entry index */
// 2191     srcTableEntryIdx = NvGetTableEntryIndexFromId(srcMetaInfo.fields.NvmDataEntryID);
        LDRH     R0,[SP, #+5]
        BL       NvGetTableEntryIndexFromId
        MOVS     R5,R0
// 2192 
// 2193     if((srcMetaInfo.fields.NvValidationStartByte != srcMetaInfo.fields.NvValidationEndByte) ||
// 2194         (srcTableEntryIdx == gNvInvalidDataEntry_c) ||
// 2195 #if gNvUseExtendedFeatureSet_d
// 2196         (srcTableEntryIdx == skipEntryId) || 
// 2197 #endif /* #if gNvUseExtendedFeatureSet_d */
// 2198         NvIsRecordCopied(dstPageId, &srcMetaInfo)
// 2199     )
        LDRB     R0,[SP, #+4]
        LDRB     R1,[SP, #+11]
        CMP      R0,R1
        BNE.N    ??NvCopyPage_4
        UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
        MOVW     R0,#+65535
        CMP      R5,R0
        BEQ.N    ??NvCopyPage_4
        ADD      R1,SP,#+4
        MOVS     R0,R7
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       NvIsRecordCopied
        CMP      R0,#+0
        BEQ.N    ??NvCopyPage_5
// 2200     {
// 2201       /* go to the next meta information tag */
// 2202       srcMetaAddress -= sizeof(NVM_RecordMetaInfo_t);
??NvCopyPage_4:
        SUBS     R4,R4,#+8
// 2203       continue;
        B.N      ??NvCopyPage_2
// 2204     }
// 2205 
// 2206     if((srcMetaInfo.fields.NvValidationStartByte != gValidationByteSingleRecord_c) && 
// 2207         (srcMetaInfo.fields.NvValidationStartByte != gValidationByteAllRecords_c))
??NvCopyPage_5:
        LDRB     R0,[SP, #+4]
        CMP      R0,#+170
        BEQ.N    ??NvCopyPage_6
        LDRB     R0,[SP, #+4]
        CMP      R0,#+85
        BEQ.N    ??NvCopyPage_6
// 2208     {
// 2209       /* go to the next meta information tag */
// 2210       srcMetaAddress -= sizeof(NVM_RecordMetaInfo_t);
        SUBS     R4,R4,#+8
// 2211       continue;
        B.N      ??NvCopyPage_2
// 2212     }
// 2213 
// 2214     /* compute the destination record start address */
// 2215     dstRecordAddress -= NvGetRecordFullSize(srcTableEntryIdx);
??NvCopyPage_6:
        MOVS     R0,R5
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        BL       NvGetRecordFullSize
        SUBS     R0,R8,R0
        MOV      R8,R0
// 2216 
// 2217     bytesToCopy = pNVM_DataTable[srcTableEntryIdx].ElementsCount * pNVM_DataTable[srcTableEntryIdx].ElementSize;
        LDR.W    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R5,R0
        LDRH     R0,[R0, #+4]
        LDR.W    R1,??DataTable16
        LDR      R1,[R1, #+0]
        UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
        MOVS     R2,#+12
        MLA      R1,R2,R5,R1
        LDRH     R1,[R1, #+6]
        MULS     R0,R1,R0
        MOV      R9,R0
// 2218 
// 2219 #if gNvUseExtendedFeatureSet_d    
// 2220     /* NV RAM table has been updated */
// 2221     if(mNvTableUpdated)
// 2222     {
// 2223       if(NvGetTableEntry(pNVM_DataTable[srcTableEntryIdx].DataEntryID, &flashDataEntry))
// 2224       {
// 2225         if(flashDataEntry.ElementSize != pNVM_DataTable[srcTableEntryIdx].ElementSize)
// 2226         {
// 2227           /* copying table entries with modified element size is not supported */
// 2228           return gNVM_NvTableWrongElementSize_c;
// 2229         }
// 2230 
// 2231         if(flashDataEntry.ElementsCount < pNVM_DataTable[srcTableEntryIdx].ElementsCount)
// 2232         {
// 2233           /* copy only the bytes that were previously written to FLASH virtual page */
// 2234           bytesToCopy = flashDataEntry.ElementsCount * flashDataEntry.ElementSize;              
// 2235         }
// 2236       }
// 2237     }
// 2238 #endif /* gNvUseExtendedFeatureSet_d */
// 2239 
// 2240 #if gNvFragmentation_Enabled_d    
// 2241     /* 
// 2242      * full table entry
// 2243      */        
// 2244     if(srcMetaInfo.fields.NvValidationStartByte == gValidationByteAllRecords_c)
// 2245     {               
// 2246       if((status = NvInternalCopy(dstRecordAddress, dstMetaAddress, &srcMetaInfo, srcTableEntryIdx, bytesToCopy)) != gNVM_OK_c)
// 2247       {
// 2248         return status;
// 2249       }
// 2250     }
// 2251     else
// 2252     {
// 2253       /* 
// 2254        * single element record
// 2255        */        
// 2256        if((status = NvInternalDefragmentedCopy(srcMetaAddress, &srcMetaInfo, srcTableEntryIdx, dstMetaAddress, dstRecordAddress)) != gNVM_OK_c)
// 2257        {
// 2258          return status;
// 2259        }            
// 2260     }
// 2261 #else
// 2262     if((status = NvInternalCopy(dstRecordAddress, dstMetaAddress, &srcMetaInfo, srcTableEntryIdx, bytesToCopy)) != gNVM_OK_c)
        MOV      R0,R9
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        STR      R0,[SP, #+0]
        MOVS     R3,R5
        UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
        ADD      R2,SP,#+4
        MOVS     R1,R6
        MOV      R0,R8
        BL       NvInternalCopy
        MOV      R10,R0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BEQ.N    ??NvCopyPage_7
// 2263     {
// 2264       return status;
        MOV      R0,R10
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        B.N      ??NvCopyPage_1
// 2265     }
// 2266 #endif /* gNvFragmentation_Enabled_d */
// 2267 
// 2268     /* update destination meta information address */
// 2269     dstMetaAddress += sizeof(NVM_RecordMetaInfo_t);
??NvCopyPage_7:
        ADDS     R6,R6,#+8
// 2270 
// 2271     /* move to the next meta info */
// 2272     srcMetaAddress -= sizeof(NVM_RecordMetaInfo_t);        
        SUBS     R4,R4,#+8
        B.N      ??NvCopyPage_2
// 2273   };
// 2274 
// 2275   /* make a request to erase the old page */
// 2276   mNvErasePgCmdStatus.NvPageToErase = mNvActivePageId;
??NvCopyPage_3:
        LDR.N    R0,??DataTable13_2
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable13_4
        STRB     R0,[R1, #+1]
// 2277   mNvErasePgCmdStatus.NvSectorAddress = mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress;
        LDR.N    R0,??DataTable13
        LDR.N    R1,??DataTable13_2
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+0]
        LDR.N    R1,??DataTable13_4
        STR      R0,[R1, #+4]
// 2278   mNvErasePgCmdStatus.NvErasePending = TRUE;
        MOVS     R0,#+1
        LDR.N    R1,??DataTable13_4
        STRB     R0,[R1, #+0]
// 2279 
// 2280   /* update the the active page ID */
// 2281   mNvActivePageId = dstPageId;
        LDR.N    R0,??DataTable13_2
        STRB     R7,[R0, #+0]
// 2282 
// 2283   /* update the last meta info address */
// 2284   mNvVirtualPageProperty[mNvActivePageId].NvLastMetaInfoAddress = dstMetaAddress - sizeof(NVM_RecordMetaInfo_t);
        SUBS     R0,R6,#+8
        LDR.N    R1,??DataTable13
        LDR.N    R2,??DataTable13_2
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+20
        MLA      R1,R3,R2,R1
        STR      R0,[R1, #+16]
// 2285 
// 2286   /* write the page counter */
// 2287   if(gNVM_OK_c == NvWritePageCounter(mNvActivePageId, (mNvPageCounter + 1)))
        LDR.N    R0,??DataTable13_3
        LDR      R0,[R0, #+0]
        ADDS     R1,R0,#+1
        LDR.N    R0,??DataTable13_2
        LDRB     R0,[R0, #+0]
        BL       NvWritePageCounter
        CMP      R0,#+0
        BNE.N    ??NvCopyPage_8
// 2288   {
// 2289     mNvPageCounter++;
        LDR.N    R0,??DataTable13_3
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR.N    R1,??DataTable13_3
        STR      R0,[R1, #+0]
// 2290   }
// 2291 
// 2292 #if gNvUseExtendedFeatureSet_d  
// 2293   if(mNvTableUpdated)
// 2294   {
// 2295     /* update the size of the NV table stored in FLASH */
// 2296     mNvTableSizeInFlash = NvGetTableSize(gFLASHTable_c);
// 2297 
// 2298     /* clear the flag */
// 2299     mNvTableUpdated = FALSE;
// 2300   }
// 2301 #endif /* gNvUseExtendedFeatureSet_d */
// 2302 
// 2303   return gNVM_OK_c;
??NvCopyPage_8:
        MOVS     R0,#+0
??NvCopyPage_1:
        POP      {R1-R11,PC}      ;; return
// 2304 }
// 2305 
// 2306 
// 2307 /******************************************************************************
// 2308  * Name: NvWritePageCounter
// 2309  * Description: Write the page counter value              
// 2310  * Parameter(s): [IN] pageId - the ID of the page 
// 2311  *               [IN] value - the page counter value that will written to 
// 2312  *                            the specified page
// 2313  *               
// 2314  * Return: gNVM_OK_c - if the operation completes successfully
// 2315  *         gNVM_Error_c - if the format operation fails
// 2316  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2317 static NVM_Status_t NvWritePageCounter
// 2318 (
// 2319   NVM_VirtualPageID_t pageId,
// 2320   uint32_t value    
// 2321 )
// 2322 {
NvWritePageCounter:
        PUSH     {R0,R1,R4,LR}
        MOVS     R4,R0
// 2323   /* write page counter on page top and page bottom */
// 2324   if(gNV_OK_c == NV_FlashProgramLongword(&mNvConfig, mNvVirtualPageProperty[pageId].NvRawSectorStartAddress, 
// 2325       sizeof(value), (uint32_t)&value))
        ADD      R3,SP,#+4
        MOVS     R2,#+4
        LDR.N    R0,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+20
        MLA      R0,R1,R4,R0
        LDR      R1,[R0, #+0]
        LDR.N    R0,??DataTable13_1
        BL       NV_FlashProgramLongword
        CMP      R0,#+0
        BNE.N    ??NvWritePageCounter_0
// 2326   {            
// 2327     if(gNV_OK_c == NV_FlashProgramLongword(&mNvConfig, (mNvVirtualPageProperty[pageId].NvRawSectorEndAddress - sizeof(value)), 
// 2328         sizeof(value), (uint32_t)&value))
        ADD      R3,SP,#+4
        MOVS     R2,#+4
        LDR.N    R0,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+20
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        SUBS     R1,R0,#+4
        LDR.N    R0,??DataTable13_1
        BL       NV_FlashProgramLongword
        CMP      R0,#+0
        BNE.N    ??NvWritePageCounter_1
// 2329     {                        
// 2330       return gNVM_OK_c;
        MOVS     R0,#+0
        B.N      ??NvWritePageCounter_2
// 2331     }
// 2332     return gNVM_Error_c;
??NvWritePageCounter_1:
        MOVS     R0,#+1
        B.N      ??NvWritePageCounter_2
// 2333   }
// 2334   return gNVM_Error_c;
??NvWritePageCounter_0:
        MOVS     R0,#+1
??NvWritePageCounter_2:
        POP      {R1,R2,R4,PC}    ;; return
// 2335 }
// 2336 
// 2337 
// 2338 /******************************************************************************
// 2339  * Name: NvInternalFormat
// 2340  * Description: Format the NV storage system. The function erases in place both
// 2341  *              virtual pages and then writes the page counter value to first  
// 2342  *              virtual page. The provided page counter value is automatically 
// 2343  *              incremented and then written to first (active) virtual page.              
// 2344  * Parameter(s): [IN] pageCounterValue - the page counter value that will
// 2345  *                                       be incremented and then written to
// 2346  *                                       active page
// 2347  * Return: gNVM_OK_c - if the operation completes successfully
// 2348  *         gNVM_FormatFailure_c - if the format operation fails
// 2349  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2350 static NVM_Status_t NvInternalFormat
// 2351 (
// 2352   uint32_t pageCounterValue
// 2353 )
// 2354 {    
NvInternalFormat:
        PUSH     {R3-R7,LR}
        MOVS     R4,R0
// 2355   uint8_t retryCount = gNvFormatRetryCount_c;
        MOVS     R5,#+3
// 2356 
// 2357   /* increment the page counter value */
// 2358   if(gPageCounterMaxValue_c == pageCounterValue)
        CMN      R4,#+1
        BNE.N    ??NvInternalFormat_0
// 2359   {
// 2360     pageCounterValue = 1;
        MOVS     R0,#+1
        MOVS     R4,R0
        B.N      ??NvInternalFormat_1
// 2361   }
// 2362   else
// 2363   {
// 2364     pageCounterValue++;
??NvInternalFormat_0:
        ADDS     R4,R4,#+1
// 2365   }
// 2366 
// 2367   while(retryCount--)
??NvInternalFormat_1:
        MOVS     R0,R5
        SUBS     R5,R0,#+1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BEQ.N    ??NvInternalFormat_2
// 2368   {
// 2369     /* erase first page */
// 2370     (void)NV_FlashEraseSector(&mNvConfig, mNvVirtualPageProperty[gFirstVirtualPage_c].NvRawSectorStartAddress,
// 2371         mNvVirtualPageProperty[gFirstVirtualPage_c].NvTotalPageSize);
        LDR.N    R0,??DataTable13
        LDR      R2,[R0, #+12]
        LDR.N    R0,??DataTable13
        LDR      R1,[R0, #+0]
        LDR.N    R0,??DataTable13_1
        BL       NV_FlashEraseSector
        MOVS     R6,R0
// 2372 
// 2373     /* erase the second page */
// 2374     (void)NV_FlashEraseSector(&mNvConfig, mNvVirtualPageProperty[gSecondVirtualPage_c].NvRawSectorStartAddress,
// 2375         mNvVirtualPageProperty[gSecondVirtualPage_c].NvTotalPageSize);
        LDR.N    R0,??DataTable13
        LDR      R2,[R0, #+32]
        LDR.N    R0,??DataTable13
        LDR      R1,[R0, #+20]
        LDR.N    R0,??DataTable13_1
        BL       NV_FlashEraseSector
        MOVS     R7,R0
// 2376 
// 2377     if( (gNVM_OK_c == NvVirtualPageBlankCheck(gFirstVirtualPage_c)) && gNVM_OK_c == NvVirtualPageBlankCheck(gSecondVirtualPage_c))
        MOVS     R0,#+0
        BL       NvVirtualPageBlankCheck
        CMP      R0,#+0
        BNE.N    ??NvInternalFormat_1
        MOVS     R0,#+1
        BL       NvVirtualPageBlankCheck
        CMP      R0,#+0
        BNE.N    ??NvInternalFormat_1
// 2378     {
// 2379       break;
// 2380     }
// 2381   }
// 2382 
// 2383   /* write page counter on page top and page bottom */
// 2384   if(gNV_OK_c == NvWritePageCounter(gFirstVirtualPage_c, pageCounterValue))
??NvInternalFormat_2:
        MOVS     R1,R4
        MOVS     R0,#+0
        BL       NvWritePageCounter
        CMP      R0,#+0
        BNE.N    ??NvInternalFormat_3
// 2385   {
// 2386     /* active page after format = first virtual page */
// 2387     mNvActivePageId = gFirstVirtualPage_c;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable13_2
        STRB     R0,[R1, #+0]
// 2388 #if gNvUseExtendedFeatureSet_d    
// 2389     /* save NV table from RAM memory to FLASH memory */
// 2390     NvSaveRamTable(mNvActivePageId);
// 2391     /* update the size of the NV table stored in FLASH */
// 2392     mNvTableSizeInFlash = NvGetTableSize(gFLASHTable_c);
// 2393 #endif /* gNvUseExtendedFeatureSet_d */
// 2394     /* update the page counter value */
// 2395     mNvPageCounter = pageCounterValue; 
        LDR.N    R0,??DataTable13_3
        STR      R4,[R0, #+0]
// 2396 
// 2397     return gNVM_OK_c;
        MOVS     R0,#+0
        B.N      ??NvInternalFormat_4
// 2398   }
// 2399 
// 2400   return gNVM_FormatFailure_c;
??NvInternalFormat_3:
        MOVS     R0,#+19
??NvInternalFormat_4:
        POP      {R1,R4-R7,PC}    ;; return
// 2401 }
// 2402 
// 2403 
// 2404 #if gNvUseExtendedFeatureSet_d
// 2405 
// 2406 /******************************************************************************
// 2407  * Name: NvSaveRamTable
// 2408  * Description: Saves the NV table
// 2409  * Parameter(s): [IN] pageId - the virtual page ID where the table will be 
// 2410  *                             saved 
// 2411  * Return: TRUE if table saved successfully, FALSE otherwise
// 2412  ******************************************************************************/
// 2413 static bool_t NvSaveRamTable
// 2414 (
// 2415   NVM_VirtualPageID_t pageId
// 2416 )
// 2417 {
// 2418   uint16_t idx;
// 2419   uint32_t addr;
// 2420   uint32_t tblQual;
// 2421   uint32_t tmp;
// 2422 
// 2423   if(NULL == pNVM_DataTable)
// 2424     return FALSE;
// 2425 
// 2426   /* write table qualifier start */
// 2427 
// 2428   tblQual = (uint32_t)gNvTableMarker_c;
// 2429   addr = mNvVirtualPageProperty[pageId].NvRawSectorStartAddress
// 2430       + sizeof(mNvPageCounter);
// 2431 
// 2432   if(gNV_OK_c != NV_FlashProgramLongword(&mNvConfig, addr, sizeof(uint32_t),
// 2433       (uint32_t)(&tblQual)))
// 2434   {
// 2435     return FALSE;
// 2436   }
// 2437 
// 2438   idx = 0;
// 2439   addr += sizeof(tblQual);
// 2440 
// 2441   while(gNvEndOfTableId_c != pNVM_DataTable[idx].DataEntryID)
// 2442   {
// 2443     /* write data entry ID */
// 2444     tmp = (pNVM_DataTable[idx].DataEntryID << 16) + 0xFFFF;
// 2445     if(gNV_OK_c != NV_FlashProgramLongword(&mNvConfig, addr, sizeof(tmp), (uint32_t)(&tmp)))
// 2446     {
// 2447       return FALSE;
// 2448     }
// 2449     /* increment address */
// 2450     addr += sizeof(tmp);
// 2451 
// 2452     /* write element count and element size */
// 2453     tmp = (pNVM_DataTable[idx].ElementsCount << 16) + pNVM_DataTable[idx].ElementSize;
// 2454     if(gNV_OK_c != NV_FlashProgramLongword(&mNvConfig, addr, sizeof(tmp), (uint32_t)(&tmp)))
// 2455     {
// 2456       return FALSE;
// 2457     }
// 2458     /* increment address */
// 2459     addr += sizeof(tmp);
// 2460 
// 2461     /* increment table entry index */
// 2462     idx++;
// 2463   }
// 2464 
// 2465   /* write table qualifier end */
// 2466   if(gNV_OK_c != NV_FlashProgramLongword(&mNvConfig, addr, sizeof(uint32_t),
// 2467       (uint32_t)(&tblQual)))
// 2468   {
// 2469     return FALSE;
// 2470   }
// 2471   return TRUE;
// 2472 }
// 2473 
// 2474 /******************************************************************************
// 2475  * Name: NvGetTableSize
// 2476  * Description: Retrieves the size of the NV table
// 2477  * Parameter(s): [IN] location - specifies if the size shall be the NV FLASH 
// 2478  *                               table size (gFLASHTable_c) or the NV RAM table 
// 2479  *                               size (gRAMTable_c) 
// 2480  * Return: the NV table size
// 2481  ******************************************************************************/
// 2482 static uint32_t NvGetTableSize
// 2483 (
// 2484   uint8_t location
// 2485 )
// 2486 {
// 2487   uint32_t addr;
// 2488   uint32_t size = 0;
// 2489   uint32_t data = 0;
// 2490   uint16_t idx = 0;
// 2491   bool_t tblEndFound;
// 2492 
// 2493   tblEndFound = FALSE;
// 2494 
// 2495   if(gRAMTable_c == location)
// 2496   {
// 2497     /* compute the size of the table stored in RAM memory, except the data pointer size
// 2498      * (the data pointer is not saved into Flash memory)
// 2499      */
// 2500     while(gNvEndOfTableId_c != pNVM_DataTable[idx].DataEntryID)
// 2501     {
// 2502       size += (sizeof(NVM_DataEntry_t)-sizeof(pNVM_DataTable[idx].pData));
// 2503       idx++;
// 2504     }
// 2505   }
// 2506   else
// 2507   {
// 2508     /* compute the size of the table stored in Flash memory */
// 2509     addr = mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress
// 2510         + sizeof(mNvPageCounter);
// 2511 
// 2512     NV_FlashRead(addr, (uint8_t*)&data, sizeof(data));
// 2513 
// 2514     if(gNvTableMarker_c != data)
// 2515     {
// 2516       return 0;
// 2517     }
// 2518 
// 2519     addr += sizeof(data);
// 2520 
// 2521     do
// 2522     {
// 2523       NV_FlashRead(addr, (uint8_t*)&data, sizeof(data));
// 2524       if(gNvTableMarker_c == data)
// 2525       {
// 2526         tblEndFound = TRUE;
// 2527         break;
// 2528       }
// 2529       size += sizeof(data);
// 2530       addr += sizeof(data);
// 2531     } while(addr < mNvVirtualPageProperty[mNvActivePageId].NvRawSectorEndAddress);
// 2532 
// 2533     if(tblEndFound)
// 2534     {
// 2535       return size;
// 2536     }
// 2537     return 0;
// 2538   }
// 2539   return size;
// 2540 }
// 2541 
// 2542 /******************************************************************************
// 2543  * Name: NvIsRamTableUpdated
// 2544  * Description: Checks if the the NV table from RAM memory has changed since
// 2545  *              last system reset (e.g. via an OTAP transfer)
// 2546  * Parameter(s): -
// 2547  * Return: TRUE if the NV RAM table has been changed / FALSE otherwise
// 2548  ******************************************************************************/
// 2549 static bool_t NvIsRamTableUpdated
// 2550 (
// 2551   void
// 2552 )
// 2553 {
// 2554   uint16_t idx;
// 2555   uint32_t data;
// 2556   uint32_t addr;
// 2557   uint32_t endAddr;
// 2558   bool_t idFound;
// 2559 
// 2560   /* address = page raw sector start address + page counter size + table marker */
// 2561   addr = mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress
// 2562       + sizeof(mNvPageCounter) + sizeof(data);
// 2563 
// 2564   /* compute the search end address */
// 2565   endAddr = addr + mNvTableSizeInFlash;
// 2566 
// 2567   do
// 2568   {
// 2569     /* read ID */
// 2570     NV_FlashRead(addr, (uint8_t*)&data, sizeof(data));
// 2571 
// 2572     idFound = FALSE;    
// 2573     idx = 0;
// 2574 
// 2575     while(gNvEndOfTableId_c != pNVM_DataTable[idx].DataEntryID)
// 2576     {
// 2577       if(data == ((pNVM_DataTable[idx].DataEntryID <<16) + 0xFFFF))
// 2578       {
// 2579         idFound = TRUE;
// 2580         break;
// 2581       }
// 2582 
// 2583       /* increment the index */
// 2584       idx++;
// 2585     }
// 2586 
// 2587     if(!idFound)
// 2588     {
// 2589       return TRUE; 
// 2590     }
// 2591 
// 2592     /* read element count and element size */
// 2593     addr += sizeof(data);
// 2594     NV_FlashRead(addr, (uint8_t*)&data, sizeof(data));
// 2595 
// 2596     if(data != ((pNVM_DataTable[idx].ElementsCount << 16) +
// 2597         pNVM_DataTable[idx].ElementSize)) {
// 2598       return TRUE;
// 2599     }
// 2600 
// 2601     /* increment the address */
// 2602     addr += sizeof(data);   
// 2603 
// 2604   } while(addr < endAddr);
// 2605 
// 2606   return FALSE;
// 2607 }
// 2608 
// 2609 /******************************************************************************
// 2610  * Name: NvGetTableEntry
// 2611  * Description: get the NV table entry information stored on FLASH memory
// 2612  * Parameter(s): [IN] tblEntryId - table entry ID
// 2613  *               [OUT] pDataEntry - a pointer to a memory location where the 
// 2614  *                                  entry information will be stored
// 2615  * Return: TRUE if the has been found / FALSE otherwise
// 2616  ******************************************************************************/
// 2617 static bool_t NvGetTableEntry
// 2618 (
// 2619   uint16_t tblEntryId,
// 2620   NVM_DataEntry_t* pDataEntry
// 2621 )
// 2622 {
// 2623   uint32_t addr;
// 2624   uint32_t data;  
// 2625 
// 2626   pDataEntry->pData = NULL; /* the data pointer is not saved on FLASH table and 
// 2627    * shall not be used by the caller of this function */
// 2628 
// 2629   addr = mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress
// 2630       + sizeof(mNvPageCounter);
// 2631 
// 2632   NV_FlashRead(addr, (uint8_t*)&data, sizeof(data));
// 2633 
// 2634   if(data != (uint32_t)gNvTableMarker_c)
// 2635   {   
// 2636     pDataEntry->ElementsCount = 0;
// 2637     pDataEntry->ElementSize = 0;
// 2638     pDataEntry->DataEntryID = gNvInvalidDataEntry_c;
// 2639     return FALSE;
// 2640   }
// 2641 
// 2642   /* increment address */
// 2643   addr += sizeof(data);
// 2644 
// 2645   do
// 2646   {
// 2647     NV_FlashRead(addr, (uint8_t*)&data, sizeof(data));
// 2648 
// 2649     if(data == (uint32_t)gNvTableMarker_c)
// 2650     {
// 2651       /* reached end of table */
// 2652       break; 
// 2653     }
// 2654 
// 2655     if(((data>>16) & 0x0000FFFF) == tblEntryId)
// 2656     {     
// 2657       /* read the next 4 bytes to get element count and element size */
// 2658       addr += sizeof(data);
// 2659       NV_FlashRead(addr, (uint8_t*)&data, sizeof(data));      
// 2660       pDataEntry->ElementsCount = (uint16_t)((data>>16)& 0x0000FFFF);
// 2661       pDataEntry->ElementSize = (uint16_t)(data & 0x0000FFFF);
// 2662       pDataEntry->DataEntryID = tblEntryId;
// 2663       return TRUE;
// 2664     }
// 2665 
// 2666     /* continue searching */
// 2667     addr += (2 * sizeof(data));
// 2668 
// 2669   } while(addr < mNvVirtualPageProperty[mNvActivePageId].NvRawSectorEndAddress);
// 2670 
// 2671   pDataEntry->pData = NULL;
// 2672   pDataEntry->ElementsCount = 0;
// 2673   pDataEntry->ElementSize = 0;
// 2674   pDataEntry->DataEntryID = gNvInvalidDataEntry_c;
// 2675 
// 2676   return FALSE;
// 2677 }
// 2678 
// 2679 #endif /* gNvUseExtendedFeatureSet_d */
// 2680 
// 2681 #endif /* no FlexNVM */
// 2682 
// 2683 
// 2684 /******************************************************************************
// 2685  * Name: NvGetEntryFromDataPtr
// 2686  * Description: get table and element indexes based on a generic pointer address
// 2687  * Parameter(s): [IN] pData - a pointer to a NVM RAM table
// 2688  *               [OUT] pIndex - a pointer to a memory location where the 
// 2689  *                              requested indexed will be stored
// 2690  * Return: gNVM_NullPointer_c - if the provided pointer is NULL
// 2691  *         gNVM_PointerOutOfRange_c - if the provided pointer cannot be founded
// 2692  *                                    within the RAM table
// 2693  *         gNVM_OK_c - if the operation completed successfully
// 2694  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2695 static NVM_Status_t NvGetEntryFromDataPtr
// 2696 (
// 2697   void* pData,
// 2698   NVM_TableEntryInfo_t* pIndex
// 2699 )
// 2700 {        
NvGetEntryFromDataPtr:
        PUSH     {R4-R6}
        MOVS     R2,R0
// 2701   uint16_t idx = 0;
        MOVS     R3,#+0
// 2702 
// 2703 
// 2704   while(gNvEndOfTableId_c != pNVM_DataTable[idx].DataEntryID)
??NvGetEntryFromDataPtr_0:
        LDR.W    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
        MOVS     R4,#+12
        MLA      R0,R4,R3,R0
        LDRH     R0,[R0, #+8]
        MOVW     R4,#+65534
        CMP      R0,R4
        BEQ.N    ??NvGetEntryFromDataPtr_1
// 2705   {
// 2706     if((uint8_t*)pData == (uint8_t*)pNVM_DataTable[idx].pData)
        LDR.W    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
        MOVS     R4,#+12
        MLA      R0,R4,R3,R0
        LDR      R0,[R0, #+0]
        CMP      R2,R0
        BNE.N    ??NvGetEntryFromDataPtr_2
// 2707     {
// 2708       pIndex->entryId = pNVM_DataTable[idx].DataEntryID;
        LDR.W    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
        MOVS     R4,#+12
        MLA      R0,R4,R3,R0
        LDRH     R0,[R0, #+8]
        STRH     R0,[R1, #+0]
// 2709       pIndex->elementIndex = 0;
        MOVS     R0,#+0
        STRH     R0,[R1, #+2]
// 2710       return gNVM_OK_c;
        MOVS     R0,#+0
        B.N      ??NvGetEntryFromDataPtr_3
// 2711     }
// 2712     idx++;
??NvGetEntryFromDataPtr_2:
        ADDS     R3,R3,#+1
        B.N      ??NvGetEntryFromDataPtr_0
// 2713   }
// 2714 
// 2715   idx = 0;
??NvGetEntryFromDataPtr_1:
        MOVS     R0,#+0
        MOVS     R3,R0
// 2716 
// 2717   while(gNvEndOfTableId_c != pNVM_DataTable[idx].DataEntryID)
??NvGetEntryFromDataPtr_4:
        LDR.W    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
        MOVS     R4,#+12
        MLA      R0,R4,R3,R0
        LDRH     R0,[R0, #+8]
        MOVW     R4,#+65534
        CMP      R0,R4
        BEQ.N    ??NvGetEntryFromDataPtr_5
// 2718   {
// 2719     if(((uint8_t*)pData >= (uint8_t*)pNVM_DataTable[idx].pData) && ((uint8_t*)pData < ((uint8_t*)pNVM_DataTable[idx].pData + 
// 2720         (pNVM_DataTable[idx].ElementSize * pNVM_DataTable[idx].ElementsCount))))
        LDR.W    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
        MOVS     R4,#+12
        MLA      R0,R4,R3,R0
        LDR      R0,[R0, #+0]
        CMP      R2,R0
        BCC.N    ??NvGetEntryFromDataPtr_6
        LDR.W    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
        MOVS     R4,#+12
        MLA      R0,R4,R3,R0
        LDR      R0,[R0, #+0]
        LDR.W    R4,??DataTable16
        LDR      R4,[R4, #+0]
        UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
        MOVS     R5,#+12
        MLA      R4,R5,R3,R4
        LDRH     R4,[R4, #+6]
        LDR.W    R5,??DataTable16
        LDR      R5,[R5, #+0]
        UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
        MOVS     R6,#+12
        MLA      R5,R6,R3,R5
        LDRH     R5,[R5, #+4]
        MLA      R0,R5,R4,R0
        CMP      R2,R0
        BCS.N    ??NvGetEntryFromDataPtr_6
// 2721     {
// 2722       pIndex->entryId = pNVM_DataTable[idx].DataEntryID;
        LDR.W    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
        MOVS     R4,#+12
        MLA      R0,R4,R3,R0
        LDRH     R0,[R0, #+8]
        STRH     R0,[R1, #+0]
// 2723       pIndex->elementIndex = (((uint32_t)pData - (uint32_t)pNVM_DataTable[idx].pData)/(pNVM_DataTable[idx].ElementSize));
        LDR.W    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
        MOVS     R4,#+12
        MLA      R0,R4,R3,R0
        LDR      R0,[R0, #+0]
        SUBS     R0,R2,R0
        LDR.W    R4,??DataTable16
        LDR      R4,[R4, #+0]
        UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
        MOVS     R5,#+12
        MLA      R4,R5,R3,R4
        LDRH     R4,[R4, #+6]
        UDIV     R0,R0,R4
        STRH     R0,[R1, #+2]
// 2724       return gNVM_OK_c;
        MOVS     R0,#+0
        B.N      ??NvGetEntryFromDataPtr_3
// 2725     }
// 2726     /* increment the loop counter */
// 2727     idx++;
??NvGetEntryFromDataPtr_6:
        ADDS     R3,R3,#+1
        B.N      ??NvGetEntryFromDataPtr_4
// 2728   }    
// 2729   return gNVM_PointerOutOfRange_c;
??NvGetEntryFromDataPtr_5:
        MOVS     R0,#+6
??NvGetEntryFromDataPtr_3:
        POP      {R4-R6}
        BX       LR               ;; return
// 2730 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13:
        DC32     mNvVirtualPageProperty

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_1:
        DC32     mNvConfig

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_2:
        DC32     mNvActivePageId

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_3:
        DC32     mNvPageCounter

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_4:
        DC32     mNvErasePgCmdStatus
// 2731 
// 2732 
// 2733 /******************************************************************************
// 2734  * Name: NvWriteRecord
// 2735  * Description: writes a record
// 2736  * Parameter(s): [IN] tblIndexes - a pointer to table and element indexes
// 2737  * Return: gNVM_InvalidPageID_c - if the active page is not valid
// 2738  *         gNVM_NullPointer_c - if the provided pointer is NULL
// 2739  *         gNVM_MetaInfoWriteError_c - if the meta information couldn't be 
// 2740  *                                     written
// 2741  *         gNVM_RecordWriteError_c - if the record couldn't be written
// 2742  *         gNVM_OK_c - if the operation completed successfully
// 2743  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2744 static NVM_Status_t NvWriteRecord
// 2745 (        
// 2746   NVM_TableEntryInfo_t* tblIndexes
// 2747 )
// 2748 {
NvWriteRecord:
        PUSH     {R4-R11,LR}
        SUB      SP,SP,#+20
        MOVS     R4,R0
// 2749 #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */  
// 2750   uint32_t metaInfoAddress;
// 2751   uint32_t lastRecordAddress;
// 2752   uint32_t newRecordAddress;
// 2753   NVM_RecordMetaInfo_t metaInfo;        
// 2754   uint32_t realRecordSize;
// 2755   uint32_t totalRecordSize; /* record + meta */    
// 2756   uint32_t pageFreeSpace;
// 2757   uint8_t paddingBytes;
// 2758   bool_t doWrite;    
// 2759   uint32_t srcAddress;
// 2760 #else /* FlexNVM */
// 2761   uint32_t lastFlexMetaInfoAddress;
// 2762   NVM_FlexMetaInfo_t lastFlexMetaInfo;
// 2763   NVM_FlexMetaInfo_t flexMetaInfo;
// 2764   uint32_t destRecordEndAddress;
// 2765 
// 2766 #endif
// 2767 
// 2768   uint16_t tableEntryIdx;
// 2769   uint32_t recordSize;
// 2770 
// 2771   tableEntryIdx = NvGetTableEntryIndexFromId(tblIndexes->entryId);
        LDRH     R0,[R4, #+0]
        BL       NvGetTableEntryIndexFromId
        MOV      R8,R0
// 2772 
// 2773   if(gNvInvalidTableEntryIndex_c == tableEntryIdx)
        UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
        MOVW     R0,#+65535
        CMP      R8,R0
        BNE.N    ??NvWriteRecord_0
// 2774   {
// 2775     return gNVM_InvalidTableEntry_c;
        MOVS     R0,#+9
        B.N      ??NvWriteRecord_1
// 2776   }
// 2777 
// 2778 #if (gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c != 0) /* FlexNVM */
// 2779 
// 2780   recordSize = pNVM_DataTable[tableEntryIdx].ElementsCount * pNVM_DataTable[tableEntryIdx].ElementSize;
// 2781 
// 2782   NvGetFlexMetaInfoFromId(tblIndexes->entryId, &flexMetaInfo);
// 2783 
// 2784   if(flexMetaInfo.rawValue == gNvFlexGuardValue_c) /* no meta found for this table entry ID */
// 2785   {
// 2786     /* set entry ID */
// 2787     flexMetaInfo.fields.NvDataEntryID = tblIndexes->entryId;      
// 2788     /* get last meta info tag address */
// 2789     lastFlexMetaInfoAddress = NvGetFlexLastMetaInfo();
// 2790 
// 2791     if(lastFlexMetaInfoAddress < mNvConfig.EERAMBlockBase) /* FlexRAM empty */
// 2792     {              
// 2793       flexMetaInfo.fields.NvDataOffset = mNvConfig.EEEBlockSize - recordSize;
// 2794       destRecordEndAddress = mNvConfig.EERAMBlockBase + mNvConfig.EEEBlockSize;
// 2795       lastFlexMetaInfoAddress = mNvConfig.EERAMBlockBase;
// 2796     }
// 2797     else
// 2798     {
// 2799       /* wait for EEPROM system to be ready */
// 2800       while(!(gNV_REG_READ(mNvConfig.ftfxRegBase + gNV_FCNFG_OFFSET_c) & gNV_FCNFG_EEERDY_c));
// 2801       /* read last meta tag */
// 2802       NV_FlashRead(lastFlexMetaInfoAddress, (uint8_t*)&lastFlexMetaInfo, sizeof(NVM_FlexMetaInfo_t));
// 2803       /* compute record destination end address */
// 2804       destRecordEndAddress = mNvConfig.EERAMBlockBase + lastFlexMetaInfo.fields.NvDataOffset;
// 2805       /* compute record offset */
// 2806       flexMetaInfo.fields.NvDataOffset = lastFlexMetaInfo.fields.NvDataOffset - recordSize;
// 2807       /* increment the last meta info address and reused it as address of the current meta info tag */
// 2808       lastFlexMetaInfoAddress += sizeof(NVM_FlexMetaInfo_t);
// 2809     }
// 2810 
// 2811     /* wait for EEPROM system to be ready */
// 2812     while(!(gNV_REG_READ(mNvConfig.ftfxRegBase + gNV_FCNFG_OFFSET_c) & gNV_FCNFG_EEERDY_c));
// 2813 
// 2814     /* write record */
// 2815     if(gNV_OK_c != NV_EEEWrite(&mNvConfig, (uint32_t) ((uint8_t*)(pNVM_DataTable[tableEntryIdx].pData)), destRecordEndAddress - recordSize, recordSize))
// 2816     {
// 2817       return gNVM_RecordWriteError_c;
// 2818     }   
// 2819 
// 2820     /* wait for EEPROM system to be ready */
// 2821     while(!(gNV_REG_READ(mNvConfig.ftfxRegBase + gNV_FCNFG_OFFSET_c) & gNV_FCNFG_EEERDY_c));
// 2822 
// 2823     /* write meta */
// 2824     if(gNV_OK_c != NV_EEEWrite(&mNvConfig, (uint32_t)(&flexMetaInfo.rawValue), lastFlexMetaInfoAddress, sizeof(NVM_FlexMetaInfo_t)))
// 2825     {
// 2826       return gNVM_RecordWriteError_c;      
// 2827     }
// 2828   }
// 2829   else /* table entry ID already in FlexRAM, update the corresponding record */
// 2830   {
// 2831     /* wait for EEPROM system to be ready */
// 2832     while(!(gNV_REG_READ(mNvConfig.ftfxRegBase + gNV_FCNFG_OFFSET_c) & gNV_FCNFG_EEERDY_c));
// 2833 
// 2834     if(gNV_OK_c != NV_EEEWrite(&mNvConfig, (uint32_t) ((uint8_t*)(pNVM_DataTable[tableEntryIdx].pData)), 
// 2835         (uint32_t)(mNvConfig.EERAMBlockBase + flexMetaInfo.fields.NvDataOffset), recordSize))
// 2836     {
// 2837       return gNVM_RecordWriteError_c;
// 2838     }
// 2839   }
// 2840 
// 2841   return gNVM_OK_c;
// 2842 
// 2843 #else
// 2844 
// 2845   if(tblIndexes->saveRestoreAll)
??NvWriteRecord_0:
        LDRB     R0,[R4, #+4]
        CMP      R0,#+0
        BEQ.N    ??NvWriteRecord_2
// 2846   {
// 2847     realRecordSize = recordSize = pNVM_DataTable[tableEntryIdx].ElementSize * pNVM_DataTable[tableEntryIdx].ElementsCount;        
        LDR.W    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R8,R0
        LDRH     R0,[R0, #+6]
        LDR.W    R1,??DataTable16
        LDR      R1,[R1, #+0]
        UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
        MOVS     R2,#+12
        MLA      R1,R2,R8,R1
        LDRH     R1,[R1, #+4]
        MULS     R0,R1,R0
        MOV      R9,R0
        MOV      R10,R9
        B.N      ??NvWriteRecord_3
// 2848   }
// 2849   else
// 2850   {
// 2851     realRecordSize = recordSize = pNVM_DataTable[tableEntryIdx].ElementSize;
??NvWriteRecord_2:
        LDR.W    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R8,R0
        LDRH     R0,[R0, #+6]
        MOV      R9,R0
        MOV      R10,R9
// 2852   }
// 2853 
// 2854   /* get active page free space */
// 2855   NvGetPageFreeSpace(&pageFreeSpace);
??NvWriteRecord_3:
        ADD      R0,SP,#+12
        BL       NvGetPageFreeSpace
// 2856 
// 2857   /* compute the 'real record size' taking into consideration that the FTFL controller only writes in burst of 4 bytes */    
// 2858   paddingBytes = recordSize % (uint8_t)gNV_LONGWORD_SIZE_c;
        MOVS     R0,#+4
        UDIV     R1,R9,R0
        MLS      R1,R1,R0,R9
        STRB     R1,[SP, #+9]
// 2859   if(paddingBytes)
        LDRB     R0,[SP, #+9]
        CMP      R0,#+0
        BEQ.N    ??NvWriteRecord_4
// 2860   {
// 2861     realRecordSize += (uint8_t)((uint8_t)gNV_LONGWORD_SIZE_c-paddingBytes);
        LDRB     R0,[SP, #+9]
        RSBS     R0,R0,#+4
        UXTAB    R10,R10,R0
// 2862   }
// 2863 
// 2864   /* compute the total size (record + meta info) */
// 2865   totalRecordSize = realRecordSize + sizeof(NVM_RecordMetaInfo_t);
??NvWriteRecord_4:
        ADDS     R0,R10,#+8
        MOVS     R6,R0
// 2866 
// 2867   /* check if the record fits the page's free space.  
// 2868    * one extra meta info space must be kept always free, to be able to perform the meta info search */
// 2869   if(totalRecordSize + sizeof(NVM_RecordMetaInfo_t) > pageFreeSpace) 
        LDR      R0,[SP, #+12]
        ADDS     R1,R6,#+8
        CMP      R0,R1
        BCS.N    ??NvWriteRecord_5
// 2870   {        
// 2871     /* there is no space to save the record, try to copy the current active page latest records
// 2872      * to the other page
// 2873      */
// 2874 #if gNvUseExtendedFeatureSet_d	  
// 2875     mNvSkipTableEntryId = gNvCopyAll_c;
// 2876 #endif /* #if gNvUseExtendedFeatureSet_d */
// 2877     mNvCopyOperationIsPending = TRUE;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable26
        STRB     R0,[R1, #+0]
// 2878     return gNVM_PageCopyPending_c;        
        MOVS     R0,#+17
        B.N      ??NvWriteRecord_1
// 2879   }
// 2880   else
// 2881   {        
// 2882     metaInfoAddress = mNvVirtualPageProperty[mNvActivePageId].NvLastMetaInfoAddress;
??NvWriteRecord_5:
        LDR.N    R0,??DataTable14_1
        LDR.W    R1,??DataTable16_1
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+16]
        MOV      R11,R0
// 2883 
// 2884     if(gEmptyPageMetaAddress_c == metaInfoAddress) 
        LDR.N    R0,??DataTable14  ;; 0x3fff0000
        CMP      R11,R0
        BNE.N    ??NvWriteRecord_6
// 2885     {      
// 2886       /* empty page, first write */
// 2887 
// 2888       /* set new record address */
// 2889       newRecordAddress = mNvVirtualPageProperty[mNvActivePageId].NvRawSectorEndAddress - sizeof(mNvPageCounter) - realRecordSize + 1;
        LDR.N    R0,??DataTable14_1
        LDR.W    R1,??DataTable16_1
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+4]
        SUBS     R0,R0,#+4
        SUBS     R0,R0,R10
        ADDS     R0,R0,#+1
        MOVS     R5,R0
// 2890 
// 2891       /* set associated meta info */            
// 2892       if(tblIndexes->saveRestoreAll)
        LDRB     R0,[R4, #+4]
        CMP      R0,#+0
        BEQ.N    ??NvWriteRecord_7
// 2893       {
// 2894         metaInfo.fields.NvValidationStartByte = gValidationByteAllRecords_c;
        MOVS     R0,#+85
        STRB     R0,[SP, #+0]
// 2895         metaInfo.fields.NvValidationEndByte = gValidationByteAllRecords_c;
        MOVS     R0,#+85
        STRB     R0,[SP, #+7]
        B.N      ??NvWriteRecord_8
// 2896       }
// 2897       else
// 2898       {
// 2899         metaInfo.fields.NvValidationStartByte = gValidationByteSingleRecord_c;
??NvWriteRecord_7:
        MOVS     R0,#+170
        STRB     R0,[SP, #+0]
// 2900         metaInfo.fields.NvValidationEndByte = gValidationByteSingleRecord_c;
        MOVS     R0,#+170
        STRB     R0,[SP, #+7]
// 2901       }
// 2902 
// 2903       metaInfo.fields.NvmDataEntryID = pNVM_DataTable[tableEntryIdx].DataEntryID;
??NvWriteRecord_8:
        LDR.W    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R8,R0
        LDRH     R0,[R0, #+8]
        STRH     R0,[SP, #+1]
// 2904       metaInfo.fields.NvmElementIndex = tblIndexes->elementIndex;
        LDRH     R0,[R4, #+2]
        STRH     R0,[SP, #+3]
// 2905       metaInfo.fields.NvmRecordOffset = mNvVirtualPageProperty[mNvActivePageId].NvRawSectorEndAddress - 
// 2906           mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress - realRecordSize - sizeof(mNvPageCounter) + 1;
        LDR.N    R0,??DataTable14_1
        LDR.W    R1,??DataTable16_1
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+4]
        LDR.N    R1,??DataTable14_1
        LDR.W    R2,??DataTable16_1
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+20
        MLA      R1,R3,R2,R1
        LDR      R1,[R1, #+0]
        SUBS     R0,R0,R1
        SUBS     R0,R0,R10
        SUBS     R0,R0,#+3
        STRH     R0,[SP, #+5]
// 2907 
// 2908       /* gEmptyPageMetaAddress_c is not a valid address and it is used only as an empty page marker;
// 2909        * therefore, set the valid value of meta information address */
// 2910 #if gNvUseExtendedFeatureSet_d      
// 2911       metaInfoAddress = mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + sizeof(mNvPageCounter) +
// 2912           mNvTableSizeInFlash + (2 * sizeof(mNvTableMarker));
// 2913 #else
// 2914       metaInfoAddress = mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + sizeof(mNvPageCounter);
        LDR.N    R0,??DataTable14_1
        LDR.W    R1,??DataTable16_1
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+4
        MOV      R11,R0
        B.N      ??NvWriteRecord_9
// 2915 #endif /* gNvUseExtendedFeatureSet_d */
// 2916     }
// 2917     else    
// 2918     {
// 2919       /* get the meta information of the last successfully written record */
// 2920       NvGetMetaInfo(mNvActivePageId, metaInfoAddress, &metaInfo);
??NvWriteRecord_6:
        ADD      R2,SP,#+0
        MOV      R1,R11
        LDR.W    R0,??DataTable16_1
        LDRB     R0,[R0, #+0]
        BL       NvGetMetaInfo
// 2921 
// 2922       /* get the last record start address (the address is always 4-bytes aligned) */
// 2923       lastRecordAddress = mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + metaInfo.fields.NvmRecordOffset;
        LDR.N    R0,??DataTable14_1
        LDR.W    R1,??DataTable16_1
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+0]
        LDRH     R1,[SP, #+5]
        UXTAH    R0,R0,R1
        STR      R0,[SP, #+16]
// 2924 
// 2925       /* set new record address */
// 2926       newRecordAddress = lastRecordAddress - realRecordSize;
        LDR      R0,[SP, #+16]
        SUBS     R0,R0,R10
        MOVS     R5,R0
// 2927 
// 2928       /* set associated meta info */
// 2929       if(tblIndexes->saveRestoreAll)
        LDRB     R0,[R4, #+4]
        CMP      R0,#+0
        BEQ.N    ??NvWriteRecord_10
// 2930       {
// 2931         metaInfo.fields.NvValidationStartByte = gValidationByteAllRecords_c;
        MOVS     R0,#+85
        STRB     R0,[SP, #+0]
// 2932         metaInfo.fields.NvValidationEndByte = gValidationByteAllRecords_c;
        MOVS     R0,#+85
        STRB     R0,[SP, #+7]
        B.N      ??NvWriteRecord_11
// 2933       }
// 2934       else
// 2935       {
// 2936         metaInfo.fields.NvValidationStartByte = gValidationByteSingleRecord_c;
??NvWriteRecord_10:
        MOVS     R0,#+170
        STRB     R0,[SP, #+0]
// 2937         metaInfo.fields.NvValidationEndByte = gValidationByteSingleRecord_c;
        MOVS     R0,#+170
        STRB     R0,[SP, #+7]
// 2938       }
// 2939       metaInfo.fields.NvmDataEntryID = pNVM_DataTable[tableEntryIdx].DataEntryID;
??NvWriteRecord_11:
        LDR.W    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R8,R0
        LDRH     R0,[R0, #+8]
        STRH     R0,[SP, #+1]
// 2940       metaInfo.fields.NvmElementIndex = tblIndexes->elementIndex;
        LDRH     R0,[R4, #+2]
        STRH     R0,[SP, #+3]
// 2941       metaInfo.fields.NvmRecordOffset = newRecordAddress - mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress;
        LDR.N    R0,??DataTable14_1
        LDR.W    R1,??DataTable16_1
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+0]
        SUBS     R0,R5,R0
        STRH     R0,[SP, #+5]
// 2942 
// 2943       metaInfoAddress += sizeof(NVM_RecordMetaInfo_t);
        ADDS     R11,R11,#+8
// 2944     }       
// 2945 
// 2946     /* check if the space needed by the record is really free (erased).
// 2947      * this check is necessary because it may happens that a record to be successfully written,
// 2948      * but the system fails (e.g. POR) before the associated meta information has been written.
// 2949      * the theoretically free space is computed as the difference between the last meta info 
// 2950      * address and the start address of the last successfully written record. This information
// 2951      * is valuable but may not reflect the reality, as mentioned in the explanation above */
// 2952 
// 2953     doWrite = FALSE;
??NvWriteRecord_9:
        MOVS     R0,#+0
        STRB     R0,[SP, #+8]
// 2954 
// 2955     while(totalRecordSize + sizeof(NVM_RecordMetaInfo_t) < pageFreeSpace)
??NvWriteRecord_12:
        ADDS     R0,R6,#+8
        LDR      R1,[SP, #+12]
        CMP      R0,R1
        BCS.N    ??NvWriteRecord_13
// 2956     {
// 2957       if(!NvIsMemoryAreaAvailable(newRecordAddress, realRecordSize))
        MOV      R1,R10
        MOVS     R0,R5
        BL       NvIsMemoryAreaAvailable
        CMP      R0,#+0
        BNE.N    ??NvWriteRecord_14
// 2958       {
// 2959         /* the memory space is not blank */
// 2960         pageFreeSpace -= realRecordSize;
        LDR      R0,[SP, #+12]
        SUBS     R0,R0,R10
        STR      R0,[SP, #+12]
// 2961         newRecordAddress -= realRecordSize;
        SUBS     R5,R5,R10
        B.N      ??NvWriteRecord_12
// 2962       }
// 2963       else
// 2964       {
// 2965         /* the memory space is blank */
// 2966         doWrite = TRUE;
??NvWriteRecord_14:
        MOVS     R0,#+1
        STRB     R0,[SP, #+8]
// 2967         break;
// 2968       }            
// 2969     }  
// 2970 
// 2971     /* update the meta info offset, if changed */
// 2972     if(newRecordAddress - mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress != metaInfo.fields.NvmRecordOffset)
??NvWriteRecord_13:
        LDR.N    R0,??DataTable14_1
        LDR.W    R1,??DataTable16_1
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+0]
        SUBS     R0,R5,R0
        LDRH     R1,[SP, #+5]
        CMP      R0,R1
        BEQ.N    ??NvWriteRecord_15
// 2973     {
// 2974       metaInfo.fields.NvmRecordOffset = newRecordAddress - mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress;
        LDR.N    R0,??DataTable14_1
        LDR.W    R1,??DataTable16_1
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+0]
        SUBS     R0,R5,R0
        STRH     R0,[SP, #+5]
// 2975     }
// 2976 
// 2977     /* Write the record and associated meta information */
// 2978     if(doWrite)
??NvWriteRecord_15:
        LDRB     R0,[SP, #+8]
        CMP      R0,#+0
        BEQ.N    ??NvWriteRecord_16
// 2979     {            
// 2980       if(tblIndexes->saveRestoreAll)
        LDRB     R0,[R4, #+4]
        CMP      R0,#+0
        BEQ.N    ??NvWriteRecord_17
// 2981       {
// 2982         srcAddress = (uint32_t)((uint8_t*)(((uint8_t*)(pNVM_DataTable[tableEntryIdx]).pData)));
        LDR.W    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R8,R0
        LDR      R0,[R0, #+0]
        MOVS     R7,R0
        B.N      ??NvWriteRecord_18
// 2983       }
// 2984       else
// 2985       {
// 2986         srcAddress = (uint32_t)((uint8_t*)(((uint8_t*)(pNVM_DataTable[tableEntryIdx]).pData)) + (tblIndexes->elementIndex * recordSize));
??NvWriteRecord_17:
        LDR.W    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R8,R0
        LDR      R0,[R0, #+0]
        LDRH     R1,[R4, #+2]
        MLA      R0,R9,R1,R0
        MOVS     R7,R0
// 2987       }
// 2988 
// 2989       if(gNV_OK_c == NV_FlashProgramLongword(&mNvConfig, newRecordAddress, recordSize, srcAddress))
??NvWriteRecord_18:
        MOVS     R3,R7
        MOV      R2,R9
        MOVS     R1,R5
        LDR.N    R0,??DataTable14_2
        BL       NV_FlashProgramLongword
        CMP      R0,#+0
        BNE.N    ??NvWriteRecord_19
// 2990       {                    
// 2991 
// 2992         /* record successfully written, now write the associated record meta information */
// 2993         if(gNV_OK_c == NV_FlashProgramLongword(&mNvConfig, metaInfoAddress, sizeof(NVM_RecordMetaInfo_t), (uint32_t)(&metaInfo)))
        ADD      R3,SP,#+0
        MOVS     R2,#+8
        MOV      R1,R11
        LDR.N    R0,??DataTable14_2
        BL       NV_FlashProgramLongword
        CMP      R0,#+0
        BNE.N    ??NvWriteRecord_20
// 2994         {      
// 2995           /* update the last record meta information */
// 2996           mNvVirtualPageProperty[mNvActivePageId].NvLastMetaInfoAddress = metaInfoAddress;                    
        LDR.N    R0,??DataTable14_1
        LDR.W    R1,??DataTable16_1
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        STR      R11,[R0, #+16]
// 2997           return gNVM_OK_c;                    
        MOVS     R0,#+0
        B.N      ??NvWriteRecord_1
// 2998         }
// 2999         else
// 3000         {
// 3001           return gNVM_MetaInfoWriteError_c;
??NvWriteRecord_20:
        MOVS     R0,#+13
        B.N      ??NvWriteRecord_1
// 3002         }
// 3003       }
// 3004       else
// 3005       {
// 3006         return gNVM_RecordWriteError_c;
??NvWriteRecord_19:
        MOVS     R0,#+12
        B.N      ??NvWriteRecord_1
// 3007       }
// 3008     }
// 3009     else
// 3010     {
// 3011       /* there is no space to save the record, try to copy the current active page latest records
// 3012        * to the other page
// 3013        */           
// 3014 #if gNvUseExtendedFeatureSet_d    	
// 3015       mNvSkipTableEntryId = gNvCopyAll_c;
// 3016 #endif /* gNvUseExtendedFeatureSet_d */      
// 3017       mNvCopyOperationIsPending = TRUE;
??NvWriteRecord_16:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable26
        STRB     R0,[R1, #+0]
// 3018       return gNVM_PageCopyPending_c;
        MOVS     R0,#+17
??NvWriteRecord_1:
        ADD      SP,SP,#+20
        POP      {R4-R11,PC}      ;; return
// 3019     }
// 3020   }
// 3021 #endif /* gNvUseFlexNVM_d */
// 3022 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14:
        DC32     0x3fff0000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_1:
        DC32     mNvVirtualPageProperty

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_2:
        DC32     mNvConfig
// 3023 
// 3024 
// 3025 /******************************************************************************
// 3026  * Name: NvRestoreData
// 3027  * Description: restore an element from NVM storage to its original RAM location
// 3028  * Parameter(s): [IN] tblIdx - pointer to table and element indexes
// 3029  * Return: gNVM_NullPointer_c - if the provided pointer is NULL
// 3030  *         gNVM_PageIsEmpty_c - if page is empty
// 3031  *         gNVM_Error_c - in case of error(s)
// 3032  *         gNVM_OK_c - if the operation completed successfully
// 3033  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 3034 static NVM_Status_t NvRestoreData
// 3035 (        
// 3036   NVM_TableEntryInfo_t* tblIdx
// 3037 )
// 3038 {
NvRestoreData:
        PUSH     {R4-R11,LR}
        SUB      SP,SP,#+20
        MOVS     R4,R0
// 3039 #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */
// 3040   NVM_RecordMetaInfo_t metaInfo;
// 3041   uint32_t metaInfoAddress;
// 3042   bool_t restoreSingleRecord;        
// 3043   uint32_t restoreAllMetaInfoAddress;
// 3044   uint32_t loopEndAddress;
// 3045   uint16_t elemMinIdx, elemMaxIdx, loopCnt;
// 3046   NVM_Status_t status;
// 3047 #else
// 3048   NVM_FlexMetaInfo_t flexMetaInfo;
// 3049   uint32_t EERamAddress;
// 3050 #endif
// 3051 
// 3052   uint16_t tableEntryIdx;
// 3053 
// 3054 #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */    
// 3055   
// 3056   /* get the last meta information address */
// 3057   if((metaInfoAddress = mNvVirtualPageProperty[mNvActivePageId].NvLastMetaInfoAddress) == gEmptyPageMetaAddress_c)
        LDR.W    R0,??DataTable28
        LDR.W    R1,??DataTable16_1
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+16]
        MOV      R11,R0
        LDR.W    R0,??DataTable28_1  ;; 0x3fff0000
        CMP      R11,R0
        BNE.N    ??NvRestoreData_0
// 3058   {
// 3059     /* blank page, no data to restore */
// 3060     return gNVM_PageIsEmpty_c;
        MOVS     R0,#+10
        B.N      ??NvRestoreData_1
// 3061   }    
// 3062 
// 3063   if(tblIdx->entryId == gNvInvalidDataEntry_c)
??NvRestoreData_0:
        LDRH     R0,[R4, #+0]
        MOVW     R1,#+65535
        CMP      R0,R1
        BNE.N    ??NvRestoreData_2
// 3064   {
// 3065     /* invalid table entry */
// 3066     return gNVM_InvalidTableEntry_c;
        MOVS     R0,#+9
        B.N      ??NvRestoreData_1
// 3067   }
// 3068 #endif
// 3069 
// 3070   tableEntryIdx = NvGetTableEntryIndexFromId(tblIdx->entryId);
??NvRestoreData_2:
        LDRH     R0,[R4, #+0]
        BL       NvGetTableEntryIndexFromId
        MOV      R10,R0
// 3071 
// 3072   if(gNvInvalidTableEntryIndex_c == tableEntryIdx)
        UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
        MOVW     R0,#+65535
        CMP      R10,R0
        BNE.N    ??NvRestoreData_3
// 3073   {
// 3074     return gNVM_InvalidTableEntry_c;
        MOVS     R0,#+9
        B.N      ??NvRestoreData_1
// 3075   }
// 3076 
// 3077 #if (gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c != 0) /* FlexNVM */
// 3078 
// 3079   /* restore data from EERAM */
// 3080   EERamAddress = mNvConfig.EERAMBlockBase;
// 3081 
// 3082   do
// 3083   {
// 3084     /* wait for EEPROM system to be ready */
// 3085     while(!(gNV_REG_READ(mNvConfig.ftfxRegBase + gNV_FCNFG_OFFSET_c) & gNV_FCNFG_EEERDY_c));
// 3086     /* read meta info tag */
// 3087     NV_FlashRead(EERamAddress, (uint8_t*)&flexMetaInfo, sizeof(flexMetaInfo));
// 3088 
// 3089     if(flexMetaInfo.rawValue == gNvFlexGuardValue_c) /* end of meta info space */
// 3090     {
// 3091       break;
// 3092     }
// 3093 
// 3094     if(tblIdx->entryId == flexMetaInfo.fields.NvDataEntryID)
// 3095     {
// 3096       if(tblIdx->saveRestoreAll)
// 3097       {
// 3098         /* wait for EEPROM system to be ready */
// 3099         while(!(gNV_REG_READ(mNvConfig.ftfxRegBase + gNV_FCNFG_OFFSET_c) & gNV_FCNFG_EEERDY_c));
// 3100         /* read all elements */
// 3101         NV_FlashRead((mNvConfig.EERAMBlockBase + flexMetaInfo.fields.NvDataOffset),
// 3102             (uint8_t*)(pNVM_DataTable[tableEntryIdx].pData),
// 3103             pNVM_DataTable[tableEntryIdx].ElementSize * pNVM_DataTable[tableEntryIdx].ElementsCount);
// 3104         return gNVM_OK_c;
// 3105       }
// 3106       else
// 3107       {
// 3108         /* wait for EEPROM system to be ready */
// 3109         while(!(gNV_REG_READ(mNvConfig.ftfxRegBase + gNV_FCNFG_OFFSET_c) & gNV_FCNFG_EEERDY_c));
// 3110         /* read element */
// 3111         NV_FlashRead(mNvConfig.EERAMBlockBase + flexMetaInfo.fields.NvDataOffset + (tblIdx->elementIndex * pNVM_DataTable[tableEntryIdx].ElementSize),
// 3112             (uint8_t*)(((uint8_t*)pNVM_DataTable[tableEntryIdx].pData) + (tblIdx->elementIndex * pNVM_DataTable[tableEntryIdx].ElementSize)),
// 3113             pNVM_DataTable[tableEntryIdx].ElementSize);
// 3114         return gNVM_OK_c;
// 3115       } 
// 3116     }       
// 3117 
// 3118     /* go to next meta tag */
// 3119     EERamAddress += sizeof(flexMetaInfo);
// 3120 
// 3121   } while(EERamAddress < (mNvConfig.EERAMBlockBase + mNvConfig.EEEBlockSize));
// 3122 
// 3123   return gNVM_MetaNotFound_c;
// 3124 #else    
// 3125 
// 3126   restoreSingleRecord = FALSE;                                    
??NvRestoreData_3:
        MOVS     R0,#+0
        STRB     R0,[SP, #+12]
// 3127   restoreAllMetaInfoAddress = gNvInvalidMetaInfoAddress_c;
        MOVS     R0,#-1
        STR      R0,[SP, #+8]
// 3128 
// 3129   /*
// 3130    * If the meta info is found, the associated record is restored, 
// 3131    * otherwise the gNVM_MetaNotFound_c will be returned
// 3132    */
// 3133   status = gNVM_MetaNotFound_c;
        MOVS     R0,#+11
        MOV      R9,R0
// 3134 
// 3135   
// 3136   /*** restore all ***/  
// 3137   if(tblIdx->saveRestoreAll)
        LDRB     R0,[R4, #+4]
        CMP      R0,#+0
        BEQ.W    ??NvRestoreData_4
// 3138   {
// 3139     elemMinIdx = pNVM_DataTable[tableEntryIdx].ElementsCount;
        LDR.W    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R10,R0
        LDRH     R0,[R0, #+4]
        MOVS     R6,R0
// 3140     elemMaxIdx = 0;			
        MOVS     R0,#+0
        MOVS     R7,R0
// 3141 	  
// 3142     /* parse meta info backwards until the element is found */
// 3143     while(metaInfoAddress >= (mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + sizeof(mNvPageCounter)
// 3144 #if gNvUseExtendedFeatureSet_d
// 3145     		+ mNvTableSizeInFlash + (2 * sizeof(mNvTableMarker))
// 3146 #endif /* gNvUseExtendedFeatureSet_d */
// 3147          ))
??NvRestoreData_5:
        LDR.W    R0,??DataTable28
        LDR.W    R1,??DataTable16_1
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+4
        CMP      R11,R0
        BCC.N    ??NvRestoreData_6
// 3148     {
// 3149       /* get the meta information */
// 3150       NvGetMetaInfo(mNvActivePageId, metaInfoAddress, &metaInfo);
        ADD      R2,SP,#+0
        MOV      R1,R11
        LDR.W    R0,??DataTable16_1
        LDRB     R0,[R0, #+0]
        BL       NvGetMetaInfo
// 3151 
// 3152       if(metaInfo.fields.NvValidationStartByte != metaInfo.fields.NvValidationEndByte)
        LDRB     R0,[SP, #+0]
        LDRB     R1,[SP, #+7]
        CMP      R0,R1
        BEQ.N    ??NvRestoreData_7
// 3153       {
// 3154         /* invalid meta info, move to the previous meta info */
// 3155     	metaInfoAddress -= sizeof(NVM_RecordMetaInfo_t);
        SUBS     R11,R11,#+8
// 3156         continue;
        B.N      ??NvRestoreData_5
// 3157       }
// 3158 
// 3159       if(metaInfo.fields.NvmDataEntryID == tblIdx->entryId)
??NvRestoreData_7:
        LDRH     R0,[SP, #+1]
        LDRH     R1,[R4, #+0]
        CMP      R0,R1
        BNE.N    ??NvRestoreData_8
// 3160       {                
// 3161         if(metaInfo.fields.NvValidationStartByte == gValidationByteSingleRecord_c)
        LDRB     R0,[SP, #+0]
        CMP      R0,#+170
        BNE.N    ??NvRestoreData_9
// 3162         {
// 3163           /* A 'restore all' command has been requested but this meta refers a single element record
// 3164            * Mark the corresponding flag  
// 3165            */
// 3166           restoreSingleRecord = TRUE;
        MOVS     R0,#+1
        STRB     R0,[SP, #+12]
// 3167           
// 3168           /* set the search limits */
// 3169           if(metaInfo.fields.NvmElementIndex < elemMinIdx)
        LDRH     R0,[SP, #+3]
        UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
        CMP      R0,R6
        BCS.N    ??NvRestoreData_10
// 3170           {
// 3171             elemMinIdx = metaInfo.fields.NvmElementIndex;
        LDRH     R0,[SP, #+3]
        MOVS     R6,R0
// 3172           }
// 3173           if(metaInfo.fields.NvmElementIndex > elemMaxIdx)
??NvRestoreData_10:
        LDRH     R0,[SP, #+3]
        UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
        CMP      R7,R0
        BCS.N    ??NvRestoreData_11
// 3174           {
// 3175             elemMaxIdx = metaInfo.fields.NvmElementIndex;
        LDRH     R0,[SP, #+3]
        MOVS     R7,R0
// 3176           }
// 3177           
// 3178           metaInfoAddress -= sizeof(NVM_RecordMetaInfo_t);
??NvRestoreData_11:
        SUBS     R11,R11,#+8
// 3179           continue;
        B.N      ??NvRestoreData_5
// 3180         }
// 3181 
// 3182         if(metaInfo.fields.NvValidationStartByte == gValidationByteAllRecords_c)
??NvRestoreData_9:
        LDRB     R0,[SP, #+0]
        CMP      R0,#+85
        BNE.N    ??NvRestoreData_8
// 3183         {       
// 3184           /* restore all records */
// 3185           NV_FlashRead( (mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + metaInfo.fields.NvmRecordOffset),
// 3186               (uint8_t*)pNVM_DataTable[tableEntryIdx].pData,
// 3187               (pNVM_DataTable[tableEntryIdx].ElementsCount * pNVM_DataTable[tableEntryIdx].ElementSize));
        LDR.N    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R10,R0
        LDRH     R0,[R0, #+4]
        LDR.N    R1,??DataTable16
        LDR      R1,[R1, #+0]
        UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
        MOVS     R2,#+12
        MLA      R1,R2,R10,R1
        LDRH     R1,[R1, #+6]
        MUL      R2,R1,R0
        LDR.N    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R10,R0
        LDR      R1,[R0, #+0]
        LDR.W    R0,??DataTable28
        LDR.N    R3,??DataTable16_1
        LDRB     R3,[R3, #+0]
        MOVS     R12,#+20
        MLA      R0,R12,R3,R0
        LDR      R0,[R0, #+0]
        LDRH     R3,[SP, #+5]
        UXTAH    R0,R0,R3
        BL       NV_FlashRead
// 3188 
// 3189           restoreAllMetaInfoAddress = metaInfoAddress;
        STR      R11,[SP, #+8]
// 3190           status = gNVM_OK_c;
        MOVS     R0,#+0
        MOV      R9,R0
// 3191           break;
        B.N      ??NvRestoreData_6
// 3192         }                    
// 3193       }
// 3194       /* move to the previous meta info */
// 3195       metaInfoAddress -= sizeof(NVM_RecordMetaInfo_t);
??NvRestoreData_8:
        SUBS     R11,R11,#+8
        B.N      ??NvRestoreData_5
// 3196     }
// 3197 
// 3198     /* restore singular element, if any */
// 3199     if(restoreSingleRecord)
??NvRestoreData_6:
        LDRB     R0,[SP, #+12]
        CMP      R0,#+0
        BEQ.N    ??NvRestoreData_12
// 3200     {                  
// 3201       /* set the loop end address */
// 3202       if(gNvInvalidMetaInfoAddress_c == restoreAllMetaInfoAddress)
        LDR      R0,[SP, #+8]
        CMN      R0,#+1
        BNE.N    ??NvRestoreData_13
// 3203       {
// 3204 #if gNvUseExtendedFeatureSet_d
// 3205         loopEndAddress = (mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + sizeof(mNvPageCounter) +
// 3206             mNvTableSizeInFlash + (2 * sizeof(mNvTableMarker)));
// 3207 #else
// 3208         loopEndAddress = (mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + sizeof(mNvPageCounter));
        LDR.W    R0,??DataTable28
        LDR.N    R1,??DataTable16_1
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+4
        MOVS     R5,R0
        B.N      ??NvRestoreData_14
// 3209 #endif /* gNvUseExtendedFeatureSet_d */
// 3210       }
// 3211       else
// 3212       {
// 3213         loopEndAddress = restoreAllMetaInfoAddress + sizeof(NVM_RecordMetaInfo_t);
??NvRestoreData_13:
        LDR      R0,[SP, #+8]
        ADDS     R0,R0,#+8
        MOVS     R5,R0
// 3214       }
// 3215       
// 3216       for(loopCnt = elemMinIdx; loopCnt <= elemMaxIdx; loopCnt++)
??NvRestoreData_14:
        MOV      R8,R6
??NvRestoreData_15:
        UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
        UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
        CMP      R7,R8
        BCC.N    ??NvRestoreData_12
// 3217       {
// 3218     	  /* copy the meta info address */
// 3219     	  metaInfoAddress = mNvVirtualPageProperty[mNvActivePageId].NvLastMetaInfoAddress;
        LDR.W    R0,??DataTable28
        LDR.N    R1,??DataTable16_1
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+16]
        MOV      R11,R0
// 3220     	  
// 3221     	  while(metaInfoAddress >= loopEndAddress)
??NvRestoreData_16:
        CMP      R11,R5
        BCC.N    ??NvRestoreData_17
// 3222     	  {
// 3223     		  /* get the meta information */
// 3224     		  NvGetMetaInfo(mNvActivePageId, metaInfoAddress, &metaInfo);
        ADD      R2,SP,#+0
        MOV      R1,R11
        LDR.N    R0,??DataTable16_1
        LDRB     R0,[R0, #+0]
        BL       NvGetMetaInfo
// 3225     		  
// 3226     		  if(metaInfo.fields.NvValidationStartByte != metaInfo.fields.NvValidationEndByte)
        LDRB     R0,[SP, #+0]
        LDRB     R1,[SP, #+7]
        CMP      R0,R1
        BEQ.N    ??NvRestoreData_18
// 3227     		  {
// 3228     			  /* invalid meta info, move to the previous meta info */
// 3229     			  metaInfoAddress -= sizeof(NVM_RecordMetaInfo_t);
        SUBS     R11,R11,#+8
// 3230     			  continue;
        B.N      ??NvRestoreData_16
// 3231     		  }
// 3232     		  
// 3233     		  if(metaInfo.fields.NvValidationStartByte == gValidationByteAllRecords_c)
??NvRestoreData_18:
        LDRB     R0,[SP, #+0]
        CMP      R0,#+85
        BNE.N    ??NvRestoreData_19
// 3234     		  {
// 3235                   /* not a single element record, continue searching */
// 3236                   metaInfoAddress -= sizeof(NVM_RecordMetaInfo_t);
        SUBS     R11,R11,#+8
// 3237                   continue;
        B.N      ??NvRestoreData_16
// 3238     		  }
// 3239 
// 3240     		  if((metaInfo.fields.NvmDataEntryID == tblIdx->entryId) && 
// 3241     				  (loopCnt == metaInfo.fields.NvmElementIndex))
??NvRestoreData_19:
        LDRH     R0,[SP, #+1]
        LDRH     R1,[R4, #+0]
        CMP      R0,R1
        BNE.N    ??NvRestoreData_20
        LDRH     R0,[SP, #+3]
        UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
        CMP      R8,R0
        BNE.N    ??NvRestoreData_20
// 3242     		  {                                        
// 3243     			  /* restore the element */                
// 3244     			  NV_FlashRead(mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + metaInfo.fields.NvmRecordOffset, 
// 3245     					  (uint8_t*)((uint8_t*)pNVM_DataTable[tableEntryIdx].pData + 
// 3246     							  (metaInfo.fields.NvmElementIndex * pNVM_DataTable[tableEntryIdx].ElementSize)), 
// 3247     							  pNVM_DataTable[tableEntryIdx].ElementSize);
        LDR.N    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R10,R0
        LDRH     R2,[R0, #+6]
        LDR.N    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R10,R0
        LDR      R0,[R0, #+0]
        LDRH     R1,[SP, #+3]
        LDR.N    R3,??DataTable16
        LDR      R3,[R3, #+0]
        UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
        MOVS     R12,#+12
        MLA      R3,R12,R10,R3
        LDRH     R3,[R3, #+6]
        MLA      R1,R3,R1,R0
        LDR.W    R0,??DataTable28
        LDR.N    R3,??DataTable16_1
        LDRB     R3,[R3, #+0]
        MOVS     R12,#+20
        MLA      R0,R12,R3,R0
        LDR      R0,[R0, #+0]
        LDRH     R3,[SP, #+5]
        UXTAH    R0,R0,R3
        BL       NV_FlashRead
// 3248                   status = gNVM_OK_c;
        MOVS     R0,#+0
        MOV      R9,R0
// 3249                   break;
        B.N      ??NvRestoreData_17
// 3250     		  }
// 3251 
// 3252     		  /* move to the previous meta info */
// 3253     		  metaInfoAddress -= sizeof(NVM_RecordMetaInfo_t);
??NvRestoreData_20:
        SUBS     R11,R11,#+8
        B.N      ??NvRestoreData_16
// 3254     	  }    	  
// 3255       }      
??NvRestoreData_17:
        ADDS     R8,R8,#+1
        B.N      ??NvRestoreData_15
// 3256     }
// 3257 
// 3258     if(gNVM_OK_c == status)
??NvRestoreData_12:
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R9,#+0
        BNE.N    ??NvRestoreData_21
// 3259     {        
// 3260       maDatasetInfo[tableEntryIdx].saveNextInterval = FALSE;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable32
        UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
        MOVS     R2,#+6
        MLA      R1,R2,R10,R1
        STRB     R0,[R1, #+0]
// 3261       maDatasetInfo[tableEntryIdx].countsToNextSave = gNvCountsBetweenSaves_c;
        MOV      R0,#+256
        LDR.W    R1,??DataTable32
        UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
        MOVS     R2,#+6
        MLA      R1,R2,R10,R1
        STRH     R0,[R1, #+4]
// 3262     }
// 3263 
// 3264     return status;
??NvRestoreData_21:
        MOV      R0,R9
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        B.N      ??NvRestoreData_1
// 3265   }
// 3266 
// 3267   /*** restore single ***/
// 3268 
// 3269   /* parse meta info backwards until the element is found */
// 3270   while(metaInfoAddress >= (mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + sizeof(mNvPageCounter))
// 3271 #if gNvUseExtendedFeatureSet_d		  
// 3272       + mNvTableSizeInFlash + (2 * sizeof(mNvTableMarker))
// 3273 #endif /* gNvUseExtendedFeatureSet_d */
// 3274       )
??NvRestoreData_4:
        LDR.W    R0,??DataTable28
        LDR.N    R1,??DataTable16_1
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+4
        CMP      R11,R0
        BCC.W    ??NvRestoreData_22
// 3275   {
// 3276     /* get the meta information */
// 3277     NvGetMetaInfo(mNvActivePageId, metaInfoAddress, &metaInfo);
        ADD      R2,SP,#+0
        MOV      R1,R11
        LDR.N    R0,??DataTable16_1
        LDRB     R0,[R0, #+0]
        BL       NvGetMetaInfo
// 3278 
// 3279     if(metaInfo.fields.NvValidationStartByte != metaInfo.fields.NvValidationEndByte)
        LDRB     R0,[SP, #+0]
        LDRB     R1,[SP, #+7]
        CMP      R0,R1
        BEQ.N    ??NvRestoreData_23
// 3280     {
// 3281       /* invalid meta info, move to the previous meta info */
// 3282       metaInfoAddress -= sizeof(NVM_RecordMetaInfo_t);
        SUBS     R11,R11,#+8
// 3283       continue;
        B.N      ??NvRestoreData_4
// 3284     }
// 3285 
// 3286     if(metaInfo.fields.NvmDataEntryID == tblIdx->entryId)
??NvRestoreData_23:
        LDRH     R0,[SP, #+1]
        LDRH     R1,[R4, #+0]
        CMP      R0,R1
        BNE.N    ??NvRestoreData_24
// 3287     {                
// 3288       if(metaInfo.fields.NvValidationStartByte == gValidationByteSingleRecord_c)
        LDRB     R0,[SP, #+0]
        CMP      R0,#+170
        BNE.N    ??NvRestoreData_25
// 3289       {                
// 3290         /* restore the element */                
// 3291         NV_FlashRead(mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + metaInfo.fields.NvmRecordOffset, 
// 3292             (uint8_t*)((uint8_t*)pNVM_DataTable[tableEntryIdx].pData + 
// 3293                 (metaInfo.fields.NvmElementIndex * pNVM_DataTable[tableEntryIdx].ElementSize)), 
// 3294                 pNVM_DataTable[tableEntryIdx].ElementSize);
        LDR.N    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R10,R0
        LDRH     R2,[R0, #+6]
        LDR.N    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R10,R0
        LDR      R0,[R0, #+0]
        LDRH     R1,[SP, #+3]
        LDR.N    R3,??DataTable16
        LDR      R3,[R3, #+0]
        UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
        MOVS     R12,#+12
        MLA      R3,R12,R10,R3
        LDRH     R3,[R3, #+6]
        MLA      R1,R3,R1,R0
        LDR.W    R0,??DataTable28
        LDR.N    R3,??DataTable16_1
        LDRB     R3,[R3, #+0]
        MOVS     R12,#+20
        MLA      R0,R12,R3,R0
        LDR      R0,[R0, #+0]
        LDRH     R3,[SP, #+5]
        UXTAH    R0,R0,R3
        BL       NV_FlashRead
// 3295         status = gNVM_OK_c;
        MOVS     R0,#+0
        MOV      R9,R0
// 3296         break;
        B.N      ??NvRestoreData_22
// 3297       }
// 3298 
// 3299       if(metaInfo.fields.NvValidationStartByte == gValidationByteAllRecords_c)
??NvRestoreData_25:
        LDRB     R0,[SP, #+0]
        CMP      R0,#+85
        BNE.N    ??NvRestoreData_24
// 3300       {   
// 3301         /* restore the single element from the entire table entry record */
// 3302         NV_FlashRead((mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress + metaInfo.fields.NvmRecordOffset + 
// 3303             (metaInfo.fields.NvmElementIndex * pNVM_DataTable[tableEntryIdx].ElementSize)), 
// 3304             ((uint8_t*)pNVM_DataTable[tableEntryIdx].pData + (metaInfo.fields.NvmElementIndex * pNVM_DataTable[tableEntryIdx].ElementSize)),
// 3305             pNVM_DataTable[tableEntryIdx].ElementSize);
        LDR.N    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R10,R0
        LDRH     R2,[R0, #+6]
        LDR.N    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R10,R0
        LDR      R0,[R0, #+0]
        LDRH     R1,[SP, #+3]
        LDR.N    R3,??DataTable16
        LDR      R3,[R3, #+0]
        UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
        MOVS     R12,#+12
        MLA      R3,R12,R10,R3
        LDRH     R3,[R3, #+6]
        MLA      R1,R3,R1,R0
        LDR.W    R0,??DataTable28
        LDR.N    R3,??DataTable16_1
        LDRB     R3,[R3, #+0]
        MOVS     R12,#+20
        MLA      R0,R12,R3,R0
        LDR      R0,[R0, #+0]
        LDRH     R3,[SP, #+5]
        UXTAH    R0,R0,R3
        LDRH     R3,[SP, #+3]
        LDR.W    R12,??DataTable16
        LDR      R12,[R12, #+0]
        UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
        MOVS     LR,#+12
        MLA      R12,LR,R10,R12
        LDRH     R12,[R12, #+6]
        MLA      R0,R12,R3,R0
        BL       NV_FlashRead
// 3306         status = gNVM_OK_c;
        MOVS     R0,#+0
        MOV      R9,R0
// 3307         break;
        B.N      ??NvRestoreData_22
// 3308       }                    
// 3309     }
// 3310 
// 3311     /* move to the previous meta info */
// 3312     metaInfoAddress -= sizeof(NVM_RecordMetaInfo_t);
??NvRestoreData_24:
        SUBS     R11,R11,#+8
        B.N      ??NvRestoreData_4
// 3313   }
// 3314 
// 3315 
// 3316   if(gNVM_OK_c == status)
??NvRestoreData_22:
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R9,#+0
        BNE.N    ??NvRestoreData_26
// 3317   {        
// 3318     maDatasetInfo[tableEntryIdx].saveNextInterval = FALSE;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable32
        UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
        MOVS     R2,#+6
        MLA      R1,R2,R10,R1
        STRB     R0,[R1, #+0]
// 3319     maDatasetInfo[tableEntryIdx].countsToNextSave = gNvCountsBetweenSaves_c;
        MOV      R0,#+256
        LDR.W    R1,??DataTable32
        UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
        MOVS     R2,#+6
        MLA      R1,R2,R10,R1
        STRH     R0,[R1, #+4]
// 3320   }
// 3321 
// 3322   return status;
??NvRestoreData_26:
        MOV      R0,R9
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
??NvRestoreData_1:
        ADD      SP,SP,#+20
        POP      {R4-R11,PC}      ;; return
// 3323 
// 3324 #endif /* gNvUseFlexNVM_d */    
// 3325 }
// 3326 
// 3327 
// 3328 /******************************************************************************
// 3329  * Name: NvGetTableEntryIndex
// 3330  * Description: get the table entry index from the provided ID
// 3331  * Parameter(s): [IN] entryId - the ID of the table entry
// 3332  * Return: table entry index of gNvInvalidTableEntryIndex_c
// 3333  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 3334 static uint16_t NvGetTableEntryIndexFromId
// 3335 (
// 3336   NvTableEntryId_t entryId 
// 3337 )
// 3338 {
NvGetTableEntryIndexFromId:
        MOVS     R1,R0
// 3339   uint16_t loopCnt = 0;
        MOVS     R2,#+0
// 3340 
// 3341   while(gNvEndOfTableId_c != pNVM_DataTable[loopCnt].DataEntryID)
??NvGetTableEntryIndexFromId_0:
        LDR.N    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        MOVS     R3,#+12
        MLA      R0,R3,R2,R0
        LDRH     R0,[R0, #+8]
        MOVW     R3,#+65534
        CMP      R0,R3
        BEQ.N    ??NvGetTableEntryIndexFromId_1
// 3342   {
// 3343     if(pNVM_DataTable[loopCnt].DataEntryID == entryId)
        LDR.N    R0,??DataTable16
        LDR      R0,[R0, #+0]
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        MOVS     R3,#+12
        MLA      R0,R3,R2,R0
        LDRH     R0,[R0, #+8]
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        CMP      R0,R1
        BNE.N    ??NvGetTableEntryIndexFromId_2
// 3344     {
// 3345       return loopCnt;
        MOVS     R0,R2
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        B.N      ??NvGetTableEntryIndexFromId_3
// 3346     }
// 3347     /* increment the loop counter */
// 3348     loopCnt++;
??NvGetTableEntryIndexFromId_2:
        ADDS     R2,R2,#+1
        B.N      ??NvGetTableEntryIndexFromId_0
// 3349   }
// 3350   return gNvInvalidTableEntryIndex_c;
??NvGetTableEntryIndexFromId_1:
        MOVW     R0,#+65535
??NvGetTableEntryIndexFromId_3:
        BX       LR               ;; return
// 3351 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16:
        DC32     pNVM_DataTable

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_1:
        DC32     mNvActivePageId
// 3352 
// 3353 
// 3354 /******************************************************************************
// 3355  * Name: NvAddSaveRequestToQueue
// 3356  * Description: Add save request to save requests queue; if the request is 
// 3357  *              already stored, ignore the current request  
// 3358  * Parameter(s): [IN] ptrTblIdx - pointer to table index
// 3359  * Return: gNVM_OK_c - if operation completed successfully
// 3360  *         gNVM_SaveRequestRejected_c - if the request couldn't be queued         
// 3361  ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 3362 static NVM_Status_t NvAddSaveRequestToQueue
// 3363 (
// 3364   NVM_TableEntryInfo_t* ptrTblIdx
// 3365 )
// 3366 {
NvAddSaveRequestToQueue:
        PUSH     {R2-R6,LR}
        MOVS     R4,R0
// 3367   uint8_t loopIdx;  
// 3368   bool_t isQueued;
// 3369 
// 3370       
// 3371   if(mNvPendingSavesQueue.EntriesCount == 0)
        LDR.W    R0,??DataTable32_1
        LDRB     R0,[R0, #+194]
        CMP      R0,#+0
        BNE.N    ??NvAddSaveRequestToQueue_0
        ADD      R0,SP,#+0
        MOVS     R1,R4
        MOVS     R2,#+6
        BL       __aeabi_memcpy
// 3372   {
// 3373     /* add request to queue */
// 3374     if(NvPushPendingSave(&mNvPendingSavesQueue, *ptrTblIdx))
        LDRD     R0,R1,[SP, #+0]
        MOVS     R2,R1
        MOVS     R1,R0
        LDR.W    R0,??DataTable32_1
        BL       NvPushPendingSave
        CMP      R0,#+0
        BEQ.N    ??NvAddSaveRequestToQueue_1
// 3375     {        
// 3376       return gNVM_OK_c;
        MOVS     R0,#+0
        B.N      ??NvAddSaveRequestToQueue_2
// 3377     }
// 3378     return gNVM_SaveRequestRejected_c;
??NvAddSaveRequestToQueue_1:
        MOVS     R0,#+23
        B.N      ??NvAddSaveRequestToQueue_2
// 3379   }
// 3380 
// 3381   isQueued = FALSE;
??NvAddSaveRequestToQueue_0:
        MOVS     R0,#+0
        MOVS     R6,R0
// 3382   
// 3383   /* start from the queue's head */
// 3384   loopIdx = mNvPendingSavesQueue.Head;  
        LDR.W    R0,??DataTable32_1
        LDRB     R0,[R0, #+192]
        MOVS     R5,R0
// 3385   
// 3386   /* check if the request is not already stored in queue */
// 3387   while(loopIdx != mNvPendingSavesQueue.Tail)
??NvAddSaveRequestToQueue_3:
        LDR.W    R0,??DataTable32_1
        LDRB     R0,[R0, #+193]
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,R0
        BEQ.N    ??NvAddSaveRequestToQueue_4
// 3388   {
// 3389     if(ptrTblIdx->entryId == mNvPendingSavesQueue.QData[loopIdx].entryId)                
        LDRH     R0,[R4, #+0]
        LDR.W    R1,??DataTable32_1
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+6
        MLA      R1,R2,R5,R1
        LDRH     R1,[R1, #+0]
        CMP      R0,R1
        BNE.N    ??NvAddSaveRequestToQueue_5
// 3390     {   
// 3391       if(mNvPendingSavesQueue.QData[loopIdx].saveRestoreAll == TRUE) /* full table entry already queued */
        LDR.W    R0,??DataTable32_1
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+6
        MLA      R0,R1,R5,R0
        LDRB     R0,[R0, #+4]
        CMP      R0,#+1
        BNE.N    ??NvAddSaveRequestToQueue_6
// 3392       {
// 3393         /* request is already queued */
// 3394         isQueued = TRUE;
        MOVS     R0,#+1
        MOVS     R6,R0
// 3395         break;
        B.N      ??NvAddSaveRequestToQueue_4
// 3396       }
// 3397 
// 3398       /* single element from table entry is queued */
// 3399       if(ptrTblIdx->saveRestoreAll == TRUE) /* a full table entry is requested to be saved */
??NvAddSaveRequestToQueue_6:
        LDRB     R0,[R4, #+4]
        CMP      R0,#+1
        BNE.N    ??NvAddSaveRequestToQueue_7
// 3400       {
// 3401         /* update only the flag of the already queued request */
// 3402         mNvPendingSavesQueue.QData[loopIdx].saveRestoreAll = TRUE;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable32_1
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+6
        MLA      R1,R2,R5,R1
        STRB     R0,[R1, #+4]
// 3403         /* request is already queued */
// 3404         isQueued = TRUE;
        MOVS     R0,#+1
        MOVS     R6,R0
// 3405         break;
        B.N      ??NvAddSaveRequestToQueue_4
// 3406       }
// 3407 
// 3408       /* The request is for a single element and the queued request is also for a single element;
// 3409        * Check if the request is for the same element. If the request is for a different element, 
// 3410        * add the new request to queue.
// 3411        */
// 3412       if(ptrTblIdx->elementIndex == mNvPendingSavesQueue.QData[loopIdx].elementIndex)
??NvAddSaveRequestToQueue_7:
        LDRH     R0,[R4, #+2]
        LDR.W    R1,??DataTable32_1
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+6
        MLA      R1,R2,R5,R1
        LDRH     R1,[R1, #+2]
        CMP      R0,R1
        BNE.N    ??NvAddSaveRequestToQueue_8
// 3413       {
// 3414         /* request is already queued */
// 3415         isQueued = TRUE;
        MOVS     R0,#+1
        MOVS     R6,R0
// 3416         break;
        B.N      ??NvAddSaveRequestToQueue_4
// 3417       }
??NvAddSaveRequestToQueue_8:
        ADD      R0,SP,#+0
        MOVS     R1,R4
        MOVS     R2,#+6
        BL       __aeabi_memcpy
// 3418 
// 3419       /* add request to queue */
// 3420       if(NvPushPendingSave(&mNvPendingSavesQueue, *ptrTblIdx))
        LDRD     R0,R1,[SP, #+0]
        MOVS     R2,R1
        MOVS     R1,R0
        LDR.W    R0,??DataTable32_1
        BL       NvPushPendingSave
        CMP      R0,#+0
        BEQ.N    ??NvAddSaveRequestToQueue_9
// 3421       {        
// 3422         return gNVM_OK_c;
        MOVS     R0,#+0
        B.N      ??NvAddSaveRequestToQueue_2
// 3423       }                                     
// 3424       return gNVM_SaveRequestRejected_c;            
??NvAddSaveRequestToQueue_9:
        MOVS     R0,#+23
        B.N      ??NvAddSaveRequestToQueue_2
// 3425     }
// 3426     /* increment and wrap the loop index */    
// 3427     loopIdx = (loopIdx + 1)  & ((uint8_t)(gNvPendigSavesQueueSize_c - 1));
??NvAddSaveRequestToQueue_5:
        ADDS     R0,R5,#+1
        ANDS     R5,R0,#0x1F
        B.N      ??NvAddSaveRequestToQueue_3
// 3428   }
// 3429 
// 3430   if(!isQueued)
??NvAddSaveRequestToQueue_4:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BNE.N    ??NvAddSaveRequestToQueue_10
        ADD      R0,SP,#+0
        MOVS     R1,R4
        MOVS     R2,#+6
        BL       __aeabi_memcpy
// 3431   {
// 3432     /* push the request to save operation pending queue */
// 3433     if(NvPushPendingSave(&mNvPendingSavesQueue, *ptrTblIdx))
        LDRD     R0,R1,[SP, #+0]
        MOVS     R2,R1
        MOVS     R1,R0
        LDR.W    R0,??DataTable32_1
        BL       NvPushPendingSave
        CMP      R0,#+0
        BEQ.N    ??NvAddSaveRequestToQueue_11
// 3434     {        
// 3435       return gNVM_OK_c;
        MOVS     R0,#+0
        B.N      ??NvAddSaveRequestToQueue_2
// 3436     }
// 3437     return gNVM_SaveRequestRejected_c;
??NvAddSaveRequestToQueue_11:
        MOVS     R0,#+23
        B.N      ??NvAddSaveRequestToQueue_2
// 3438   }
// 3439 
// 3440   return gNVM_OK_c;
??NvAddSaveRequestToQueue_10:
        MOVS     R0,#+0
??NvAddSaveRequestToQueue_2:
        POP      {R1,R2,R4-R6,PC}  ;; return
// 3441 }
// 3442 
// 3443 /******************************************************************************
// 3444  * Name: NvIntervalTimerCallback
// 3445  * Description: Callback function of the timer used by the NvSaveOnInterval()
// 3446  * Parameter(s): [IN] timerID - timer ID
// 3447  * Return: -
// 3448  ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 3449 static void NvIntervalTimerCallback
// 3450 (
// 3451   tmrTimerID_t timerID
// 3452 )
// 3453 {
// 3454   mNvSaveOnIntervalEvent = TRUE;
NvIntervalTimerCallback:
        MOVS     R1,#+1
        LDR.W    R2,??DataTable32_2
        STRB     R1,[R2, #+0]
// 3455 }
        BX       LR               ;; return
// 3456 
// 3457 /******************************************************************************
// 3458  * Name: NvGetRandomRange
// 3459  * Description: Returns a random number between 'low' and 'high'
// 3460  * Parameter(s): [IN] low, high - generated number range
// 3461  * Return: 0..255
// 3462  ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 3463 static uint8_t NvGetRandomRange
// 3464 (
// 3465   uint8_t low, 
// 3466   uint8_t high
// 3467 )
// 3468 {
NvGetRandomRange:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
        MOVS     R5,R1
// 3469   uint32_t random;
// 3470 
// 3471   RNG_GetRandomNo(&random);
        ADD      R0,SP,#+0
        BL       RNG_GetRandomNo
// 3472 
// 3473   if(high <= low)
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R4,R5
        BCC.N    ??NvGetRandomRange_0
// 3474   {
// 3475     return low;
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        B.N      ??NvGetRandomRange_1
// 3476   }
// 3477   return low + (uint8_t)(random % (high - low + 1));    
??NvGetRandomRange_0:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        SUBS     R0,R5,R4
        ADDS     R0,R0,#+1
        LDR      R1,[SP, #+0]
        ADDS     R1,R1,R4
        LDR      R2,[SP, #+0]
        UDIV     R2,R2,R0
        MLS      R0,R0,R2,R1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
??NvGetRandomRange_1:
        POP      {R1,R4,R5,PC}    ;; return
// 3478 };
// 3479 
// 3480 #if (gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c != 0) /* FlexNVM */
// 3481 /******************************************************************************
// 3482  * Name: NvGetFlexLastMetaInfo
// 3483  * Description: Get FlexRAM last meta information address 
// 3484  * Parameter(s): -
// 3485  * Return: the address of the last valid meta information       
// 3486  ******************************************************************************/
// 3487 static uint32_t NvGetFlexLastMetaInfo
// 3488 (
// 3489   void
// 3490 )
// 3491 {
// 3492   uint32_t address, size;
// 3493   NVM_FlexMetaInfo_t flexMetaInfo;
// 3494 
// 3495   address = mNvConfig.EERAMBlockBase;
// 3496   size = mNvConfig.EEEBlockSize;
// 3497 
// 3498   while(size)
// 3499   {
// 3500     /* wait for EEPROM system to be ready */
// 3501     while(!(gNV_REG_READ(mNvConfig.ftfxRegBase + gNV_FCNFG_OFFSET_c) & gNV_FCNFG_EEERDY_c)); 
// 3502     /* read meta info tag */
// 3503     NV_FlashRead(address, (uint8_t*)&flexMetaInfo, sizeof(flexMetaInfo));
// 3504     if(flexMetaInfo.rawValue == gNvFlexGuardValue_c)
// 3505     {    
// 3506       break;
// 3507     }
// 3508     address += sizeof(flexMetaInfo);
// 3509     size -= sizeof(flexMetaInfo);
// 3510   }  
// 3511   return address - sizeof(flexMetaInfo);  
// 3512 }
// 3513 
// 3514 /******************************************************************************
// 3515  * Name: NvGetFlexMetaInfoFromId
// 3516  * Description: Get FlexRAM meta information tag from table entry ID 
// 3517  * Parameter(s): [IN] tblEntryId - table entry ID
// 3518  *               [OUT] pMetaInfo - a pointer to a memory location where the
// 3519  *                                 meta information tag will be stored
// 3520  * Return: -
// 3521  ******************************************************************************/
// 3522 static void NvGetFlexMetaInfoFromId
// 3523 (
// 3524   NvTableEntryId_t tblEntryId,
// 3525   NVM_FlexMetaInfo_t* pMetaInfo
// 3526 )
// 3527 {
// 3528   uint32_t address, size;
// 3529   NVM_FlexMetaInfo_t flexMetaInfo;
// 3530 
// 3531   address = mNvConfig.EERAMBlockBase;
// 3532   size = mNvConfig.EEEBlockSize;
// 3533 
// 3534   while(size)
// 3535   {
// 3536     /* wait for EEPROM system to be ready */
// 3537     while(!(gNV_REG_READ(mNvConfig.ftfxRegBase + gNV_FCNFG_OFFSET_c) & gNV_FCNFG_EEERDY_c));
// 3538 
// 3539     NV_FlashRead(address, (uint8_t*)&flexMetaInfo, sizeof(flexMetaInfo));
// 3540     if(flexMetaInfo.rawValue == gNvFlexGuardValue_c)
// 3541     {
// 3542       break;
// 3543     }
// 3544 
// 3545     if(flexMetaInfo.fields.NvDataEntryID == tblEntryId)
// 3546     {
// 3547       pMetaInfo->fields.NvDataEntryID = flexMetaInfo.fields.NvDataEntryID;
// 3548       pMetaInfo->fields.NvDataOffset = flexMetaInfo.fields.NvDataOffset;
// 3549       return;
// 3550     }
// 3551 
// 3552     address += sizeof(flexMetaInfo);
// 3553     size -= sizeof(flexMetaInfo);
// 3554   }
// 3555 
// 3556   pMetaInfo->rawValue = gNvFlexGuardValue_c;
// 3557 }
// 3558 
// 3559 /******************************************************************************
// 3560  * Name: NvCheckNvmTableForFlexRAMUsage
// 3561  * Description: Check if the existing NVM table fits within the FlexRAM window 
// 3562  * Parameter(s): -
// 3563  * Return: gNVM_NvTableExceedFlexRAMSize_c - the table exceed the size of
// 3564  *                                           FlexRAM window
// 3565  *         gNVM_OK_c - the table fits within the size of window FlexRAM window                                  
// 3566  ******************************************************************************/
// 3567 static NVM_Status_t NvCheckNvmTableForFlexRAMUsage
// 3568 (
// 3569   void
// 3570 )
// 3571 {
// 3572   index_t loopCnt = 0;
// 3573   uint32_t allDatasetSize = 0;    
// 3574 
// 3575   while(gNvEndOfTableId_c != pNVM_DataTable[loopCnt].DataEntryID)
// 3576   {
// 3577     if(gNvInvalidDataEntry_c == pNVM_DataTable[loopCnt].DataEntryID)
// 3578     {
// 3579       loopCnt++;
// 3580       continue;
// 3581     }  
// 3582     /* add the record size */
// 3583     allDatasetSize += (pNVM_DataTable[loopCnt].ElementsCount * pNVM_DataTable[loopCnt].ElementSize);
// 3584     /* add the meta size */
// 3585     allDatasetSize += sizeof(NVM_FlexMetaInfo_t);
// 3586     /* increment the loop counter */
// 3587     loopCnt++;
// 3588   }
// 3589 
// 3590   /* add the safe guard space (equal to meta size) */
// 3591   allDatasetSize += sizeof(NVM_FlexMetaInfo_t);
// 3592 
// 3593   if(allDatasetSize > mNvConfig.EEEBlockSize)
// 3594   {
// 3595     return gNVM_NvTableExceedFlexRAMSize_c;  
// 3596   }  
// 3597 
// 3598   return gNVM_OK_c;
// 3599 }
// 3600 
// 3601 #endif /* gNvUseFlexNVM_d */
// 3602 
// 3603 #endif /* gNvStorageIncluded_d */
// 3604 
// 3605 
// 3606 
// 3607 /*****************************************************************************
// 3608  *****************************************************************************
// 3609  * Public functions
// 3610  *****************************************************************************
// 3611  *****************************************************************************/
// 3612 
// 3613 
// 3614 /******************************************************************************
// 3615  * Name: NvModuleInit
// 3616  * Description: Initialize the NV storage module
// 3617  * Parameter(s): -
// 3618  * Return: gNVM_ModuleAlreadyInitialized_c - if the module is already 
// 3619  *                                           initialized
// 3620  *         gNVM_InvalidSectorsCount_c - if the sector count configured in the
// 3621  *                                      project linker file is invalid
// 3622  *         gNVM_MetaNotFound_c - if no meta information was found                                       
// 3623  *         gNVM_OK_c - module was successfully initialized
// 3624  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 3625 NVM_Status_t NvModuleInit
// 3626 (
// 3627   void
// 3628 )
// 3629 {
NvModuleInit:
        PUSH     {R3-R5,LR}
// 3630 #if gNvStorageIncluded_d
// 3631 
// 3632   index_t loopCnt;
// 3633 #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */
// 3634 #if gNvUseExtendedFeatureSet_d
// 3635   uint32_t pageCounterValue;
// 3636 #endif /* gNvUseExtendedFeatureSet_d */
// 3637 #endif    
// 3638   bool_t  eot = FALSE; /* end of table marker flag */
        MOVS     R5,#+0
// 3639 
// 3640   if(mNvModuleInitialized)
        LDR.W    R0,??DataTable32_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??NvModuleInit_0
// 3641   {
// 3642     return gNVM_ModuleAlreadyInitialized_c;
        MOVS     R0,#+16
        B.N      ??NvModuleInit_1
// 3643   }
// 3644 
// 3645 #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */    
// 3646   /* check linker file symbol definition for sector count; it should be multiple of 2 */
// 3647   if((uint32_t)((uint8_t*) NV_STORAGE_MAX_SECTORS) >> 1 != (uint32_t)((uint8_t*) NV_STORAGE_MAX_SECTORS) - 
// 3648       ((uint32_t)((uint8_t*) NV_STORAGE_MAX_SECTORS) >> 1))
??NvModuleInit_0:
        LDR.W    R0,??DataTable32_4
        LSRS     R0,R0,#+1
        LDR.W    R1,??DataTable32_4
        LDR.W    R2,??DataTable32_4
        SUBS     R1,R1,R2, LSR #+1
        CMP      R0,R1
        BEQ.N    ??NvModuleInit_2
// 3649   {
// 3650     return gNVM_InvalidSectorsCount_c;
        MOVS     R0,#+8
        B.N      ??NvModuleInit_1
// 3651   }
// 3652 #endif
// 3653 
// 3654 /* check the RAM table to have 'End-Of-Table' terminator */
// 3655   for(loopCnt = 0; loopCnt < (index_t)gNvTableEntriesCountMax_c; loopCnt++)
??NvModuleInit_2:
        MOVS     R0,#+0
        MOVS     R4,R0
??NvModuleInit_3:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+32
        BGE.N    ??NvModuleInit_4
// 3656   {
// 3657     if((NULL == pNVM_DataTable[loopCnt].pData) && (gNvEndOfTableId_c == pNVM_DataTable[loopCnt].DataEntryID))
        LDR.N    R0,??DataTable24
        LDR      R0,[R0, #+0]
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+12
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??NvModuleInit_5
        LDR.N    R0,??DataTable24
        LDR      R0,[R0, #+0]
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+12
        MLA      R0,R1,R4,R0
        LDRH     R0,[R0, #+8]
        MOVW     R1,#+65534
        CMP      R0,R1
        BNE.N    ??NvModuleInit_5
// 3658     {
// 3659       eot = TRUE;
        MOVS     R0,#+1
        MOVS     R5,R0
// 3660       break;
        B.N      ??NvModuleInit_4
// 3661     }
// 3662   }    
??NvModuleInit_5:
        ADDS     R4,R4,#+1
        B.N      ??NvModuleInit_3
// 3663   if(!eot)
??NvModuleInit_4:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BNE.N    ??NvModuleInit_6
// 3664   {
// 3665     return gNVM_MissingEndOfTableMarker_c;
        MOVS     R0,#+25
        B.N      ??NvModuleInit_1
// 3666   }
// 3667 
// 3668 #if (gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c != 0) /* FlexNVM */    
// 3669   /* check if the NVM table fits within the size of the FlexRAM window */
// 3670   if(gNVM_OK_c != NvCheckNvmTableForFlexRAMUsage())
// 3671   {
// 3672     return gNVM_NvTableExceedFlexRAMSize_c;
// 3673   }    
// 3674 #endif /* FlexNVM */
// 3675 
// 3676 #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */    
// 3677   /* avoid compiler warnings, only sizeof(mNvTableMarker) is required in this code */
// 3678 #if gNvUseExtendedFeatureSet_d
// 3679   (void)mNvTableMarker;
// 3680 #endif /* gNvUseExtendedFeatureSet_d */
// 3681 #endif /* no FlexNVM */
// 3682 
// 3683   /* Initialize flash HAL driver */
// 3684   NV_FlashInit(&mNvConfig);
??NvModuleInit_6:
        LDR.N    R0,??DataTable21
        BL       NV_FlashInit
// 3685 
// 3686 #if (gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c != 0)  /* FlexNVM */
// 3687 
// 3688   /* check data flash IFR map */
// 3689   if(mNvConfig.EEEBlockSize == 0)
// 3690   {
// 3691     return gNVM_NvWrongFlashDataIFRMap_c;
// 3692   }
// 3693 
// 3694   /* Enable the EERAM */
// 3695   NV_SetEEEEnable(&mNvConfig, gNV_FLEXRAM_FNC_CTRL_CODE);
// 3696 
// 3697 #else /* no FlexNVM */   
// 3698 
// 3699   /* Initialize the active page ID */
// 3700   mNvActivePageId = gVirtualPageNone_c;
        MOVS     R0,#+2
        LDR.W    R1,??DataTable32_5
        STRB     R0,[R1, #+0]
// 3701 
// 3702   /* First virtual page initialisation */
// 3703   mNvVirtualPageProperty[gFirstVirtualPage_c].NvRawSectorStartAddress = (uint32_t)((uint8_t*)NV_STORAGE_END_ADDRESS);
        LDR.W    R0,??DataTable32_6
        LDR.W    R1,??DataTable28
        STR      R0,[R1, #+0]
// 3704   mNvVirtualPageProperty[gFirstVirtualPage_c].NvRawSectorsCount = (uint32_t)((uint8_t*) NV_STORAGE_MAX_SECTORS) >> 1;
        LDR.W    R0,??DataTable32_4
        LSRS     R0,R0,#+1
        LDR.W    R1,??DataTable28
        STRB     R0,[R1, #+8]
// 3705   mNvVirtualPageProperty[gFirstVirtualPage_c].NvTotalPageSize = mNvVirtualPageProperty[gFirstVirtualPage_c].NvRawSectorsCount * 
// 3706       (uint32_t)((uint8_t*)NV_STORAGE_SECTOR_SIZE);
        LDR.W    R0,??DataTable28
        LDRB     R0,[R0, #+8]
        LDR.W    R1,??DataTable32_7
        MULS     R0,R1,R0
        LDR.W    R1,??DataTable28
        STR      R0,[R1, #+12]
// 3707   mNvVirtualPageProperty[gFirstVirtualPage_c].NvRawSectorEndAddress = mNvVirtualPageProperty[gFirstVirtualPage_c].NvRawSectorStartAddress + 
// 3708       mNvVirtualPageProperty[gFirstVirtualPage_c].NvTotalPageSize - 1;
        LDR.W    R0,??DataTable28
        LDR      R0,[R0, #+0]
        LDR.W    R1,??DataTable28
        LDR      R1,[R1, #+12]
        ADDS     R0,R1,R0
        SUBS     R0,R0,#+1
        LDR.W    R1,??DataTable28
        STR      R0,[R1, #+4]
// 3709 
// 3710   /* Second virtual page initialisation */
// 3711   mNvVirtualPageProperty[gSecondVirtualPage_c].NvRawSectorStartAddress = mNvVirtualPageProperty[gFirstVirtualPage_c].NvRawSectorEndAddress + 1;
        LDR.W    R0,??DataTable28
        LDR      R0,[R0, #+4]
        ADDS     R0,R0,#+1
        LDR.W    R1,??DataTable28
        STR      R0,[R1, #+20]
// 3712   mNvVirtualPageProperty[gSecondVirtualPage_c].NvRawSectorsCount = (uint32_t)((uint8_t*) NV_STORAGE_MAX_SECTORS) >> 1;
        LDR.W    R0,??DataTable32_4
        LSRS     R0,R0,#+1
        LDR.W    R1,??DataTable28
        STRB     R0,[R1, #+28]
// 3713   mNvVirtualPageProperty[gSecondVirtualPage_c].NvTotalPageSize = mNvVirtualPageProperty[gSecondVirtualPage_c].NvRawSectorsCount * 
// 3714       (uint32_t)((uint8_t*)NV_STORAGE_SECTOR_SIZE);
        LDR.W    R0,??DataTable28
        LDRB     R0,[R0, #+28]
        LDR.W    R1,??DataTable32_7
        MULS     R0,R1,R0
        LDR.W    R1,??DataTable28
        STR      R0,[R1, #+32]
// 3715   mNvVirtualPageProperty[gSecondVirtualPage_c].NvRawSectorEndAddress = mNvVirtualPageProperty[gSecondVirtualPage_c].NvRawSectorStartAddress + 
// 3716       mNvVirtualPageProperty[gSecondVirtualPage_c].NvTotalPageSize - 1;
        LDR.W    R0,??DataTable28
        LDR      R0,[R0, #+20]
        LDR.W    R1,??DataTable28
        LDR      R1,[R1, #+32]
        ADDS     R0,R1,R0
        SUBS     R0,R0,#+1
        LDR.W    R1,??DataTable28
        STR      R0,[R1, #+24]
// 3717 
// 3718   /* no pending erase operations on system initialisation */
// 3719   mNvErasePgCmdStatus.NvErasePending = FALSE;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable32_8
        STRB     R0,[R1, #+0]
// 3720 
// 3721   /* at init, no table entries are to be skipped when copy */
// 3722 #if gNvUseExtendedFeatureSet_d  
// 3723   mNvSkipTableEntryId = gNvCopyAll_c;
// 3724 #endif /* #if gNvUseExtendedFeatureSet_d */
// 3725 
// 3726   /* Initialize the storage system: get active page and page counter */
// 3727   NvInitStorageSystem();
        BL       NvInitStorageSystem
// 3728 
// 3729 #endif
// 3730 
// 3731   /* Initialize the pending saves queue */
// 3732   NvInitPendingSavesQueue(&mNvPendingSavesQueue);
        LDR.W    R0,??DataTable32_1
        BL       NvInitPendingSavesQueue
// 3733 
// 3734   /* Initialize the data set info table */
// 3735   for(loopCnt = 0; loopCnt < (index_t)gNvTableEntriesCountMax_c; loopCnt++)
        MOVS     R0,#+0
        MOVS     R4,R0
??NvModuleInit_7:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+32
        BGE.N    ??NvModuleInit_8
// 3736   {      
// 3737     maDatasetInfo[loopCnt].saveNextInterval = FALSE;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable32
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+6
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+0]
// 3738     maDatasetInfo[loopCnt].countsToNextSave = gNvCountsBetweenSaves;
        LDR.W    R0,??DataTable32_9
        LDRH     R0,[R0, #+0]
        LDR.W    R1,??DataTable32
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+6
        MLA      R1,R2,R4,R1
        STRH     R0,[R1, #+4]
// 3739   }
        ADDS     R4,R4,#+1
        B.N      ??NvModuleInit_7
// 3740 
// 3741   /* initialize the event used by save-on-interval functionality */
// 3742   mNvSaveOnIntervalEvent = FALSE;
??NvModuleInit_8:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable32_2
        STRB     R0,[R1, #+0]
// 3743 
// 3744   /* initialize the timer used by the save-on-interval functionality */
// 3745   mNvSaveOnIntervalTimerID = gTmrInvalidTimerID_c; 
        MOVS     R0,#+255
        LDR.W    R1,??DataTable32_10
        STRB     R0,[R1, #+0]
// 3746 
// 3747 #if (gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c != 0) /* FlexNVM */
// 3748 
// 3749   /* NVM module is now initialized */
// 3750   mNvModuleInitialized = TRUE;
// 3751   return gNVM_OK_c;
// 3752 
// 3753 #else /* no FlexNVM */
// 3754 
// 3755 #if gNvUseExtendedFeatureSet_d  
// 3756   /* get the size of the NV table stored in RAM memory */
// 3757   mNvTableSizeInRAM = NvGetTableSize(gRAMTable_c);
// 3758   /* get the size of the NV table stored in FLASH memory */
// 3759   mNvTableSizeInFlash = NvGetTableSize(gFLASHTable_c);
// 3760 
// 3761   if(0 == mNvTableSizeInFlash) /* no NV table found in FLASH, format the system */
// 3762   {
// 3763     NV_FlashRead(mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress,
// 3764         (uint8_t*)&pageCounterValue, sizeof(pageCounterValue));
// 3765     NvInternalFormat(pageCounterValue); /* will also save the NV table to FLASH memory */
// 3766   }
// 3767   else /* found an valid NV table in FLASH memory */
// 3768   {
// 3769     mNvTableUpdated = FALSE;
// 3770 
// 3771     /* check if the RAM table was updated (e.g. new binary image via OTAP) */
// 3772     if((mNvTableUpdated = NvIsRamTableUpdated()) == TRUE)
// 3773     {
// 3774       if(gNV_OK_c == NvGetLastMetaInfoAddress())
// 3775       {       
// 3776         /* copy the new RAM table and the page content */    	  
// 3777         (void)NvCopyPage(gNvCopyAll_c);
// 3778         /* NVM module is now initialised */
// 3779         mNvModuleInitialized = TRUE;          
// 3780         return gNVM_OK_c;
// 3781       }
// 3782 
// 3783       /* format the system */
// 3784       if(gNVM_OK_c == NvInternalFormat(0))
// 3785       {     
// 3786         if(gNV_OK_c == NvGetLastMetaInfoAddress())
// 3787         {       
// 3788           /* NVM module is now initialised */
// 3789           mNvModuleInitialized = TRUE;
// 3790           return gNVM_OK_c;
// 3791         }
// 3792       }
// 3793       return gNVM_FormatFailure_c;
// 3794     }      
// 3795   }
// 3796 #endif /* gNvUseExtendedFeatureSet_d */
// 3797 
// 3798   /* get the last meta information address */
// 3799   if(gNV_OK_c == NvGetLastMetaInfoAddress())
        BL       NvGetLastMetaInfoAddress
        CMP      R0,#+0
        BNE.N    ??NvModuleInit_9
// 3800   {       
// 3801     /* NVM module is now initialized */
// 3802     mNvModuleInitialized = TRUE;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable32_3
        STRB     R0,[R1, #+0]
// 3803     return gNVM_OK_c;
        MOVS     R0,#+0
        B.N      ??NvModuleInit_1
// 3804   }
// 3805 
// 3806   /* format the system */
// 3807   if(gNVM_OK_c == NvInternalFormat(0))
??NvModuleInit_9:
        MOVS     R0,#+0
        BL       NvInternalFormat
        CMP      R0,#+0
        BNE.N    ??NvModuleInit_10
// 3808   {     
// 3809     if(gNV_OK_c == NvGetLastMetaInfoAddress())
        BL       NvGetLastMetaInfoAddress
        CMP      R0,#+0
        BNE.N    ??NvModuleInit_10
// 3810     {       
// 3811       /* NVM module is now initialised */
// 3812       mNvModuleInitialized = TRUE;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable32_3
        STRB     R0,[R1, #+0]
// 3813       return gNVM_OK_c;
        MOVS     R0,#+0
        B.N      ??NvModuleInit_1
// 3814     }
// 3815   }
// 3816 
// 3817   return gNVM_FormatFailure_c;
??NvModuleInit_10:
        MOVS     R0,#+19
??NvModuleInit_1:
        POP      {R1,R4,R5,PC}    ;; return
// 3818 
// 3819 #endif /* no FlexNVM */
// 3820 
// 3821 #else
// 3822   return gNVM_Error_c;
// 3823 #endif /* #if gNvStorageIncluded_d */
// 3824 
// 3825 }
// 3826 
// 3827 
// 3828 /******************************************************************************
// 3829  * Name: NvSaveOnIdle
// 3830  * Description: Save the data pointed by ptrData on the next call to NvIdle()
// 3831  * Parameter(s): [IN] ptrData - pointer to data to be saved
// 3832  *               [IN] saveRestoreAll - specify if all the elements from the NVM table
// 3833  *                              entry shall be saved
// 3834  * Return: gNVM_OK_c - if operation completed successfully
// 3835  *         gNVM_Error_c - in case of error(s)
// 3836  *         Note: see also return codes of NvGetEntryFromDataPtr() function         
// 3837  ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 3838 NVM_Status_t NvSaveOnIdle
// 3839 (
// 3840   void* ptrData,
// 3841   bool_t saveAll
// 3842 )
// 3843 {    
NvSaveOnIdle:
        PUSH     {R2-R6,LR}
        MOVS     R4,R0
        MOVS     R5,R1
// 3844 #if gNvStorageIncluded_d    
// 3845   NVM_Status_t status;
// 3846   NVM_TableEntryInfo_t tblIdx;
// 3847 
// 3848   if(!mNvModuleInitialized)
        LDR.W    R0,??DataTable32_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??NvSaveOnIdle_0
// 3849   {
// 3850     return gNVM_ModuleNotInitialized_c;
        MOVS     R0,#+14
        B.N      ??NvSaveOnIdle_1
// 3851   }
// 3852 
// 3853   if(NULL == ptrData)
??NvSaveOnIdle_0:
        CMP      R4,#+0
        BNE.N    ??NvSaveOnIdle_2
// 3854   {
// 3855     return gNVM_NullPointer_c;
        MOVS     R0,#+5
        B.N      ??NvSaveOnIdle_1
// 3856   }
// 3857 
// 3858   /* get the NVM table entry */
// 3859   if((status = NvGetEntryFromDataPtr(ptrData, &tblIdx)) != gNVM_OK_c)
??NvSaveOnIdle_2:
        ADD      R1,SP,#+0
        MOVS     R0,R4
        BL       NvGetEntryFromDataPtr
        MOVS     R6,R0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BEQ.N    ??NvSaveOnIdle_3
// 3860   {
// 3861     return status;
        MOVS     R0,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        B.N      ??NvSaveOnIdle_1
// 3862   }
// 3863 
// 3864   if(gNvInvalidDataEntry_c == tblIdx.entryId)
??NvSaveOnIdle_3:
        LDRH     R0,[SP, #+0]
        MOVW     R1,#+65535
        CMP      R0,R1
        BNE.N    ??NvSaveOnIdle_4
// 3865   {
// 3866     return gNVM_InvalidTableEntry_c;
        MOVS     R0,#+9
        B.N      ??NvSaveOnIdle_1
// 3867   }
// 3868 
// 3869   /* write the save all flag */
// 3870 #if gNvFragmentation_Enabled_d    
// 3871   tblIdx.saveRestoreAll = saveAll;
// 3872 #else
// 3873   tblIdx.saveRestoreAll = TRUE;
??NvSaveOnIdle_4:
        MOVS     R0,#+1
        STRB     R0,[SP, #+4]
// 3874 #endif /* gNvFragmentation_Enabled_d */
// 3875 
// 3876   return NvAddSaveRequestToQueue(&tblIdx);
        ADD      R0,SP,#+0
        BL       NvAddSaveRequestToQueue
??NvSaveOnIdle_1:
        POP      {R1,R2,R4-R6,PC}  ;; return
// 3877 
// 3878 #else
// 3879   (void)ptrData;
// 3880   (void)saveAll;
// 3881   return gNVM_Error_c;
// 3882 #endif /* # gNvStorageIncluded_d */
// 3883 }
// 3884 
// 3885 /******************************************************************************
// 3886  * Name: NvSaveOnInterval
// 3887  * Description:  save no more often than a given time interval. If it has 
// 3888  *               been at least that long since the last save,
// 3889  *               this function will cause a save the next time the idle 
// 3890  *               task runs.
// 3891  * Parameters: [IN] ptrData - pointer to data to be saved
// 3892  * NOTE: this function saves all the element of the table entry pointed by
// 3893  *       ptrData 
// 3894  * Return: NVM_OK_c - if operation completed successfully
// 3895  *         Note: see also return codes of NvGetEntryFromDataPtr() function 
// 3896  ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 3897 NVM_Status_t NvSaveOnInterval
// 3898 (
// 3899   void* ptrData
// 3900 )
// 3901 {
NvSaveOnInterval:
        PUSH     {R2-R6,LR}
        MOVS     R4,R0
// 3902 #if gNvStorageIncluded_d
// 3903 
// 3904   NVM_Status_t status;
// 3905   NVM_TableEntryInfo_t tblIdx;
// 3906   uint16_t tableEntryIdx;
// 3907 
// 3908   if(!mNvModuleInitialized)
        LDR.W    R0,??DataTable32_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??NvSaveOnInterval_0
// 3909   {
// 3910     return gNVM_ModuleNotInitialized_c;
        MOVS     R0,#+14
        B.N      ??NvSaveOnInterval_1
// 3911   }
// 3912 
// 3913   if(NULL == ptrData)
??NvSaveOnInterval_0:
        CMP      R4,#+0
        BNE.N    ??NvSaveOnInterval_2
// 3914   {
// 3915     return gNVM_NullPointer_c;
        MOVS     R0,#+5
        B.N      ??NvSaveOnInterval_1
// 3916   }
// 3917 
// 3918   if(gTmrInvalidTimerID_c == mNvSaveOnIntervalTimerID)
??NvSaveOnInterval_2:
        LDR.W    R0,??DataTable32_10
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??NvSaveOnInterval_3
// 3919   {
// 3920     /* try to allocate the timer used by the save-on-interval functionality */      
// 3921     mNvSaveOnIntervalTimerID = TMR_AllocateTimer();
        BL       TMR_AllocateTimer
        LDR.W    R1,??DataTable32_10
        STRB     R0,[R1, #+0]
// 3922 
// 3923     if(gTmrInvalidTimerID_c == mNvSaveOnIntervalTimerID)
        LDR.W    R0,??DataTable32_10
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??NvSaveOnInterval_3
// 3924     {
// 3925       return gNVM_InvalidTimerID_c;
        MOVS     R0,#+24
        B.N      ??NvSaveOnInterval_1
// 3926     }
// 3927   }
// 3928 
// 3929   /* get the NVM table entry */
// 3930   if((status = NvGetEntryFromDataPtr(ptrData, &tblIdx)) != gNVM_OK_c)
??NvSaveOnInterval_3:
        ADD      R1,SP,#+0
        MOVS     R0,R4
        BL       NvGetEntryFromDataPtr
        MOVS     R5,R0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BEQ.N    ??NvSaveOnInterval_4
// 3931   {
// 3932     return status;
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        B.N      ??NvSaveOnInterval_1
// 3933   }
// 3934 
// 3935   if(gNvInvalidDataEntry_c == tblIdx.entryId)
??NvSaveOnInterval_4:
        LDRH     R0,[SP, #+0]
        MOVW     R1,#+65535
        CMP      R0,R1
        BNE.N    ??NvSaveOnInterval_5
// 3936   {
// 3937     return gNVM_InvalidTableEntry_c;
        MOVS     R0,#+9
        B.N      ??NvSaveOnInterval_1
// 3938   }
// 3939 
// 3940   tableEntryIdx = NvGetTableEntryIndexFromId(tblIdx.entryId);
??NvSaveOnInterval_5:
        LDRH     R0,[SP, #+0]
        BL       NvGetTableEntryIndexFromId
        MOVS     R6,R0
// 3941 
// 3942   if(gNvInvalidTableEntryIndex_c == tableEntryIdx)
        UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
        MOVW     R0,#+65535
        CMP      R6,R0
        BNE.N    ??NvSaveOnInterval_6
// 3943   {
// 3944     return gNVM_InvalidTableEntry_c;
        MOVS     R0,#+9
        B.N      ??NvSaveOnInterval_1
// 3945   }
// 3946 
// 3947   if(maDatasetInfo[tableEntryIdx].saveNextInterval == FALSE)
??NvSaveOnInterval_6:
        LDR.W    R0,??DataTable32
        UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
        MOVS     R1,#+6
        MLA      R0,R1,R6,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??NvSaveOnInterval_7
// 3948   {
// 3949     maDatasetInfo[tableEntryIdx].ticksToNextSave = gNvMinimumTicksBetweenSaves;
        LDR.W    R0,??DataTable32_11
        LDRH     R0,[R0, #+0]
        LDR.W    R1,??DataTable32
        UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
        MOVS     R2,#+6
        MLA      R1,R2,R6,R1
        STRH     R0,[R1, #+2]
// 3950     maDatasetInfo[tableEntryIdx].saveNextInterval = TRUE;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable32
        UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
        MOVS     R2,#+6
        MLA      R1,R2,R6,R1
        STRB     R0,[R1, #+0]
// 3951     mNvSaveOnIntervalEvent = TRUE;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable32_2
        STRB     R0,[R1, #+0]
// 3952   }
// 3953 
// 3954   return status;
??NvSaveOnInterval_7:
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
??NvSaveOnInterval_1:
        POP      {R1,R2,R4-R6,PC}  ;; return
// 3955 #else    
// 3956   (void)ptrData;
// 3957   return gNVM_Error_c;
// 3958 #endif
// 3959 }                                       /* NvSaveOnInterval() */

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable21:
        DC32     mNvConfig
// 3960 
// 3961 
// 3962 /******************************************************************************
// 3963  * Name: NvSaveOnCount
// 3964  * Description: Decrement the counter. Once it reaches 0, the next call to 
// 3965  *              NvIdle() will save the entire table entry (all elements).
// 3966  * Parameters: [IN] ptrData - pointer to data to be saved
// 3967  * Return: NVM_OK_c - if operation completed successfully
// 3968  *         Note: see also return codes of NvGetEntryFromDataPtr() function 
// 3969  ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 3970 NVM_Status_t NvSaveOnCount
// 3971 (
// 3972   void* ptrData
// 3973 )
// 3974 {
NvSaveOnCount:
        PUSH     {R2-R6,LR}
        MOVS     R4,R0
// 3975 #if gNvStorageIncluded_d
// 3976 
// 3977   NVM_Status_t status;
// 3978   NVM_TableEntryInfo_t tblIdx;
// 3979   uint16_t tableEntryIdx;
// 3980 
// 3981   if(!mNvModuleInitialized)
        LDR.W    R0,??DataTable32_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??NvSaveOnCount_0
// 3982   {
// 3983     return gNVM_ModuleNotInitialized_c;
        MOVS     R0,#+14
        B.N      ??NvSaveOnCount_1
// 3984   }
// 3985 
// 3986   if(NULL == ptrData)
??NvSaveOnCount_0:
        CMP      R4,#+0
        BNE.N    ??NvSaveOnCount_2
// 3987   {
// 3988     return gNVM_NullPointer_c;
        MOVS     R0,#+5
        B.N      ??NvSaveOnCount_1
// 3989   }
// 3990 
// 3991   /* get the NVM table entry */
// 3992   if((status = NvGetEntryFromDataPtr(ptrData, &tblIdx)) != gNVM_OK_c)
??NvSaveOnCount_2:
        ADD      R1,SP,#+0
        MOVS     R0,R4
        BL       NvGetEntryFromDataPtr
        MOVS     R6,R0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BEQ.N    ??NvSaveOnCount_3
// 3993   {
// 3994     return status;
        MOVS     R0,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        B.N      ??NvSaveOnCount_1
// 3995   }
// 3996 
// 3997   if(gNvInvalidDataEntry_c == tblIdx.entryId)
??NvSaveOnCount_3:
        LDRH     R0,[SP, #+0]
        MOVW     R1,#+65535
        CMP      R0,R1
        BNE.N    ??NvSaveOnCount_4
// 3998   {
// 3999     return gNVM_InvalidTableEntry_c;
        MOVS     R0,#+9
        B.N      ??NvSaveOnCount_1
// 4000   }
// 4001 
// 4002   tableEntryIdx = NvGetTableEntryIndexFromId(tblIdx.entryId);
??NvSaveOnCount_4:
        LDRH     R0,[SP, #+0]
        BL       NvGetTableEntryIndexFromId
        MOVS     R5,R0
// 4003 
// 4004   if(gNvInvalidTableEntryIndex_c == tableEntryIdx)
        UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
        MOVW     R0,#+65535
        CMP      R5,R0
        BNE.N    ??NvSaveOnCount_5
// 4005   {
// 4006     return gNVM_InvalidTableEntry_c;
        MOVS     R0,#+9
        B.N      ??NvSaveOnCount_1
// 4007   }
// 4008 
// 4009   if(maDatasetInfo[tableEntryIdx].countsToNextSave)
??NvSaveOnCount_5:
        LDR.W    R0,??DataTable32
        UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
        MOVS     R1,#+6
        MLA      R0,R1,R5,R0
        LDRH     R0,[R0, #+4]
        CMP      R0,#+0
        BEQ.N    ??NvSaveOnCount_6
// 4010   {
// 4011     --maDatasetInfo[tableEntryIdx].countsToNextSave;
        LDR.W    R0,??DataTable32
        UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
        MOVS     R1,#+6
        MLA      R0,R1,R5,R0
        LDRH     R0,[R0, #+4]
        SUBS     R0,R0,#+1
        LDR.W    R1,??DataTable32
        UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
        MOVS     R2,#+6
        MLA      R1,R2,R5,R1
        STRH     R0,[R1, #+4]
        B.N      ??NvSaveOnCount_7
// 4012   }
// 4013   else
// 4014   {
// 4015     /* all the elements of the NVM table entry will be saved */
// 4016     tblIdx.saveRestoreAll = TRUE;
??NvSaveOnCount_6:
        MOVS     R0,#+1
        STRB     R0,[SP, #+4]
// 4017 
// 4018     status = NvAddSaveRequestToQueue(&tblIdx);        
        ADD      R0,SP,#+0
        BL       NvAddSaveRequestToQueue
        MOVS     R6,R0
// 4019   }
// 4020 
// 4021   return status;
??NvSaveOnCount_7:
        MOVS     R0,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
??NvSaveOnCount_1:
        POP      {R1,R2,R4-R6,PC}  ;; return
// 4022 
// 4023 #else    
// 4024   (void)ptrData;
// 4025   return gNVM_Error_c;
// 4026 #endif
// 4027 }                                       /* NvSaveOnCount() */
// 4028 
// 4029 
// 4030 /******************************************************************************
// 4031  * Name: NvSetMinimumTicksBetweenSaves
// 4032  * Description: Set the timer used by NvSaveOnInterval(). Takes effect after 
// 4033  *              the next save.
// 4034  * Parameters: [IN] newInterval - new time interval
// 4035  * Return: - 
// 4036  ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 4037 void NvSetMinimumTicksBetweenSaves
// 4038 (
// 4039   NvSaveInterval_t newInterval
// 4040 )
// 4041 {
// 4042 #if gNvStorageIncluded_d
// 4043   gNvMinimumTicksBetweenSaves = newInterval;
NvSetMinimumTicksBetweenSaves:
        LDR.W    R1,??DataTable32_11
        STRH     R0,[R1, #+0]
// 4044 #else
// 4045   (void)newInterval;
// 4046 #endif
// 4047 }                                       /* NvSetMinimumTicksBetweenSaves() */
        BX       LR               ;; return
// 4048 
// 4049 
// 4050 /******************************************************************************
// 4051  * Name: NvSetCountsBetweenSaves
// 4052  * Description: Set the counter trigger value used by NvSaveOnCount().
// 4053  *              Takes effect after the next save.
// 4054  * Parameters: [IN] newCounter - new counter value
// 4055  * Return: - 
// 4056  ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 4057 void NvSetCountsBetweenSaves
// 4058 (
// 4059   NvSaveCounter_t newCounter
// 4060 )
// 4061 {
// 4062 #if gNvStorageIncluded_d    
// 4063   gNvCountsBetweenSaves = newCounter;    
NvSetCountsBetweenSaves:
        LDR.W    R1,??DataTable32_9
        STRH     R0,[R1, #+0]
// 4064 #else
// 4065   (void)newCounter;
// 4066 #endif
// 4067 }                                       /* NvSetCountsBetweenSaves() */
        BX       LR               ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable24:
        DC32     pNVM_DataTable
// 4068 
// 4069 
// 4070 /******************************************************************************
// 4071  * Name: NvTimerTick
// 4072  * Description: Called from the idle task to process save-on-interval requests
// 4073  * Parameters: [IN] countTick - enable/disable tick count
// 4074  * Return: FALSE if the timer tick counters for all data sets have reached 
// 4075  *         zero. In this case, the timer can be turned off.
// 4076  *         TRUE if any of the data sets' timer tick counters have not yet
// 4077  *         counted down to zero. In this case, the timer should be active
// 4078  ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 4079 bool_t NvTimerTick
// 4080 (
// 4081   bool_t countTick
// 4082 )
// 4083 {
NvTimerTick:
        PUSH     {R2-R6,LR}
        MOVS     R4,R0
// 4084 #if gNvStorageIncluded_d
// 4085 
// 4086   bool_t fTicksLeft;                
// 4087   NVM_TableEntryInfo_t tblIdx;
// 4088   uint16_t idx;
// 4089 
// 4090   if(!mNvModuleInitialized)
        LDR.W    R0,??DataTable32_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??NvTimerTick_0
// 4091   {
// 4092     return gNVM_ModuleNotInitialized_c;
        MOVS     R0,#+14
        B.N      ??NvTimerTick_1
// 4093   }
// 4094 
// 4095   idx = 0;
??NvTimerTick_0:
        MOVS     R0,#+0
        MOVS     R6,R0
// 4096   fTicksLeft = FALSE;
        MOVS     R0,#+0
        MOVS     R5,R0
// 4097 
// 4098   if(countTick) 
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+0
        BEQ.W    ??NvTimerTick_2
// 4099   {
// 4100     while(gNvEndOfTableId_c != pNVM_DataTable[idx].DataEntryID)
??NvTimerTick_3:
        LDR.W    R0,??DataTable32_12
        LDR      R0,[R0, #+0]
        UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R6,R0
        LDRH     R0,[R0, #+8]
        MOVW     R1,#+65534
        CMP      R0,R1
        BEQ.N    ??NvTimerTick_2
// 4101     {
// 4102       if(maDatasetInfo[idx].ticksToNextSave)
        LDR.W    R0,??DataTable32
        UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
        MOVS     R1,#+6
        MLA      R0,R1,R6,R0
        LDRH     R0,[R0, #+2]
        CMP      R0,#+0
        BEQ.N    ??NvTimerTick_4
// 4103       {
// 4104         --maDatasetInfo[idx].ticksToNextSave;
        LDR.W    R0,??DataTable32
        UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
        MOVS     R1,#+6
        MLA      R0,R1,R6,R0
        LDRH     R0,[R0, #+2]
        SUBS     R0,R0,#+1
        LDR.W    R1,??DataTable32
        UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
        MOVS     R2,#+6
        MLA      R1,R2,R6,R1
        STRH     R0,[R1, #+2]
// 4105       }
// 4106 
// 4107       if(maDatasetInfo[idx].ticksToNextSave)
??NvTimerTick_4:
        LDR.W    R0,??DataTable32
        UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
        MOVS     R1,#+6
        MLA      R0,R1,R6,R0
        LDRH     R0,[R0, #+2]
        CMP      R0,#+0
        BEQ.N    ??NvTimerTick_5
// 4108       {
// 4109         fTicksLeft = TRUE;
        MOVS     R0,#+1
        MOVS     R5,R0
// 4110       }
// 4111 
// 4112       if(maDatasetInfo[idx].saveNextInterval && !maDatasetInfo[idx].ticksToNextSave)
??NvTimerTick_5:
        LDR.W    R0,??DataTable32
        UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
        MOVS     R1,#+6
        MLA      R0,R1,R6,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??NvTimerTick_6
        LDR.W    R0,??DataTable32
        UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
        MOVS     R1,#+6
        MLA      R0,R1,R6,R0
        LDRH     R0,[R0, #+2]
        CMP      R0,#+0
        BNE.N    ??NvTimerTick_6
// 4113       {
// 4114         if(!mNvCriticalSectionFlag)
        LDR.W    R0,??DataTable32_13
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??NvTimerTick_7
// 4115         {
// 4116           tblIdx.entryId = pNVM_DataTable[idx].DataEntryID;
        LDR.W    R0,??DataTable32_12
        LDR      R0,[R0, #+0]
        UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R6,R0
        LDRH     R0,[R0, #+8]
        STRH     R0,[SP, #+0]
// 4117           tblIdx.elementIndex = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+2]
// 4118           tblIdx.saveRestoreAll = TRUE;
        MOVS     R0,#+1
        STRB     R0,[SP, #+4]
// 4119 #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */
// 4120           if(NvWriteRecord(&tblIdx) == gNVM_PageCopyPending_c)
        ADD      R0,SP,#+0
        BL       NvWriteRecord
        CMP      R0,#+17
        BNE.N    ??NvTimerTick_8
// 4121           {
// 4122             NvAddSaveRequestToQueue(&tblIdx);
        ADD      R0,SP,#+0
        BL       NvAddSaveRequestToQueue
// 4123           }                                                   
// 4124 #else /* FlexNVM */
// 4125           NvWriteRecord(&tblIdx);
// 4126 #endif
// 4127           maDatasetInfo[idx].saveNextInterval = FALSE;
??NvTimerTick_8:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable32
        UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
        MOVS     R2,#+6
        MLA      R1,R2,R6,R1
        STRB     R0,[R1, #+0]
// 4128           maDatasetInfo[idx].countsToNextSave = gNvCountsBetweenSaves_c;
        MOV      R0,#+256
        LDR.W    R1,??DataTable32
        UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
        MOVS     R2,#+6
        MLA      R1,R2,R6,R1
        STRH     R0,[R1, #+4]
        B.N      ??NvTimerTick_6
// 4129         }
// 4130         else
// 4131         {                    
// 4132           tblIdx.entryId = pNVM_DataTable[idx].DataEntryID;
??NvTimerTick_7:
        LDR.W    R0,??DataTable32_12
        LDR      R0,[R0, #+0]
        UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
        MOVS     R1,#+12
        MLA      R0,R1,R6,R0
        LDRH     R0,[R0, #+8]
        STRH     R0,[SP, #+0]
// 4133           tblIdx.elementIndex = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+2]
// 4134           tblIdx.saveRestoreAll = TRUE;
        MOVS     R0,#+1
        STRB     R0,[SP, #+4]
// 4135           /* push the pending save to pending queue */
// 4136           NvAddSaveRequestToQueue(&tblIdx);
        ADD      R0,SP,#+0
        BL       NvAddSaveRequestToQueue
// 4137         }
// 4138       }        
// 4139       /* increment the loop counter */
// 4140       idx++;
??NvTimerTick_6:
        ADDS     R6,R6,#+1
        B.N      ??NvTimerTick_3
// 4141     }
// 4142   }
// 4143   return fTicksLeft;
??NvTimerTick_2:
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
??NvTimerTick_1:
        POP      {R1,R2,R4-R6,PC}  ;; return
// 4144 
// 4145 #else
// 4146   (void)countTick;
// 4147   return FALSE;
// 4148 #endif /* #if gNvStorageIncluded_d */
// 4149 }                                       /* NvTimerTick() */
// 4150 
// 4151 
// 4152 /******************************************************************************
// 4153  * Name: NvRestoreDataSet
// 4154  * Description: copy the most recent version of the element/table entry pointed 
// 4155  *              by ptrData from NVM storage system to RAM memory
// 4156  * Parameter(s): [IN] ptrData - pointer to data (element) to be restored 
// 4157  *               [IN] restoreAll - if FALSE restores a single element
// 4158  *                               - if TRUE restores an entire table entry
// 4159  * Return: status of the restore operation
// 4160  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 4161 NVM_Status_t NvRestoreDataSet
// 4162 (
// 4163   void* ptrData,    
// 4164   bool_t restoreAll
// 4165 )
// 4166 {
NvRestoreDataSet:
        PUSH     {R4,R5,LR}
        SUB      SP,SP,#+12
        MOVS     R4,R0
        MOVS     R5,R1
// 4167 #if gNvStorageIncluded_d
// 4168 
// 4169   NVM_TableEntryInfo_t tblIdx;
// 4170 
// 4171   if(!mNvModuleInitialized)
        LDR.W    R0,??DataTable32_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??NvRestoreDataSet_0
// 4172   {
// 4173     return gNVM_ModuleNotInitialized_c;
        MOVS     R0,#+14
        B.N      ??NvRestoreDataSet_1
// 4174   }
// 4175 
// 4176   if(NULL == ptrData)
??NvRestoreDataSet_0:
        CMP      R4,#+0
        BNE.N    ??NvRestoreDataSet_2
// 4177   {
// 4178     return gNVM_NullPointer_c;
        MOVS     R0,#+5
        B.N      ??NvRestoreDataSet_1
// 4179   }
// 4180 
// 4181 #if gNvFragmentation_Enabled_d
// 4182   tblIdx.saveRestoreAll = restoreAll;
// 4183 #else
// 4184   tblIdx.saveRestoreAll = TRUE;
??NvRestoreDataSet_2:
        MOVS     R0,#+1
        STRB     R0,[SP, #+4]
// 4185 #endif /* gNvFragmentation_Enabled_d */
// 4186 
// 4187   if(NvGetEntryFromDataPtr(ptrData, &tblIdx) != gNVM_OK_c)
        ADD      R1,SP,#+0
        MOVS     R0,R4
        BL       NvGetEntryFromDataPtr
        CMP      R0,#+0
        BEQ.N    ??NvRestoreDataSet_3
// 4188   {
// 4189     return gNVM_PointerOutOfRange_c;
        MOVS     R0,#+6
        B.N      ??NvRestoreDataSet_1
// 4190   }
// 4191 
// 4192   return NvRestoreData(&tblIdx);    
??NvRestoreDataSet_3:
        ADD      R0,SP,#+0
        BL       NvRestoreData
??NvRestoreDataSet_1:
        POP      {R1-R5,PC}       ;; return
// 4193 
// 4194 #else
// 4195   (void)ptrData;
// 4196   return gNVM_Error_c;
// 4197 #endif
// 4198 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable26:
        DC32     mNvCopyOperationIsPending
// 4199 
// 4200 /******************************************************************************
// 4201  * Name: NvClearCriticalSection
// 4202  * Description: leave critical section
// 4203  * Parameters: -
// 4204  * Return: - 
// 4205  ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 4206 void NvClearCriticalSection
// 4207 (
// 4208   void
// 4209 ) 
// 4210 {
// 4211 #if (gNvStorageIncluded_d && gNvEnableCriticalSection_c)
// 4212   if(mNvCriticalSectionFlag)  /* in case of set/clear mismatch */
// 4213     --mNvCriticalSectionFlag;
// 4214 #endif
// 4215 }
NvClearCriticalSection:
        BX       LR               ;; return
// 4216 
// 4217 
// 4218 /******************************************************************************
// 4219  * Name: NvSetCriticalSection
// 4220  * Description: enter critical section
// 4221  * Parameters: -
// 4222  * Return: - 
// 4223  ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 4224 void NvSetCriticalSection
// 4225 (
// 4226   void
// 4227 ) 
// 4228 {
// 4229 #if (gNvStorageIncluded_d && gNvEnableCriticalSection_c)
// 4230   ++mNvCriticalSectionFlag;
// 4231 #endif    
// 4232 }
NvSetCriticalSection:
        BX       LR               ;; return
// 4233 
// 4234 
// 4235 /******************************************************************************
// 4236  * Name: NvIdle
// 4237  * Description: Called from the idle task (bare-metal) or NVM_Task (MQX,
// 4238  *              FreeRTOS) to process the pending saves, erase or copy 
// 4239  *              operations.
// 4240  * Parameters: -
// 4241  * Return: -
// 4242  ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 4243 void NvIdle
// 4244 (
// 4245   void
// 4246 )
// 4247 {
NvIdle:
        PUSH     {R2-R6,LR}
// 4248 #if gNvStorageIncluded_d
// 4249 
// 4250   NVM_TableEntryInfo_t tblIdx;
// 4251   uint16_t tableEntryIdx;
// 4252   uint8_t timerJitter;
// 4253 
// 4254   if (!mNvModuleInitialized || mNvCriticalSectionFlag) 
        LDR.W    R0,??DataTable32_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??NvIdle_0
        LDR.W    R0,??DataTable32_13
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??NvIdle_1
// 4255   {
// 4256     return;
??NvIdle_0:
        B.N      ??NvIdle_2
// 4257   }
// 4258 
// 4259 #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */    
// 4260 
// 4261   if(mNvCopyOperationIsPending)
??NvIdle_1:
        LDR.W    R0,??DataTable32_14
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??NvIdle_3
// 4262   {
// 4263 #if gNvUseExtendedFeatureSet_d	  
// 4264     (void)NvCopyPage(mNvSkipTableEntryId);
// 4265 #else
// 4266     (void)NvCopyPage();
        BL       NvCopyPage
// 4267 #endif /* #if gNvUseExtendedFeatureSet_d */
// 4268     mNvCopyOperationIsPending = FALSE;
        MOVS     R1,#+0
        LDR.W    R2,??DataTable32_14
        STRB     R1,[R2, #+0]
// 4269   }    
// 4270 
// 4271   if(mNvErasePgCmdStatus.NvErasePending)
??NvIdle_3:
        LDR.W    R0,??DataTable32_8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??NvIdle_4
// 4272   {
// 4273     if(mNvErasePgCmdStatus.NvSectorAddress >= mNvVirtualPageProperty[mNvErasePgCmdStatus.NvPageToErase].NvRawSectorEndAddress)
        LDR.W    R0,??DataTable32_8
        LDR      R0,[R0, #+4]
        LDR.N    R1,??DataTable28
        LDR.W    R2,??DataTable32_8
        LDRB     R2,[R2, #+1]
        MOVS     R3,#+20
        MLA      R1,R3,R2,R1
        LDR      R1,[R1, #+4]
        CMP      R0,R1
        BCC.N    ??NvIdle_5
// 4274     {
// 4275       /* all sectors of the page had been erased */
// 4276       mNvVirtualPageProperty[mNvErasePgCmdStatus.NvPageToErase].NvLastMetaInfoAddress = gEmptyPageMetaAddress_c;
        LDR.N    R0,??DataTable28
        LDR.W    R1,??DataTable32_8
        LDRB     R1,[R1, #+1]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR.N    R1,??DataTable28_1  ;; 0x3fff0000
        STR      R1,[R0, #+16]
// 4277       mNvErasePgCmdStatus.NvErasePending = FALSE;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable32_8
        STRB     R0,[R1, #+0]
// 4278       return;
        B.N      ??NvIdle_2
// 4279     }
// 4280 
// 4281     /* erase */
// 4282     (void)NV_FlashEraseSector(&mNvConfig, mNvErasePgCmdStatus.NvSectorAddress, (uint32_t)((uint8_t*)NV_STORAGE_SECTOR_SIZE));
??NvIdle_5:
        LDR.W    R2,??DataTable32_7
        LDR.W    R0,??DataTable32_8
        LDR      R1,[R0, #+4]
        LDR.W    R0,??DataTable32_15
        BL       NV_FlashEraseSector
        MOVS     R6,R0
// 4283 
// 4284     /* blank check */
// 4285     if(gNV_OK_c == NV_FlashVerifySection(&mNvConfig, mNvErasePgCmdStatus.NvSectorAddress,
// 4286         (uint32_t)((uint8_t*)NV_STORAGE_SECTOR_SIZE), gNV_MARGIN_NORMAL_c))
        MOVS     R3,#+0
        LDR.W    R2,??DataTable32_7
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        LDR.W    R0,??DataTable32_8
        LDR      R1,[R0, #+4]
        LDR.W    R0,??DataTable32_15
        BL       NV_FlashVerifySection
        CMP      R0,#+0
        BNE.N    ??NvIdle_4
// 4287     {
// 4288       mNvErasePgCmdStatus.NvSectorAddress += (uint32_t)((uint8_t*)NV_STORAGE_SECTOR_SIZE);
        LDR.N    R0,??DataTable32_8
        LDR      R0,[R0, #+4]
        LDR.N    R1,??DataTable32_7
        ADDS     R0,R1,R0
        LDR.N    R1,??DataTable32_8
        STR      R0,[R1, #+4]
// 4289       return;
        B.N      ??NvIdle_2
// 4290     }        
// 4291   }
// 4292 #endif
// 4293 
// 4294   /* process the save-on-interval requests */    
// 4295   if(NvTimerTick(mNvSaveOnIntervalEvent)) 
??NvIdle_4:
        LDR.N    R0,??DataTable32_2
        LDRB     R0,[R0, #+0]
        BL       NvTimerTick
        CMP      R0,#+0
        BEQ.N    ??NvIdle_6
// 4296   {
// 4297     if(!TMR_IsTimerActive(mNvSaveOnIntervalTimerID))
        LDR.N    R0,??DataTable32_10
        LDRB     R0,[R0, #+0]
        BL       TMR_IsTimerActive
        CMP      R0,#+0
        BNE.N    ??NvIdle_6
// 4298     {
// 4299       timerJitter = NvGetRandomRange(0,255);
        MOVS     R1,#+255
        MOVS     R0,#+0
        BL       NvGetRandomRange
        MOVS     R5,R0
// 4300       TMR_StartSingleShotTimer(mNvSaveOnIntervalTimerID,
// 4301           TmrSeconds(1) + timerJitter - 128,
// 4302           NvIntervalTimerCallback);
        LDR.N    R2,??DataTable32_16
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        ADDS     R1,R5,#+872
        LDR.N    R0,??DataTable32_10
        LDRB     R0,[R0, #+0]
        BL       TMR_StartSingleShotTimer
// 4303     }
// 4304   }
// 4305 
// 4306   if(mNvSaveOnIntervalEvent)
??NvIdle_6:
        LDR.N    R0,??DataTable32_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??NvIdle_7
// 4307   {
// 4308     mNvSaveOnIntervalEvent = FALSE;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable32_2
        STRB     R0,[R1, #+0]
// 4309   }
// 4310 
// 4311   /* process the save-on-idle requests */
// 4312   if(NvGetPendingSavesCount(&mNvPendingSavesQueue))
??NvIdle_7:
        LDR.N    R0,??DataTable32_1
        BL       NvGetPendingSavesCount
        CMP      R0,#+0
        BEQ.N    ??NvIdle_8
// 4313   {
// 4314     while(NvPopPendingSave(&mNvPendingSavesQueue, &tblIdx))
??NvIdle_9:
        ADD      R1,SP,#+0
        LDR.N    R0,??DataTable32_1
        BL       NvPopPendingSave
        CMP      R0,#+0
        BEQ.N    ??NvIdle_8
// 4315     {            
// 4316       tableEntryIdx = NvGetTableEntryIndexFromId(tblIdx.entryId);
        LDRH     R0,[SP, #+0]
        BL       NvGetTableEntryIndexFromId
        MOVS     R4,R0
// 4317 
// 4318       if(gNvInvalidTableEntryIndex_c == tableEntryIdx)
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        MOVW     R0,#+65535
        CMP      R4,R0
        BEQ.N    ??NvIdle_9
// 4319       {
// 4320         continue;
// 4321       }            
// 4322 
// 4323 #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */            
// 4324       if(NvWriteRecord(&tblIdx) == gNVM_PageCopyPending_c)
??NvIdle_10:
        ADD      R0,SP,#+0
        BL       NvWriteRecord
        CMP      R0,#+17
        BNE.N    ??NvIdle_11
// 4325       {
// 4326         NvAddSaveRequestToQueue(&tblIdx);
        ADD      R0,SP,#+0
        BL       NvAddSaveRequestToQueue
// 4327         break;
        B.N      ??NvIdle_8
// 4328       }
// 4329 #else /* FlexNVM */
// 4330       NvWriteRecord(&tblIdx);
// 4331 #endif
// 4332 
// 4333       if(tblIdx.saveRestoreAll)
??NvIdle_11:
        LDRB     R0,[SP, #+4]
        CMP      R0,#+0
        BEQ.N    ??NvIdle_9
// 4334       {
// 4335         maDatasetInfo[tableEntryIdx].saveNextInterval = FALSE;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable32
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        MOVS     R2,#+6
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+0]
// 4336         maDatasetInfo[tableEntryIdx].countsToNextSave = gNvCountsBetweenSaves_c;
        MOV      R0,#+256
        LDR.N    R1,??DataTable32
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        MOVS     R2,#+6
        MLA      R1,R2,R4,R1
        STRH     R0,[R1, #+4]
        B.N      ??NvIdle_9
// 4337       }
// 4338     }
// 4339   }
// 4340 #endif
// 4341 }                                       /* NvIdle() */
??NvIdle_8:
??NvIdle_2:
        POP      {R0,R1,R4-R6,PC}  ;; return
// 4342 
// 4343 
// 4344 /******************************************************************************
// 4345  * Name: NvIsDataSetDirty
// 4346  * Description: return TRUE if the element pointed by ptrData is dirty
// 4347  * Parameters: [IN] ptrData - pointer to data to be checked
// 4348  * Return: TRUE if the element is dirty, FALSE otherwise 
// 4349  ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 4350 bool_t NvIsDataSetDirty
// 4351 (
// 4352   void* ptrData
// 4353 )
// 4354 {    
NvIsDataSetDirty:
        PUSH     {R4,R5,LR}
        SUB      SP,SP,#+12
        MOVS     R4,R0
// 4355 #if gNvStorageIncluded_d
// 4356 
// 4357   NVM_TableEntryInfo_t tblIdx;
// 4358   uint16_t tableEntryIdx;
// 4359 
// 4360   if(!mNvModuleInitialized)
        LDR.N    R0,??DataTable32_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??NvIsDataSetDirty_0
// 4361   {
// 4362     return FALSE;
        MOVS     R0,#+0
        B.N      ??NvIsDataSetDirty_1
// 4363   }
// 4364 
// 4365   if(NULL == ptrData)
??NvIsDataSetDirty_0:
        CMP      R4,#+0
        BNE.N    ??NvIsDataSetDirty_2
// 4366   {
// 4367     return gNVM_NullPointer_c;
        MOVS     R0,#+5
        B.N      ??NvIsDataSetDirty_1
// 4368   }
// 4369 
// 4370   if(gNVM_OK_c != NvGetEntryFromDataPtr(ptrData, &tblIdx))
??NvIsDataSetDirty_2:
        ADD      R1,SP,#+0
        MOVS     R0,R4
        BL       NvGetEntryFromDataPtr
        CMP      R0,#+0
        BEQ.N    ??NvIsDataSetDirty_3
// 4371   {
// 4372     return FALSE;
        MOVS     R0,#+0
        B.N      ??NvIsDataSetDirty_1
// 4373   }
// 4374   else
// 4375   {
// 4376     tableEntryIdx = NvGetTableEntryIndexFromId(tblIdx.entryId);
??NvIsDataSetDirty_3:
        LDRH     R0,[SP, #+0]
        BL       NvGetTableEntryIndexFromId
        MOVS     R5,R0
// 4377 
// 4378     if(gNvInvalidTableEntryIndex_c == tableEntryIdx)
        UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
        MOVW     R0,#+65535
        CMP      R5,R0
        BNE.N    ??NvIsDataSetDirty_4
// 4379     {
// 4380       return FALSE;
        MOVS     R0,#+0
        B.N      ??NvIsDataSetDirty_1
// 4381     }
// 4382 
// 4383     return(maDatasetInfo[tableEntryIdx].saveNextInterval || 
// 4384         (maDatasetInfo[tableEntryIdx].countsToNextSave != gNvCountsBetweenSaves_c));         
??NvIsDataSetDirty_4:
        LDR.N    R0,??DataTable32
        UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
        MOVS     R1,#+6
        MLA      R0,R1,R5,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??NvIsDataSetDirty_5
        LDR.N    R0,??DataTable32
        UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
        MOVS     R1,#+6
        MLA      R0,R1,R5,R0
        LDRH     R0,[R0, #+4]
        CMP      R0,#+256
        BEQ.N    ??NvIsDataSetDirty_6
??NvIsDataSetDirty_5:
        MOVS     R0,#+1
        B.N      ??NvIsDataSetDirty_7
??NvIsDataSetDirty_6:
        MOVS     R0,#+0
??NvIsDataSetDirty_7:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
??NvIsDataSetDirty_1:
        POP      {R1-R5,PC}       ;; return
// 4385   }
// 4386 
// 4387 #else
// 4388   (void)ptrData;
// 4389   return FALSE;
// 4390 #endif
// 4391 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable28:
        DC32     mNvVirtualPageProperty

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable28_1:
        DC32     0x3fff0000
// 4392 
// 4393 /******************************************************************************
// 4394  * Name: NvGetStatistics
// 4395  * Description:       
// 4396  * Parameter(s): [OUT] ptrStat - pointer to a memory location where the pages
// 4397  *                               statistics (erase cycles of each page) will 
// 4398  *                               be stored
// 4399  * Return: -
// 4400  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 4401 void NvGetPagesStatistics
// 4402 (
// 4403   NVM_Statistics_t* ptrStat 
// 4404 )
// 4405 {    
// 4406 #if gNvStorageIncluded_d
// 4407 #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */    
// 4408   if(!mNvModuleInitialized)
NvGetPagesStatistics:
        LDR.N    R1,??DataTable32_3
        LDRB     R1,[R1, #+0]
        CMP      R1,#+0
        BEQ.N    ??NvGetPagesStatistics_0
// 4409   {
// 4410     return;
// 4411   }
// 4412 
// 4413   if(NULL == ptrStat)
??NvGetPagesStatistics_1:
        CMP      R0,#+0
        BEQ.N    ??NvGetPagesStatistics_0
// 4414   {
// 4415     return;
// 4416   }
// 4417 
// 4418   if(mNvPageCounter%2)
??NvGetPagesStatistics_2:
        LDR.N    R1,??DataTable32_17
        LDRB     R1,[R1, #+0]
        LSLS     R1,R1,#+31
        BPL.N    ??NvGetPagesStatistics_3
// 4419   {
// 4420     ptrStat->FirstPageEraseCyclesCount = ptrStat->SecondPageEraseCyclesCount = (mNvPageCounter-1)/2;
        LDR.N    R1,??DataTable32_17
        LDR      R1,[R1, #+0]
        SUBS     R1,R1,#+1
        LSRS     R1,R1,#+1
        STR      R1,[R0, #+4]
        LDR      R1,[R0, #+4]
        STR      R1,[R0, #+0]
        B.N      ??NvGetPagesStatistics_4
// 4421   }
// 4422   else
// 4423   {
// 4424     ptrStat->FirstPageEraseCyclesCount = mNvPageCounter/2;
??NvGetPagesStatistics_3:
        LDR.N    R1,??DataTable32_17
        LDR      R1,[R1, #+0]
        LSRS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 4425     ptrStat->SecondPageEraseCyclesCount = (mNvPageCounter-2)/2;
        LDR.N    R1,??DataTable32_17
        LDR      R1,[R1, #+0]
        SUBS     R1,R1,#+2
        LSRS     R1,R1,#+1
        STR      R1,[R0, #+4]
// 4426   }
// 4427 
// 4428 #else /* FlexNVM */
// 4429 ptrStat->FirstPageEraseCyclesCount = 0;
// 4430 ptrStat->SecondPageEraseCyclesCount = 0;
// 4431 return;
// 4432 #endif
// 4433 
// 4434 #else
// 4435 (void)ptrStat;
// 4436 return;
// 4437 #endif
// 4438 }
??NvGetPagesStatistics_4:
??NvGetPagesStatistics_0:
        BX       LR               ;; return
// 4439 
// 4440 /******************************************************************************
// 4441  * Name: NvFormat
// 4442  * Description: Format the NV storage system. The function erases both virtual
// 4443  *              pages and then writes the page counter to active page.              
// 4444  * Parameter(s): -
// 4445  * Return: gNVM_OK_c - if the operation completes successfully
// 4446  *         gNVM_FormatFailure_c - if the format operation fails
// 4447  *         gNVM_ModuleNotInitialized_c - if the NVM  module is not initialized
// 4448  *         gNVM_CriticalSectionActive_c - if the system has entered in a 
// 4449  *                                        critical section
// 4450  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 4451 NVM_Status_t NvFormat
// 4452 (
// 4453   void
// 4454 )
// 4455 {
NvFormat:
        PUSH     {R3-R5,LR}
// 4456 #if gNvStorageIncluded_d
// 4457 
// 4458 #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */  
// 4459 
// 4460   uint32_t pageCounterValue;  
// 4461   NVM_Status_t status;
// 4462 
// 4463   if(!mNvModuleInitialized)
        LDR.N    R0,??DataTable32_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??NvFormat_0
// 4464   {
// 4465     return gNVM_ModuleNotInitialized_c;
        MOVS     R0,#+14
        B.N      ??NvFormat_1
// 4466   }
// 4467 
// 4468   if(mNvCriticalSectionFlag)
??NvFormat_0:
        LDR.N    R0,??DataTable32_13
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??NvFormat_2
// 4469   {
// 4470     return gNVM_CriticalSectionActive_c;
        MOVS     R0,#+15
        B.N      ??NvFormat_1
// 4471   }
// 4472 
// 4473   NV_FlashRead(mNvVirtualPageProperty[mNvActivePageId].NvRawSectorStartAddress, (uint8_t*)&pageCounterValue, sizeof(pageCounterValue));        
??NvFormat_2:
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        LDR.N    R0,??DataTable32_18
        LDR.N    R3,??DataTable32_5
        LDRB     R3,[R3, #+0]
        MOVS     R5,#+20
        MLA      R0,R5,R3,R0
        LDR      R0,[R0, #+0]
        BL       NV_FlashRead
// 4474 
// 4475   if((status = NvInternalFormat(pageCounterValue)) == gNVM_OK_c)
        LDR      R0,[SP, #+0]
        BL       NvInternalFormat
        MOVS     R4,R0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??NvFormat_3
// 4476   {     
// 4477     /* update last meta info address */
// 4478     (void)NvGetLastMetaInfoAddress();
        BL       NvGetLastMetaInfoAddress
// 4479   }
// 4480 
// 4481   return status;
??NvFormat_3:
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
??NvFormat_1:
        POP      {R1,R4,R5,PC}    ;; return
// 4482 
// 4483 #else /* FlexNVM */
// 4484 
// 4485   uint8_t buff[gNvFlexFormatBufferSize_c];
// 4486   uint32_t addr;
// 4487   uint16_t size;
// 4488 
// 4489   FLib_MemSet(buff, gNvErasedFlashCellValue_c, gNvFlexFormatBufferSize_c);
// 4490 
// 4491   addr = mNvConfig.EERAMBlockBase;
// 4492   size = mNvConfig.EEEBlockSize;
// 4493 
// 4494   while(size)
// 4495   {
// 4496     /* wait for EEPROM system to be ready */
// 4497     while(!(gNV_REG_READ(mNvConfig.ftfxRegBase + gNV_FCNFG_OFFSET_c) & gNV_FCNFG_EEERDY_c));
// 4498 
// 4499     if(gNV_OK_c != NV_EEEWrite(&mNvConfig, (uint32_t)(&buff), addr, sizeof(buff)))        
// 4500     {
// 4501       return gNVM_FormatFailure_c;
// 4502     }
// 4503     size -= gNvFlexFormatBufferSize_c;
// 4504     addr += gNvFlexFormatBufferSize_c;
// 4505   }    
// 4506   return gNVM_OK_c;
// 4507 #endif /* gNvUseFlexNVM_d */
// 4508 
// 4509 #else    
// 4510   return gNVM_Error_c;
// 4511 #endif /* gNvStorageIncluded_d */    
// 4512 }
// 4513 
// 4514 
// 4515 /******************************************************************************
// 4516  * Name: NvRegisterTableEntry
// 4517  * Description: The function tries to register a new table entry within an
// 4518  *              existing NV table. If the NV table contained an erased (invalid)
// 4519  *              entry, the entry will be overwritten with a new one (provided
// 4520  *              by the mean of this function arguments)      
// 4521  * Parameter(s): [IN] ptrData - generic pointer to RAM data to be registered
// 4522  *                              within the NV storage system
// 4523  *               [IN] uniqueId - an unique ID of the table entry
// 4524  *               [IN] elemCount - how many elements the table entry contains
// 4525  *               [IN] elemSize - the size of an element 
// 4526  *               [IN] overwrite - if an existing table entry shall be 
// 4527  *                                overwritten
// 4528  * Return: gNVM_OK_c - if the operation completes successfully         
// 4529  *         gNVM_ModuleNotInitialized_c - if the NVM  module is not initialized
// 4530  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 4531 NVM_Status_t NvRegisterTableEntry
// 4532 (
// 4533   void* ptrData,
// 4534   NvTableEntryId_t uniqueId,
// 4535   uint16_t elemCount,
// 4536   uint16_t elemSize,
// 4537   bool_t overwrite
// 4538 )
// 4539 {
NvRegisterTableEntry:
        PUSH     {R4}
        MOVS     R4,R0
// 4540 #if gNvStorageIncluded_d && gNvUseExtendedFeatureSet_d
// 4541 
// 4542   uint16_t loopCnt = 0;
// 4543   uint16_t nullPos = gNvTableEntriesCountMax_c;
// 4544 
// 4545   if(!mNvModuleInitialized)
// 4546   {
// 4547     return gNVM_ModuleNotInitialized_c;
// 4548   }
// 4549 
// 4550   if((gNvInvalidDataEntry_c == uniqueId) || (gNvEndOfTableId_c == uniqueId))
// 4551   {
// 4552     return gNVM_RegisterFailure_c;
// 4553   }
// 4554 
// 4555   while(gNvEndOfTableId_c != pNVM_DataTable[loopCnt].DataEntryID)
// 4556   {
// 4557     if(NULL == pNVM_DataTable[loopCnt].pData)
// 4558     {
// 4559       nullPos = loopCnt;        
// 4560     }
// 4561 
// 4562     if(pNVM_DataTable[loopCnt].DataEntryID == uniqueId)            
// 4563     {
// 4564       if(overwrite)
// 4565       {
// 4566         pNVM_DataTable[loopCnt].pData= ptrData;                
// 4567         pNVM_DataTable[loopCnt].ElementsCount = elemCount;
// 4568         pNVM_DataTable[loopCnt].ElementSize = elemSize;
// 4569         return gNVM_OK_c;
// 4570       }
// 4571       else
// 4572       {
// 4573         return gNVM_AlreadyRegistered;
// 4574       }        
// 4575     }
// 4576     /* increment the loop counter */
// 4577     loopCnt++;
// 4578   }
// 4579 
// 4580   if(gNvTableEntriesCountMax_c != nullPos)
// 4581   {
// 4582     pNVM_DataTable[nullPos].pData= ptrData;
// 4583     pNVM_DataTable[nullPos].DataEntryID = uniqueId;
// 4584     pNVM_DataTable[nullPos].ElementsCount = elemCount;
// 4585     pNVM_DataTable[nullPos].ElementSize = elemSize;
// 4586     return gNVM_OK_c;
// 4587   }        
// 4588 
// 4589   return gNVM_RegisterFailure_c;
// 4590 #else
// 4591   (void)ptrData;
// 4592   (void)uniqueId;
// 4593   (void)elemCount;
// 4594   (void)elemSize;
// 4595   (void)overwrite;
// 4596   return gNVM_Error_c;
        MOVS     R0,#+1
        POP      {R4}
        BX       LR               ;; return
// 4597 #endif
// 4598 }
// 4599 
// 4600 
// 4601 /******************************************************************************
// 4602  * Name: NvEraseEntryFromStorage
// 4603  * Description: The function removes a table entry within the existing NV 
// 4604  *              table. 
// 4605  * Parameter(s): [IN] ptrData - a pointer to an existing RAM data that is
// 4606  *                              managed by the NV storage system    
// 4607  * Return: gNVM_OK_c - if the operation completes successfully         
// 4608  *         gNVM_ModuleNotInitialized_c - if the NVM  module is not initialized
// 4609  *         gNVM_NullPointer_c - if a NULL pointer is provided
// 4610  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 4611 NVM_Status_t NvEraseEntryFromStorage
// 4612 (
// 4613   void* ptrData
// 4614 )
// 4615 {
NvEraseEntryFromStorage:
        MOVS     R1,R0
// 4616 #if gNvStorageIncluded_d && gNvUseExtendedFeatureSet_d
// 4617 
// 4618   NVM_TableEntryInfo_t tblIdx;    
// 4619   uint16_t tableEntryIndex;
// 4620 
// 4621 #if (gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c != 0) /* FlexNVM */    
// 4622   index_t loopCnt;    
// 4623   NVM_Status_t status;
// 4624 #endif
// 4625 
// 4626   if(!mNvModuleInitialized)
// 4627   {
// 4628     return gNVM_ModuleNotInitialized_c;
// 4629   }
// 4630 
// 4631   if(mNvCriticalSectionFlag)
// 4632   {
// 4633     return gNVM_CriticalSectionActive_c;
// 4634   }
// 4635 
// 4636   if(NULL == ptrData)
// 4637   {
// 4638     return gNVM_NullPointer_c;
// 4639   }
// 4640 
// 4641   if(gNVM_PointerOutOfRange_c == NvGetEntryFromDataPtr(ptrData, &tblIdx))
// 4642   {
// 4643     return gNVM_PointerOutOfRange_c;
// 4644   }
// 4645 
// 4646   if(gNvInvalidDataEntry_c == tblIdx.entryId)
// 4647   {
// 4648     /* element already deleted from RAM table, it can be assumed that also the associated NVM records are erased */
// 4649     return gNVM_OK_c;
// 4650   }
// 4651 
// 4652   if((tableEntryIndex = NvGetTableEntryIndexFromId(tblIdx.entryId)) == gNvInvalidTableEntryIndex_c)
// 4653   {
// 4654     return gNVM_InvalidTableEntry_c;
// 4655   }
// 4656 
// 4657   /* invalidate the table entry */
// 4658   pNVM_DataTable[tableEntryIndex].DataEntryID = gNvInvalidDataEntry_c;
// 4659 
// 4660 #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */
// 4661   /* erase the table entry by making a copy of the active page to the inactive one, 
// 4662    * but skipping while copying the table entry to be erased */     
// 4663   mNvSkipTableEntryId = tblIdx.entryId;
// 4664   /* make a request to make a page copy */
// 4665   mNvCopyOperationIsPending = TRUE;
// 4666 
// 4667   return gNVM_OK_c;
// 4668 #else /* FlexNVM */
// 4669 
// 4670   /* format the FlexRAM window */
// 4671   NvFormat();
// 4672 
// 4673   /* re-write the entire NVM table */    
// 4674   loopCnt = 0;
// 4675   while(gNvEndOfTableId_c != pNVM_DataTable[loopCnt].DataEntryID)
// 4676   {
// 4677     NvGetEntryFromDataPtr(pNVM_DataTable[loopCnt].pData, &tblIdx);
// 4678 
// 4679     if(gNvInvalidDataEntry_c == tblIdx.entryId)
// 4680     {
// 4681       loopCnt++;
// 4682       continue;
// 4683     }
// 4684 
// 4685     if(gNVM_OK_c != (status = NvWriteRecord(&tblIdx)))
// 4686     {
// 4687       return status;
// 4688     }
// 4689     /* increment the loop counter */
// 4690     loopCnt++;
// 4691   }
// 4692   return status;
// 4693 #endif /* FlexNVM */
// 4694 
// 4695 #else
// 4696   (void)ptrData;
// 4697   return gNVM_Error_c;
        MOVS     R0,#+1
        BX       LR               ;; return
// 4698 #endif    
// 4699 }
// 4700 
// 4701 /******************************************************************************
// 4702  * Name: NvSyncSave
// 4703  * Description: The function saves the pointed element or the entire table
// 4704  *              entry to the storage system. The save operation is not
// 4705  *              performed on the idle task but within this function call.
// 4706  * Parameter(s): [IN] ptrData - a pointer to data to be saved
// 4707  *               [IN] saveAll - specifies if the entire table entry shall be 
// 4708  *                              saved or only the pointed element
// 4709  *               [IN] ignoreCriticalSectionFlag - if set to TRUE, the critical
// 4710  *                                                section flag is ignored
// 4711  * Return: gNVM_OK_c - if the operation completes successfully         
// 4712  *         gNVM_ModuleNotInitialized_c - if the NVM  module is not initialized
// 4713  *         gNVM_NullPointer_c - if a NULL pointer is provided
// 4714  *         gNVM_PointerOutOfRange_c - if the pointer is out of range
// 4715  *         gNVM_InvalidTableEntry_c - if the table entry is not valid
// 4716  *         gNVM_MetaInfoWriteError_c - meta tag couldn't be written
// 4717  *         gNVM_RecordWriteError_c - record couldn't be written
// 4718  *         gNVM_CriticalSectionActive_c - the module is in critical section                             
// 4719  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 4720 NVM_Status_t NvSyncSave
// 4721 (
// 4722   void* ptrData,
// 4723   bool_t saveAll,
// 4724   bool_t ignoreCriticalSectionFlag
// 4725 )
// 4726 {
NvSyncSave:
        PUSH     {R2-R8,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
// 4727 #if gNvStorageIncluded_d
// 4728 
// 4729   NVM_TableEntryInfo_t tblIdx;
// 4730   NVM_Status_t status;
// 4731 
// 4732   if(!mNvModuleInitialized)
        LDR.N    R0,??DataTable32_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??NvSyncSave_0
// 4733   {
// 4734     return gNVM_ModuleNotInitialized_c;
        MOVS     R0,#+14
        B.N      ??NvSyncSave_1
// 4735   }
// 4736 
// 4737   if(mNvCriticalSectionFlag && !ignoreCriticalSectionFlag)
??NvSyncSave_0:
        LDR.N    R0,??DataTable32_13
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??NvSyncSave_2
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BNE.N    ??NvSyncSave_2
// 4738   {
// 4739     NvAddSaveRequestToQueue(&tblIdx);
        ADD      R0,SP,#+0
        BL       NvAddSaveRequestToQueue
// 4740     return gNVM_CriticalSectionActive_c;
        MOVS     R0,#+15
        B.N      ??NvSyncSave_1
// 4741   }
// 4742 
// 4743   if(NULL == ptrData)
??NvSyncSave_2:
        CMP      R4,#+0
        BNE.N    ??NvSyncSave_3
// 4744   {
// 4745     return gNVM_NullPointer_c;
        MOVS     R0,#+5
        B.N      ??NvSyncSave_1
// 4746   }
// 4747 
// 4748   if((status = NvGetEntryFromDataPtr(ptrData, &tblIdx)) != gNVM_OK_c)
??NvSyncSave_3:
        ADD      R1,SP,#+0
        MOVS     R0,R4
        BL       NvGetEntryFromDataPtr
        MOVS     R7,R0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BEQ.N    ??NvSyncSave_4
// 4749   {
// 4750     return status;
        MOVS     R0,R7
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        B.N      ??NvSyncSave_1
// 4751   }
// 4752 
// 4753   tblIdx.saveRestoreAll = saveAll;
??NvSyncSave_4:
        STRB     R5,[SP, #+4]
// 4754 
// 4755 #if (gNvUseFlexNVM_d == FALSE) || ((gNvUseFlexNVM_d == TRUE) && (gNV_DEBLOCK_SIZE_c == 0)) /* no FlexNVM */
// 4756   if((status = NvWriteRecord(&tblIdx)) == gNVM_PageCopyPending_c)
        ADD      R0,SP,#+0
        BL       NvWriteRecord
        MOVS     R7,R0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+17
        BNE.N    ??NvSyncSave_5
// 4757   {
// 4758 #if gNvUseExtendedFeatureSet_d    	  
// 4759 	/* copy active page */
// 4760     if((status = NvCopyPage(gNvCopyAll_c)) != gNVM_OK_c)
// 4761     {
// 4762 	  return status;
// 4763 	}
// 4764 #else
// 4765     /* copy active page */
// 4766     if((status = NvCopyPage()) != gNVM_OK_c)
        BL       NvCopyPage
        MOVS     R7,R0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BEQ.N    ??NvSyncSave_6
// 4767     {
// 4768       return status;
        MOVS     R0,R7
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        B.N      ??NvSyncSave_1
// 4769     }
// 4770 #endif /* #if gNvUseExtendedFeatureSet_d */
// 4771 
// 4772     mNvCopyOperationIsPending = FALSE;
??NvSyncSave_6:
        MOVS     R0,#+0
        LDR.N    R1,??DataTable32_14
        STRB     R0,[R1, #+0]
// 4773 
// 4774     /* erase old page */
// 4775     (void)NV_FlashEraseSector(&mNvConfig, mNvVirtualPageProperty[mNvErasePgCmdStatus.NvPageToErase].NvRawSectorStartAddress,
// 4776         mNvVirtualPageProperty[mNvErasePgCmdStatus.NvPageToErase].NvTotalPageSize);
        LDR.N    R0,??DataTable32_18
        LDR.N    R1,??DataTable32_8
        LDRB     R1,[R1, #+1]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R2,[R0, #+12]
        LDR.N    R0,??DataTable32_18
        LDR.N    R1,??DataTable32_8
        LDRB     R1,[R1, #+1]
        MOVS     R3,#+20
        MLA      R0,R3,R1,R0
        LDR      R1,[R0, #+0]
        LDR.N    R0,??DataTable32_15
        BL       NV_FlashEraseSector
        MOV      R8,R0
// 4777 
// 4778     /* blank check */
// 4779     if(gNV_OK_c == NV_FlashVerifySection(&mNvConfig, mNvVirtualPageProperty[mNvErasePgCmdStatus.NvPageToErase].NvRawSectorStartAddress,
// 4780         mNvVirtualPageProperty[mNvErasePgCmdStatus.NvPageToErase].NvTotalPageSize, gNV_MARGIN_NORMAL_c))
        MOVS     R3,#+0
        LDR.N    R0,??DataTable32_18
        LDR.N    R1,??DataTable32_8
        LDRB     R1,[R1, #+1]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR      R2,[R0, #+12]
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        LDR.N    R0,??DataTable32_18
        LDR.N    R1,??DataTable32_8
        LDRB     R1,[R1, #+1]
        MOVS     R12,#+20
        MLA      R0,R12,R1,R0
        LDR      R1,[R0, #+0]
        LDR.N    R0,??DataTable32_15
        BL       NV_FlashVerifySection
        CMP      R0,#+0
        BNE.N    ??NvSyncSave_7
// 4781     {
// 4782       mNvVirtualPageProperty[mNvErasePgCmdStatus.NvPageToErase].NvLastMetaInfoAddress = gEmptyPageMetaAddress_c;
        LDR.N    R0,??DataTable32_18
        LDR.N    R1,??DataTable32_8
        LDRB     R1,[R1, #+1]
        MOVS     R2,#+20
        MLA      R0,R2,R1,R0
        LDR.N    R1,??DataTable32_19  ;; 0x3fff0000
        STR      R1,[R0, #+16]
// 4783       mNvErasePgCmdStatus.NvErasePending = FALSE;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable32_8
        STRB     R0,[R1, #+0]
// 4784     }
// 4785 
// 4786     /* write record */
// 4787     status = NvWriteRecord(&tblIdx);
??NvSyncSave_7:
        ADD      R0,SP,#+0
        BL       NvWriteRecord
        MOVS     R7,R0
// 4788   }
// 4789 #else /* FlexNVM */
// 4790   /* write record */
// 4791   status = NvWriteRecord(&tblIdx);
// 4792   /* wait for EEPROM system to be ready (fix@ENGR283453) */
// 4793   while(!(gNV_REG_READ(mNvConfig.ftfxRegBase + gNV_FCNFG_OFFSET_c) & gNV_FCNFG_EEERDY_c));
// 4794 #endif
// 4795 
// 4796   return status;
??NvSyncSave_5:
        MOVS     R0,R7
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
??NvSyncSave_1:
        POP      {R1,R2,R4-R8,PC}  ;; return
// 4797 
// 4798 #else
// 4799   (void)ptrData;
// 4800   (void)saveAll;
// 4801   return gNVM_Error_c;
// 4802 #endif
// 4803 }
// 4804 
// 4805 
// 4806 /******************************************************************************
// 4807  * Name: NvAtomicSave
// 4808  * Description: The function performs an atomic save of the entire NV table
// 4809  *              to the storage system. The operation is performed
// 4810  *              in place (atomic).
// 4811  * Parameter(s):  [IN] ignoreCriticalSectionFlag - if set to TRUE, the critical
// 4812  *                                                section flag is ignored
// 4813  * Return: gNVM_OK_c - if the operation completes successfully
// 4814  *         gNVM_ModuleNotInitialized_c - if the NVM  module is not initialized
// 4815  *         gNVM_NullPointer_c - if a NULL pointer is provided
// 4816  *         gNVM_PointerOutOfRange_c - if the pointer is out of range
// 4817  *         gNVM_InvalidTableEntry_c - if the table entry is not valid
// 4818  *         gNVM_MetaInfoWriteError_c - meta tag couldn't be written
// 4819  *         gNVM_RecordWriteError_c - record couldn't be written
// 4820  *         gNVM_CriticalSectionActive_c - the module is in critical section
// 4821  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 4822 NVM_Status_t NvAtomicSave
// 4823 (
// 4824   bool_t ignoreCriticalSectionFlag
// 4825 )
// 4826 {
NvAtomicSave:
        PUSH     {R4-R6,LR}
        MOVS     R4,R0
// 4827 #if gNvStorageIncluded_d
// 4828   NVM_Status_t status = gNVM_OK_c;
        MOVS     R5,#+0
// 4829   index_t loopCnt = 0;
        MOVS     R6,#+0
// 4830 
// 4831   while(gNvEndOfTableId_c != pNVM_DataTable[loopCnt].DataEntryID)
??NvAtomicSave_0:
        LDR.N    R0,??DataTable32_12
        LDR      R0,[R0, #+0]
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        MOVS     R1,#+12
        MLA      R0,R1,R6,R0
        LDRH     R0,[R0, #+8]
        MOVW     R1,#+65534
        CMP      R0,R1
        BEQ.N    ??NvAtomicSave_1
// 4832   {
// 4833     status = NvSyncSave(pNVM_DataTable[loopCnt].pData, TRUE, ignoreCriticalSectionFlag);
        MOVS     R2,R4
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,#+1
        LDR.N    R0,??DataTable32_12
        LDR      R0,[R0, #+0]
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        MOVS     R3,#+12
        MLA      R0,R3,R6,R0
        LDR      R0,[R0, #+0]
        BL       NvSyncSave
        MOVS     R5,R0
// 4834 
// 4835     if((gNVM_CriticalSectionActive_c == status) || (gNVM_NullPointer_c == status))
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+15
        BEQ.N    ??NvAtomicSave_2
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+5
        BNE.N    ??NvAtomicSave_3
// 4836     {
// 4837       /* skip */
// 4838       loopCnt++;
??NvAtomicSave_2:
        ADDS     R6,R6,#+1
// 4839       continue;
        B.N      ??NvAtomicSave_0
// 4840     }
// 4841 
// 4842     if(gNVM_OK_c != status)
??NvAtomicSave_3:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BNE.N    ??NvAtomicSave_1
// 4843     {
// 4844       /* error */
// 4845       break;
// 4846     }
// 4847 
// 4848     /* increment the loop counter */
// 4849     loopCnt++;
??NvAtomicSave_4:
        ADDS     R6,R6,#+1
        B.N      ??NvAtomicSave_0
// 4850   }
// 4851   return status;
??NvAtomicSave_1:
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R4-R6,PC}       ;; return
// 4852 #else
// 4853   return gNVM_Error_c;
// 4854 #endif
// 4855 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32:
        DC32     maDatasetInfo

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_1:
        DC32     mNvPendingSavesQueue

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_2:
        DC32     mNvSaveOnIntervalEvent

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_3:
        DC32     mNvModuleInitialized

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_4:
        DC32     NV_STORAGE_MAX_SECTORS

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_5:
        DC32     mNvActivePageId

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_6:
        DC32     NV_STORAGE_END_ADDRESS

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_7:
        DC32     NV_STORAGE_SECTOR_SIZE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_8:
        DC32     mNvErasePgCmdStatus

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_9:
        DC32     gNvCountsBetweenSaves

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_10:
        DC32     mNvSaveOnIntervalTimerID

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_11:
        DC32     gNvMinimumTicksBetweenSaves

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_12:
        DC32     pNVM_DataTable

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_13:
        DC32     mNvCriticalSectionFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_14:
        DC32     mNvCopyOperationIsPending

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_15:
        DC32     mNvConfig

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_16:
        DC32     NvIntervalTimerCallback

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_17:
        DC32     mNvPageCounter

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_18:
        DC32     mNvVirtualPageProperty

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_19:
        DC32     0x3fff0000

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        END
// 4856 
// 4857 /* EOF */
// 4858 
// 
//   446 bytes in section .bss
//    36 bytes in section .data
// 7 616 bytes in section .text
// 
// 7 616 bytes of CODE memory
//   482 bytes of DATA memory
//
//Errors: none
//Warnings: none
