###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        02/Sep/2018  14:19:38
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Generic
#        Services\Source\CommUtil.c
#    Command line =  
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Generic
#        Services\Source\CommUtil.c" -D IAR --preprocess "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\List\" -lC "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\List\" -lB "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\List\" --diag_suppress
#        Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\Obj\" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\CDC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\Descriptor\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\USB\Class\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Sys Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
#    List file    =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\List\CommUtil.lst
#    Object file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\Obj\CommUtil.o
#
###############################################################################

F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\Generic Services\Source\CommUtil.c
      1          /************************************************************************************
      2          * Includes the Comm Utils.
      3          *
      4          * (c) Copyright 2012, Freescale, Inc. All rights reserved.
      5          *
      6          * No part of this document may be reproduced in any form - including copied,
      7          * transcribed, printed or by any electronic means - without specific written
      8          * permission from Freescale Semiconductor.
      9          *
     10          *
     11          ************************************************************************************/
     12          #include "EmbeddedTypes.h"
     13          #include "CommUtil.h"
     14          #include "Utilities_Interface.h"
     15          #include "MsgSystem.h"
     16          /******************************************************************************/
     17          /******************************************************************************/
     18          
     19          /************************************************************************************
     20          *************************************************************************************
     21          * Private macros
     22          *************************************************************************************
     23          ************************************************************************************/
     24          
     25          /************************************************************************************
     26          *************************************************************************************
     27          * Private prototypes
     28          *************************************************************************************/
     29          
     30          /************************************************************************************
     31          *************************************************************************************
     32          * Private type definitions
     33          *************************************************************************************
     34          ************************************************************************************/
     35          
     36          /************************************************************************************
     37          *************************************************************************************
     38          * Public memory declarations
     39          *************************************************************************************
     40          ************************************************************************************/
     41          
     42          /************************************************************************************
     43          *************************************************************************************
     44          * Private memory declarations
     45          *************************************************************************************
     46          ************************************************************************************/
     47          extern uint32_t __region_ROM_start__[];
     48          extern uint32_t __region_ROM_end__[];
     49          /************************************************************************************
     50          *************************************************************************************
     51          * Public functions
     52          *************************************************************************************
     53          ************************************************************************************/
     54          
     55          #if (gComm_Type_d != gNoComm_c)
     56          /************************************************************************************/
     57          #ifndef gUartDefaultBaud_c
     58          #define gUartDefaultBaud_c UartX_DefaultBaud
     59          #endif
     60          
     61          /************************************************************************************/
     62          

   \                                 In section .text, align 2, keep-with-next
     63          void CommUtil_TxCallback(unsigned char const *pBuf)
     64          {
   \                     CommUtil_TxCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     65            if(pBuf != NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD002             BEQ.N    ??CommUtil_TxCallback_0
     66            {
     67              MM_Free((void*)pBuf);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       MM_Free
     68            }
     69            
     70          }
   \                     ??CommUtil_TxCallback_0: (+1)
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
     71          
     72          /************************************************************************************/
     73          

   \                                 In section .text, align 2, keep-with-next
     74          void CommUtil_Tx(uint8_t * pData, uint8_t length)
     75          {
   \                     CommUtil_Tx: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     76            /* wait until module can insert message into Comm buffers */
     77            if ( ((uint32_t)pData > (uint32_t)__region_ROM_start__) &&
     78                      ((uint32_t)pData < (uint32_t)__region_ROM_end__))
   \   00000006   0x....             LDR.N    R0,??DataTable1
   \   00000008   0x42A0             CMP      R0,R4
   \   0000000A   0xD218             BCS.N    ??CommUtil_Tx_0
   \   0000000C   0x....             LDR.N    R0,??DataTable1_1
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD215             BCS.N    ??CommUtil_Tx_0
     79            {
     80              uint8_t* pRam = MM_Alloc(length);
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x.... 0x....      BL       MM_Alloc
   \   0000001A   0x0006             MOVS     R6,R0
     81              if(pRam == NULL)
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD01A             BEQ.N    ??CommUtil_Tx_1
     82              {
     83                return;
     84              }
     85              MemoryCpy( pRam, pData, length );
   \                     ??CommUtil_Tx_2: (+1)
   \   00000020   0x002A             MOVS     R2,R5
   \   00000022   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000024   0x0021             MOVS     R1,R4
   \   00000026   0x0030             MOVS     R0,R6
   \   00000028   0x.... 0x....      BL       MemoryCpy
     86              while(!Comm_Transmit(pRam,(index_t)length,CommUtil_TxCallback));
   \                     ??CommUtil_Tx_3: (+1)
   \   0000002C   0x....             LDR.N    R2,??DataTable1_2
   \   0000002E   0x0029             MOVS     R1,R5
   \   00000030   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000032   0x0030             MOVS     R0,R6
   \   00000034   0x.... 0x....      BL       Uart1_Transmit
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD108             BNE.N    ??CommUtil_Tx_4
   \   0000003C   0xE7F6             B.N      ??CommUtil_Tx_3
     87            }
     88          
     89            else
     90            {
     91              while(!Comm_Transmit(pData,(index_t)length,NULL));
   \                     ??CommUtil_Tx_0: (+1)
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x0029             MOVS     R1,R5
   \   00000042   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       Uart1_Transmit
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD0F7             BEQ.N    ??CommUtil_Tx_0
     92            }
     93            
     94            /* wait until tx complete */
     95            while (Comm_IsTxActive());
   \                     ??CommUtil_Tx_4: (+1)
   \   0000004E   0x.... 0x....      BL       Uart1_IsTxActive
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD1FB             BNE.N    ??CommUtil_Tx_4
     96          }
   \                     ??CommUtil_Tx_1: (+1)
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
     97          
     98          /************************************************************************************/
     99          

   \                                 In section .text, align 2, keep-with-next
    100          void CommUtil_Print(char* pString, commUtilBlock_t allowToBlock)
    101          {
   \                     CommUtil_Print: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    102            uint16_t i = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    103            char *  pTmpString = pString ;
   \   0000000A   0x0026             MOVS     R6,R4
    104          
    105            while (*pTmpString != '\0')
   \                     ??CommUtil_Print_0: (+1)
   \   0000000C   0x7830             LDRB     R0,[R6, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD002             BEQ.N    ??CommUtil_Print_1
    106            {
    107              pTmpString++;
   \   00000012   0x1C76             ADDS     R6,R6,#+1
    108              i++;
   \   00000014   0x1C7F             ADDS     R7,R7,#+1
   \   00000016   0xE7F9             B.N      ??CommUtil_Print_0
    109            }
    110            if(allowToBlock)
   \                     ??CommUtil_Print_1: (+1)
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD005             BEQ.N    ??CommUtil_Print_2
    111            {
    112              /* wait until module can insert message into Comm buffers and until tx completes */
    113          	CommUtil_Tx((uint8_t *)pString,(uint8_t)i);
   \   0000001E   0x0039             MOVS     R1,R7
   \   00000020   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       CommUtil_Tx
   \   00000028   0xE020             B.N      ??CommUtil_Print_3
    114            }
    115            else
    116            {
    117              if ( ((uint32_t)pString > (uint32_t)__region_ROM_start__) &&
    118                      ((uint32_t)pString < (uint32_t)__region_ROM_end__))
   \                     ??CommUtil_Print_2: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable1
   \   0000002C   0x42A0             CMP      R0,R4
   \   0000002E   0xD217             BCS.N    ??CommUtil_Print_4
   \   00000030   0x....             LDR.N    R0,??DataTable1_1
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD214             BCS.N    ??CommUtil_Print_4
    119              {
    120                uint8_t* pRam = MM_Alloc((uint8_t)i);
   \   00000036   0x0038             MOVS     R0,R7
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x.... 0x....      BL       MM_Alloc
   \   0000003E   0x4680             MOV      R8,R0
    121                if(pRam == NULL)
   \   00000040   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000044   0xD012             BEQ.N    ??CommUtil_Print_5
    122                {
    123                  return;
    124                }
    125                MemoryCpy( pRam, pString, (uint8_t)i );
   \                     ??CommUtil_Print_6: (+1)
   \   00000046   0x003A             MOVS     R2,R7
   \   00000048   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000004A   0x0021             MOVS     R1,R4
   \   0000004C   0x4640             MOV      R0,R8
   \   0000004E   0x.... 0x....      BL       MemoryCpy
    126                (void)Comm_Transmit((unsigned char const*)pRam,(index_t)i,CommUtil_TxCallback);
   \   00000052   0x....             LDR.N    R2,??DataTable1_2
   \   00000054   0x0039             MOVS     R1,R7
   \   00000056   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000058   0x4640             MOV      R0,R8
   \   0000005A   0x.... 0x....      BL       Uart1_Transmit
   \   0000005E   0xE005             B.N      ??CommUtil_Print_3
    127              }
    128              else
    129              {
    130                (void)Comm_Transmit((unsigned char const*)pString,(index_t)i,NULL);      
   \                     ??CommUtil_Print_4: (+1)
   \   00000060   0x2200             MOVS     R2,#+0
   \   00000062   0x0039             MOVS     R1,R7
   \   00000064   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0x.... 0x....      BL       Uart1_Transmit
    131              }    
    132          
    133            }
    134          }
   \                     ??CommUtil_Print_3: (+1)
   \                     ??CommUtil_Print_5: (+1)
   \   0000006C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    135          
    136          /************************************************************************************/
    137          

   \                                 In section .text, align 2, keep-with-next
    138          void CommUtil_PrintHex(uint8_t *hex, uint8_t len, uint8_t flags)
    139          {
   \                     CommUtil_PrintHex: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0007             MOVS     R7,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
    140            uint8_t i=0;
   \   0000000A   0x2600             MOVS     R6,#+0
    141            uint8_t hexString[6]; /* 2 bytes  - hexadecimal display
    142                                     1 byte   - separator ( comma)
    143          						   1 byte   - separator ( space)
    144                                     2 bytes  - new line (\n\r)  */
    145          
    146            if(! (flags & gPrtHexBigEndian_c))
   \   0000000C   0x07E8             LSLS     R0,R5,#+31
   \   0000000E   0xD402             BMI.N    ??CommUtil_PrintHex_0
    147             {
    148              hex = hex + (len-1);
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x19E0             ADDS     R0,R4,R7
   \   00000014   0x1E47             SUBS     R7,R0,#+1
    149             }
    150          
    151            while(len)
   \                     ??CommUtil_PrintHex_0: (+1)
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD041             BEQ.N    ??CommUtil_PrintHex_1
    152            {
    153              /* wait until previous hex print transmission is over */
    154              while (Comm_IsTxActive());
   \                     ??CommUtil_PrintHex_2: (+1)
   \   0000001C   0x.... 0x....      BL       Uart1_IsTxActive
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD1FB             BNE.N    ??CommUtil_PrintHex_2
    155          
    156              /* start preparing the print of a new byte */
    157              i=0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x0006             MOVS     R6,R0
    158              hexString[i++] = HexToAscii((*hex)>>4);
   \   00000028   0x7838             LDRB     R0,[R7, #+0]
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x0900             LSRS     R0,R0,#+4
   \   0000002E   0x.... 0x....      BL       HexToAscii
   \   00000032   0xA900             ADD      R1,SP,#+0
   \   00000034   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000036   0x5470             STRB     R0,[R6, R1]
   \   00000038   0x1C76             ADDS     R6,R6,#+1
    159              hexString[i++] = HexToAscii( *hex);
   \   0000003A   0x7838             LDRB     R0,[R7, #+0]
   \   0000003C   0x.... 0x....      BL       HexToAscii
   \   00000040   0xA900             ADD      R1,SP,#+0
   \   00000042   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000044   0x5470             STRB     R0,[R6, R1]
   \   00000046   0x1C76             ADDS     R6,R6,#+1
    160          
    161              if(flags & gPrtHexCommas_c)
   \   00000048   0x0768             LSLS     R0,R5,#+29
   \   0000004A   0xD504             BPL.N    ??CommUtil_PrintHex_3
    162               {
    163                hexString[i++] = ',';
   \   0000004C   0x202C             MOVS     R0,#+44
   \   0000004E   0xA900             ADD      R1,SP,#+0
   \   00000050   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000052   0x5470             STRB     R0,[R6, R1]
   \   00000054   0x1C76             ADDS     R6,R6,#+1
    164               }
    165              if(flags & gPrtHexSpaces_c)
   \                     ??CommUtil_PrintHex_3: (+1)
   \   00000056   0x0728             LSLS     R0,R5,#+28
   \   00000058   0xD504             BPL.N    ??CommUtil_PrintHex_4
    166               {
    167                hexString[i++] = ' ';
   \   0000005A   0x2020             MOVS     R0,#+32
   \   0000005C   0xA900             ADD      R1,SP,#+0
   \   0000005E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000060   0x5470             STRB     R0,[R6, R1]
   \   00000062   0x1C76             ADDS     R6,R6,#+1
    168               }
    169              hex = hex + (flags & gPrtHexBigEndian_c ? 1 : -1);
   \                     ??CommUtil_PrintHex_4: (+1)
   \   00000064   0x07E8             LSLS     R0,R5,#+31
   \   00000066   0xD501             BPL.N    ??CommUtil_PrintHex_5
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0xE001             B.N      ??CommUtil_PrintHex_6
   \                     ??CommUtil_PrintHex_5: (+1)
   \   0000006C   0xF05F 0x30FF      MOVS     R0,#-1
   \                     ??CommUtil_PrintHex_6: (+1)
   \   00000070   0x19C7             ADDS     R7,R0,R7
    170              len--;
   \   00000072   0x1E64             SUBS     R4,R4,#+1
    171          
    172              if((len == 0) && (flags & gPrtHexNewLine_c))
   \   00000074   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000076   0x2C00             CMP      R4,#+0
   \   00000078   0xD10B             BNE.N    ??CommUtil_PrintHex_7
   \   0000007A   0x07A8             LSLS     R0,R5,#+30
   \   0000007C   0xD509             BPL.N    ??CommUtil_PrintHex_7
    173               {
    174                hexString[i++] = '\n';
   \   0000007E   0x200A             MOVS     R0,#+10
   \   00000080   0xA900             ADD      R1,SP,#+0
   \   00000082   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000084   0x5470             STRB     R0,[R6, R1]
   \   00000086   0x1C76             ADDS     R6,R6,#+1
    175                hexString[i++] = '\r';
   \   00000088   0x200D             MOVS     R0,#+13
   \   0000008A   0xA900             ADD      R1,SP,#+0
   \   0000008C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000008E   0x5470             STRB     R0,[R6, R1]
   \   00000090   0x1C76             ADDS     R6,R6,#+1
    176               }
    177               /* transmit formatted byte */
    178              (void)Comm_Transmit((unsigned char const*)hexString,(index_t)i,NULL);
   \                     ??CommUtil_PrintHex_7: (+1)
   \   00000092   0x2200             MOVS     R2,#+0
   \   00000094   0x0031             MOVS     R1,R6
   \   00000096   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000098   0xA800             ADD      R0,SP,#+0
   \   0000009A   0x.... 0x....      BL       Uart1_Transmit
   \   0000009E   0xE7BA             B.N      ??CommUtil_PrintHex_0
    179            }
    180            /* wait to complete the last transmission */
    181            while (Comm_IsTxActive());
   \                     ??CommUtil_PrintHex_1: (+1)
   \   000000A0   0x.... 0x....      BL       Uart1_IsTxActive
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD1FB             BNE.N    ??CommUtil_PrintHex_1
    182            (void)hexString;
   \   000000A8   0xA800             ADD      R0,SP,#+0
    183          }
   \   000000AA   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    184          
    185          /************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    186          void CommUtil_PrintDec(uint32_t nr)
    187          {
   \                     CommUtil_PrintDec: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    188            uint8_t i = gDecStringLen_d-1;
   \   00000004   0x250B             MOVS     R5,#+11
    189            uint8_t decString[gDecStringLen_d];
    190          
    191            if (nr == 0)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD104             BNE.N    ??CommUtil_PrintDec_0
    192            {
    193              decString[i] = '0';
   \   0000000A   0x2030             MOVS     R0,#+48
   \   0000000C   0xA900             ADD      R1,SP,#+0
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x5468             STRB     R0,[R5, R1]
   \   00000012   0xE010             B.N      ??CommUtil_PrintDec_1
    194            }
    195            else
    196            {
    197              while (nr)
   \                     ??CommUtil_PrintDec_0: (+1)
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD00D             BEQ.N    ??CommUtil_PrintDec_2
    198              {
    199                decString[i] = '0' + (uint8_t)(nr % 10);
   \   00000018   0x200A             MOVS     R0,#+10
   \   0000001A   0xFBB4 0xF1F0      UDIV     R1,R4,R0
   \   0000001E   0xFB00 0x4011      MLS      R0,R0,R1,R4
   \   00000022   0x3030             ADDS     R0,R0,#+48
   \   00000024   0xA900             ADD      R1,SP,#+0
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x5468             STRB     R0,[R5, R1]
    200                nr = nr / 10;
   \   0000002A   0x200A             MOVS     R0,#+10
   \   0000002C   0xFBB4 0xF4F0      UDIV     R4,R4,R0
    201                i--;
   \   00000030   0x1E6D             SUBS     R5,R5,#+1
   \   00000032   0xE7EF             B.N      ??CommUtil_PrintDec_0
    202              }
    203              i++;
   \                     ??CommUtil_PrintDec_2: (+1)
   \   00000034   0x1C6D             ADDS     R5,R5,#+1
    204            }
    205          
    206            /* wait to complete the last transmission */
    207            while (Comm_IsTxActive());
   \                     ??CommUtil_PrintDec_1: (+1)
   \   00000036   0x.... 0x....      BL       Uart1_IsTxActive
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD1FB             BNE.N    ??CommUtil_PrintDec_1
    208          
    209             /* transmit formatted byte */
    210            (void)Comm_Transmit((uint8_t*)&decString[i], gDecStringLen_d-i, NULL);
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0xF1D5 0x010C      RSBS     R1,R5,#+12
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000046   0xA800             ADD      R0,SP,#+0
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x1828             ADDS     R0,R5,R0
   \   0000004C   0x.... 0x....      BL       Uart1_Transmit
    211          
    212            /* wait to complete the last transmission */
    213            while (Comm_IsTxActive());
   \                     ??CommUtil_PrintDec_3: (+1)
   \   00000050   0x.... 0x....      BL       Uart1_IsTxActive
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD1FB             BNE.N    ??CommUtil_PrintDec_3
    214            (void)decString;
   \   00000058   0xA800             ADD      R0,SP,#+0
    215          }
   \   0000005A   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     __region_ROM_start__

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     __region_ROM_end__

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x........         DC32     CommUtil_TxCallback
    216          
    217          /************************************************************************************/
    218          
    219          #else /* (gComm_Type_d != gNoComm_c) */
    220          
    221          /************************************************************************************/
    222          /* Create  dummy functions  */
    223          /************************************************************************************/
    224          void CommUtil_Init(pCommRxCallBack_t pCommRxCallBack)
    225          {
    226            (void)pCommRxCallBack;
    227          }
    228          
    229          void CommUtil_Print(uint8_t * pString, commUtilBlock_t allowToBlock)
    230          {
    231            /* Avoid compiler warning */
    232            (void)pString;
    233            (void)allowToBlock;
    234          }
    235          
    236          /************************************************************************************/
    237          
    238          void CommUtil_PrintHex(uint8_t *hex, uint8_t len, uint8_t flags)
    239          {
    240            /* Avoid compiler warning */
    241            (void)hex;
    242            (void)len;
    243            (void)flags;
    244          }
    245          
    246          /************************************************************************************/
    247          
    248          void CommUtil_Tx(uint8_t * pData, uint8_t length){
    249            /* Avoid compiler warning */
    250            (void)pData;
    251            (void)length;
    252          }
    253          
    254          /************************************************************************************/
    255          #endif  /* (gComm_Type_d != gNoComm_c) */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   CommUtil_Print
        24   -> CommUtil_Tx
        24   -> MM_Alloc
        24   -> MemoryCpy
        24   -> Uart1_Transmit
      24   CommUtil_PrintDec
        24   -> Uart1_IsTxActive
        24   -> Uart1_Transmit
      32   CommUtil_PrintHex
        32   -> HexToAscii
        32   -> Uart1_IsTxActive
        32   -> Uart1_Transmit
      16   CommUtil_Tx
        16   -> MM_Alloc
        16   -> MemoryCpy
        16   -> Uart1_IsTxActive
        16   -> Uart1_Transmit
       8   CommUtil_TxCallback
         8   -> MM_Free


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
     112  CommUtil_Print
      92  CommUtil_PrintDec
     172  CommUtil_PrintHex
      88  CommUtil_Tx
      16  CommUtil_TxCallback

 
 492 bytes in section .text
 
 492 bytes of CODE memory

Errors: none
Warnings: none
