///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM       02/Sep/2018  14:19:43
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\Common\usb_class.c
//    Command line =  
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\Common\usb_class.c" -D IAR --preprocess
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\" -lC
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\" -lB
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\"
//        --diag_suppress Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\Obj\" --no_cse
//        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
//        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\APP\CDC\" -I "F:\Guardrail Work\Sensor Code\Git
//        Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\USB\APP\Descriptor\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Class\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Sys Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
//    List file    =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\usb_class.s
//
///////////////////////////////////////////////////////////////////////////////

        #define SHT_PROGBITS 0x1

        EXTERN IntDisableAll
        EXTERN IntRestoreAll
        EXTERN USB_Desc_RemoteWakeup
        EXTERN USB_DeviceAssertResume
        EXTERN USB_DeviceDeinitEndpoint
        EXTERN USB_DeviceGetStatus
        EXTERN USB_DeviceInitEndpoint
        EXTERN USB_DeviceRegisterService
        EXTERN USB_DeviceSendData
        EXTERN USB_DeviceSetStatus
        EXTERN USB_Framework_DeInit
        EXTERN USB_Framework_Init
        EXTERN gpaUsbClassDescriptor
        EXTERN gpfClassFrameworkCallback

        PUBLIC USB_ClassDeInit
        PUBLIC USB_ClassInit
        PUBLIC USB_ClassSendData_

// F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\usb_class.c
//    1 /******************************************************************************
//    2  *
//    3  * Freescale Semiconductor Inc.
//    4  * (c) Copyright 2004-2010 Freescale Semiconductor, Inc.
//    5  * ALL RIGHTS RESERVED.
//    6  *
//    7  ******************************************************************************
//    8  *
//    9  * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR 
//   10  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
//   11  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
//   12  * IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
//   13  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
//   14  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
//   15  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
//   16  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
//   17  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
//   18  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
//   19  * THE POSSIBILITY OF SUCH DAMAGE.
//   20  *
//   21  **************************************************************************//*!
//   22  *
//   23  * @file usb_class.c
//   24  *
//   25  * @author
//   26  *
//   27  * @version
//   28  *
//   29  * @date
//   30  *
//   31  * @brief The file contains USB stack Class module implementation.
//   32  *
//   33  *****************************************************************************/
//   34 
//   35 /******************************************************************************
//   36  * Includes
//   37  *****************************************************************************/
//   38 #include "USB_Configuration.h"  
//   39 #include "usb_class.h"      /* USB class Header File */
//   40 #include "usb_dciapi.h"   
//   41 #include "usb_devapi.h"     /* USB device Header file */
//   42 #include "usb_framework.h"  /* USB framework module header file */
//   43 #include "USB.h"
//   44 #include "Interrupt.h"   
//   45 
//   46 #if gUsbIncluded_d
//   47 
//   48 /*****************************************************************************
//   49  * Constant and Macro's
//   50  *****************************************************************************/
//   51 
//   52 /****************************************************************************
//   53  * Global Variables
//   54  ****************************************************************************/
//   55  /* Class callback pointer */
//   56  #define  gapfClassCallback(controller_ID) gpfClassFrameworkCallback
//   57 /* save the device state before device goes to suspend state */

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
//   58 static uint16_t gaDeviceStateBeforeSuspend[gNumUsbControllers_d];
gaDeviceStateBeforeSuspend:
        DS8 2
//   59 /*****************************************************************************
//   60  * Local Types - None
//   61  *****************************************************************************/
//   62 
//   63 /*****************************************************************************
//   64  * Local Functions Prototypes
//   65  *****************************************************************************/
//   66 static void USB_Service_Suspend (usbDeviceEvent_t * event );
//   67 static void USB_Service_Resume (usbDeviceEvent_t * event );
//   68 static void USB_Service_Stall (usbDeviceEvent_t * event );
//   69 static void USB_Service_SOF (usbDeviceEvent_t * event );
//   70 static void USB_Service_Reset (usbDeviceEvent_t * event );
//   71 static void USB_Service_Error (usbDeviceEvent_t * event );
//   72 
//   73 /*****************************************************************************
//   74  * Local Variables
//   75  *****************************************************************************/
//   76 
//   77  /*****************************************************************************
//   78  * Local Functions - None
//   79  *****************************************************************************/
//   80 
//   81 /*****************************************************************************
//   82  * Global Functions
//   83  *****************************************************************************/
//   84 /**************************************************************************//*!
//   85  *
//   86  * @name  USB_Service_Suspend
//   87  *
//   88  * @brief The funtion is called when host suspends the USB port
//   89  *
//   90  * @param event     : Pointer to USB Event Structure
//   91  *
//   92  * @return None
//   93  ******************************************************************************
//   94  * Sets the device state as gUsbDeviceState_Suspend_d
//   95  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//   96 static void USB_Service_Suspend (
//   97     usbDeviceEvent_t * event /* [IN] Pointer to USB Event Structure */
//   98 )
//   99 {
USB_Service_Suspend:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
//  100 #if  gUsbAppNotificationOnSuspend_d
//  101   usbMsg_t usbMsg;  
//  102 #endif
//  103   /* Get the status of the device before suspend, so that on resume we can get back to the same state */
//  104   (void)USB_DeviceGetStatus(event->controllerId,gUsbComponentStatus_DeviceState_d, &gaDeviceStateBeforeSuspend[event->controllerId]);
        LDR.N    R0,??DataTable6
        LDRB     R1,[R4, #+0]
        ADDS     R2,R0,R1, LSL #+1
        MOVS     R1,#+1
        LDRB     R0,[R4, #+0]
        BL       USB_DeviceGetStatus
        MOVS     R5,R0
//  105   /* Set the device state in the Device Layer to SUSPEND */
//  106   (void)USB_DeviceSetStatus(event->controllerId, gUsbComponentStatus_DeviceState_d,gUsbDeviceState_Suspend_d);
        MOVS     R2,#+128
        MOVS     R1,#+1
        LDRB     R0,[R4, #+0]
        BL       USB_DeviceSetStatus
//  107 #if  gUsbAppNotificationOnSuspend_d
//  108   usbMsg.controllerId = event->controllerId;
//  109   usbMsg.eventType = gUsbToAppEvent_Suspend_c;
//  110   gapfClassCallback(event->controllerId)(event->controllerId, gUsbToAppEvent_Suspend_c, &usbMsg);
//  111 #endif  
//  112 }
        POP      {R0,R4,R5,PC}    ;; return
//  113 
//  114 /**************************************************************************//*!
//  115  *
//  116  * @name  USB_Service_Resume
//  117  *
//  118  * @brief The funtion is called when host resumes the USB port
//  119  *
//  120  * @param event     : Pointer to USB Event Structure
//  121  *
//  122  * @return None
//  123  ******************************************************************************
//  124  * Restore the state of the device before suspend
//  125  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  126 static void USB_Service_Resume (
//  127     usbDeviceEvent_t * event /* [IN] Pointer to USB Event Structure */
//  128 )
//  129 {
USB_Service_Resume:
        PUSH     {R4,LR}
        SUB      SP,SP,#+8
        MOVS     R4,R0
//  130   uint16_t deviceState;
//  131   (void)USB_DeviceGetStatus(event->controllerId, gUsbComponentStatus_DeviceState_d,&deviceState);
        ADD      R2,SP,#+0
        MOVS     R1,#+1
        LDRB     R0,[R4, #+0]
        BL       USB_DeviceGetStatus
//  132   if(deviceState == gUsbDeviceState_Suspend_d)
        LDRH     R1,[SP, #+0]
        CMP      R1,#+128
        BNE.N    ??USB_Service_Resume_0
//  133   {
//  134     /*Set the device state in the Device Layer to the state before suspend */
//  135     (void)USB_DeviceSetStatus(event->controllerId,
//  136             gUsbComponentStatus_DeviceState_d, gaDeviceStateBeforeSuspend[event->controllerId]);
        LDR.N    R0,??DataTable6
        LDRB     R1,[R4, #+0]
        LDRH     R2,[R0, R1, LSL #+1]
        MOVS     R1,#+1
        LDRB     R0,[R4, #+0]
        BL       USB_DeviceSetStatus
//  137   }
//  138 }
??USB_Service_Resume_0:
        POP      {R0,R1,R4,PC}    ;; return
//  139 
//  140 /**************************************************************************//*!
//  141  *
//  142  * @name  USB_Service_Stall
//  143  *
//  144  * @brief The funtion is called when endpoint is stalled
//  145  *
//  146  * @param event: Pointer to USB Event Structure
//  147  *
//  148  * @return None
//  149  ******************************************************************************
//  150  * This function sends STALL Packet for the endpoint to be stalled. Also, sets
//  151  * the status of Endpoint as STALLED
//  152  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  153 static void USB_Service_Stall (
//  154     usbDeviceEvent_t * event /* [IN] Pointer to USB Event Structure */
//  155 )
//  156 {
USB_Service_Stall:
        PUSH     {R4,LR}
        MOVS     R4,R0
//  157   if(event->epNum == gUsbControlEndpoint_d)
        LDRB     R0,[R4, #+1]
        CMP      R0,#+0
        BNE.N    ??USB_Service_Stall_0
//  158   {
//  159   /* Update the Endpoint Status in the Device Layer to Idle */
//  160   (void)USB_DeviceSetStatus(event->controllerId,
//  161             (uint8_t)(gUsbComponentStatus_Endpoint_d | gUsbControlEndpoint_d |
//  162             (event->direction << gUsbComponent_DirectionShift_d)),
//  163             (uint16_t)gUsbStatus_Idle_d);
        MOVS     R2,#+0
        LDRB     R0,[R4, #+3]
        LSLS     R0,R0,#+7
        ORRS     R1,R0,#0x10
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R0,[R4, #+0]
        BL       USB_DeviceSetStatus
//  164   }
//  165   return;
??USB_Service_Stall_0:
        POP      {R4,PC}          ;; return
//  166 }
//  167 
//  168 /**************************************************************************//*!
//  169  *
//  170  * @name  USB_Service_SOF
//  171  *
//  172  * @brief The funtion is called when SOF flag is set (from ISR)
//  173  *
//  174  * @param event: Pointer to USB Event Structure
//  175  *
//  176  * @return None
//  177  ******************************************************************************
//  178  * This function is called when SOF token is received by controller. Updates
//  179  * SOF Count status.
//  180  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  181 static void USB_Service_SOF (
//  182     usbDeviceEvent_t * event     /* [IN] Pointer to USB Event Structure */
//  183 )
//  184 {
USB_Service_SOF:
        PUSH     {R4-R6,LR}
        SUB      SP,SP,#+8
        MOVS     R4,R0
//  185   uint16_t sofCount,deviceState;
//  186   uint8_t i;
//  187   /* update SOF */
//  188   sofCount = *((uint16_t*)event->pBuffer);
        LDR      R0,[R4, #+4]
        LDRH     R0,[R0, #+0]
        MOVS     R5,R0
//  189   /* write SOF to status */
//  190   for(i=0 ; i< gNumUsbControllers_d ; i++)
        MOVS     R0,#+0
        MOVS     R6,R0
??USB_Service_SOF_0:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BNE.N    ??USB_Service_SOF_1
//  191   {
//  192     (void)USB_DeviceGetStatus( i , gUsbComponentStatus_DeviceState_d, &deviceState);
        ADD      R2,SP,#+0
        MOVS     R1,#+1
        MOVS     R0,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceGetStatus
//  193     if(deviceState < gUsbDeviceState_Suspend_d)
        LDRH     R1,[SP, #+0]
        CMP      R1,#+128
        BGE.N    ??USB_Service_SOF_2
//  194     {
//  195       (void)USB_DeviceSetStatus( i , gUsbComponentStatus_SOFCount_d , sofCount);   
        MOVS     R2,R5
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        MOVS     R1,#+5
        MOVS     R0,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceSetStatus
//  196     }
//  197   }
??USB_Service_SOF_2:
        ADDS     R6,R6,#+1
        B.N      ??USB_Service_SOF_0
//  198   return;
??USB_Service_SOF_1:
        POP      {R0,R1,R4-R6,PC}  ;; return
//  199 }
//  200 /**************************************************************************//*!
//  201  *
//  202  * @name  USB_Service_Reset
//  203  *
//  204  * @brief The funtion is called upon a bus reset event.
//  205               Initializes the control endpoint.
//  206  *
//  207  * @param event: Pointer to USB Event Structure
//  208  *
//  209  * @return None
//  210  ******************************************************************************
//  211  * Reset Callback function. This function re-initializes CONTROL Endpoint
//  212  *****************************************************************************/
//  213 
//  214 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  215 static void USB_Service_Reset 
//  216 (
//  217     usbDeviceEvent_t * event  /* [IN] Pointer to USB Event Structure */
//  218 )
//  219 {
USB_Service_Reset:
        PUSH     {R4-R11,LR}
        SUB      SP,SP,#+28
        MOVS     R4,R0
//  220   usbEpStruct_t epStruct;
//  221   usbMsg_t usbMsg;
//  222 
//  223   /* Initialize the endpoint 0 in both directions */
//  224   epStruct.direction = gUsbEpDirection_In_c;
        MOVS     R0,#+1
        STRB     R0,[SP, #+2]
//  225   epStruct.number = gUsbControlEndpoint_d;
        MOVS     R0,#+0
        STRB     R0,[SP, #+0]
//  226   epStruct.size = gpaUsbClassDescriptor[event->controllerId]->controlEpSize;
        LDR.N    R0,??DataTable6_1
        LDRB     R1,[R4, #+0]
        LDR      R0,[R0, R1, LSL #+2]
        LDRB     R0,[R0, #+40]
        STRH     R0,[SP, #+4]
//  227   epStruct.type = gUsbEpType_Control_c;
        MOVS     R0,#+0
        STRB     R0,[SP, #+1]
//  228   /* Deinit Endpoint in case its already initialized */
//  229   (void)USB_DeviceDeinitEndpoint(event->controllerId , epStruct.number, epStruct.direction);
        LDRB     R2,[SP, #+2]
        LDRB     R1,[SP, #+0]
        LDRB     R0,[R4, #+0]
        BL       USB_DeviceDeinitEndpoint
        MOVS     R5,R0
//  230   epStruct.direction = gUsbEpDirection_Out_c;
        MOVS     R0,#+0
        STRB     R0,[SP, #+2]
//  231   (void)USB_DeviceDeinitEndpoint(event->controllerId,	epStruct.number, epStruct.direction);
        LDRB     R2,[SP, #+2]
        LDRB     R1,[SP, #+0]
        LDRB     R0,[R4, #+0]
        BL       USB_DeviceDeinitEndpoint
        MOVS     R6,R0
//  232    /* now initialize the endpoint */
//  233   epStruct.direction = gUsbEpDirection_In_c;	
        MOVS     R0,#+1
        STRB     R0,[SP, #+2]
//  234   (void)USB_DeviceInitEndpoint(event->controllerId, &epStruct, TRUE);
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        LDRB     R0,[R4, #+0]
        BL       USB_DeviceInitEndpoint
        MOVS     R7,R0
//  235   epStruct.direction = gUsbEpDirection_Out_c;
        MOVS     R0,#+0
        STRB     R0,[SP, #+2]
//  236   (void)USB_DeviceInitEndpoint(event->controllerId, &epStruct, TRUE);
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        LDRB     R0,[R4, #+0]
        BL       USB_DeviceInitEndpoint
        MOV      R8,R0
//  237   /* set the default device state */
//  238   (void)USB_DeviceSetStatus(event->controllerId , gUsbComponentStatus_DeviceState_d , gUsbDeviceState_Default_d);
        MOVS     R2,#+2
        MOVS     R1,#+1
        LDRB     R0,[R4, #+0]
        BL       USB_DeviceSetStatus
        MOV      R9,R0
//  239   /* set the default device state */
//  240   (void)USB_DeviceSetStatus(event->controllerId, gUsbComponentStatus_Device_d, gbmUsbAttributes_SelfPowered_d >> gUsbSelfPoweredBitShift_d);
        MOVS     R2,#+1
        MOVS     R1,#+6
        LDRB     R0,[R4, #+0]
        BL       USB_DeviceSetStatus
        MOV      R10,R0
//  241   // gbmUsbAttributes_SelfPowered_d must be moved in usbClassDescriptor_t
//  242   /* set the EndPoint Status as Idle in the device layer */
//  243   (void)USB_DeviceSetStatus(event->controllerId,
//  244         (uint8_t)(gUsbComponentStatus_Endpoint_d | gUsbControlEndpoint_d |
//  245         (gUsbEpDirection_In_c << gUsbComponent_DirectionShift_d)),
//  246         gUsbStatus_Idle_d);
        MOVS     R2,#+0
        MOVS     R1,#+144
        LDRB     R0,[R4, #+0]
        BL       USB_DeviceSetStatus
        MOV      R11,R0
//  247   /* let the application know that bus reset has taken place */
//  248   usbMsg.controllerId = event->controllerId;
        LDRB     R0,[R4, #+0]
        STRB     R0,[SP, #+8]
//  249   usbMsg.eventType = gUsbToAppEvent_BusReset_c;
        MOVS     R0,#+0
        STRB     R0,[SP, #+9]
//  250   gapfClassCallback(event->controllerId)(event->controllerId, gUsbToAppEvent_BusReset_c, &usbMsg);
        ADD      R2,SP,#+8
        MOVS     R1,#+0
        LDRB     R0,[R4, #+0]
        LDR.N    R3,??DataTable6_2
        LDR      R3,[R3, #+0]
        BLX      R3
//  251   return;
        ADD      SP,SP,#+28
        POP      {R4-R11,PC}      ;; return
//  252 }
//  253 
//  254 /**************************************************************************//*!
//  255  *
//  256  * @name  USB_Service_Error
//  257  *
//  258  * @brief The funtion is called when an error has been detected
//  259  *
//  260  * @param event: Pointer to USB Event Structure
//  261  *
//  262  * @return None
//  263  ******************************************************************************
//  264  * Calls application with the error code received from the lower layer
//  265  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  266 static void USB_Service_Error (
//  267     usbDeviceEvent_t * event /* [IN] Pointer to USB Event Structure */
//  268 )
//  269 {
USB_Service_Error:
        PUSH     {R0-R4,LR}
        MOVS     R4,R0
//  270   /* notify the application of the error */
//  271   usbMsg_t usbMsg;
//  272   usbMsg.controllerId = event->controllerId;
        LDRB     R0,[R4, #+0]
        STRB     R0,[SP, #+0]
//  273   usbMsg.eventType = gUsbToAppEvent_Error_c;
        MOVS     R0,#+5
        STRB     R0,[SP, #+1]
//  274   usbMsg.eventParam.errorEvent.errors = event->errors;
        LDRB     R0,[R4, #+10]
        STRB     R0,[SP, #+4]
//  275   gapfClassCallback(event->controllerId)(event->controllerId, gUsbToAppEvent_Error_c,&usbMsg);
        ADD      R2,SP,#+0
        MOVS     R1,#+5
        LDRB     R0,[R4, #+0]
        LDR.N    R3,??DataTable6_2
        LDR      R3,[R3, #+0]
        BLX      R3
//  276   return;
        POP      {R0-R4,PC}       ;; return
//  277 }
//  278 
//  279 
//  280 /**************************************************************************//*!
//  281  *
//  282  * @name  USB_ClassInit
//  283  *
//  284  * @brief The funtion initializes the Class Module
//  285  *
//  286  * @param controller_ID         : Controller ID
//  287  * @param class_callback        : Class callback
//  288  * @param other_req_callback    : Other Requests Callback
//  289  *
//  290  * @return status
//  291  *         gUsbErr_NoError_c           : When Successfull
//  292  *         Others           : Errors
//  293  ******************************************************************************
//  294  * Initializes USB Class Module
//  295  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  296 uint8_t USB_ClassInit (
//  297     uint8_t    controllerId,                /* [IN] Controller ID */
//  298     pfUsbToAppEventHandler_t classCallback,      /* [IN] Class Callback */
//  299     pfusbReqHandler_t       otherReqCallback   /* [IN] Other Requests Callback */
//  300 )
//  301 {
USB_ClassInit:
        PUSH     {R3-R7,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
//  302   uint8_t status = USB_Framework_Init(controllerId , classCallback , otherReqCallback);
        MOVS     R2,R6
        MOVS     R1,R5
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_Framework_Init
        MOVS     R7,R0
//  303   /* save callback address */
//  304   gapfClassCallback(controllerId) = classCallback;
        LDR.N    R0,??DataTable6_2
        STR      R5,[R0, #+0]
//  305   if(status == gUsbErr_NoError_c)
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+0
        BNE.N    ??USB_ClassInit_0
//  306   {
//  307     /* Register all the services here */
//  308     status |= USB_DeviceRegisterService(controllerId , gUsbService_BusReset_d , USB_Service_Reset);
        LDR.N    R2,??DataTable6_3
        MOVS     R1,#+16
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceRegisterService
        ORRS     R0,R0,R7
        MOVS     R7,R0
//  309     status |= USB_DeviceRegisterService(controllerId , gUsbService_SOF_d , USB_Service_SOF);
        LDR.N    R2,??DataTable6_4
        MOVS     R1,#+17
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceRegisterService
        ORRS     R0,R0,R7
        MOVS     R7,R0
//  310     status |= USB_DeviceRegisterService(controllerId , gUsbService_Sleep_d , USB_Service_Suspend);
        LDR.N    R2,??DataTable6_5
        MOVS     R1,#+19
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceRegisterService
        ORRS     R0,R0,R7
        MOVS     R7,R0
//  311     status |= USB_DeviceRegisterService(controllerId , gUsbService_Resume_d,USB_Service_Resume);
        LDR.N    R2,??DataTable6_6
        MOVS     R1,#+18
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceRegisterService
        ORRS     R0,R0,R7
        MOVS     R7,R0
//  312     status |= USB_DeviceRegisterService(controllerId , gUsbService_Stall_d , USB_Service_Stall);
        LDR.N    R2,??DataTable6_7
        MOVS     R1,#+21
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceRegisterService
        ORRS     R0,R0,R7
        MOVS     R7,R0
//  313     status |= USB_DeviceRegisterService(controllerId , gUsbService_Error_d , USB_Service_Error);
        LDR.N    R2,??DataTable6_8
        MOVS     R1,#+20
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceRegisterService
        ORRS     R0,R0,R7
        MOVS     R7,R0
//  314      /* set the device state as powered */
//  315     (void)USB_DeviceSetStatus(controllerId , gUsbComponentStatus_DeviceState_d , gUsbDeviceState_Powered_d);
        MOVS     R2,#+3
        MOVS     R1,#+1
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceSetStatus
//  316     gaDeviceStateBeforeSuspend[controllerId] = gUsbDeviceState_Powered_d;
        MOVS     R1,#+3
        LDR.N    R2,??DataTable6
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        STRH     R1,[R2, R4, LSL #+1]
//  317   }
//  318   return status;
??USB_ClassInit_0:
        MOVS     R0,R7
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R1,R4-R7,PC}    ;; return
//  319 }
//  320 
//  321 /**************************************************************************//*!
//  322  *
//  323  * @name  USB_ClassDeInit
//  324  *
//  325  * @brief The funtion De-initializes the Class Module
//  326  *
//  327  * @param controller_ID         : Controller ID
//  328  *
//  329  * @return status
//  330  *         gUsbErr_NoError_c           : When Successfull
//  331  *         Others           : Errors
//  332  ******************************************************************************
//  333  * De-initializes USB Class Module
//  334  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  335 uint8_t USB_ClassDeInit 
//  336 (
//  337     uint8_t    controllerId          /* [IN] Controller ID */
//  338 ) 
//  339 {
USB_ClassDeInit:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
//  340   uint8_t status = gUsbErr_NoError_c;
        MOVS     R5,#+0
//  341   status = USB_Framework_DeInit(controllerId);    
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_Framework_DeInit
        MOVS     R5,R0
//  342   /* Free class_callback */
//  343   gapfClassCallback(controllerId) = NULL;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable6_2
        STR      R0,[R1, #+0]
//  344   return status;
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R1,R4,R5,PC}    ;; return
//  345 }
//  346 
//  347 /**************************************************************************//*!
//  348  *
//  349  * @name  USB_ClassSendData
//  350  *
//  351  * @brief The funtion calls the device to send data upon recieving an IN token
//  352  *
//  353  * @param controller_ID     : Controller ID
//  354  * @param ep_num            : Endpoint number
//  355  * @param buff_ptr          : Buffer to send
//  356  * @param size              : Length of transfer
//  357  *
//  358  * @return status
//  359  *         gUsbErr_NoError_c           : When Successfull
//  360  *         Others           : Errors
//  361  ******************************************************************************
//  362  * Used by Application to send Data on USB Bus if not suspended
//  363  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  364 uint8_t USB_ClassSendData_ (
//  365     uint8_t           controllerId, /* [IN] Controller ID */
//  366     uint8_t           epNum,        /* [IN] Endpoint number */
//  367     uint8_t*          pBuff,      /* [IN] Buffer to send */
//  368     usbPacketSize_t   size  ,         /* [IN] Length of the transfer */
//  369     bool_t            sendShort
//  370 )
//  371 {
USB_ClassSendData_:
        PUSH     {R4-R11,LR}
        SUB      SP,SP,#+12
        MOVS     R5,R0
        MOVS     R6,R1
        MOVS     R7,R2
        MOV      R8,R3
        LDR      R4,[SP, #+48]
//  372   uint8_t status = gUsbErr_NoError_c;
        MOVS     R9,#+0
//  373   uint16_t deviceState, state;
//  374   uint32_t ccr;
//  375   if(controllerId >= gNumUsbControllers_d)
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BEQ.N    ??USB_ClassSendData__0
//  376   {
//  377     return gUsbErr_InvalidParam_c;
        MOVS     R0,#+208
        B.N      ??USB_ClassSendData__1
//  378   }
//  379   //USB_Lock();  
//  380   ccr = IntDisableAll();
??USB_ClassSendData__0:
        BL       IntDisableAll
        MOV      R10,R0
//  381   (void)USB_DeviceGetStatus(controllerId , gUsbComponentStatus_DeviceState_d , &deviceState);
        ADD      R2,SP,#+4
        MOVS     R1,#+1
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceGetStatus
        MOV      R11,R0
//  382   (void)USB_DeviceGetStatus(controllerId , gUsbComponentStatus_Device_d , &state);
        ADD      R2,SP,#+6
        MOVS     R1,#+6
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceGetStatus
//  383   if((deviceState == gUsbDeviceState_Suspend_d) && 
//  384            (state & gUsbRemoteWakeupStatusMask_d ) && 
//  385            (USB_Framework_RemoteWakeup(controllerId) == TRUE))
        LDRH     R1,[SP, #+4]
        CMP      R1,#+128
        BNE.N    ??USB_ClassSendData__2
        LDRH     R0,[SP, #+6]
        LSLS     R0,R0,#+30
        BPL.N    ??USB_ClassSendData__2
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_Desc_RemoteWakeup
        CMP      R0,#+1
        BNE.N    ??USB_ClassSendData__2
//  386   {
//  387     /* Resume the bus */
//  388       USB_DeviceAssertResume(controllerId);    
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceAssertResume
//  389       deviceState = gaDeviceStateBeforeSuspend[controllerId];
        LDR.N    R0,??DataTable6
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        LDRH     R0,[R0, R5, LSL #+1]
        STRH     R0,[SP, #+4]
//  390     /* Set the device state in the Device Layer to DEFAULT */
//  391       (void)USB_DeviceSetStatus(controllerId,gUsbComponentStatus_DeviceState_d, gaDeviceStateBeforeSuspend[controllerId]);
        LDR.N    R0,??DataTable6
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        LDRH     R2,[R0, R5, LSL #+1]
        MOVS     R1,#+1
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceSetStatus
//  392     
//  393 	}
//  394   if(deviceState != gUsbDeviceState_Suspend_d)
??USB_ClassSendData__2:
        LDRH     R0,[SP, #+4]
        CMP      R0,#+128
        BEQ.N    ??USB_ClassSendData__3
//  395   {
//  396     /* if not suspended */
//  397     status = USB_DeviceSendData(controllerId, epNum, pBuff, size, sendShort);
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        STR      R4,[SP, #+0]
        MOV      R3,R8
        UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
        MOVS     R2,R7
        MOVS     R1,R6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceSendData
        MOV      R9,R0
//  398   }
//  399  // USB_UnLock();
//  400   IntRestoreAll(ccr);
??USB_ClassSendData__3:
        MOV      R0,R10
        BL       IntRestoreAll
//  401   return status;
        MOV      R0,R9
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
??USB_ClassSendData__1:
        POP      {R1-R11,PC}      ;; return
//  402  }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6:
        DC32     gaDeviceStateBeforeSuspend

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6_1:
        DC32     gpaUsbClassDescriptor

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6_2:
        DC32     gpfClassFrameworkCallback

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6_3:
        DC32     USB_Service_Reset

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6_4:
        DC32     USB_Service_SOF

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6_5:
        DC32     USB_Service_Suspend

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6_6:
        DC32     USB_Service_Resume

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6_7:
        DC32     USB_Service_Stall

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6_8:
        DC32     USB_Service_Error

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        END
//  403 
//  404 
//  405 
//  406 #endif // gUsbIncluded_d
// 
//   2 bytes in section .bss
// 782 bytes in section .text
// 
// 782 bytes of CODE memory
//   2 bytes of DATA memory
//
//Errors: none
//Warnings: none
