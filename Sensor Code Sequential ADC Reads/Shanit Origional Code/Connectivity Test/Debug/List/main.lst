###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        02/Sep/2018  14:19:39
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\Application\Source\main.c
#    Command line =  
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\Application\Source\main.c" -D IAR --preprocess "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\List\" -lC "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\List\" -lB "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\List\" --diag_suppress
#        Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\Obj\" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\CDC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\Descriptor\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\USB\Class\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Sys Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
#    List file    =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\List\main.lst
#    Object file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\Obj\main.o
#
###############################################################################

F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\Application\Source\main.c
      1          /*****************************************************************************
      2          * Connectivity test demo main file.
      3          * 
      4          * Copyright (c) 2012, Freescale, Inc. All rights reserved.
      5          *
      6          * 
      7          * No part of this document must be reproduced in any form - including copied,
      8          * transcribed, printed or by any electronic means - without specific written
      9          * permission from Freescale Semiconductor.
     10          *
     11          *  The Connectivity Test Demo  is  mainly  used  to perform radio performance 
     12          *  test in hardware for wireless implementations. It allows users to exercise 
     13          *  all the radio functionality and to get results for some important wireless 
     14          *  tests as Packet Error Rate and Range test.
     15          *  
     16          *  The main functions provided by Connectivity test are:
     17          *  - Perform Range test.
     18          *  - Perform Packet Error Rate test.
     19          *  - Manage radio parameters as Channel, Power and Crystal Trim.
     20          *  - Perform Radio Tests as Continuous Modulated TX, Continuous PRBS9 packets 
     21          *    Tx, Un-modulated TX, Continuous Rx and Channel energy Detect.
     22          *  - Manage to read and write radio registers by address.
     23          *
     24          *****************************************************************************/
     25          
     26          #include "ApplicationConf.h"             /*Defines the Application default parameters*/
     27          #include "SMAC.h"
     28          #include <stdio.h>
     29          #include <stdlib.h>
     30          #include <string.h>
     31          
     32          /************************************************************************************
     33          *************************************************************************************
     34          * Private prototypes 
     35          *************************************************************************************
     36          ************************************************************************************/
     37          static void InitProject(void);
     38          void InitSmac(void);
     39          static void PrintTestParameters(bool_t bEraseLine);
     40          static void SerialUIStateMachine(void);
     41          static bool_t SerialContinuousTxRxTest(void);
     42          static bool_t PacketErrorRateTx(void);
     43          static bool_t PacketErrorRateRx(void);
     44          static void SetRadioRxOnTimeOut15ms(void);
     45          static void SetRadioRxOnNoTimeOut(void);
     46          static void PrintPerRxFinalLine(uint16_t u16Received, uint16_t u16Total);
     47          static bool_t RangeTx(void);
     48          static bool_t RangeRx(void);
     49          
     50          static bool_t EditRegisters(void);
     51          static bool_t OverrideDirectRegisters(void);
     52          static bool_t OverrideIndirectRegisters(void);
     53          static bool_t ReadDirectRegisters(void);
     54          static bool_t ReadIndirectRegisters(void);
     55          

   \                                 In section .data, align 1
     56          tmrTimerID_t mLEDTimerID_1 = gTmrInvalidTimerID_c;
   \                     mLEDTimerID_1:
   \   00000000   0xFF               DC8 255

   \                                 In section .data, align 1
     57          tmrTimerID_t mBufferTimerID = gTmrInvalidTimerID_c;
   \                     mBufferTimerID:
   \   00000000   0xFF               DC8 255

   \                                 In section .data, align 2
     58          uint16_t mLEDInterval1_c = 1150;
   \                     mLEDInterval1_c:
   \   00000000   0x047E             DC16 1150

   \                                 In section .data, align 1
     59          uint8_t mBufferInterval_c = 1;
   \                     mBufferInterval_c:
   \   00000000   0x01               DC8 1
     60          
     61          void MLMEScanConfirm(channels_t ClearestChann);
     62          void MLMEResetIndication(void);
     63          void MLMEWakeConfirm(void);
     64          void CommRxCallback();
     65          void ShortCutsParser(uint8_t u8CommData);
     66          void CommTxCallback(void);
     67          void MCPSDataConfirm(txStatus_t TransmissionResult);
     68          void MCPSDataIndication(rxPacket_t *gsRxPacket);
     69          void GlobalDataInit(void);
     70          /* Place your callbacks prototypes declarations here */
     71          void InitPacket();
     72          smacErrors_t SendASCIIPacket();
     73          smacErrors_t SendBinaryPacket();
     74          void ReceivePacket();
     75          void PrintPacketID(uint16_t packetID);
     76          void CopyBinaryPacketToSMAC();
     77          void SndSwapEndianness();
     78          void PngSwapEndianness();
     79          void OptSwapEndianness(tOptions* opt);
     80          void GetFactoryOptions(tOptions *pOptions);
     81          void FlashSaveOptions();
     82          void ChangeOptions(tOptions* pOptions);
     83          int ValidateOptions(tOptions *pOptions);
     84          smacErrors_t SendCurrentOptions();
     85          void CopyOptPacketToSMAC();
     86          void CopyOptionsFromRecvPacket(tOptions* pOptions);
     87          void CopyPngPacketToSMAC();
     88          uint8_t ChooseBestChannel();
     89          uint8_t GetRandomNibble();
     90          int8_t GetLinkQdBm();
     91          /************************************************************************************
     92          *************************************************************************************
     93          * Module Constants
     94          *************************************************************************************
     95          ************************************************************************************/
     96          /*initilize the functions to turn on and off the power to the Accel Module*/
     97          #define AccellPowerOn()         (gLED_PortDataSetReg_c |= gAccelPower);
     98          #define AccellEnableOn()         (gLED_PortDataSetReg_c |= gAccelEnable);
     99          
    100          /*initilize the functions that will turn on the power to teh accell module */
    101          #define AccellPowerOff()        (gLED_PortDataClearReg_c |= gAccelPower);
    102          #define AccellEnableOff()          (gLED_PortDataClearReg_c |= gAccelEnable);
    103          
    104          /************************************************************************************
    105          *************************************************************************************
    106          * Public memory declarations
    107          *************************************************************************************
    108          ************************************************************************************/
    109          
    110          #if (TRUE == gEnableConfigMenus_d)

   \                                 In section .bss, align 1
    111            wuConfigState_t gConfigState;
   \                     gConfigState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    112            wuConfigState_t gLastConfigState;
   \                     gLastConfigState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    113            wuLPConfigState_t gLPConfigState;
   \                     gLPConfigState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    114            wuLPConfigState_t gLastLPConfigState;
   \                     gLastLPConfigState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    115            bool_t  bGotoLowPwrFlag;
   \                     bGotoLowPwrFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    116            bool_t  bFirstNibbleFlag;
   \                     bFirstNibbleFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    117            uint8_t u8ConfigHexValue;
   \                     u8ConfigHexValue:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    118            uint8_t u8ConfigDecValue;
   \                     u8ConfigDecValue:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    119            uint8_t u8SequencePointerCounter;
   \                     u8SequencePointerCounter:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    120            bool_t bReturnToMainMenuFlag;
   \                     bReturnToMainMenuFlag:
   \   00000000                      DS8 1
    121          #endif
    122          
    123          #if (gEnableLowPower_d == TRUE)    

   \                                 In section .bss, align 4
    124          uint8_t *pu8MainLowPowerString;
   \                     pu8MainLowPowerString:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    125          uint8_t * pu8MainWakeupSourceString;
   \                     pu8MainWakeupSourceString:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    126          uint8_t * pu8GotoLowPowerString;
   \                     pu8GotoLowPowerString:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    127          uint8_t * pu8NowInLowPowerString;
   \                     pu8NowInLowPowerString:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    128          uint8_t * pu8WakeupSourceString;
   \                     pu8WakeupSourceString:
   \   00000000                      DS8 4
    129          

   \                                 In section .bss, align 4
    130          uint32_t u32PortAPCRBackup[8];
   \                     u32PortAPCRBackup:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
    131          uint32_t u32PortBPCRBackup[8];
   \                     u32PortBPCRBackup:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
    132          uint32_t u32PortCPCRBackup[8];
   \                     u32PortCPCRBackup:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
    133          uint32_t u32PortDPCRBackup[8];
   \                     u32PortDPCRBackup:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
    134          uint32_t u32PortEPCRBackup[8];
   \                     u32PortEPCRBackup:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
    135          uint32_t u32SCGCxBackup[5];
   \                     u32SCGCxBackup:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
    136          uint32_t u32GPIOs_PDORBackup[8];
   \                     u32GPIOs_PDORBackup:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
    137          uint32_t u32GPIOs_PDDRBackup[8];
   \                     u32GPIOs_PDDRBackup:
   \   00000000                      DS8 32

   \                                 In section .data, align 4
    138          zbClock24_t LPTMR_Duration = 360; //LowPowerTimer
   \                     LPTMR_Duration:
   \   00000000   0x00000168         DC32 360

   \                                 In section .data, align 4
    139          zbClock24_t RTC_Duration = 10;
   \                     RTC_Duration:
   \   00000000   0x0000000A         DC32 10

   \                                 In section .bss, align 1
    140          bool_t  bGPIOWakeupFlag = FALSE;
   \                     bGPIOWakeupFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    141          bool_t  bLPTMRWakeupFlag = FALSE;
   \                     bLPTMRWakeupFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    142          bool_t  bRTCWakeupFlag = FALSE;
   \                     bRTCWakeupFlag:
   \   00000000                      DS8 1
    143          #endif
    144          

   \                                 In section .bss, align 4
    145          static uint8_t gau8RxDataBuffer[130]; 
   \                     gau8RxDataBuffer:
   \   00000000                      DS8 132

   \                                 In section .bss, align 4
    146          static uint8_t gau8TxDataBuffer[128]; 
   \                     gau8TxDataBuffer:
   \   00000000                      DS8 128
    147          

   \                                 In section .bss, align 4
    148          static txPacket_t * gAppTxPacket;
   \                     gAppTxPacket:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    149          static rxPacket_t * gAppRxPacket;
   \                     gAppRxPacket:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    150          static tSnd        gSnd;
   \                     gSnd:
   \   00000000                      DS8 72

   \                                 In section .bss, align 4
    151          tOptions    gOptions;
   \                     gOptions:
   \   00000000                      DS8 24

   \                                 In section .bss, align 4
    152          tOpt        gOpt;
   \                     gOpt:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
    153          tPng        gPng;
   \                     gPng:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
    154          tRawSnd     gRawSnd;      
   \                     gRawSnd:
   \   00000000                      DS8 96
    155          

   \                                 In section .bss, align 1
    156          volatile int8_t appState;
   \                     appState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    157          uint8_t       gIsAck;
   \                     gIsAck:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    158          uint8_t       gIsMyAck;
   \                     gIsMyAck:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    159          uint32_t      gRxTimeout;
   \                     gRxTimeout:
   \   00000000                      DS8 4

   \                                 In section .rodata, align 4
    160          const uint32_t g_DEAD_BEEF = 0xDEADBEEF;  // unlikely-to-exist bit pattern
   \                     g_DEAD_BEEF:
   \   00000000   0xDEADBEEF         DC32 3735928559

   \                                 In section .rodata, align 4
    161          const uint32_t settingsAddress = 0x0007F800;
   \                     settingsAddress:
   \   00000000   0x0007F800         DC32 522240
    162          //uint32_t      gFlashDeadBeef  @0x0007F800;

   \                                 In section .bss, align 4
    163          uint32_t      gFlashDeadBeef;
   \                     gFlashDeadBeef:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    164          tOptions    gFlashOptions;    // Note: on same FLASH memory page as "gFlashDeadBeef"
   \                     gFlashOptions:
   \   00000000                      DS8 24

   \                                 In section .bss, align 2
    165          uint16_t sensorID;
   \                     sensorID:
   \   00000000                      DS8 2
    166          

   \                                 In section .bss, align 1
    167          bool_t bTxDone;
   \                     bTxDone:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    168          bool_t bRxDone;
   \                     bRxDone:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    169          bool_t bScanDone;
   \                     bScanDone:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    170          channels_t bestChannel;
   \                     bestChannel:
   \   00000000                      DS8 1
    171          

   \                                 In section .bss, align 1
    172          bool_t  bCommTxDone;  
   \                     bCommTxDone:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    173          uint8_t gu8CommData;
   \                     gu8CommData:
   \   00000000                      DS8 1
    174          

   \                                 In section .bss, align 1
    175          operationModes_t testOpMode;
   \                     testOpMode:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    176          operationModes_t prevOpMode;
   \                     prevOpMode:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    177          channels_t       testChannel;
   \                     testChannel:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    178          uint8_t          testPower;
   \                     testPower:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    179          uint8_t          testTrimmValue;
   \                     testTrimmValue:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    180          uint8_t          testPayloadLen;
   \                     testPayloadLen:
   \   00000000                      DS8 1
    181          

   \                                 In section .bss, align 1
    182          smacTestMode_t contTestRunning;
   \                     contTestRunning:
   \   00000000                      DS8 1
    183          

   \                                 In section .bss, align 1
    184          bool_t evDataFromCOMM;
   \                     evDataFromCOMM:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    185          bool_t evTestParameters;
   \                     evTestParameters:
   \   00000000                      DS8 1
    186          

   \                                 In section .bss, align 1
    187          bool_t shortCutsEnabled;
   \                     shortCutsEnabled:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    188          ConnectivityStates_t       connState;
   \                     connState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    189          ContinuousTxRxTestStates_t cTxRxState;
   \                     cTxRxState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    190          PerTxStates_t              perTxState;
   \                     perTxState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    191          PerRxStates_t              perRxState;
   \                     perRxState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    192          RangeTxStates_t            rangeTxState;
   \                     rangeTxState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    193          RangeRxStates_t            rangeRxState;
   \                     rangeRxState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    194          EditRegsStates_t    eRState; 
   \                     eRState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    195          ODRStates_t         oDRState;
   \                     oDRState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    196          OIRStates_t         oIRState;
   \                     oIRState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    197          RDRStates_t         rDRState;
   \                     rDRState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    198          RIRStates_t         rIRState;
   \                     rIRState:
   \   00000000                      DS8 1
    199          

   \                                 In section .bss, align 1
    200          bool_t bTxOtaBusyFlag;
   \                     bTxOtaBusyFlag:
   \   00000000                      DS8 1
    201          

   \                                 In section .bss, align 4
    202          int     PIT_ITTERATIONS;
   \                     PIT_ITTERATIONS:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    203          int     AXIS ;
   \                     AXIS:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    204          uint32_t  TempSumx ;
   \                     TempSumx:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    205          uint32_t  TempSumy ;
   \                     TempSumy:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    206          uint32_t  TempSumz ;
   \                     TempSumz:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
    207          bool_t bCommGetDataTimerFlag;
   \                     bCommGetDataTimerFlag:
   \   00000000                      DS8 1
    208          

   \                                 In section .bss, align 1
    209          bool_t LowPowerEntered = FALSE;
   \                     LowPowerEntered:
   \   00000000                      DS8 1
    210          

   \                                 In section .bss, align 4
    211          uint8_t au8ScanResults[16];
   \                     au8ScanResults:
   \   00000000                      DS8 16
    212          

   \                                 In section .bss, align 1
    213          txTests_t txTestIndex;
   \                     txTestIndex:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    214          RxTests_t rxTestIndex;
   \                     rxTestIndex:
   \   00000000                      DS8 1

   \                                 In section .bss, align 2
    215          uint16_t sentPackets;
   \                     sentPackets:
   \   00000000                      DS8 2
    216          #define MMCAU_TEST  FALSE    
    217          
    218          #if TRUE == MMCAU_TEST
    219            #define AES192                    192
    220            unsigned char key_expansion[60*4];
    221            /*24 bytes key: "UltraMegaSecretPassword1"*/
    222            unsigned char   key192[AES192/8] = { 0x55, 0x6c, 0x74, 0x72, 0x61, 0x4d, 0x65, 0x67, 
    223                                                 0x61, 0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x50, 
    224          	                               0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x31 };
    225          #endif
    226          
    227          
    228          /************************************************************************************
    229          *************************************************************************************
    230          * Main application functions
    231          *************************************************************************************
    232          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    233          void main(void)
    234          {
   \                     main: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB08D             SUB      SP,SP,#+52
    235            int XDiff;
    236            int YDiff;
    237            int ZDiff;
    238            
    239            int LoopItterations = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    240            
    241            int threshHold = 120;
   \   00000008   0x2778             MOVS     R7,#+120
    242            sensorID=6543; 
   \   0000000A   0xF641 0x108F      MOVW     R0,#+6543
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000012   0x8008             STRH     R0,[R1, #+0]
    243            TempSumx = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable13
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    244            TempSumy = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \   00000022   0x6008             STR      R0,[R1, #+0]
    245            TempSumz = 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    246            AXIS = 0; 
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   00000032   0x6008             STR      R0,[R1, #+0]
    247            PIT_ITTERATIONS =0;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    248            
    249            InitProject(); 
   \   0000003C   0x.... 0x....      BL       InitProject
    250            /* SMAC Initialization */
    251            InitSmac(); 
   \   00000040   0x.... 0x....      BL       InitSmac
    252            
    253            //initalize the accelerometter
    254            InitAccelControlls();
   \   00000044   0x.... 0x....      BL       InitAccelControlls
    255            ADCInit();
   \   00000048   0x.... 0x....      BL       ADCInit
    256            
    257           //right now this should be equal to a pit running every .000125 seconds so it will run 8000 itterations in 1 second
    258            INIT_PIT((uint32_t) 5999);        //((50,000,000)/(1/TIME)) -1 = TimeForInitFucntion Here Time is equal to  intot initthis can be changed for different sample times if the number is increased the sample time is increased
   \   0000004C   0xF241 0x706F      MOVW     R0,#+5999
   \   00000050   0x.... 0x....      BL       INIT_PIT
    259            /*this time is for 8000Hz */
    260            
    261            //blink the leds
    262            RedStatLedOn();
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x400ff0c8
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x400ff0c8
   \   00000062   0x6008             STR      R0,[R1, #+0]
    263            GreenStatLedOn();
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x400ff0c8
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x400ff0c8
   \   00000072   0x6008             STR      R0,[R1, #+0]
    264            
    265          #if defined(gCDCInterface_d)    //Wait for user to open the VirtualCom
    266            while(!Comm_Open());
    267          #endif
    268            /*Prints the Welcome screens in the COMM*/  
    269            //PrintMenu(cu8FreescaleLogo, gDefaultCommPort_c);
    270            
    271            #if TRUE == MMCAU_TEST
    272             cau_aes_set_key(key192, AES192, key_expansion);
    273            #endif
    274            
    275            /*Waits until de user selects press Enter*/    
    276           // while(!(evDataFromCOMM && ('\r' == gu8CommData))); 
    277            connState = gConnIdleState_c; 
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable13_5
   \   0000007A   0x7008             STRB     R0,[R1, #+0]
    278            int32_t cin[30];
    279            int in;
    280            
    281            gSnd.channel=gChannel11_c;
   \   0000007C   0x200B             MOVS     R0,#+11
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000082   0xF881 0x0043      STRB     R0,[R1, #+67]
    282            uint16_t flashCount=0;
   \   00000086   0xF05F 0x0800      MOVS     R8,#+0
    283            (void)MLMESetChannelRequest(gSnd.channel);
                                               ^
Warning[Pe188]: enumerated type mixed with another type
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000008E   0xF890 0x0043      LDRB     R0,[R0, #+67]
   \   00000092   0x.... 0x....      BL       MLMESetChannelRequest
   \   00000096   0x4681             MOV      R9,R0
    284            (void)MLMEPAOutputAdjust(gMaxOutputPower_c);
   \   00000098   0x201F             MOVS     R0,#+31
   \   0000009A   0x.... 0x....      BL       MLMEPAOutputAdjust
   \   0000009E   0x4682             MOV      R10,R0
    285            (void)MLMEXtalAdjust(testTrimmValue);
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable13_6
   \   000000A4   0x7800             LDRB     R0,[R0, #+0]
   \   000000A6   0x.... 0x....      BL       MLMEXtalAdjust
   \   000000AA   0x4683             MOV      R11,R0
    286            //MLMESetPromiscuousMode(TRUE);
    287            sentPackets=0;
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable13_7
   \   000000B2   0x8008             STRH     R0,[R1, #+0]
    288          
    289            (void)ChooseBestChannel();
   \   000000B4   0x.... 0x....      BL       ChooseBestChannel
    290            appState=TRANSMIT_MODE;
   \   000000B8   0x2100             MOVS     R1,#+0
   \   000000BA   0x.... 0x....      LDR.W    R2,??DataTable15
   \   000000BE   0x7011             STRB     R1,[R2, #+0]
    291            
    292              RedStatLedOff();
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable13_8  ;; 0x400ff0c4
   \   000000C4   0x6809             LDR      R1,[R1, #+0]
   \   000000C6   0xF051 0x0110      ORRS     R1,R1,#0x10
   \   000000CA   0x.... 0x....      LDR.W    R2,??DataTable13_8  ;; 0x400ff0c4
   \   000000CE   0x6011             STR      R1,[R2, #+0]
    293            GreenStatLedOff();
   \   000000D0   0x.... 0x....      LDR.W    R1,??DataTable13_8  ;; 0x400ff0c4
   \   000000D4   0x6809             LDR      R1,[R1, #+0]
   \   000000D6   0xF051 0x0108      ORRS     R1,R1,#0x8
   \   000000DA   0x.... 0x....      LDR.W    R2,??DataTable13_8  ;; 0x400ff0c4
   \   000000DE   0x6011             STR      R1,[R2, #+0]
    294            
    295            PIT_ITTERATIONS =0;
   \   000000E0   0x2100             MOVS     R1,#+0
   \   000000E2   0x.... 0x....      LDR.W    R2,??DataTable13_4
   \   000000E6   0x6011             STR      R1,[R2, #+0]
    296            
    297            AccellEnableOn();
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable13_8  ;; 0x400ff0c4
   \   000000EC   0x6809             LDR      R1,[R1, #+0]
   \   000000EE   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   000000F2   0x.... 0x....      LDR.W    R2,??DataTable13_8  ;; 0x400ff0c4
   \   000000F6   0x6011             STR      R1,[R2, #+0]
    298            AccellPowerOn();
   \   000000F8   0x.... 0x....      LDR.W    R1,??DataTable13_8  ;; 0x400ff0c4
   \   000000FC   0x6809             LDR      R1,[R1, #+0]
   \   000000FE   0xF051 0x0120      ORRS     R1,R1,#0x20
   \   00000102   0x.... 0x....      LDR.W    R2,??DataTable13_8  ;; 0x400ff0c4
   \   00000106   0x6011             STR      R1,[R2, #+0]
    299            
    300            
    301            
    302            for(;;){
    303              
    304             TempSumx = 0;
   \                     ??main_0: (+1)
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0x.... 0x....      LDR.W    R1,??DataTable13
   \   0000010E   0x6008             STR      R0,[R1, #+0]
    305             TempSumy = 0;
   \   00000110   0x2000             MOVS     R0,#+0
   \   00000112   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \   00000116   0x6008             STR      R0,[R1, #+0]
    306             TempSumz = 0;
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000011E   0x6008             STR      R0,[R1, #+0]
    307             gSnd.xmax =0;
   \   00000120   0x2000             MOVS     R0,#+0
   \   00000122   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000126   0x8148             STRH     R0,[R1, #+10]
    308             gSnd.ymax =0;
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000012E   0x8348             STRH     R0,[R1, #+26]
    309             gSnd.zmax =0;
   \   00000130   0x2000             MOVS     R0,#+0
   \   00000132   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000136   0x8548             STRH     R0,[R1, #+42]
    310             gSnd.xmin = 4000;
   \   00000138   0xF44F 0x607A      MOV      R0,#+4000
   \   0000013C   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000140   0x8108             STRH     R0,[R1, #+8]
    311             gSnd.ymin = 4000;
   \   00000142   0xF44F 0x607A      MOV      R0,#+4000
   \   00000146   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000014A   0x8308             STRH     R0,[R1, #+24]
    312             gSnd.zmin = 4000;
   \   0000014C   0xF44F 0x607A      MOV      R0,#+4000
   \   00000150   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000154   0x8508             STRH     R0,[R1, #+40]
    313              
    314              
    315              uint16_t sleepTime = 1000*gOptions.u16SleepAfterAck;
   \   00000156   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   0000015A   0x8AC0             LDRH     R0,[R0, #+22]
   \   0000015C   0xF44F 0x717A      MOV      R1,#+1000
   \   00000160   0xFB10 0xF901      SMULBB   R9,R0,R1
    316              
    317               
    318               // Prepare the usual stats SND packet
    319               // get temp and vibration data, put in packet
    320               GetDeviceData();
   \   00000164   0x.... 0x....      BL       GetDeviceData
    321              
    322              
    323              //delayMs(3000);
    324              XDiff = gSnd.xmax - gSnd.xmin;
   \   00000168   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000016C   0x8940             LDRH     R0,[R0, #+10]
   \   0000016E   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000172   0x8909             LDRH     R1,[R1, #+8]
   \   00000174   0x1A40             SUBS     R0,R0,R1
   \   00000176   0x9000             STR      R0,[SP, #+0]
    325              YDiff = gSnd.ymax - gSnd.ymin;
   \   00000178   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000017C   0x8B40             LDRH     R0,[R0, #+26]
   \   0000017E   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000182   0x8B09             LDRH     R1,[R1, #+24]
   \   00000184   0x1A40             SUBS     R0,R0,R1
   \   00000186   0x0004             MOVS     R4,R0
    326              ZDiff = gSnd.zmax - gSnd.zmin;
   \   00000188   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000018C   0x8D40             LDRH     R0,[R0, #+42]
   \   0000018E   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000192   0x8D09             LDRH     R1,[R1, #+40]
   \   00000194   0x1A40             SUBS     R0,R0,R1
   \   00000196   0x0005             MOVS     R5,R0
    327              
    328              
    329              //if( (XDiff > threshHold || XDiff < -threshHold) || (YDiff > threshHold || YDiff < -threshHold) || (ZDiff > threshHold || ZDiff < -threshHold))
    330              //{
    331                sentPackets++;
   \   00000198   0x.... 0x....      LDR.W    R0,??DataTable13_7
   \   0000019C   0x8800             LDRH     R0,[R0, #+0]
   \   0000019E   0x1C40             ADDS     R0,R0,#+1
   \   000001A0   0x.... 0x....      LDR.W    R1,??DataTable13_7
   \   000001A4   0x8008             STRH     R0,[R1, #+0]
    332                flashCount=0;
   \   000001A6   0x2000             MOVS     R0,#+0
   \   000001A8   0x4680             MOV      R8,R0
    333                //LED_SetLed(LED2, gLedOn_c);
    334                
    335                smacErrors_t status=SendBinaryPacket();
   \   000001AA   0x.... 0x....      BL       SendBinaryPacket
   \   000001AE   0x4682             MOV      R10,R0
    336                if(status==gErrorNoError_c){
   \   000001B0   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001B4   0xF1BA 0x0F00      CMP      R10,#+0
   \   000001B8   0xD101             BNE.N    ??main_1
    337                  ReceivePacket();
   \   000001BA   0x.... 0x....      BL       ReceivePacket
    338                }
    339                while(--flashCount);
   \                     ??main_1: (+1)
   \   000001BE   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   000001C2   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000001C6   0xF1B8 0x0F00      CMP      R8,#+0
   \   000001CA   0xD1F8             BNE.N    ??main_1
    340                
    341                evDataFromCOMM=FALSE;
   \   000001CC   0x2000             MOVS     R0,#+0
   \   000001CE   0x.... 0x....      LDR.W    R1,??DataTable15_1
   \   000001D2   0x7008             STRB     R0,[R1, #+0]
    342                //PrintPacketID(sentPackets);
    343                tOptions pOptions;
    344                if(appState==RECEIVE_FINISHED && gIsAck) {
   \   000001D4   0x.... 0x....      LDR.W    R0,??DataTable15
   \   000001D8   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   000001DC   0x2802             CMP      R0,#+2
   \   000001DE   0xD11F             BNE.N    ??main_2
   \   000001E0   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   000001E4   0x7800             LDRB     R0,[R0, #+0]
   \   000001E6   0x2800             CMP      R0,#+0
   \   000001E8   0xD01A             BEQ.N    ??main_2
    345                  if(gAppRxPacket->u8DataLength>ACK_HEADER_SIZE){
   \   000001EA   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   000001EE   0x6800             LDR      R0,[R0, #+0]
   \   000001F0   0x7880             LDRB     R0,[R0, #+2]
   \   000001F2   0x2806             CMP      R0,#+6
   \   000001F4   0xDB14             BLT.N    ??main_2
    346                    if(gAppRxPacket->u8DataLength==ACK_OPT_SIZE){
   \   000001F6   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   000001FA   0x6800             LDR      R0,[R0, #+0]
   \   000001FC   0x7880             LDRB     R0,[R0, #+2]
   \   000001FE   0x2818             CMP      R0,#+24
   \   00000200   0xD10B             BNE.N    ??main_3
    347                      CopyOptionsFromRecvPacket(&pOptions);
   \   00000202   0xA807             ADD      R0,SP,#+28
   \   00000204   0x.... 0x....      BL       CopyOptionsFromRecvPacket
    348                      
    349                      OptSwapEndianness(&pOptions);
   \   00000208   0xA807             ADD      R0,SP,#+28
   \   0000020A   0x.... 0x....      BL       OptSwapEndianness
    350                      if (!ValidateOptions(&pOptions)) continue;
   \   0000020E   0xA807             ADD      R0,SP,#+28
   \   00000210   0x.... 0x....      BL       ValidateOptions
   \   00000214   0x2800             CMP      R0,#+0
   \   00000216   0xD103             BNE.N    ??main_2
   \   00000218   0xE776             B.N      ??main_0
    351                    }
    352                    else {
    353                      GetFactoryOptions(&pOptions);
   \                     ??main_3: (+1)
   \   0000021A   0xA807             ADD      R0,SP,#+28
   \   0000021C   0x.... 0x....      BL       GetFactoryOptions
    354                    }
    355                    //ChangeOptions(&pOptions);
    356                  }
    357                  
    358                }
    359                LoopItterations =0;
   \                     ??main_2: (+1)
   \   00000220   0x2000             MOVS     R0,#+0
   \   00000222   0x0006             MOVS     R6,R0
    360              //}
    361              
    362              
    363              
    364              if(LoopItterations == 120)
   \   00000224   0x2E78             CMP      R6,#+120
   \   00000226   0xD15D             BNE.N    ??main_4
    365              {
    366                //need to send a heartbeat message
    367                gSnd.xmax = 0;
   \   00000228   0x2000             MOVS     R0,#+0
   \   0000022A   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000022E   0x8148             STRH     R0,[R1, #+10]
    368                gSnd.xmin = 0;
   \   00000230   0x2000             MOVS     R0,#+0
   \   00000232   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000236   0x8108             STRH     R0,[R1, #+8]
    369                gSnd.ymax = 0;
   \   00000238   0x2000             MOVS     R0,#+0
   \   0000023A   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000023E   0x8348             STRH     R0,[R1, #+26]
    370                gSnd.ymin = 0;
   \   00000240   0x2000             MOVS     R0,#+0
   \   00000242   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000246   0x8308             STRH     R0,[R1, #+24]
    371                gSnd.zmax = 0;
   \   00000248   0x2000             MOVS     R0,#+0
   \   0000024A   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000024E   0x8548             STRH     R0,[R1, #+42]
    372                gSnd.zmin = 0;
   \   00000250   0x2000             MOVS     R0,#+0
   \   00000252   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000256   0x8508             STRH     R0,[R1, #+40]
    373                
    374                
    375                sentPackets++;
   \   00000258   0x.... 0x....      LDR.W    R0,??DataTable13_7
   \   0000025C   0x8800             LDRH     R0,[R0, #+0]
   \   0000025E   0x1C40             ADDS     R0,R0,#+1
   \   00000260   0x.... 0x....      LDR.W    R1,??DataTable13_7
   \   00000264   0x8008             STRH     R0,[R1, #+0]
    376                flashCount=0;
   \   00000266   0x2000             MOVS     R0,#+0
   \   00000268   0x4680             MOV      R8,R0
    377                //LED_SetLed(LED2, gLedOn_c);
    378                
    379                smacErrors_t status=SendBinaryPacket();
   \   0000026A   0x.... 0x....      BL       SendBinaryPacket
   \   0000026E   0x4683             MOV      R11,R0
    380                if(status==gErrorNoError_c){
   \   00000270   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000274   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000278   0xD101             BNE.N    ??main_5
    381                  ReceivePacket();
   \   0000027A   0x.... 0x....      BL       ReceivePacket
    382                }
    383                while(--flashCount);
   \                     ??main_5: (+1)
   \   0000027E   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   00000282   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000286   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000028A   0xD1F8             BNE.N    ??main_5
    384                
    385                evDataFromCOMM=FALSE;
   \   0000028C   0x2000             MOVS     R0,#+0
   \   0000028E   0x.... 0x....      LDR.W    R1,??DataTable15_1
   \   00000292   0x7008             STRB     R0,[R1, #+0]
    386                //PrintPacketID(sentPackets);
    387                tOptions pOptions;
    388                if(appState==RECEIVE_FINISHED && gIsAck) {
   \   00000294   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000298   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   0000029C   0x2802             CMP      R0,#+2
   \   0000029E   0xD11F             BNE.N    ??main_6
   \   000002A0   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   000002A4   0x7800             LDRB     R0,[R0, #+0]
   \   000002A6   0x2800             CMP      R0,#+0
   \   000002A8   0xD01A             BEQ.N    ??main_6
    389                  if(gAppRxPacket->u8DataLength>ACK_HEADER_SIZE){
   \   000002AA   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   000002AE   0x6800             LDR      R0,[R0, #+0]
   \   000002B0   0x7880             LDRB     R0,[R0, #+2]
   \   000002B2   0x2806             CMP      R0,#+6
   \   000002B4   0xDB14             BLT.N    ??main_6
    390                    if(gAppRxPacket->u8DataLength==ACK_OPT_SIZE){
   \   000002B6   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   000002BA   0x6800             LDR      R0,[R0, #+0]
   \   000002BC   0x7880             LDRB     R0,[R0, #+2]
   \   000002BE   0x2818             CMP      R0,#+24
   \   000002C0   0xD10B             BNE.N    ??main_7
    391                      CopyOptionsFromRecvPacket(&pOptions);
   \   000002C2   0xA801             ADD      R0,SP,#+4
   \   000002C4   0x.... 0x....      BL       CopyOptionsFromRecvPacket
    392                      
    393                      OptSwapEndianness(&pOptions);
   \   000002C8   0xA801             ADD      R0,SP,#+4
   \   000002CA   0x.... 0x....      BL       OptSwapEndianness
    394                      if (!ValidateOptions(&pOptions)) continue;
   \   000002CE   0xA801             ADD      R0,SP,#+4
   \   000002D0   0x.... 0x....      BL       ValidateOptions
   \   000002D4   0x2800             CMP      R0,#+0
   \   000002D6   0xD103             BNE.N    ??main_6
   \   000002D8   0xE716             B.N      ??main_0
    395                    }
    396                    else {
    397                      GetFactoryOptions(&pOptions);
   \                     ??main_7: (+1)
   \   000002DA   0xA801             ADD      R0,SP,#+4
   \   000002DC   0x.... 0x....      BL       GetFactoryOptions
    398                    }
    399                    //ChangeOptions(&pOptions);
    400                  }
    401                  
    402                }
    403                LoopItterations =0;
   \                     ??main_6: (+1)
   \   000002E0   0x2000             MOVS     R0,#+0
   \   000002E2   0x0006             MOVS     R6,R0
    404                
    405              }
    406              /*this needs to be here to reset the packet ID every time*/
    407              LoopItterations = LoopItterations +1;
   \                     ??main_4: (+1)
   \   000002E4   0x1C76             ADDS     R6,R6,#+1
    408              
    409              InitPacket(); 
   \   000002E6   0x.... 0x....      BL       InitPacket
    410              
    411              
    412              //------------------------------------------------------------------------------------
    413              //Temporary Code to just push the controller into low power mode on every itteration through the code.
    414              //this was just set to make sure we could go into low power mode.
    415              
    416              gOptions.u16SleepAfterAck = SLEEP_AFTER_ACK;
   \   000002EA   0xF44F 0x7096      MOV      R0,#+300
   \   000002EE   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   000002F2   0x82C8             STRH     R0,[R1, #+22]
    417              
    418              while(!LowPowerEntered){
   \                     ??main_8: (+1)
   \   000002F4   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \   000002F8   0x7800             LDRB     R0,[R0, #+0]
   \   000002FA   0x2800             CMP      R0,#+0
   \   000002FC   0xF47F 0xAF04      BNE.W    ??main_0
    419                  //this loop will put the controller into sleep mode
    420                  //the sleeo mode will then cause a reset when it wakes back up.
    421                  gLED_PortDataDirReg_c = 0x0u;
   \   00000300   0x2000             MOVS     R0,#+0
   \   00000302   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x400ff0d4
   \   00000306   0x6008             STR      R0,[R1, #+0]
    422                  
    423                  WUApp_LowPwrStateMachine();
   \   00000308   0x.... 0x....      BL       WUApp_LowPwrStateMachine
   \   0000030C   0xE7F2             B.N      ??main_8
    424                }
    425              
    426            }/* For(;;)*/
    427            
    428          }/*Main*/

   \                                 In section .text, align 2, keep-with-next
    429          int ValidateOptions(tOptions *pOptions){
   \                     ValidateOptions: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    430            if((pOptions->u8RawSpinCount!=0) && (pOptions->u8RawSpinCount > 64 || pOptions->u8RawSpinCount < 5)) return 0;   // updated *** 06/08/11 *** (formerly "u8Reserved1")
   \   00000002   0x7808             LDRB     R0,[R1, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD007             BEQ.N    ??ValidateOptions_0
   \   00000008   0x7808             LDRB     R0,[R1, #+0]
   \   0000000A   0x2841             CMP      R0,#+65
   \   0000000C   0xDA02             BGE.N    ??ValidateOptions_1
   \   0000000E   0x7808             LDRB     R0,[R1, #+0]
   \   00000010   0x2805             CMP      R0,#+5
   \   00000012   0xDA01             BGE.N    ??ValidateOptions_0
   \                     ??ValidateOptions_1: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE03B             B.N      ??ValidateOptions_2
    431            if(pOptions->u16TimeoutsToKill > 3600 || pOptions->u16TimeoutsToKill < 1) return 0;
   \                     ??ValidateOptions_0: (+1)
   \   00000018   0x8848             LDRH     R0,[R1, #+2]
   \   0000001A   0xF5B0 0x6F61      CMP      R0,#+3600
   \   0000001E   0xDC02             BGT.N    ??ValidateOptions_3
   \   00000020   0x8848             LDRH     R0,[R1, #+2]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD101             BNE.N    ??ValidateOptions_4
   \                     ??ValidateOptions_3: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE032             B.N      ??ValidateOptions_2
    432            if(pOptions->u16SampleSize != ACCEL_SAMPLE_SIZE) return 0;
   \                     ??ValidateOptions_4: (+1)
   \   0000002A   0x8888             LDRH     R0,[R1, #+4]
   \   0000002C   0xF5B0 0x5FFA      CMP      R0,#+8000
   \   00000030   0xD001             BEQ.N    ??ValidateOptions_5
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xE02C             B.N      ??ValidateOptions_2
    433            if(pOptions->bAsciiMode > 1) return 0;
   \                     ??ValidateOptions_5: (+1)
   \   00000036   0x7988             LDRB     R0,[R1, #+6]
   \   00000038   0x2802             CMP      R0,#+2
   \   0000003A   0xDB01             BLT.N    ??ValidateOptions_6
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE027             B.N      ??ValidateOptions_2
    434            if(pOptions->bBlinkingLEDs > 1) return 0;
   \                     ??ValidateOptions_6: (+1)
   \   00000040   0x79C8             LDRB     R0,[R1, #+7]
   \   00000042   0x2802             CMP      R0,#+2
   \   00000044   0xDB01             BLT.N    ??ValidateOptions_7
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xE022             B.N      ??ValidateOptions_2
    435            if(pOptions->u8OutputPower != OUTPUT_POWER) return 0;
   \                     ??ValidateOptions_7: (+1)
   \   0000004A   0x7A08             LDRB     R0,[R1, #+8]
   \   0000004C   0x2864             CMP      R0,#+100
   \   0000004E   0xD001             BEQ.N    ??ValidateOptions_8
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xE01D             B.N      ??ValidateOptions_2
    436            if(pOptions->u32PngTimeout != PNG_TIMEOUT) return 0;
   \                     ??ValidateOptions_8: (+1)
   \   00000054   0x68C8             LDR      R0,[R1, #+12]
   \   00000056   0xF248 0x02E8      MOVW     R2,#+33000
   \   0000005A   0x4290             CMP      R0,R2
   \   0000005C   0xD001             BEQ.N    ??ValidateOptions_9
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xE016             B.N      ??ValidateOptions_2
    437            if(pOptions->u32SndTimeout != SND_TIMEOUT) return 0;
   \                     ??ValidateOptions_9: (+1)
   \   00000062   0x6908             LDR      R0,[R1, #+16]
   \   00000064   0x.... 0x....      LDR.W    R2,??DataTable17_1  ;; 0x28488
   \   00000068   0x4290             CMP      R0,R2
   \   0000006A   0xD001             BEQ.N    ??ValidateOptions_10
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xE00F             B.N      ??ValidateOptions_2
    438            if(pOptions->bLNAHighGainMode != 1) return 0; // i.e. Low Noise Amplifier - updated *** 10/26/10 *** (formerly "u8Reserved2")
   \                     ??ValidateOptions_10: (+1)
   \   00000070   0x7D08             LDRB     R0,[R1, #+20]
   \   00000072   0x2801             CMP      R0,#+1
   \   00000074   0xD001             BEQ.N    ??ValidateOptions_11
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xE00A             B.N      ??ValidateOptions_2
    439            if(pOptions->u16SleepAfterAck > 3000|| pOptions->u16SleepAfterAck < 3) return 0;
   \                     ??ValidateOptions_11: (+1)
   \   0000007A   0x8AC8             LDRH     R0,[R1, #+22]
   \   0000007C   0xF640 0x32B9      MOVW     R2,#+3001
   \   00000080   0x4290             CMP      R0,R2
   \   00000082   0xDA02             BGE.N    ??ValidateOptions_12
   \   00000084   0x8AC8             LDRH     R0,[R1, #+22]
   \   00000086   0x2803             CMP      R0,#+3
   \   00000088   0xDA01             BGE.N    ??ValidateOptions_13
   \                     ??ValidateOptions_12: (+1)
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xE000             B.N      ??ValidateOptions_2
    440            return 1;
   \                     ??ValidateOptions_13: (+1)
   \   0000008E   0x2001             MOVS     R0,#+1
   \                     ??ValidateOptions_2: (+1)
   \   00000090   0x4770             BX       LR               ;; return
    441          }/*ValidateOptions*/
    442          

   \                                 In section .text, align 2, keep-with-next
    443          void ChangeOptions(tOptions* pOptions)
    444          {
   \                     ChangeOptions: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    445              
    446            // Are the new options different from the old/current options?
    447            if (memcmp(pOptions, &gOptions, sizeof(tOptions)) != 0)
   \   00000004   0x2218             MOVS     R2,#+24
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       memcmp
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD00D             BEQ.N    ??ChangeOptions_0
    448              {
    449          //        TRACE("\r\nConfiguration OPTIONS will be changed\r\n");
    450                  
    451                  // Save the new options
    452                  gOptions = *pOptions;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   00000018   0x0021             MOVS     R1,R4
   \   0000001A   0x2218             MOVS     R2,#+24
   \   0000001C   0x.... 0x....      BL       __aeabi_memcpy4
    453                  
    454                  // Save new options to FLASH memory
    455                  FlashSaveOptions();
   \   00000020   0x.... 0x....      BL       FlashSaveOptions
    456                  
    457                  // Make sure all of the options changes will be in effect
    458          //        RadioInitNew(); // added *** 10/27/10 ***
    459          //        (void)MLMEMC13192PAOutputAdjust(gOptions.u8OutputPower);
    460                  gRxTimeout = gOptions.u32SndTimeout;    // usual timeout value, i.e., timeout for SND packets
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   00000028   0x6900             LDR      R0,[R0, #+16]
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable18
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    461                  
    462                  // Updated *** 06/20/11 ***
    463                  // Whenever options change, flush the sending of raw data packets
    464           /*
    465                  gRawSnd.rawSpinCount = gOptions.u8RawSpinCount;
    466                  gRawSnd.axis = 3;     // Note: 1 = X-axis, 2 = Y-axis, 3 = Z-axis
    467                  gRawSnd.blockNo = 16; // Note: raw data is sent in blocks numbered 1 thru 16 (0 means not ready)
    468          */        
    469              }
    470              
    471              // Inform pan coordinator of our new configuration options
    472              SendCurrentOptions();
   \                     ??ChangeOptions_0: (+1)
   \   00000030   0x.... 0x....      BL       SendCurrentOptions
    473          
    474              return;
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    475          }//ChangeOptions
    476          

   \                                 In section .text, align 2, keep-with-next
    477          smacErrors_t SendCurrentOptions(){
   \                     SendCurrentOptions: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    478              
    479              gOpt.options = gOptions;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   0000000A   0x2218             MOVS     R2,#+24
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy4
    480              OptSwapEndianness(&gOpt.options);
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   00000014   0x.... 0x....      BL       OptSwapEndianness
    481              gOpt.hdr.u16SensorID = gOpt.hdr.u16SensorID << 8 | gOpt.hdr.u16SensorID>>8;
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   0000001C   0x8880             LDRH     R0,[R0, #+4]
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable16_6
   \   00000022   0x8889             LDRH     R1,[R1, #+4]
   \   00000024   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000026   0x0A09             LSRS     R1,R1,#+8
   \   00000028   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable16_6
   \   00000030   0x8088             STRH     R0,[R1, #+4]
    482              
    483              CopyOptPacketToSMAC();
   \   00000032   0x.... 0x....      BL       CopyOptPacketToSMAC
    484              // Get ready to send the configuration options SND packet
    485           //   gAppTxPacket->u8DataLength = sizeof(gOpt);
    486          //    gAppTxPacket->smacPdu.u8Data = (uint8_t*)&gOpt;
    487              return MCPSDataRequest(gAppTxPacket); // transmit data
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x.... 0x....      BL       MCPSDataRequest
   \   00000040   0xBD02             POP      {R1,PC}          ;; return
    488              
    489              // Note: even though the pan coordinator may acknowledge this message,
    490              // we don't need to wait for it, because the sensor data SND messages
    491              // are sent much more frequently, so we'll ignore any ACK here.
    492            
    493              
    494          }//SendCurrentOptions
    495          
    496          
    497          
    498          
    499          #if (gEnableLowPower_d == TRUE)
    500          /************************************************************************************
    501          *
    502          * WUApp_LowPwrStateMachine
    503          *
    504          ************************************************************************************/
    505          #if (TRUE == gEnableConfigMenus_d)

   \                                 In section .text, align 2, keep-with-next
    506          void WUApp_LowPwrStateMachine (void) 
    507          {
   \                     WUApp_LowPwrStateMachine: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    508            switch (gLPConfigState)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable16_7
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD005             BEQ.N    ??WUApp_LowPwrStateMachine_0
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD01B             BEQ.N    ??WUApp_LowPwrStateMachine_1
   \   00000010   0xD30B             BCC.N    ??WUApp_LowPwrStateMachine_2
   \   00000012   0x2803             CMP      R0,#+3
   \   00000014   0xD056             BEQ.N    ??WUApp_LowPwrStateMachine_3
   \   00000016   0xE06B             B.N      ??WUApp_LowPwrStateMachine_4
    509            {
    510              case gWULPStateInit_c:
    511                     gLPConfigState = gWULPStateGotoLowPower_c;	 
   \                     ??WUApp_LowPwrStateMachine_0: (+1)
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
    512                     WUApp_InitLowPowerMode(); /*Select low power mode to using in the state machine*/ 
   \   00000020   0x.... 0x....      BL       WUApp_InitLowPowerMode
    513                     WUApp_InitWakupSource();  /*Select the way MCU wakeup from low power*/
   \   00000024   0x.... 0x....      BL       WUApp_InitWakupSource
    514                     /*this is the part that i can change how and when to wake up the processor i think this is important fo waking the proccessor!!!!!!!!!!!!!!!#*/
    515              break;
   \   00000028   0xE06A             B.N      ??WUApp_LowPwrStateMachine_5
    516              
    517              case gWULPStateWait4Options_c:
    518                      
    519                      evDataFromCOMM = FALSE;                  
   \                     ??WUApp_LowPwrStateMachine_2: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable15_1
   \   00000030   0x7008             STRB     R0,[R1, #+0]
    520                      bGotoLowPwrFlag = TRUE;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable16_8
   \   00000038   0x7008             STRB     R0,[R1, #+0]
    521                      gLPConfigState = gLastLPConfigState;
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable16_9
   \   0000003E   0x7800             LDRB     R0,[R0, #+0]
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \   00000044   0x7008             STRB     R0,[R1, #+0]
    522                      
    523              break;
   \   00000046   0xE05B             B.N      ??WUApp_LowPwrStateMachine_5
    524              
    525              case gWULPStateGotoLowPower_c:
    526                      if (!bGotoLowPwrFlag){
   \                     ??WUApp_LowPwrStateMachine_1: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD115             BNE.N    ??WUApp_LowPwrStateMachine_6
    527                        PrintMenu((char * const *)pu8GotoLowPowerString, gDefaultCommPort_c);
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable16_10
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x.... 0x....      BL       PrintMenu
    528                        PrintMenu(cau8WUContinueAskString, gDefaultCommPort_c);
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable16_11
   \   00000064   0x.... 0x....      BL       PrintMenu
    529                        gLastLPConfigState = gLPConfigState;
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable16_7
   \   0000006C   0x7800             LDRB     R0,[R0, #+0]
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable16_9
   \   00000072   0x7008             STRB     R0,[R1, #+0]
    530                        gLPConfigState = gWULPStateWait4Options_c;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \   0000007A   0x7008             STRB     R0,[R1, #+0]
   \   0000007C   0xE021             B.N      ??WUApp_LowPwrStateMachine_7
    531                      }
    532                      else{
    533                        PrintMenu ((char * const *)pu8NowInLowPowerString, gDefaultCommPort_c);
   \                     ??WUApp_LowPwrStateMachine_6: (+1)
   \   0000007E   0x2101             MOVS     R1,#+1
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable16_12
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x.... 0x....      BL       PrintMenu
    534                        PrintMenu ((char * const *)pu8WakeupSourceString, gDefaultCommPort_c);
   \   0000008A   0x2101             MOVS     R1,#+1
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0x.... 0x....      BL       PrintMenu
    535                        WUApp_LowPowerWhile(); /*Go to Low Power and remain until wake up*/
   \   00000096   0x.... 0x....      BL       WUApp_LowPowerWhile
    536                        
    537                        /*If didn't wakeup from reset, continue here.*/
    538                        LED_StartSerialFlash();
   \   0000009A   0x.... 0x....      BL       LED_StartSerialFlash
    539                        TMR_StartSingleShotTimer(mLEDTimerID_1, mLEDInterval1_c, AppLedTimerCallback);
   \   0000009E   0x.... 0x....      LDR.W    R2,??DataTable17_2
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable17_3
   \   000000A6   0x8801             LDRH     R1,[R0, #+0]
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   000000AC   0x7800             LDRB     R0,[R0, #+0]
   \   000000AE   0x.... 0x....      BL       TMR_StartSingleShotTimer
    540          
    541                        bGotoLowPwrFlag = FALSE; 
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable16_8
   \   000000B8   0x7008             STRB     R0,[R1, #+0]
    542                        gConfigState = gWUConfigStateMainMenu_c;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable20
   \   000000C0   0x7008             STRB     R0,[R1, #+0]
    543                      }        
    544              break;    
   \                     ??WUApp_LowPwrStateMachine_7: (+1)
   \   000000C2   0xE01D             B.N      ??WUApp_LowPwrStateMachine_5
    545           
    546              case gWULPStateInvalid_c:
    547                      PrintMenu(cau8WUInvalidValueString, gDefaultCommPort_c); 
   \                     ??WUApp_LowPwrStateMachine_3: (+1)
   \   000000C4   0x2101             MOVS     R1,#+1
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable17_5
   \   000000CA   0x.... 0x....      BL       PrintMenu
    548                      if(gWULPStateWait4Options_c == gLastLPConfigState){
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable16_9
   \   000000D2   0x7800             LDRB     R0,[R0, #+0]
   \   000000D4   0x2801             CMP      R0,#+1
   \   000000D6   0xD104             BNE.N    ??WUApp_LowPwrStateMachine_8
    549                            PrintMenu(cau8WUWait4Option, gDefaultCommPort_c);
   \   000000D8   0x2101             MOVS     R1,#+1
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable17_6
   \   000000DE   0x.... 0x....      BL       PrintMenu
    550                      }
    551                      gLPConfigState = gLastLPConfigState;
   \                     ??WUApp_LowPwrStateMachine_8: (+1)
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable16_9
   \   000000E6   0x7800             LDRB     R0,[R0, #+0]
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \   000000EC   0x7008             STRB     R0,[R1, #+0]
    552              break;
   \   000000EE   0xE007             B.N      ??WUApp_LowPwrStateMachine_5
    553              
    554              default:
    555                gLPConfigState = gWULPStateGotoLowPower_c;
   \                     ??WUApp_LowPwrStateMachine_4: (+1)
   \   000000F0   0x2002             MOVS     R0,#+2
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \   000000F6   0x7008             STRB     R0,[R1, #+0]
    556                gConfigState = gWUConfigStateMainMenu_c;  /* Exit valve in case of Error */	        
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable20
   \   000000FE   0x7008             STRB     R0,[R1, #+0]
    557              break;
    558              
    559            } 
    560          }
   \                     ??WUApp_LowPwrStateMachine_5: (+1)
   \   00000100   0xBD01             POP      {R0,PC}          ;; return
    561          #endif
    562          #endif
    563          
    564          
    565          
    566          

   \                                 In section .text, align 2, keep-with-next
    567          void InitAccelControlls(){
    568           /*
    569          Initilizes the GPIO's that controll the  power in the Accelerommeter.
    570          This initilizes PTD1 and PTD 5 as GPIO's with output functionality and active low performance.
    571          */
    572                  //enable the clock gating to the module.
    573                  gLED_ClkGatingReg_c |= gLED_ClkGatingBit_c; 
   \                     InitAccelControlls: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable17_7  ;; 0x40048038
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable17_7  ;; 0x40048038
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    574                  //enable the conenctions, and enable the clock to the PTD output
    575                  gAccelEnableControlReg_c &= ~PORT_PCR_MUX_MASK;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable17_8  ;; 0x4004c004
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF430 0x60E0      BICS     R0,R0,#0x700
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable17_8  ;; 0x4004c004
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    576                  gAccelEnableControlReg_c |= PORT_PCR_MUX(gLED_PinCtrlAltFunc_c);
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable17_8  ;; 0x4004c004
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable17_8  ;; 0x4004c004
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    577                  gAccelPowerControlReg_c &= ~PORT_PCR_MUX_MASK;
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable17_9  ;; 0x4004c014
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0xF430 0x60E0      BICS     R0,R0,#0x700
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable17_9  ;; 0x4004c014
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    578                  gAccelPowerControlReg_c |= PORT_PCR_MUX(gLED_PinCtrlAltFunc_c);
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable17_9  ;; 0x4004c014
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable17_9  ;; 0x4004c014
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    579                  
    580                  
    581                  /*Pins direction -> output */
    582                  gLED_PortDataDirReg_c |= (gAccelPower | gAccelEnable);
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x400ff0d4
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0xF050 0x0022      ORRS     R0,R0,#0x22
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x400ff0d4
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    583                  /*turn off all outputs */
    584                  gLED_PortDataOutReg_c |= (gAccelPower | gAccelEnable);
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable20_1  ;; 0x400ff0c0
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0xF050 0x0022      ORRS     R0,R0,#0x22
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable20_1  ;; 0x400ff0c0
   \   0000006E   0x6008             STR      R0,[R1, #+0]
    585            
    586          }/*void InitAccelControlls()*/
   \   00000070   0x4770             BX       LR               ;; return
    587          
    588          

   \                                 In section .text, align 2, keep-with-next
    589          void GetDeviceData()
    590          {
   \                     GetDeviceData: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    591            
    592            int TempTempVal =0;
   \   00000002   0x2400             MOVS     R4,#+0
    593            int TempBat =0;
   \   00000004   0x2500             MOVS     R5,#+0
    594            //filteringCode  =0;
    595            
    596              /*for the regular data smapling we might want to make the change so that it will sample at the rate in gOptions.sampleRate
    597                the filtering code below needs to run at 20Khz at all times though that will not change*/
    598            
    599              AXIS =1 ;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    600             /*first want to get the max average and other values at 8KHz and then teansition into 20KHz*/
    601              INIT_PIT((uint32_t) 5999);        /*this is the 8K Hz*/
   \   0000000E   0xF241 0x706F      MOVW     R0,#+5999
   \   00000012   0x.... 0x....      BL       INIT_PIT
    602              NVIC_EnableIRQ(48);
   \   00000016   0x2030             MOVS     R0,#+48
   \   00000018   0x.... 0x....      BL       NVIC_EnableIRQ
    603              
    604              
    605              AXIS = 1;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   00000022   0x6008             STR      R0,[R1, #+0]
    606              PIT_ITTERATIONS =0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    607              
    608              while(PIT_ITTERATIONS < ACCEL_SAMPLE_SIZE)
   \                     ??GetDeviceData_0: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable13_4
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF5B0 0x5FFA      CMP      R0,#+8000
   \   00000036   0xDBF9             BLT.N    ??GetDeviceData_0
    609              {
    610                // X Y and Z to complete wait for the conversions to finish before continuing
    611              }
    612              AXIS =0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    613              gSnd.xmean = (uint16_t)((TempSumx + (ACCEL_SAMPLE_SIZE >>1))/ ACCEL_SAMPLE_SIZE);
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF510 0x607A      ADDS     R0,R0,#+4000
   \   0000004A   0xF44F 0x51FA      MOV      R1,#+8000
   \   0000004E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000056   0x8188             STRH     R0,[R1, #+12]
    614              
    615              
    616              gSnd.ymean = (uint16_t)((TempSumy + (ACCEL_SAMPLE_SIZE >>1))/ ACCEL_SAMPLE_SIZE);
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0xF510 0x607A      ADDS     R0,R0,#+4000
   \   00000062   0xF44F 0x51FA      MOV      R1,#+8000
   \   00000066   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000006E   0x8388             STRH     R0,[R1, #+28]
    617              
    618              
    619              gSnd.zmean = (uint16_t)((TempSumz + (ACCEL_SAMPLE_SIZE >>1))/ ACCEL_SAMPLE_SIZE);
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0xF510 0x607A      ADDS     R0,R0,#+4000
   \   0000007A   0xF44F 0x51FA      MOV      R1,#+8000
   \   0000007E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000086   0x8588             STRH     R0,[R1, #+44]
    620              
    621             /*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    622              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    623              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    624              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    625              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    626              *
    627              *This is where the filtering code needs to be enetered when we want to implement filtering again.
    628              *
    629              *
    630              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    631              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    632              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    633              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    634              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    635              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    636              */
    637              
    638              /*stop the timer and finish the temp and battery conversion and then send the data that was packed*/
    639              NVIC_DisableIRQ(48);
   \   00000088   0x2030             MOVS     R0,#+48
   \   0000008A   0x.... 0x....      BL       NVIC_DisableIRQ
    640                
    641                
    642              
    643              StartTempConversion();
   \   0000008E   0x.... 0x....      BL       StartTempConversion
    644              
    645              while(ConversionAComplete()==0){
   \                     ??GetDeviceData_1: (+1)
   \   00000092   0x.... 0x....      BL       ConversionAComplete
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD0FB             BEQ.N    ??GetDeviceData_1
    646              }
    647              TempTempVal = GetConversionValue();
   \   0000009A   0x.... 0x....      BL       GetConversionValue
   \   0000009E   0x0004             MOVS     R4,R0
    648              gSnd.temperature = 373 - (int16_t)((uint32_t)(TempTempVal) * 37800/84909)  ;
   \   000000A0   0xF240 0x1075      MOVW     R0,#+373
   \   000000A4   0xF249 0x31A8      MOVW     R1,#+37800
   \   000000A8   0xFB01 0xF104      MUL      R1,R1,R4
   \   000000AC   0x.... 0x....      LDR.W    R2,??DataTable18_2  ;; 0x14bad
   \   000000B0   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   000000B4   0x1A40             SUBS     R0,R0,R1
   \   000000B6   0x.... 0x....      LDR.W    R1,??DataTable16
   \   000000BA   0x8708             STRH     R0,[R1, #+56]
    649              
    650              /*now that the conversions are finished measure the voltage over the battery using adc 7 */
    651              StartBattConversion();
   \   000000BC   0x.... 0x....      BL       StartBattConversion
    652              while(ConversionAComplete()==0){
   \                     ??GetDeviceData_2: (+1)
   \   000000C0   0x.... 0x....      BL       ConversionAComplete
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD0FB             BEQ.N    ??GetDeviceData_2
    653              }
    654              TempBat = GetConversionValue();
   \   000000C8   0x.... 0x....      BL       GetConversionValue
   \   000000CC   0x0005             MOVS     R5,R0
    655              gSnd.battery_mV = (uint16_t)((uint32_t)(TempBat) * 4200 / 1023);
   \   000000CE   0xF241 0x0068      MOVW     R0,#+4200
   \   000000D2   0xFB00 0xF005      MUL      R0,R0,R5
   \   000000D6   0xF240 0x31FF      MOVW     R1,#+1023
   \   000000DA   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable16
   \   000000E2   0x8748             STRH     R0,[R1, #+58]
    656          
    657              
    658              
    659              
    660          }/*void GetDeviceData()*/
   \   000000E4   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    661          
    662          /*
    663          
    664          inits the pit timmer
    665          */

   \                                 In section .text, align 2, keep-with-next
    666          void INIT_PIT(uint32_t SampleSpeed)
    667          {
   \                     INIT_PIT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    668            NVIC_DisableIRQ(48);
   \   00000004   0x2030             MOVS     R0,#+48
   \   00000006   0x.... 0x....      BL       NVIC_DisableIRQ
    669            
    670            //set bit 24 in scgc6
    671            SIM_SCGC6 |= (uint32_t)(1<<23);
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x4004803c
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF450 0x0000      ORRS     R0,R0,#0x800000
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable18_3  ;; 0x4004803c
   \   00000018   0x6008             STR      R0,[R1, #+0]
    672            
    673            
    674            PIT_MCR = (uint32_t)0x1;                  //enable the freexe bit and enable the clock for standard pit timer
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable18_4  ;; 0x40037000
   \   00000020   0x6008             STR      R0,[R1, #+0]
    675            PIT_LDVAL0 = SampleSpeed;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable18_5  ;; 0x40037100
   \   00000026   0x6004             STR      R4,[R0, #+0]
    676            PIT_TCTRL0 = (uint32_t)0x3;                   //enable the timer and inable the timer interupt diable the cahin mode
   \   00000028   0x2003             MOVS     R0,#+3
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable18_6  ;; 0x40037108
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    677            
    678            
    679            
    680            PIT_TFLG0  = (uint32_t)0x1;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable24  ;; 0x4003710c
   \   00000036   0x6008             STR      R0,[R1, #+0]
    681            NVIC_SetPriority(48, 0);
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x2030             MOVS     R0,#+48
   \   0000003C   0x.... 0x....      BL       NVIC_SetPriority
    682            NVIC_EnableIRQ(48);
   \   00000040   0x2030             MOVS     R0,#+48
   \   00000042   0x.... 0x....      BL       NVIC_EnableIRQ
    683          }
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
    684          
    685          
    686          
    687          /*This is the Pit ISR, It will take samples of the ADC 8000 times in 1 second these two values will eventually 
    688          be modifiable using vibe.
    689          
    690          There will be a Golbal boolean that needs to be set when the value is at 8000 itterations, it needs to be reset when the program starts up
    691          
    692          */
    693          

   \                                 In section .text, align 2, keep-with-next
    694          void PIT_ISR()
    695          {
   \                     PIT_ISR: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    696            int TempXVal =0;
   \   00000002   0x2400             MOVS     R4,#+0
    697            int TempYVal =0;
   \   00000004   0x2500             MOVS     R5,#+0
    698            int TempZVal =0;  
   \   00000006   0x2600             MOVS     R6,#+0
    699            
    700            
    701            /*GreenStatLedOn();*/
    702          
    703          /*this is just set to do the 8 k samples it will not run the filtering code.
    704            */
    705            
    706                  /*need to take the sampling at 8KHz and find the min and max values here*/
    707                  /*need take 10,000 samples for the x conversion and save the raw values into the q15_t temp value thing */
    708                if(PIT_ITTERATIONS <= ACCEL_SAMPLE_SIZE && AXIS==1)
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable13_4
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF5B0 0x5FFA      CMP      R0,#+8000
   \   00000012   0xDC6B             BGT.N    ??PIT_ISR_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD166             BNE.N    ??PIT_ISR_0
    709                {
    710                //take the converstion values forom the a to d converter an then increment the number of ittereantion
    711                    StartXConversion();
   \   0000001E   0x.... 0x....      BL       StartXConversion
    712                    while(ConversionAComplete()==0){
   \                     ??PIT_ISR_1: (+1)
   \   00000022   0x.... 0x....      BL       ConversionAComplete
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD0FB             BEQ.N    ??PIT_ISR_1
    713                    }
    714                    TempXVal = GetConversionValue();
   \   0000002A   0x.... 0x....      BL       GetConversionValue
   \   0000002E   0x0004             MOVS     R4,R0
    715                     
    716                    
    717                    if(TempXVal > gSnd.xmax)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000034   0x8940             LDRH     R0,[R0, #+10]
   \   00000036   0x42A0             CMP      R0,R4
   \   00000038   0xDA02             BGE.N    ??PIT_ISR_2
    718                    {
    719                      gSnd.xmax = TempXVal;
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000003E   0x8144             STRH     R4,[R0, #+10]
    720                    }
    721                    if(TempXVal < gSnd.xmin)
   \                     ??PIT_ISR_2: (+1)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000044   0x8900             LDRH     R0,[R0, #+8]
   \   00000046   0x4284             CMP      R4,R0
   \   00000048   0xDA02             BGE.N    ??PIT_ISR_3
    722                    {
    723                      gSnd.xmin = TempXVal;
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000004E   0x8104             STRH     R4,[R0, #+8]
    724                    }
    725                    TempSumx += TempXVal;  
   \                     ??PIT_ISR_3: (+1)
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x1820             ADDS     R0,R4,R0
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable13
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    726                
    727                
    728                    StartYConversion();
   \   0000005E   0x.... 0x....      BL       StartYConversion
    729                    while(ConversionAComplete()==0){
   \                     ??PIT_ISR_4: (+1)
   \   00000062   0x.... 0x....      BL       ConversionAComplete
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD0FB             BEQ.N    ??PIT_ISR_4
    730                    }   
    731                    TempYVal = GetConversionValue();
   \   0000006A   0x.... 0x....      BL       GetConversionValue
   \   0000006E   0x0005             MOVS     R5,R0
    732                         
    733                    /*check th eY max and the Y Min */
    734                    if(TempYVal > gSnd.ymax)
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000074   0x8B40             LDRH     R0,[R0, #+26]
   \   00000076   0x42A8             CMP      R0,R5
   \   00000078   0xDA02             BGE.N    ??PIT_ISR_5
    735                    {
    736                      gSnd.ymax = TempYVal;
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000007E   0x8345             STRH     R5,[R0, #+26]
    737                    }
    738                    if(TempYVal < gSnd.ymin)
   \                     ??PIT_ISR_5: (+1)
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000084   0x8B00             LDRH     R0,[R0, #+24]
   \   00000086   0x4285             CMP      R5,R0
   \   00000088   0xDA02             BGE.N    ??PIT_ISR_6
    739                    {
    740                      gSnd.ymin = TempYVal;
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000008E   0x8305             STRH     R5,[R0, #+24]
    741                    }
    742                    TempSumy += TempYVal;
   \                     ??PIT_ISR_6: (+1)
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0x1828             ADDS     R0,R5,R0
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \   0000009C   0x6008             STR      R0,[R1, #+0]
    743                
    744                
    745                    StartZConversion();
   \   0000009E   0x.... 0x....      BL       StartZConversion
    746                    while(ConversionAComplete()==0){
   \                     ??PIT_ISR_7: (+1)
   \   000000A2   0x.... 0x....      BL       ConversionAComplete
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD0FB             BEQ.N    ??PIT_ISR_7
    747                    }
    748                    TempZVal = GetConversionValue();
   \   000000AA   0x.... 0x....      BL       GetConversionValue
   \   000000AE   0x0006             MOVS     R6,R0
    749                    /*Check the Z max and the Z min*/
    750                    if(TempZVal > gSnd.zmax)
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000B4   0x8D40             LDRH     R0,[R0, #+42]
   \   000000B6   0x42B0             CMP      R0,R6
   \   000000B8   0xDA02             BGE.N    ??PIT_ISR_8
    751                    {
    752                      gSnd.zmax = TempZVal;
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000BE   0x8546             STRH     R6,[R0, #+42]
    753                    }
    754                    if(TempZVal < gSnd.zmin)
   \                     ??PIT_ISR_8: (+1)
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000C4   0x8D00             LDRH     R0,[R0, #+40]
   \   000000C6   0x4286             CMP      R6,R0
   \   000000C8   0xDA02             BGE.N    ??PIT_ISR_9
    755                    {
    756                      gSnd.zmin = TempZVal;
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000CE   0x8506             STRH     R6,[R0, #+40]
    757                    }
    758                    TempSumz += TempZVal; 
   \                     ??PIT_ISR_9: (+1)
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0x1830             ADDS     R0,R6,R0
   \   000000D8   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000000DC   0x6008             STR      R0,[R1, #+0]
    759                
    760                
    761                
    762                
    763                PIT_ITTERATIONS ++;
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable13_4
   \   000000E2   0x6800             LDR      R0,[R0, #+0]
   \   000000E4   0x1C40             ADDS     R0,R0,#+1
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   000000EA   0x6008             STR      R0,[R1, #+0]
    764                }
    765                  
    766             
    767          
    768            
    769            /*the changing of axis will be handled in the main code. this needs to be done there since I need to calculate other tings there using the filter as well. */
    770            PIT_TFLG0  = (uint32_t)0x1;           //clears the interupt flag and will start a new 
   \                     ??PIT_ISR_0: (+1)
   \   000000EC   0x2001             MOVS     R0,#+1
   \   000000EE   0x.... 0x....      LDR.W    R1,??DataTable24  ;; 0x4003710c
   \   000000F2   0x6008             STR      R0,[R1, #+0]
    771            /*GreenStatLedOff();*/
    772          }
   \   000000F4   0xBD70             POP      {R4-R6,PC}       ;; return
    773          
    774          
    775          //return random number 0-15

   \                                 In section .text, align 2, keep-with-next
    776          uint8_t GetRandomNibble()
    777          {
    778              static uint8_t b=0;
    779              uint8_t* p = (uint8_t*) 0x1fff9200;
   \                     GetRandomNibble: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable20_2  ;; 0x1fff9200
    780             
    781              while (p> (uint8_t*) 0x1fff80f0)
   \                     ??GetRandomNibble_0: (+1)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable20_3  ;; 0x1fff80f1
   \   00000008   0x4281             CMP      R1,R0
   \   0000000A   0xD309             BCC.N    ??GetRandomNibble_1
    782              {
    783                --p;
   \   0000000C   0x1E49             SUBS     R1,R1,#+1
    784                
    785                  b ^= *p;    // xor "b" with next byte of memory
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x780A             LDRB     R2,[R1, #+0]
   \   00000016   0x4050             EORS     R0,R2,R0
   \   00000018   0x.... 0x....      LDR.W    R2,??DataTable25
   \   0000001C   0x7010             STRB     R0,[R2, #+0]
   \   0000001E   0xE7F1             B.N      ??GetRandomNibble_0
    786              }
    787              return (b >> 4) ^ (b & 15); // return left-nibble xor'ed with right-nibble (4 random bits)
   \                     ??GetRandomNibble_1: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable25
   \   0000002C   0x7812             LDRB     R2,[R2, #+0]
   \   0000002E   0xF012 0x020F      ANDS     R2,R2,#0xF
   \   00000032   0xEA92 0x1010      EORS     R0,R2,R0, LSR #+4
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x4770             BX       LR               ;; return
    788          }

   \                                 In section .bss, align 1
   \                     ??b:
   \   00000000                      DS8 1

   \                                 In section .text, align 2, keep-with-next
    789          int8_t GetLinkQdBm()
    790          {
   \                     GetLinkQdBm: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    791              // Get link quality (dBm) from last successful RX packet
    792            uint8_t quality;
    793           //   return (int8_t)((-(int16_t)MLMELinkQuality()) >> 1); // Note: "floor", not truncation
    794            MLMELinkQuality(&quality);
   \   00000002   0xA800             ADD      R0,SP,#+0
   \   00000004   0x.... 0x....      BL       MLMELinkQuality
    795            return quality;
   \   00000008   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
    796          }

   \                                 In section .text, align 2, keep-with-next
    797          uint8_t getRandomNumberInRange(uint8_t low,uint8_t high){
    798            if(high <= low) return low;
   \                     getRandomNumberInRange: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD301             BCC.N    ??getRandomNumberInRange_0
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0xE009             B.N      ??getRandomNumberInRange_1
    799            uint32_t random;
    800          //  RNG_GetRandomNo(&random);
    801          //  CR[INTM]=1;
    802            return low + (uint8_t)(random % (high - low + 1));    
                                          ^
Warning[Pe549]: variable "random" is used before its value is set
   \                     ??getRandomNumberInRange_0: (+1)
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x1A09             SUBS     R1,R1,R0
   \   00000012   0x1C49             ADDS     R1,R1,#+1
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0xFBB2 0xF2F1      UDIV     R2,R2,R1
   \   0000001A   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??getRandomNumberInRange_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return
    803          }
    804          

   \                                 In section .text, align 2, keep-with-next
    805          uint8_t ChooseBestChannel()
    806          {
   \                     ChooseBestChannel: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
    807            //RNG_Init();  
    808              uint8_t   channelStatus = INITIAL_VALUE;   // something other than SUCCESS
   \   00000004   0x2400             MOVS     R4,#+0
    809              uint8_t   channel = 0;
   \   00000006   0x2500             MOVS     R5,#+0
    810              uint8_t   iter;
    811              channels_t iChannel;
    812              //
    813              // Updated *** 10/26/10 ***
    814              // Note: all calls now go thru "GetLinkQdBm"
    815              //
    816              int8_t    maxLinkQdBm;
    817              
    818              
    819              // Get ready to send the PNG packet
    820              gAppTxPacket->u8DataLength = PNG_SIZE;
   \   00000008   0x2005             MOVS     R0,#+5
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable18_1
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   \   00000010   0x7008             STRB     R0,[R1, #+0]
    821              PngSwapEndianness();
   \   00000012   0x.... 0x....      BL       PngSwapEndianness
    822              CopyPngPacketToSMAC();
   \   00000016   0x.... 0x....      BL       CopyPngPacketToSMAC
    823              
    824              // Note: we don't want to wait very long between testing each channel,
    825              // so temporarily change the timeout to a low value
    826              gRxTimeout = gOptions.u32PngTimeout;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   0000001E   0x68C0             LDR      R0,[R0, #+12]
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable18
   \   00000024   0x6008             STR      R0,[R1, #+0]
    827              
    828              // Find channel with the best link quality
    829              maxLinkQdBm = -128;
   \   00000026   0xF07F 0x007F      MVNS     R0,#+127
   \   0000002A   0x4680             MOV      R8,R0
    830              channel=GetRandomNibble();
   \   0000002C   0x.... 0x....      BL       GetRandomNibble
   \   00000030   0x0005             MOVS     R5,R0
    831              smacErrors_t smacStatus;
    832              for (iter = 0; iter < 64; iter++) {
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x0006             MOVS     R6,R0
   \                     ??ChooseBestChannel_0: (+1)
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x2E40             CMP      R6,#+64
   \   0000003A   0xDA3C             BGE.N    ??ChooseBestChannel_1
    833                  smacStatus=gErrorBusy_c;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x4681             MOV      R9,R0
    834                  channel = (channel + 1) & 15;
   \   00000040   0x1C68             ADDS     R0,R5,#+1
   \   00000042   0xF010 0x050F      ANDS     R5,R0,#0xF
    835           //       channel=0;
    836                  iChannel=channel+gChannel11_c;
                                 ^
Warning[Pe188]: enumerated type mixed with another type
   \   00000046   0xF115 0x000B      ADDS     R0,R5,#+11
   \   0000004A   0x0007             MOVS     R7,R0
    837                  
    838                  while(smacStatus!=gErrorNoError_c){
   \                     ??ChooseBestChannel_2: (+1)
   \   0000004C   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000050   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000054   0xD005             BEQ.N    ??ChooseBestChannel_3
    839                    smacStatus=MLMESetChannelRequest(iChannel);
   \   00000056   0x0038             MOVS     R0,R7
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0x.... 0x....      BL       MLMESetChannelRequest
   \   0000005E   0x4681             MOV      R9,R0
   \   00000060   0xE7F4             B.N      ??ChooseBestChannel_2
    840                  }
    841                  smacStatus=gErrorBusy_c;
   \                     ??ChooseBestChannel_3: (+1)
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0x4681             MOV      R9,R0
    842                  //while(smacStatus!=gErrorNoError_c){
    843                    smacStatus=MCPSDataRequest(gAppTxPacket); // transmit data
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x.... 0x....      BL       MCPSDataRequest
   \   00000070   0x4681             MOV      R9,R0
    844                  //}
    845                  // NOTE: we have to keep looping here, because our PNG packets may be sent back
    846                  // to us by a REPEATER, but we should ignore them (only intereseted in ACK packets)
    847                  if(smacStatus==gErrorNoError_c){
   \   00000072   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000076   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000007A   0xD11A             BNE.N    ??ChooseBestChannel_4
    848                  
    849                  do 
    850                  {
    851                      ReceivePacket();
   \                     ??ChooseBestChannel_5: (+1)
   \   0000007C   0x.... 0x....      BL       ReceivePacket
    852                      if (gIsMyAck) 
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable26
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD00D             BEQ.N    ??ChooseBestChannel_6
    853                      {
    854                          int8_t linkQdBm = GetLinkQdBm();
   \   0000008A   0x.... 0x....      BL       GetLinkQdBm
    855                          if (linkQdBm > maxLinkQdBm)
   \   0000008E   0xFA4F 0xF888      SXTB     R8,R8            ;; SignExt  R8,R8,#+24,#+24
   \   00000092   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000094   0x4580             CMP      R8,R0
   \   00000096   0xDA06             BGE.N    ??ChooseBestChannel_6
    856                          {
    857                              maxLinkQdBm = linkQdBm;
   \   00000098   0x4680             MOV      R8,R0
    858                              gSnd.channel = iChannel;
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000009E   0xF881 0x7043      STRB     R7,[R1, #+67]
    859                              channelStatus = SUCCESS;
   \   000000A2   0x2177             MOVS     R1,#+119
   \   000000A4   0x000C             MOVS     R4,R1
    860                          }
    861                          //printf("Channel %d Link Quality %d",iChannel,linkQdBm);
    862                      }
    863                  }
    864                  while (gAppRxPacket->rxStatus != rxTimeOutStatus_c);
   \                     ??ChooseBestChannel_6: (+1)
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0x7840             LDRB     R0,[R0, #+1]
   \   000000AE   0x2803             CMP      R0,#+3
   \   000000B0   0xD1E4             BNE.N    ??ChooseBestChannel_5
    865                  }
    866              }
   \                     ??ChooseBestChannel_4: (+1)
   \   000000B2   0x1C76             ADDS     R6,R6,#+1
   \   000000B4   0xE7BF             B.N      ??ChooseBestChannel_0
    867              
    868              // Remember to restore the usual timeout value, i.e., the timeout for SND packets
    869              gRxTimeout = gOptions.u32SndTimeout;
   \                     ??ChooseBestChannel_1: (+1)
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   000000BA   0x6900             LDR      R0,[R0, #+16]
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable18
   \   000000C0   0x6008             STR      R0,[R1, #+0]
    870              
    871              // Reset channel (even if none were successful, since then it's original gChannelNumber)
    872              if (MLMESetChannelRequest(gSnd.channel) != SUCCESS) // select channel here (0-15)
                                               ^
Warning[Pe188]: enumerated type mixed with another type
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000C6   0xF890 0x0043      LDRB     R0,[R0, #+67]
   \   000000CA   0x.... 0x....      BL       MLMESetChannelRequest
   \   000000CE   0x4682             MOV      R10,R0
    873              { 
    874                  //printf("can't set channel %d",gSnd.channel);
    875              }
    876              
    877            	// Added *** 10/27/10 ***
    878              // NOTE: the most meaningful "linkQdBm" value in the first SND packet after
    879              // channel scan is "maxLinkQdBm" - see also "ReceivePacket".
    880              gSnd.linkQdBm = maxLinkQdBm;
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000D4   0xF880 0x803C      STRB     R8,[R0, #+60]
    881          
    882              // Finally, send our current options to the pan coordinator
    883              SendCurrentOptions();
   \   000000D8   0x.... 0x....      BL       SendCurrentOptions
    884              
    885              return channelStatus;  // return SUCCESS if selected channel is good
   \   000000DC   0x0020             MOVS     R0,R4
   \   000000DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E0   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    886          }
    887          

   \                                 In section .text, align 2, keep-with-next
    888          void ReceivePacket(){
   \                     ReceivePacket: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    889            appState = WAIT_FOR_ACK;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable15
   \   00000008   0x7008             STRB     R0,[R1, #+0]
    890            gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
   \   0000000A   0x207B             MOVS     R0,#+123
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x7008             STRB     R0,[R1, #+0]
    891            smacErrors_t status = MLMERXEnableRequest(gAppRxPacket, gRxTimeout);
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x.... 0x....      BL       MLMERXEnableRequest
   \   00000024   0x0004             MOVS     R4,R0
    892            while(status!=gErrorNoError_c){
   \                     ??ReceivePacket_0: (+1)
   \   00000026   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000028   0x2C00             CMP      R4,#+0
   \   0000002A   0xD009             BEQ.N    ??ReceivePacket_1
    893              status = MLMERXEnableRequest(gAppRxPacket, gRxTimeout);
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000030   0x6801             LDR      R1,[R0, #+0]
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x.... 0x....      BL       MLMERXEnableRequest
   \   0000003C   0x0004             MOVS     R4,R0
   \   0000003E   0xE7F2             B.N      ??ReceivePacket_0
    894            }
    895            
    896            while(appState == WAIT_FOR_ACK);
   \                     ??ReceivePacket_1: (+1)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000044   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD0F9             BEQ.N    ??ReceivePacket_1
    897            if(gAppRxPacket->rxStatus==rxSuccessStatus_c) {
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x7840             LDRB     R0,[R0, #+1]
   \   00000054   0x2802             CMP      R0,#+2
   \   00000056   0xD13B             BNE.N    ??ReceivePacket_2
    898              //LED_SetLed(LED3, gLedOn_c);
    899              if (gAppRxPacket->smacPdu.u8Data[0] == 'A' &&
    900                  gAppRxPacket->smacPdu.u8Data[1] == 'C' && 
    901                  gAppRxPacket->smacPdu.u8Data[2] == 'K' &&
    902                  gAppRxPacket->u8DataLength >= ACK_HEADER_SIZE)
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x7940             LDRB     R0,[R0, #+5]
   \   00000060   0x2841             CMP      R0,#+65
   \   00000062   0xD12D             BNE.N    ??ReceivePacket_3
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x7980             LDRB     R0,[R0, #+6]
   \   0000006C   0x2843             CMP      R0,#+67
   \   0000006E   0xD127             BNE.N    ??ReceivePacket_3
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0x79C0             LDRB     R0,[R0, #+7]
   \   00000078   0x284B             CMP      R0,#+75
   \   0000007A   0xD121             BNE.N    ??ReceivePacket_3
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0x7880             LDRB     R0,[R0, #+2]
   \   00000084   0x2805             CMP      R0,#+5
   \   00000086   0xDB1B             BLT.N    ??ReceivePacket_3
    903              {
    904                  gIsAck = TRUE;
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable16_2
   \   0000008E   0x7008             STRB     R0,[R1, #+0]
    905                  uint16_t ackID = (*(uint16_t*)&gAppRxPacket->smacPdu.u8Data[3]);
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0x8900             LDRH     R0,[R0, #+8]
    906                  ackID = (ackID << 8) | (ackID >> 8);
   \   00000098   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000009A   0x0A01             LSRS     R1,R0,#+8
   \   0000009C   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
    907                  gIsMyAck = (ackID == sensorID);
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable14
   \   000000A4   0x8809             LDRH     R1,[R1, #+0]
   \   000000A6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000A8   0x4288             CMP      R0,R1
   \   000000AA   0xD104             BNE.N    ??ReceivePacket_4
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable26
   \   000000B2   0x7008             STRB     R0,[R1, #+0]
   \   000000B4   0xE00C             B.N      ??ReceivePacket_2
   \                     ??ReceivePacket_4: (+1)
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable26
   \   000000BC   0x7008             STRB     R0,[R1, #+0]
   \   000000BE   0xE007             B.N      ??ReceivePacket_2
    908                  //if(gIsMyAck) LED_SetLed(LED1, gLedOn_c);
    909                 
    910              }
    911              else
    912              {
    913                  gIsAck = FALSE;
   \                     ??ReceivePacket_3: (+1)
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable16_2
   \   000000C6   0x7008             STRB     R0,[R1, #+0]
    914                  gIsMyAck = FALSE;
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable26
   \   000000CE   0x7008             STRB     R0,[R1, #+0]
    915              }
    916            }
    917            if(gAppRxPacket->rxStatus==rxTimeOutStatus_c) {
    918              //LED_SetLed(LED4, gLedOn_c); 
    919            }
    920            
    921          }
   \                     ??ReceivePacket_2: (+1)
   \   000000D0   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    922          void PrintPacketID(uint16_t packetID){
   \                     PrintPacketID: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    923            CommUtil_Print("\f\r\n Running PER Tx, Sending ", gAllowToBlock_d);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   0000000A   0x.... 0x....      BL       CommUtil_Print
    924            PrintWordOnDecimalFormatBlocking(packetID, 0, FALSE, gDefaultCommPort_c);
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000018   0x.... 0x....      BL       PrintWordOnDecimalFormatBlocking
    925            CommUtil_Print(" Packets", gAllowToBlock_d);
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable28
   \   00000022   0x.... 0x....      BL       CommUtil_Print
    926              
    927          }
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    928          
    929          

   \                                 In section .text, align 2, keep-with-next
    930          void SndSwapEndianness(){
    931            //uint16
    932            gSnd.hdr.u16SensorID  = (gSnd.hdr.u16SensorID << 8) | (gSnd.hdr.u16SensorID >> 8 );
   \                     SndSwapEndianness: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000004   0x8880             LDRH     R0,[R0, #+4]
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000000A   0x8889             LDRH     R1,[R1, #+4]
   \   0000000C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   0x0A09             LSRS     R1,R1,#+8
   \   00000010   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000018   0x8088             STRH     R0,[R1, #+4]
    933            gSnd.packetID         = (gSnd.packetID        << 8) | (gSnd.packetID       >> 8 );
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000001E   0x88C0             LDRH     R0,[R0, #+6]
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000024   0x88C9             LDRH     R1,[R1, #+6]
   \   00000026   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000028   0x0A09             LSRS     R1,R1,#+8
   \   0000002A   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000032   0x80C8             STRH     R0,[R1, #+6]
    934            gSnd.xmin             = (gSnd.xmin            << 8) | (gSnd.xmin           >> 8 );
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000038   0x8900             LDRH     R0,[R0, #+8]
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000003E   0x8909             LDRH     R1,[R1, #+8]
   \   00000040   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000042   0x0A09             LSRS     R1,R1,#+8
   \   00000044   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000004C   0x8108             STRH     R0,[R1, #+8]
    935            gSnd.xmax             = (gSnd.xmax            << 8) | (gSnd.xmax           >> 8 );
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000052   0x8940             LDRH     R0,[R0, #+10]
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000058   0x8949             LDRH     R1,[R1, #+10]
   \   0000005A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000005C   0x0A09             LSRS     R1,R1,#+8
   \   0000005E   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000066   0x8148             STRH     R0,[R1, #+10]
    936            gSnd.xmean            = (gSnd.xmean           << 8) | (gSnd.xmean          >> 8 );
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000006C   0x8980             LDRH     R0,[R0, #+12]
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000072   0x8989             LDRH     R1,[R1, #+12]
   \   00000074   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000076   0x0A09             LSRS     R1,R1,#+8
   \   00000078   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000080   0x8188             STRH     R0,[R1, #+12]
    937            gSnd.ymin             = (gSnd.ymin            << 8) | (gSnd.ymin           >> 8 );
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000086   0x8B00             LDRH     R0,[R0, #+24]
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000008C   0x8B09             LDRH     R1,[R1, #+24]
   \   0000008E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000090   0x0A09             LSRS     R1,R1,#+8
   \   00000092   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000009A   0x8308             STRH     R0,[R1, #+24]
    938            gSnd.ymax             = (gSnd.ymax            << 8) | (gSnd.ymax           >> 8 );
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000000A0   0x8B40             LDRH     R0,[R0, #+26]
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000000A6   0x8B49             LDRH     R1,[R1, #+26]
   \   000000A8   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000AA   0x0A09             LSRS     R1,R1,#+8
   \   000000AC   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000000B4   0x8348             STRH     R0,[R1, #+26]
    939            gSnd.ymean            = (gSnd.ymean           << 8) | (gSnd.ymean          >> 8 );
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000000BA   0x8B80             LDRH     R0,[R0, #+28]
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000000C0   0x8B89             LDRH     R1,[R1, #+28]
   \   000000C2   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000C4   0x0A09             LSRS     R1,R1,#+8
   \   000000C6   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000000CE   0x8388             STRH     R0,[R1, #+28]
    940            gSnd.zmin             = (gSnd.zmin            << 8) | (gSnd.zmin           >> 8 );
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000000D4   0x8D00             LDRH     R0,[R0, #+40]
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000000DA   0x8D09             LDRH     R1,[R1, #+40]
   \   000000DC   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000DE   0x0A09             LSRS     R1,R1,#+8
   \   000000E0   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000000E8   0x8508             STRH     R0,[R1, #+40]
    941            gSnd.zmax             = (gSnd.zmax            << 8) | (gSnd.zmax           >> 8 );
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000000EE   0x8D40             LDRH     R0,[R0, #+42]
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000000F4   0x8D49             LDRH     R1,[R1, #+42]
   \   000000F6   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000F8   0x0A09             LSRS     R1,R1,#+8
   \   000000FA   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000FE   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000102   0x8548             STRH     R0,[R1, #+42]
    942            gSnd.zmean            = (gSnd.zmean           << 8) | (gSnd.zmean          >> 8 );
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000108   0x8D80             LDRH     R0,[R0, #+44]
   \   0000010A   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000010E   0x8D89             LDRH     R1,[R1, #+44]
   \   00000110   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000112   0x0A09             LSRS     R1,R1,#+8
   \   00000114   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000118   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000011C   0x8588             STRH     R0,[R1, #+44]
    943            gSnd.battery_mV       = (gSnd.battery_mV      << 8) | (gSnd.battery_mV     >> 8 );
   \   0000011E   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000122   0x8F40             LDRH     R0,[R0, #+58]
   \   00000124   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000128   0x8F49             LDRH     R1,[R1, #+58]
   \   0000012A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000012C   0x0A09             LSRS     R1,R1,#+8
   \   0000012E   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000132   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000136   0x8748             STRH     R0,[R1, #+58]
    944            gSnd.totalTimeouts    = (gSnd.totalTimeouts   << 8) | (gSnd.totalTimeouts  >> 8 );
   \   00000138   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000013C   0x8FC0             LDRH     R0,[R0, #+62]
   \   0000013E   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000142   0x8FC9             LDRH     R1,[R1, #+62]
   \   00000144   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000146   0x0A09             LSRS     R1,R1,#+8
   \   00000148   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000014C   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000150   0x87C8             STRH     R0,[R1, #+62]
    945            gSnd.maxMissedCount   = (gSnd.maxMissedCount  << 8) | (gSnd.maxMissedCount >> 8 );
   \   00000152   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000156   0xF8B0 0x0040      LDRH     R0,[R0, #+64]
   \   0000015A   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000015E   0xF8B1 0x1040      LDRH     R1,[R1, #+64]
   \   00000162   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000164   0x0A09             LSRS     R1,R1,#+8
   \   00000166   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000016A   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000016E   0xF8A1 0x0040      STRH     R0,[R1, #+64]
    946            
    947            //int16
    948            gSnd.temperature      = (gSnd.temperature << 8) | ((gSnd.temperature >> 8) & 0xFF);
   \   00000172   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000176   0x8F00             LDRH     R0,[R0, #+56]
   \   00000178   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000017C   0xF9B1 0x1038      LDRSH    R1,[R1, #+56]
   \   00000180   0xF3C1 0x2107      UBFX     R1,R1,#+8,#+8
   \   00000184   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000188   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000018C   0x8708             STRH     R0,[R1, #+56]
    949            
    950            //uint32
    951            gSnd.xsum0 = ((gSnd.xsum0 << 8) & 0xFF00FF00 ) | ((gSnd.xsum0 >> 8) & 0xFF00FF ); 
   \   0000018E   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000192   0x6900             LDR      R0,[R0, #+16]
   \   00000194   0x0200             LSLS     R0,R0,#+8
   \   00000196   0xF030 0x10FF      BICS     R0,R0,#0xFF00FF
   \   0000019A   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000019E   0x6909             LDR      R1,[R1, #+16]
   \   000001A0   0x0A09             LSRS     R1,R1,#+8
   \   000001A2   0xF011 0x11FF      ANDS     R1,R1,#0xFF00FF
   \   000001A6   0x4308             ORRS     R0,R1,R0
   \   000001A8   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000001AC   0x6108             STR      R0,[R1, #+16]
    952            gSnd.xsum0 = (gSnd.xsum0 << 16) | (gSnd.xsum0 >> 16);
   \   000001AE   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000001B2   0x6900             LDR      R0,[R0, #+16]
   \   000001B4   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000001B8   0x6909             LDR      R1,[R1, #+16]
   \   000001BA   0xEA5F 0x4031      RORS     R0,R1,#+16
   \   000001BE   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000001C2   0x6108             STR      R0,[R1, #+16]
    953            gSnd.xsum1 = ((gSnd.xsum1 << 8) & 0xFF00FF00 ) | ((gSnd.xsum1 >> 8) & 0xFF00FF ); 
   \   000001C4   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000001C8   0x6940             LDR      R0,[R0, #+20]
   \   000001CA   0x0200             LSLS     R0,R0,#+8
   \   000001CC   0xF030 0x10FF      BICS     R0,R0,#0xFF00FF
   \   000001D0   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000001D4   0x6949             LDR      R1,[R1, #+20]
   \   000001D6   0x0A09             LSRS     R1,R1,#+8
   \   000001D8   0xF011 0x11FF      ANDS     R1,R1,#0xFF00FF
   \   000001DC   0x4308             ORRS     R0,R1,R0
   \   000001DE   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000001E2   0x6148             STR      R0,[R1, #+20]
    954            gSnd.xsum1 =  (gSnd.xsum1 << 16) | (gSnd.xsum1 >> 16);
   \   000001E4   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000001E8   0x6940             LDR      R0,[R0, #+20]
   \   000001EA   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000001EE   0x6949             LDR      R1,[R1, #+20]
   \   000001F0   0xEA5F 0x4031      RORS     R0,R1,#+16
   \   000001F4   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000001F8   0x6148             STR      R0,[R1, #+20]
    955            gSnd.ysum0 = ((gSnd.ysum0 << 8) & 0xFF00FF00 ) | ((gSnd.ysum0 >> 8) & 0xFF00FF ); 
   \   000001FA   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000001FE   0x6A00             LDR      R0,[R0, #+32]
   \   00000200   0x0200             LSLS     R0,R0,#+8
   \   00000202   0xF030 0x10FF      BICS     R0,R0,#0xFF00FF
   \   00000206   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000020A   0x6A09             LDR      R1,[R1, #+32]
   \   0000020C   0x0A09             LSRS     R1,R1,#+8
   \   0000020E   0xF011 0x11FF      ANDS     R1,R1,#0xFF00FF
   \   00000212   0x4308             ORRS     R0,R1,R0
   \   00000214   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000218   0x6208             STR      R0,[R1, #+32]
    956            gSnd.ysum0 = (gSnd.ysum0 << 16) | (gSnd.ysum0 >> 16);
   \   0000021A   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000021E   0x6A00             LDR      R0,[R0, #+32]
   \   00000220   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000224   0x6A09             LDR      R1,[R1, #+32]
   \   00000226   0xEA5F 0x4031      RORS     R0,R1,#+16
   \   0000022A   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000022E   0x6208             STR      R0,[R1, #+32]
    957            gSnd.ysum1 = ((gSnd.ysum1 << 8) & 0xFF00FF00 ) | ((gSnd.ysum1 >> 8) & 0xFF00FF ); 
   \   00000230   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000234   0x6A40             LDR      R0,[R0, #+36]
   \   00000236   0x0200             LSLS     R0,R0,#+8
   \   00000238   0xF030 0x10FF      BICS     R0,R0,#0xFF00FF
   \   0000023C   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000240   0x6A49             LDR      R1,[R1, #+36]
   \   00000242   0x0A09             LSRS     R1,R1,#+8
   \   00000244   0xF011 0x11FF      ANDS     R1,R1,#0xFF00FF
   \   00000248   0x4308             ORRS     R0,R1,R0
   \   0000024A   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000024E   0x6248             STR      R0,[R1, #+36]
    958            gSnd.ysum1 =  (gSnd.ysum1 << 16) | (gSnd.ysum1 >> 16);  
   \   00000250   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000254   0x6A40             LDR      R0,[R0, #+36]
   \   00000256   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000025A   0x6A49             LDR      R1,[R1, #+36]
   \   0000025C   0xEA5F 0x4031      RORS     R0,R1,#+16
   \   00000260   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000264   0x6248             STR      R0,[R1, #+36]
    959            gSnd.zsum0 = ((gSnd.zsum0 << 8) & 0xFF00FF00 ) | ((gSnd.zsum0 >> 8) & 0xFF00FF ); 
   \   00000266   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000026A   0x6B00             LDR      R0,[R0, #+48]
   \   0000026C   0x0200             LSLS     R0,R0,#+8
   \   0000026E   0xF030 0x10FF      BICS     R0,R0,#0xFF00FF
   \   00000272   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000276   0x6B09             LDR      R1,[R1, #+48]
   \   00000278   0x0A09             LSRS     R1,R1,#+8
   \   0000027A   0xF011 0x11FF      ANDS     R1,R1,#0xFF00FF
   \   0000027E   0x4308             ORRS     R0,R1,R0
   \   00000280   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000284   0x6308             STR      R0,[R1, #+48]
    960            gSnd.zsum0 = (gSnd.zsum0 << 16) | (gSnd.zsum0 >> 16);
   \   00000286   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000028A   0x6B00             LDR      R0,[R0, #+48]
   \   0000028C   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000290   0x6B09             LDR      R1,[R1, #+48]
   \   00000292   0xEA5F 0x4031      RORS     R0,R1,#+16
   \   00000296   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000029A   0x6308             STR      R0,[R1, #+48]
    961            gSnd.zsum1 = ((gSnd.zsum1 << 8) & 0xFF00FF00 ) | ((gSnd.zsum1 >> 8) & 0xFF00FF ); 
   \   0000029C   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000002A0   0x6B40             LDR      R0,[R0, #+52]
   \   000002A2   0x0200             LSLS     R0,R0,#+8
   \   000002A4   0xF030 0x10FF      BICS     R0,R0,#0xFF00FF
   \   000002A8   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000002AC   0x6B49             LDR      R1,[R1, #+52]
   \   000002AE   0x0A09             LSRS     R1,R1,#+8
   \   000002B0   0xF011 0x11FF      ANDS     R1,R1,#0xFF00FF
   \   000002B4   0x4308             ORRS     R0,R1,R0
   \   000002B6   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000002BA   0x6348             STR      R0,[R1, #+52]
    962            gSnd.zsum1 =  (gSnd.zsum1 << 16) | (gSnd.zsum1 >> 16);
   \   000002BC   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000002C0   0x6B40             LDR      R0,[R0, #+52]
   \   000002C2   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000002C6   0x6B49             LDR      R1,[R1, #+52]
   \   000002C8   0xEA5F 0x4031      RORS     R0,R1,#+16
   \   000002CC   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000002D0   0x6348             STR      R0,[R1, #+52]
    963            
    964          }
   \   000002D2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    965          void CopyOptionsFromRecvPacket(tOptions* pOptions){
   \                     CopyOptionsFromRecvPacket: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    966          
    967            uint32_t offset = ACK_HEADER_SIZE;      
   \   00000004   0x2505             MOVS     R5,#+5
    968            MemoryCpy(&pOptions->u8RawSpinCount, &gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->u8RawSpinCount));  
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x....             LDR.N    R0,??DataTable16_3
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x1828             ADDS     R0,R5,R0
   \   0000000E   0x1D41             ADDS     R1,R0,#+5
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       MemoryCpy
    969            offset += sizeof(uint8_t);
   \   00000016   0x1C6D             ADDS     R5,R5,#+1
    970            MemoryCpy(&pOptions->u16TimeoutsToKill, &gAppRxPacket->smacPdu.u8Data[offset],sizeof(pOptions->u16TimeoutsToKill));
   \   00000018   0x2202             MOVS     R2,#+2
   \   0000001A   0x....             LDR.N    R0,??DataTable16_3
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x1828             ADDS     R0,R5,R0
   \   00000020   0x1D41             ADDS     R1,R0,#+5
   \   00000022   0x1CA0             ADDS     R0,R4,#+2
   \   00000024   0x.... 0x....      BL       MemoryCpy
    971            offset += sizeof(uint16_t);
   \   00000028   0x1CAD             ADDS     R5,R5,#+2
    972            MemoryCpy(&pOptions->u16SampleSize, &gAppRxPacket->smacPdu.u8Data[offset],sizeof(pOptions->u16SampleSize));
   \   0000002A   0x2202             MOVS     R2,#+2
   \   0000002C   0x....             LDR.N    R0,??DataTable16_3
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x1828             ADDS     R0,R5,R0
   \   00000032   0x1D41             ADDS     R1,R0,#+5
   \   00000034   0x1D20             ADDS     R0,R4,#+4
   \   00000036   0x.... 0x....      BL       MemoryCpy
    973            offset += sizeof(uint16_t);
   \   0000003A   0x1CAD             ADDS     R5,R5,#+2
    974            MemoryCpy(&pOptions->bAsciiMode, &gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->bAsciiMode));
   \   0000003C   0x2201             MOVS     R2,#+1
   \   0000003E   0x....             LDR.N    R0,??DataTable16_3
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x1828             ADDS     R0,R5,R0
   \   00000044   0x1D41             ADDS     R1,R0,#+5
   \   00000046   0x1DA0             ADDS     R0,R4,#+6
   \   00000048   0x.... 0x....      BL       MemoryCpy
    975            offset += sizeof(uint8_t);
   \   0000004C   0x1C6D             ADDS     R5,R5,#+1
    976            MemoryCpy(&pOptions->bBlinkingLEDs, &gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->bBlinkingLEDs));
   \   0000004E   0x2201             MOVS     R2,#+1
   \   00000050   0x....             LDR.N    R0,??DataTable16_3
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x1828             ADDS     R0,R5,R0
   \   00000056   0x1D41             ADDS     R1,R0,#+5
   \   00000058   0x1DE0             ADDS     R0,R4,#+7
   \   0000005A   0x.... 0x....      BL       MemoryCpy
    977            offset += sizeof(uint8_t);                                           
   \   0000005E   0x1C6D             ADDS     R5,R5,#+1
    978            MemoryCpy(&pOptions->u8OutputPower, &gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->u8OutputPower));
   \   00000060   0x2201             MOVS     R2,#+1
   \   00000062   0x....             LDR.N    R0,??DataTable16_3
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0x1828             ADDS     R0,R5,R0
   \   00000068   0x1D41             ADDS     R1,R0,#+5
   \   0000006A   0xF114 0x0008      ADDS     R0,R4,#+8
   \   0000006E   0x.... 0x....      BL       MemoryCpy
    979            offset += sizeof(uint8_t);                                        
   \   00000072   0x1C6D             ADDS     R5,R5,#+1
    980            MemoryCpy(&pOptions->u32PngTimeout, &gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->u32PngTimeout));
   \   00000074   0x2204             MOVS     R2,#+4
   \   00000076   0x....             LDR.N    R0,??DataTable16_3
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x1828             ADDS     R0,R5,R0
   \   0000007C   0x1D41             ADDS     R1,R0,#+5
   \   0000007E   0xF114 0x000C      ADDS     R0,R4,#+12
   \   00000082   0x.... 0x....      BL       MemoryCpy
    981            offset += sizeof(uint32_t);                                        
   \   00000086   0x1D2D             ADDS     R5,R5,#+4
    982            MemoryCpy(&pOptions->u32SndTimeout, &gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->u32SndTimeout));
   \   00000088   0x2204             MOVS     R2,#+4
   \   0000008A   0x....             LDR.N    R0,??DataTable16_3
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0x1828             ADDS     R0,R5,R0
   \   00000090   0x1D41             ADDS     R1,R0,#+5
   \   00000092   0xF114 0x0010      ADDS     R0,R4,#+16
   \   00000096   0x.... 0x....      BL       MemoryCpy
    983            offset += sizeof(uint32_t);
   \   0000009A   0x1D2D             ADDS     R5,R5,#+4
    984            MemoryCpy(&pOptions->bLNAHighGainMode,&gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->bLNAHighGainMode)); // i.e. Low Noise Amplifier - updated *** 10/26/10 *** (formerly "u8Reserved2")
   \   0000009C   0x2201             MOVS     R2,#+1
   \   0000009E   0x....             LDR.N    R0,??DataTable16_3
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x1828             ADDS     R0,R5,R0
   \   000000A4   0x1D41             ADDS     R1,R0,#+5
   \   000000A6   0xF114 0x0014      ADDS     R0,R4,#+20
   \   000000AA   0x.... 0x....      BL       MemoryCpy
    985            offset += sizeof(uint8_t);
   \   000000AE   0x1C6D             ADDS     R5,R5,#+1
    986            MemoryCpy(&pOptions->u16SleepAfterAck,&gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->u16SleepAfterAck));
   \   000000B0   0x2202             MOVS     R2,#+2
   \   000000B2   0x....             LDR.N    R0,??DataTable16_3
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0x1828             ADDS     R0,R5,R0
   \   000000B8   0x1D41             ADDS     R1,R0,#+5
   \   000000BA   0xF114 0x0016      ADDS     R0,R4,#+22
   \   000000BE   0x.... 0x....      BL       MemoryCpy
    987            
    988          
    989          }
   \   000000C2   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
    990          void OptSwapEndianness(tOptions* pOptions){
    991            
    992            
    993            
    994            pOptions->u16TimeoutsToKill   = ((pOptions->u16TimeoutsToKill)       << 8) | ((pOptions->u16TimeoutsToKill) >> 8);
   \                     OptSwapEndianness: (+1)
   \   00000000   0x8841             LDRH     R1,[R0, #+2]
   \   00000002   0x8842             LDRH     R2,[R0, #+2]
   \   00000004   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000006   0x0A12             LSRS     R2,R2,#+8
   \   00000008   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   0000000C   0x8041             STRH     R1,[R0, #+2]
    995            pOptions->u16SampleSize       = ((pOptions->u16SampleSize)           << 8) | ((pOptions->u16SampleSize)     >> 8);
   \   0000000E   0x8881             LDRH     R1,[R0, #+4]
   \   00000010   0x8882             LDRH     R2,[R0, #+4]
   \   00000012   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000014   0x0A12             LSRS     R2,R2,#+8
   \   00000016   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   0000001A   0x8081             STRH     R1,[R0, #+4]
    996            pOptions->u16SleepAfterAck    = ((pOptions->u16SleepAfterAck)        << 8) | ((pOptions->u16SleepAfterAck)  >> 8);
   \   0000001C   0x8AC1             LDRH     R1,[R0, #+22]
   \   0000001E   0x8AC2             LDRH     R2,[R0, #+22]
   \   00000020   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000022   0x0A12             LSRS     R2,R2,#+8
   \   00000024   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   00000028   0x82C1             STRH     R1,[R0, #+22]
    997            
    998            pOptions->u32PngTimeout = (((pOptions->u32PngTimeout) << 8) & 0xFF00FF00 ) | (((pOptions->u32PngTimeout) >> 8) & 0xFF00FF );
   \   0000002A   0x68C1             LDR      R1,[R0, #+12]
   \   0000002C   0x0209             LSLS     R1,R1,#+8
   \   0000002E   0xF031 0x11FF      BICS     R1,R1,#0xFF00FF
   \   00000032   0x68C2             LDR      R2,[R0, #+12]
   \   00000034   0x0A12             LSRS     R2,R2,#+8
   \   00000036   0xF012 0x12FF      ANDS     R2,R2,#0xFF00FF
   \   0000003A   0x4311             ORRS     R1,R2,R1
   \   0000003C   0x60C1             STR      R1,[R0, #+12]
    999            pOptions->u32PngTimeout = (pOptions->u32PngTimeout << 16) | (pOptions->u32PngTimeout >> 16);
   \   0000003E   0x68C1             LDR      R1,[R0, #+12]
   \   00000040   0x68C2             LDR      R2,[R0, #+12]
   \   00000042   0xEA5F 0x4132      RORS     R1,R2,#+16
   \   00000046   0x60C1             STR      R1,[R0, #+12]
   1000            
   1001            pOptions->u32SndTimeout = (((pOptions->u32SndTimeout) << 8) & 0xFF00FF00 ) | (((pOptions->u32SndTimeout) >> 8) & 0xFF00FF );
   \   00000048   0x6901             LDR      R1,[R0, #+16]
   \   0000004A   0x0209             LSLS     R1,R1,#+8
   \   0000004C   0xF031 0x11FF      BICS     R1,R1,#0xFF00FF
   \   00000050   0x6902             LDR      R2,[R0, #+16]
   \   00000052   0x0A12             LSRS     R2,R2,#+8
   \   00000054   0xF012 0x12FF      ANDS     R2,R2,#0xFF00FF
   \   00000058   0x4311             ORRS     R1,R2,R1
   \   0000005A   0x6101             STR      R1,[R0, #+16]
   1002            pOptions->u32SndTimeout = (pOptions->u32SndTimeout << 16) | (pOptions->u32SndTimeout >> 16);
   \   0000005C   0x6901             LDR      R1,[R0, #+16]
   \   0000005E   0x6902             LDR      R2,[R0, #+16]
   \   00000060   0xEA5F 0x4132      RORS     R1,R2,#+16
   \   00000064   0x6101             STR      R1,[R0, #+16]
   1003            
   1004            
   1005            
   1006          }
   \   00000066   0x4770             BX       LR               ;; return
   1007          

   \                                 In section .text, align 2, keep-with-next
   1008          void PngSwapEndianness(){
   1009            gPng.u16SensorID = (gPng.u16SensorID << 8) | (gPng.u16SensorID >> 8);
   \                     PngSwapEndianness: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \   00000004   0x8880             LDRH     R0,[R0, #+4]
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable28_1
   \   0000000A   0x8889             LDRH     R1,[R1, #+4]
   \   0000000C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   0x0A09             LSRS     R1,R1,#+8
   \   00000010   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable28_1
   \   00000018   0x8088             STRH     R0,[R1, #+4]
   1010          }
   \   0000001A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1011          void CopyPngPacketToSMAC(){
   \                     CopyPngPacketToSMAC: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1012            MemoryCpy(&gAppTxPacket->smacPdu.u8Data[0],       (uint8_t*)&gPng.u8Prefix[0],       sizeof(gPng.u8Prefix[0]));
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable28_1
   \   00000008   0x....             LDR.N    R0,??DataTable18_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x1CC0             ADDS     R0,R0,#+3
   \   0000000E   0x.... 0x....      BL       MemoryCpy
   1013            MemoryCpy(&gAppTxPacket->smacPdu.u8Data[1],       (uint8_t*)&gPng.u8Prefix[1],       sizeof(gPng.u8Prefix[1]));
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable28_2
   \   00000018   0x....             LDR.N    R0,??DataTable18_1
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x1D00             ADDS     R0,R0,#+4
   \   0000001E   0x.... 0x....      BL       MemoryCpy
   1014            MemoryCpy(&gAppTxPacket->smacPdu.u8Data[2],       (uint8_t*)&gPng.u8Prefix[2],       sizeof(gPng.u8Prefix[2]));
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable28_3
   \   00000028   0x....             LDR.N    R0,??DataTable18_1
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x1D40             ADDS     R0,R0,#+5
   \   0000002E   0x.... 0x....      BL       MemoryCpy
   1015            MemoryCpy(&gAppTxPacket->smacPdu.u8Data[3],       (uint8_t*)&gPng.u16SensorID,       sizeof(gPng.u16SensorID));
   \   00000032   0x2202             MOVS     R2,#+2
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable28_4
   \   00000038   0x....             LDR.N    R0,??DataTable18_1
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x1D80             ADDS     R0,R0,#+6
   \   0000003E   0x.... 0x....      BL       MemoryCpy
   1016                     
   1017          }
   \   00000042   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   1018          void CopyBinaryPacketToSMAC(){
   \                     CopyBinaryPacketToSMAC: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1019            
   1020            
   1021            
   1022              
   1023            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[0]),  (uint8_t*)&gSnd.hdr.u8Prefix[0]        ,sizeof(gSnd.hdr.u8Prefix[0]));
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000008   0x....             LDR.N    R0,??DataTable18_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x1CC0             ADDS     R0,R0,#+3
   \   0000000E   0x.... 0x....      BL       MemoryCpy
   1024            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[1]),  (uint8_t*)&gSnd.hdr.u8Prefix[1]        ,sizeof(gSnd.hdr.u8Prefix[1]));
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable28_5
   \   00000018   0x....             LDR.N    R0,??DataTable18_1
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x1D00             ADDS     R0,R0,#+4
   \   0000001E   0x.... 0x....      BL       MemoryCpy
   1025            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[2]),  (uint8_t*)&gSnd.hdr.u8Prefix[2]        ,sizeof(gSnd.hdr.u8Prefix[2]));
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable28_6
   \   00000028   0x....             LDR.N    R0,??DataTable18_1
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x1D40             ADDS     R0,R0,#+5
   \   0000002E   0x.... 0x....      BL       MemoryCpy
   1026            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[3]),  (uint8_t*)&gSnd.hdr.u8Length           ,sizeof(gSnd.hdr.u8Length   ));
   \   00000032   0x2201             MOVS     R2,#+1
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable28_7
   \   00000038   0x....             LDR.N    R0,??DataTable18_1
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x1D80             ADDS     R0,R0,#+6
   \   0000003E   0x.... 0x....      BL       MemoryCpy
   1027            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[4]),  (uint8_t*)&gSnd.hdr.u16SensorID        ,sizeof(gSnd.hdr.u16SensorID));
   \   00000042   0x2202             MOVS     R2,#+2
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable28_8
   \   00000048   0x....             LDR.N    R0,??DataTable18_1
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x1DC0             ADDS     R0,R0,#+7
   \   0000004E   0x.... 0x....      BL       MemoryCpy
   1028            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[6]),  (uint8_t*)&gSnd.packetID               ,sizeof(gSnd.packetID       ));
   \   00000052   0x2202             MOVS     R2,#+2
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable28_9
   \   00000058   0x....             LDR.N    R0,??DataTable18_1
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x3009             ADDS     R0,R0,#+9
   \   0000005E   0x.... 0x....      BL       MemoryCpy
   1029            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[8]),  (uint8_t*)&gSnd.xmin                   ,sizeof(gSnd.xmin           ));
   \   00000062   0x2202             MOVS     R2,#+2
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable28_10
   \   00000068   0x....             LDR.N    R0,??DataTable18_1
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x300B             ADDS     R0,R0,#+11
   \   0000006E   0x.... 0x....      BL       MemoryCpy
   1030            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[10]), (uint8_t*)&gSnd.xmax                   ,sizeof(gSnd.xmax           ));
   \   00000072   0x2202             MOVS     R2,#+2
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable28_11
   \   00000078   0x....             LDR.N    R0,??DataTable18_1
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x300D             ADDS     R0,R0,#+13
   \   0000007E   0x.... 0x....      BL       MemoryCpy
   1031            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[12]), (uint8_t*)&gSnd.xmean                  ,sizeof(gSnd.xmean          ));
   \   00000082   0x2202             MOVS     R2,#+2
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable28_12
   \   00000088   0x....             LDR.N    R0,??DataTable18_1
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x300F             ADDS     R0,R0,#+15
   \   0000008E   0x.... 0x....      BL       MemoryCpy
   1032            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[14]), (uint8_t*)&gSnd.xsum0                  ,sizeof(gSnd.xsum0          ));
   \   00000092   0x2204             MOVS     R2,#+4
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable28_13
   \   00000098   0x....             LDR.N    R0,??DataTable18_1
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0x3011             ADDS     R0,R0,#+17
   \   0000009E   0x.... 0x....      BL       MemoryCpy
   1033            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[18]), (uint8_t*)&gSnd.xsum1                  ,sizeof(gSnd.xsum1          ));
   \   000000A2   0x2204             MOVS     R2,#+4
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable28_14
   \   000000A8   0x....             LDR.N    R0,??DataTable18_1
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0x3015             ADDS     R0,R0,#+21
   \   000000AE   0x.... 0x....      BL       MemoryCpy
   1034            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[22]), (uint8_t*)&gSnd.ymin                   ,sizeof(gSnd.ymin           ));
   \   000000B2   0x2202             MOVS     R2,#+2
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable28_15
   \   000000B8   0x....             LDR.N    R0,??DataTable18_1
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0x3019             ADDS     R0,R0,#+25
   \   000000BE   0x.... 0x....      BL       MemoryCpy
   1035            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[24]), (uint8_t*)&gSnd.ymax                   ,sizeof(gSnd.ymax           ));
   \   000000C2   0x2202             MOVS     R2,#+2
   \   000000C4   0x.... 0x....      LDR.W    R1,??DataTable28_16
   \   000000C8   0x....             LDR.N    R0,??DataTable18_1
   \   000000CA   0x6800             LDR      R0,[R0, #+0]
   \   000000CC   0x301B             ADDS     R0,R0,#+27
   \   000000CE   0x.... 0x....      BL       MemoryCpy
   1036            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[26]), (uint8_t*)&gSnd.ymean                  ,sizeof(gSnd.ymean          ));
   \   000000D2   0x2202             MOVS     R2,#+2
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable28_17
   \   000000D8   0x....             LDR.N    R0,??DataTable18_1
   \   000000DA   0x6800             LDR      R0,[R0, #+0]
   \   000000DC   0x301D             ADDS     R0,R0,#+29
   \   000000DE   0x.... 0x....      BL       MemoryCpy
   1037            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[28]), (uint8_t*)&gSnd.ysum0                  ,sizeof(gSnd.ysum0          ));
   \   000000E2   0x2204             MOVS     R2,#+4
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable28_18
   \   000000E8   0x....             LDR.N    R0,??DataTable18_1
   \   000000EA   0x6800             LDR      R0,[R0, #+0]
   \   000000EC   0x301F             ADDS     R0,R0,#+31
   \   000000EE   0x.... 0x....      BL       MemoryCpy
   1038            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[32]), (uint8_t*)&gSnd.ysum1                  ,sizeof(gSnd.ysum1          ));
   \   000000F2   0x2204             MOVS     R2,#+4
   \   000000F4   0x.... 0x....      LDR.W    R1,??DataTable28_19
   \   000000F8   0x....             LDR.N    R0,??DataTable18_1
   \   000000FA   0x6800             LDR      R0,[R0, #+0]
   \   000000FC   0x3023             ADDS     R0,R0,#+35
   \   000000FE   0x.... 0x....      BL       MemoryCpy
   1039            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[36]), (uint8_t*)&gSnd.zmin                   ,sizeof(gSnd.zmin           ));
   \   00000102   0x2202             MOVS     R2,#+2
   \   00000104   0x.... 0x....      LDR.W    R1,??DataTable28_20
   \   00000108   0x....             LDR.N    R0,??DataTable18_1
   \   0000010A   0x6800             LDR      R0,[R0, #+0]
   \   0000010C   0x3027             ADDS     R0,R0,#+39
   \   0000010E   0x.... 0x....      BL       MemoryCpy
   1040            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[38]), (uint8_t*)&gSnd.zmax                   ,sizeof(gSnd.zmax           ));
   \   00000112   0x2202             MOVS     R2,#+2
   \   00000114   0x.... 0x....      LDR.W    R1,??DataTable28_21
   \   00000118   0x....             LDR.N    R0,??DataTable18_1
   \   0000011A   0x6800             LDR      R0,[R0, #+0]
   \   0000011C   0x3029             ADDS     R0,R0,#+41
   \   0000011E   0x.... 0x....      BL       MemoryCpy
   1041            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[40]), (uint8_t*)&gSnd.zmean                  ,sizeof(gSnd.zmean          ));
   \   00000122   0x2202             MOVS     R2,#+2
   \   00000124   0x.... 0x....      LDR.W    R1,??DataTable28_22
   \   00000128   0x....             LDR.N    R0,??DataTable18_1
   \   0000012A   0x6800             LDR      R0,[R0, #+0]
   \   0000012C   0x302B             ADDS     R0,R0,#+43
   \   0000012E   0x.... 0x....      BL       MemoryCpy
   1042            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[42]), (uint8_t*)&gSnd.zsum0                  ,sizeof(gSnd.zsum0          ));
   \   00000132   0x2204             MOVS     R2,#+4
   \   00000134   0x.... 0x....      LDR.W    R1,??DataTable28_23
   \   00000138   0x....             LDR.N    R0,??DataTable18_1
   \   0000013A   0x6800             LDR      R0,[R0, #+0]
   \   0000013C   0x302D             ADDS     R0,R0,#+45
   \   0000013E   0x.... 0x....      BL       MemoryCpy
   1043            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[46]), (uint8_t*)&gSnd.zsum1                  ,sizeof(gSnd.zsum1          ));
   \   00000142   0x2204             MOVS     R2,#+4
   \   00000144   0x.... 0x....      LDR.W    R1,??DataTable28_24
   \   00000148   0x....             LDR.N    R0,??DataTable18_1
   \   0000014A   0x6800             LDR      R0,[R0, #+0]
   \   0000014C   0x3031             ADDS     R0,R0,#+49
   \   0000014E   0x.... 0x....      BL       MemoryCpy
   1044            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[50]), (uint8_t*)&gSnd.temperature            ,sizeof(gSnd.temperature    ));
   \   00000152   0x2202             MOVS     R2,#+2
   \   00000154   0x.... 0x....      LDR.W    R1,??DataTable28_25
   \   00000158   0x....             LDR.N    R0,??DataTable18_1
   \   0000015A   0x6800             LDR      R0,[R0, #+0]
   \   0000015C   0x3035             ADDS     R0,R0,#+53
   \   0000015E   0x.... 0x....      BL       MemoryCpy
   1045            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[52]), (uint8_t*)&gSnd.battery_mV             ,sizeof(gSnd.battery_mV     ));
   \   00000162   0x2202             MOVS     R2,#+2
   \   00000164   0x.... 0x....      LDR.W    R1,??DataTable28_26
   \   00000168   0x....             LDR.N    R0,??DataTable18_1
   \   0000016A   0x6800             LDR      R0,[R0, #+0]
   \   0000016C   0x3037             ADDS     R0,R0,#+55
   \   0000016E   0x.... 0x....      BL       MemoryCpy
   1046            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[54]), (uint8_t*)&gSnd.linkQdBm               ,sizeof(gSnd.linkQdBm       ));
   \   00000172   0x2201             MOVS     R2,#+1
   \   00000174   0x.... 0x....      LDR.W    R1,??DataTable28_27
   \   00000178   0x....             LDR.N    R0,??DataTable18_1
   \   0000017A   0x6800             LDR      R0,[R0, #+0]
   \   0000017C   0x3039             ADDS     R0,R0,#+57
   \   0000017E   0x.... 0x....      BL       MemoryCpy
   1047            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[55]), (uint8_t*)&gSnd.totalTimeouts          ,sizeof(gSnd.totalTimeouts  ));
   \   00000182   0x2202             MOVS     R2,#+2
   \   00000184   0x.... 0x....      LDR.W    R1,??DataTable28_28
   \   00000188   0x....             LDR.N    R0,??DataTable18_1
   \   0000018A   0x6800             LDR      R0,[R0, #+0]
   \   0000018C   0x303A             ADDS     R0,R0,#+58
   \   0000018E   0x.... 0x....      BL       MemoryCpy
   1048            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[57]), (uint8_t*)&gSnd.maxMissedCount         ,sizeof(gSnd.maxMissedCount ));
   \   00000192   0x2202             MOVS     R2,#+2
   \   00000194   0x.... 0x....      LDR.W    R1,??DataTable28_29
   \   00000198   0x....             LDR.N    R0,??DataTable18_1
   \   0000019A   0x6800             LDR      R0,[R0, #+0]
   \   0000019C   0x303C             ADDS     R0,R0,#+60
   \   0000019E   0x.... 0x....      BL       MemoryCpy
   1049            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[59]), (uint8_t*)&gSnd.voltageWarning         ,sizeof(gSnd.voltageWarning ));
   \   000001A2   0x2201             MOVS     R2,#+1
   \   000001A4   0x.... 0x....      LDR.W    R1,??DataTable28_30
   \   000001A8   0x....             LDR.N    R0,??DataTable18_1
   \   000001AA   0x6800             LDR      R0,[R0, #+0]
   \   000001AC   0x303E             ADDS     R0,R0,#+62
   \   000001AE   0x.... 0x....      BL       MemoryCpy
   1050            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[60]), (uint8_t*)&gSnd.channel                ,sizeof(gSnd.channel        ));
   \   000001B2   0x2201             MOVS     R2,#+1
   \   000001B4   0x.... 0x....      LDR.W    R1,??DataTable28_31
   \   000001B8   0x....             LDR.N    R0,??DataTable18_1
   \   000001BA   0x6800             LDR      R0,[R0, #+0]
   \   000001BC   0x303F             ADDS     R0,R0,#+63
   \   000001BE   0x.... 0x....      BL       MemoryCpy
   1051            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[61]), (uint8_t*)&gSnd.version                ,sizeof(gSnd.version        ));
   \   000001C2   0x2201             MOVS     R2,#+1
   \   000001C4   0x.... 0x....      LDR.W    R1,??DataTable28_32
   \   000001C8   0x....             LDR.N    R0,??DataTable18_1
   \   000001CA   0x6800             LDR      R0,[R0, #+0]
   \   000001CC   0x3040             ADDS     R0,R0,#+64
   \   000001CE   0x.... 0x....      BL       MemoryCpy
   1052             
   1053            gAppTxPacket->u8DataLength = SND_SIZE;
   \   000001D2   0x203E             MOVS     R0,#+62
   \   000001D4   0x....             LDR.N    R1,??DataTable18_1
   \   000001D6   0x6809             LDR      R1,[R1, #+0]
   \   000001D8   0x7008             STRB     R0,[R1, #+0]
   1054          }
   \   000001DA   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   1055          void CopyOptPacketToSMAC(){
   \                     CopyOptPacketToSMAC: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1056            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[0]),   (uint8_t*)&gOpt.hdr.u8Prefix[0]        ,sizeof(gOpt.hdr.u8Prefix[0]));
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable28_33
   \   00000008   0x....             LDR.N    R0,??DataTable18_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x1CC0             ADDS     R0,R0,#+3
   \   0000000E   0x.... 0x....      BL       MemoryCpy
   1057            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[1]),   (uint8_t*)&gOpt.hdr.u8Prefix[1]        ,sizeof(gOpt.hdr.u8Prefix[1]));
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable29
   \   00000018   0x....             LDR.N    R0,??DataTable18_1
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x1D00             ADDS     R0,R0,#+4
   \   0000001E   0x.... 0x....      BL       MemoryCpy
   1058            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[2]),   (uint8_t*)&gOpt.hdr.u8Prefix[2]        ,sizeof(gOpt.hdr.u8Prefix[2]));
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable29_1
   \   00000028   0x....             LDR.N    R0,??DataTable18_1
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x1D40             ADDS     R0,R0,#+5
   \   0000002E   0x.... 0x....      BL       MemoryCpy
   1059            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[3]),   (uint8_t*)&gOpt.hdr.u8Length           ,sizeof(gOpt.hdr.u8Length   ));
   \   00000032   0x2201             MOVS     R2,#+1
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable29_2
   \   00000038   0x....             LDR.N    R0,??DataTable18_1
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x1D80             ADDS     R0,R0,#+6
   \   0000003E   0x.... 0x....      BL       MemoryCpy
   1060            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[4]),   (uint8_t*)&gOpt.hdr.u16SensorID        ,sizeof(gOpt.hdr.u16SensorID));
   \   00000042   0x2202             MOVS     R2,#+2
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable29_3
   \   00000048   0x....             LDR.N    R0,??DataTable18_1
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x1DC0             ADDS     R0,R0,#+7
   \   0000004E   0x.... 0x....      BL       MemoryCpy
   1061            
   1062            
   1063            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[6]),   (uint8_t*)&gOpt.options.u8RawSpinCount        ,sizeof(gOpt.options.u8RawSpinCount    ));   // updated *** 06/08/11 *** (formerly "u8Reserved1")
   \   00000052   0x2201             MOVS     R2,#+1
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable29_4
   \   00000058   0x....             LDR.N    R0,??DataTable18_1
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x3009             ADDS     R0,R0,#+9
   \   0000005E   0x.... 0x....      BL       MemoryCpy
   1064            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[7]),   (uint8_t*)&gOpt.options.u16TimeoutsToKill     ,sizeof(gOpt.options.u16TimeoutsToKill ));
   \   00000062   0x2202             MOVS     R2,#+2
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable29_5
   \   00000068   0x....             LDR.N    R0,??DataTable18_1
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x300A             ADDS     R0,R0,#+10
   \   0000006E   0x.... 0x....      BL       MemoryCpy
   1065            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[9]),   (uint8_t*)&gOpt.options.u16SampleSize         ,sizeof(gOpt.options.u16SampleSize     ));
   \   00000072   0x2202             MOVS     R2,#+2
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable29_6
   \   00000078   0x....             LDR.N    R0,??DataTable18_1
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x300C             ADDS     R0,R0,#+12
   \   0000007E   0x.... 0x....      BL       MemoryCpy
   1066            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[11]),   (uint8_t*)&gOpt.options.bAsciiMode            ,sizeof(gOpt.options.bAsciiMode        ));
   \   00000082   0x2201             MOVS     R2,#+1
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable29_7
   \   00000088   0x....             LDR.N    R0,??DataTable18_1
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x300E             ADDS     R0,R0,#+14
   \   0000008E   0x.... 0x....      BL       MemoryCpy
   1067            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[12]),   (uint8_t*)&gOpt.options.bBlinkingLEDs         ,sizeof(gOpt.options.bBlinkingLEDs     ));
   \   00000092   0x2201             MOVS     R2,#+1
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable29_8
   \   00000098   0x....             LDR.N    R0,??DataTable18_1
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0x300F             ADDS     R0,R0,#+15
   \   0000009E   0x.... 0x....      BL       MemoryCpy
   1068            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[13]),  (uint8_t*)&gOpt.options.u8OutputPower         ,sizeof(gOpt.options.u8OutputPower     ));
   \   000000A2   0x2201             MOVS     R2,#+1
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable29_9
   \   000000A8   0x....             LDR.N    R0,??DataTable18_1
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0x3010             ADDS     R0,R0,#+16
   \   000000AE   0x.... 0x....      BL       MemoryCpy
   1069            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[14]),  (uint8_t*)&gOpt.options.u32PngTimeout         ,sizeof(gOpt.options.u32PngTimeout     ));
   \   000000B2   0x2204             MOVS     R2,#+4
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable29_10
   \   000000B8   0x....             LDR.N    R0,??DataTable18_1
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0x3011             ADDS     R0,R0,#+17
   \   000000BE   0x.... 0x....      BL       MemoryCpy
   1070            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[18]),  (uint8_t*)&gOpt.options.u32SndTimeout         ,sizeof(gOpt.options.u32SndTimeout     ));
   \   000000C2   0x2204             MOVS     R2,#+4
   \   000000C4   0x.... 0x....      LDR.W    R1,??DataTable29_11
   \   000000C8   0x....             LDR.N    R0,??DataTable18_1
   \   000000CA   0x6800             LDR      R0,[R0, #+0]
   \   000000CC   0x3015             ADDS     R0,R0,#+21
   \   000000CE   0x.... 0x....      BL       MemoryCpy
   1071            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[22]),  (uint8_t*)&gOpt.options.bLNAHighGainMode      ,sizeof(gOpt.options.bLNAHighGainMode  )); // i.e. Low Noise Amplifier - updated *** 10/26/10 *** (formerly "u8Reserved2")
   \   000000D2   0x2201             MOVS     R2,#+1
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable29_12
   \   000000D8   0x....             LDR.N    R0,??DataTable18_1
   \   000000DA   0x6800             LDR      R0,[R0, #+0]
   \   000000DC   0x3019             ADDS     R0,R0,#+25
   \   000000DE   0x.... 0x....      BL       MemoryCpy
   1072            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[23]),  (uint8_t*)&gOpt.options.u16SleepAfterAck      ,sizeof(gOpt.options.u16SleepAfterAck  ));
   \   000000E2   0x2202             MOVS     R2,#+2
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable29_13
   \   000000E8   0x....             LDR.N    R0,??DataTable18_1
   \   000000EA   0x6800             LDR      R0,[R0, #+0]
   \   000000EC   0x301A             ADDS     R0,R0,#+26
   \   000000EE   0x.... 0x....      BL       MemoryCpy
   1073            gAppTxPacket->u8DataLength = OPT_SIZE;
   \   000000F2   0x2019             MOVS     R0,#+25
   \   000000F4   0x....             LDR.N    R1,??DataTable18_1
   \   000000F6   0x6809             LDR      R1,[R1, #+0]
   \   000000F8   0x7008             STRB     R0,[R1, #+0]
   1074            
   1075          }
   \   000000FA   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   1076          smacErrors_t SendASCIIPacket(){
   \                     SendASCIIPacket: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB094             SUB      SP,SP,#+80
   1077            InitPacket();
   \   00000004   0x.... 0x....      BL       InitPacket
   1078            gSnd.packetID=sentPackets;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable29_14
   \   0000000C   0x8800             LDRH     R0,[R0, #+0]
   \   0000000E   0x....             LDR.N    R1,??DataTable19
   \   00000010   0x80C8             STRH     R0,[R1, #+6]
   1079            int len = sprintf(&gAppTxPacket->smacPdu.u8Data[0],
   1080                      "SND\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%d\t%u\t%d\t%u\t%u\t%u\t%u\t%u\r\n",
   1081                      gSnd.hdr.u16SensorID, gSnd.packetID,
   1082                      gSnd.xmin, gSnd.xmax, gSnd.xmean,
   1083                      gSnd.ymin, gSnd.ymax, gSnd.ymean, 
   1084                      gSnd.ysum0, gSnd.ysum1,
   1085                      gSnd.zmin, gSnd.zmax, gSnd.zmean,
   1086                      gSnd.temperature, gSnd.battery_mV, gSnd.linkQdBm,
   1087                      gSnd.totalTimeouts, gSnd.maxMissedCount,
   1088                      gSnd.voltageWarning, gSnd.channel, gSnd.version);
   \   00000012   0x....             LDR.N    R0,??DataTable19
   \   00000014   0xF890 0x0044      LDRB     R0,[R0, #+68]
   \   00000018   0x9012             STR      R0,[SP, #+72]
   \   0000001A   0x....             LDR.N    R0,??DataTable19
   \   0000001C   0xF890 0x0043      LDRB     R0,[R0, #+67]
   \   00000020   0x9011             STR      R0,[SP, #+68]
   \   00000022   0x....             LDR.N    R0,??DataTable19
   \   00000024   0xF890 0x0042      LDRB     R0,[R0, #+66]
   \   00000028   0x9010             STR      R0,[SP, #+64]
   \   0000002A   0x....             LDR.N    R0,??DataTable19
   \   0000002C   0xF8B0 0x0040      LDRH     R0,[R0, #+64]
   \   00000030   0x900F             STR      R0,[SP, #+60]
   \   00000032   0x....             LDR.N    R0,??DataTable19
   \   00000034   0x8FC0             LDRH     R0,[R0, #+62]
   \   00000036   0x900E             STR      R0,[SP, #+56]
   \   00000038   0x....             LDR.N    R0,??DataTable19
   \   0000003A   0xF990 0x003C      LDRSB    R0,[R0, #+60]
   \   0000003E   0x900D             STR      R0,[SP, #+52]
   \   00000040   0x....             LDR.N    R0,??DataTable19
   \   00000042   0x8F40             LDRH     R0,[R0, #+58]
   \   00000044   0x900C             STR      R0,[SP, #+48]
   \   00000046   0x....             LDR.N    R0,??DataTable19
   \   00000048   0xF9B0 0x0038      LDRSH    R0,[R0, #+56]
   \   0000004C   0x900B             STR      R0,[SP, #+44]
   \   0000004E   0x....             LDR.N    R0,??DataTable19
   \   00000050   0x8D80             LDRH     R0,[R0, #+44]
   \   00000052   0x900A             STR      R0,[SP, #+40]
   \   00000054   0x....             LDR.N    R0,??DataTable19
   \   00000056   0x8D40             LDRH     R0,[R0, #+42]
   \   00000058   0x9009             STR      R0,[SP, #+36]
   \   0000005A   0x....             LDR.N    R0,??DataTable19
   \   0000005C   0x8D00             LDRH     R0,[R0, #+40]
   \   0000005E   0x9008             STR      R0,[SP, #+32]
   \   00000060   0x....             LDR.N    R0,??DataTable19
   \   00000062   0x6A40             LDR      R0,[R0, #+36]
   \   00000064   0x9007             STR      R0,[SP, #+28]
   \   00000066   0x....             LDR.N    R0,??DataTable19
   \   00000068   0x6A00             LDR      R0,[R0, #+32]
   \   0000006A   0x9006             STR      R0,[SP, #+24]
   \   0000006C   0x....             LDR.N    R0,??DataTable19
   \   0000006E   0x8B80             LDRH     R0,[R0, #+28]
   \   00000070   0x9005             STR      R0,[SP, #+20]
   \   00000072   0x....             LDR.N    R0,??DataTable19
   \   00000074   0x8B40             LDRH     R0,[R0, #+26]
   \   00000076   0x9004             STR      R0,[SP, #+16]
   \   00000078   0x....             LDR.N    R0,??DataTable19
   \   0000007A   0x8B00             LDRH     R0,[R0, #+24]
   \   0000007C   0x9003             STR      R0,[SP, #+12]
   \   0000007E   0x....             LDR.N    R0,??DataTable19
   \   00000080   0x8980             LDRH     R0,[R0, #+12]
   \   00000082   0x9002             STR      R0,[SP, #+8]
   \   00000084   0x....             LDR.N    R0,??DataTable19
   \   00000086   0x8940             LDRH     R0,[R0, #+10]
   \   00000088   0x9001             STR      R0,[SP, #+4]
   \   0000008A   0x....             LDR.N    R0,??DataTable19
   \   0000008C   0x8900             LDRH     R0,[R0, #+8]
   \   0000008E   0x9000             STR      R0,[SP, #+0]
   \   00000090   0x....             LDR.N    R0,??DataTable19
   \   00000092   0x88C3             LDRH     R3,[R0, #+6]
   \   00000094   0x....             LDR.N    R0,??DataTable19
   \   00000096   0x8882             LDRH     R2,[R0, #+4]
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable29_15
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable29_16
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x1CC0             ADDS     R0,R0,#+3
   \   000000A4   0x.... 0x....      BL       sprintf
   \   000000A8   0x0004             MOVS     R4,R0
   1089            gAppTxPacket->u8DataLength = len;
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable29_16
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0x7004             STRB     R4,[R0, #+0]
   1090            smacErrors_t status=MCPSDataRequest(gAppTxPacket);    
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable29_16
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0x.... 0x....      BL       MCPSDataRequest
   1091            return status;
   \   000000BC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BE   0xB014             ADD      SP,SP,#+80
   \   000000C0   0xBD10             POP      {R4,PC}          ;; return
   1092              
   1093          }

   \                                 In section .text, align 2, keep-with-next
   1094          smacErrors_t SendBinaryPacket(){
   \                     SendBinaryPacket: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1095            //InitPacket();
   1096            gSnd.packetID=sentPackets;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable29_14
   \   00000006   0x8800             LDRH     R0,[R0, #+0]
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   0000000C   0x80C8             STRH     R0,[R1, #+6]
   1097            gSnd.linkQdBm=GetLinkQdBm();
   \   0000000E   0x.... 0x....      BL       GetLinkQdBm
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   00000016   0xF881 0x003C      STRB     R0,[R1, #+60]
   1098            SndSwapEndianness();
   \   0000001A   0x.... 0x....      BL       SndSwapEndianness
   1099            CopyBinaryPacketToSMAC();  
   \   0000001E   0x.... 0x....      BL       CopyBinaryPacketToSMAC
   1100            smacErrors_t status=MCPSDataRequest(gAppTxPacket);    
   \   00000022   0x....             LDR.N    R0,??DataTable25_2
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x.... 0x....      BL       MCPSDataRequest
   1101            appState = WAIT_FOR_ACK;
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0x.... 0x....      LDR.W    R2,??DataTable36
   \   00000030   0x7011             STRB     R1,[R2, #+0]
   1102            return status;
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0xBD02             POP      {R1,PC}          ;; return
   1103          }
   1104          

   \                                 In section .text, align 2, keep-with-next
   1105          void InitPacket(){
   1106            gSnd.hdr.u8Prefix[0] = 'S';
   \                     InitPacket: (+1)
   \   00000000   0x2053             MOVS     R0,#+83
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   00000006   0x7008             STRB     R0,[R1, #+0]
   1107            gSnd.hdr.u8Prefix[1] = 'N';
   \   00000008   0x204E             MOVS     R0,#+78
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   0000000E   0x7048             STRB     R0,[R1, #+1]
   1108            gSnd.hdr.u8Prefix[2] = 'D';       
   \   00000010   0x2044             MOVS     R0,#+68
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   00000016   0x7088             STRB     R0,[R1, #+2]
   1109            gSnd.hdr.u8Length = SND_SIZE;
   \   00000018   0x203E             MOVS     R0,#+62
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   0000001E   0x70C8             STRB     R0,[R1, #+3]
   1110            gSnd.hdr.u16SensorID = sensorID;  
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable29_18
   \   00000024   0x8800             LDRH     R0,[R0, #+0]
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   0000002A   0x8088             STRH     R0,[R1, #+4]
   1111            
   1112            gSnd.xsum0 = 1111111;
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable29_19  ;; 0x10f447
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   00000034   0x6108             STR      R0,[R1, #+16]
   1113            gSnd.ysum0 = 2222222;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable29_20  ;; 0x21e88e
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   0000003E   0x6208             STR      R0,[R1, #+32]
   1114            gSnd.zsum0 = 3333333;
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable29_21  ;; 0x32dcd5
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   00000048   0x6308             STR      R0,[R1, #+48]
   1115            gSnd.xsum1 = 111111111;
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0x69f6bc7
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   00000052   0x6148             STR      R0,[R1, #+20]
   1116            gSnd.ysum1 = 222222222;
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable31  ;; 0xd3ed78e
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   0000005C   0x6248             STR      R0,[R1, #+36]
   1117            gSnd.zsum1 = 333333333;
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable31_1  ;; 0x13de4355
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   00000066   0x6348             STR      R0,[R1, #+52]
   1118            gSnd.xmin = 1000;
   \   00000068   0xF44F 0x707A      MOV      R0,#+1000
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   00000070   0x8108             STRH     R0,[R1, #+8]
   1119            gSnd.ymin = 2000;
   \   00000072   0xF44F 0x60FA      MOV      R0,#+2000
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   0000007A   0x8308             STRH     R0,[R1, #+24]
   1120            gSnd.zmin = 3000;
   \   0000007C   0xF640 0x30B8      MOVW     R0,#+3000
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   00000084   0x8508             STRH     R0,[R1, #+40]
   1121            gSnd.xmax = 9991;
   \   00000086   0xF242 0x7007      MOVW     R0,#+9991
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   0000008E   0x8148             STRH     R0,[R1, #+10]
   1122            gSnd.ymax = 9992;
   \   00000090   0xF242 0x7008      MOVW     R0,#+9992
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   00000098   0x8348             STRH     R0,[R1, #+26]
   1123            gSnd.zmax = 9993;
   \   0000009A   0xF242 0x7009      MOVW     R0,#+9993
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   000000A2   0x8548             STRH     R0,[R1, #+42]
   1124            gSnd.xmean = 111;
   \   000000A4   0x206F             MOVS     R0,#+111
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   000000AA   0x8188             STRH     R0,[R1, #+12]
   1125            gSnd.ymean = 222;
   \   000000AC   0x20DE             MOVS     R0,#+222
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   000000B2   0x8388             STRH     R0,[R1, #+28]
   1126            gSnd.zmean = 333;
   \   000000B4   0xF240 0x104D      MOVW     R0,#+333
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   000000BC   0x8588             STRH     R0,[R1, #+44]
   1127            gSnd.packetID=666;
   \   000000BE   0xF240 0x209A      MOVW     R0,#+666
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   000000C6   0x80C8             STRH     R0,[R1, #+6]
   1128            gSnd.temperature=375;
   \   000000C8   0xF240 0x1077      MOVW     R0,#+375
   \   000000CC   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   000000D0   0x8708             STRH     R0,[R1, #+56]
   1129            gSnd.battery_mV=3000;
   \   000000D2   0xF640 0x30B8      MOVW     R0,#+3000
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   000000DA   0x8748             STRH     R0,[R1, #+58]
   1130           // gSnd.linkQdBm=-75;
   1131            gSnd.totalTimeouts=3;
   \   000000DC   0x2003             MOVS     R0,#+3
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   000000E2   0x87C8             STRH     R0,[R1, #+62]
   1132            gSnd.maxMissedCount=3;
   \   000000E4   0x2003             MOVS     R0,#+3
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   000000EA   0xF8A1 0x0040      STRH     R0,[R1, #+64]
   1133            gSnd.voltageWarning=2;
   \   000000EE   0x2002             MOVS     R0,#+2
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   000000F4   0xF881 0x0042      STRB     R0,[R1, #+66]
   1134            gSnd.channel=gChannel11_c - 11;
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   000000FE   0xF881 0x0043      STRB     R0,[R1, #+67]
   1135            gSnd.version=9;
   \   00000102   0x2009             MOVS     R0,#+9
   \   00000104   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   00000108   0xF881 0x0044      STRB     R0,[R1, #+68]
   1136            
   1137            evDataFromCOMM = FALSE;
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable36_1
   \   00000112   0x7008             STRB     R0,[R1, #+0]
   1138          }
   \   00000114   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1139          void FlashSaveOptions(){
   \                     FlashSaveOptions: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   1140            
   1141            uint32_t statErase, statRead, statWrite;
   1142            NvConfig_t mNvConfig = {
   1143             gNV_FTFX_REG_BASE_c,
   1144             gNV_PFLASH_BLOCK_BASE_c,
   1145             gNV_PFLASH_BLOCK_SIZE_c,
   1146             gNV_DFLASH_BLOCK_BASE_c,
   1147             gNV_DFLASH_BLOCK_SIZE_c,
   1148             gNV_EERAM_BLOCK_BASE_c,
   1149             gNV_EERAM_BLOCK_SIZE_c,
   1150             gNV_EEE_BLOCK_SIZE_c
   1151            };
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable35
   \   0000000A   0x2220             MOVS     R2,#+32
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy4
   1152            gFlashDeadBeef=g_DEAD_BEEF;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable35_2
   \   0000001A   0x6008             STR      R0,[R1, #+0]
   1153            statErase = NV_FlashEraseSector(&mNvConfig, settingsAddress,0x800);
   \   0000001C   0xF44F 0x6200      MOV      R2,#+2048
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable35_3
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0xA800             ADD      R0,SP,#+0
   \   00000028   0x.... 0x....      BL       NV_FlashEraseSector
   \   0000002C   0x0004             MOVS     R4,R0
   1154            uint32_t address = settingsAddress;
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable35_3
   \   00000032   0x6806             LDR      R6,[R0, #+0]
   1155            statWrite = NV_FlashProgramLongword(&mNvConfig,settingsAddress,sizeof(gFlashDeadBeef),(uint32_t)&gFlashDeadBeef);
   \   00000034   0x.... 0x....      LDR.W    R3,??DataTable35_2
   \   00000038   0x2204             MOVS     R2,#+4
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable35_3
   \   0000003E   0x6801             LDR      R1,[R0, #+0]
   \   00000040   0xA800             ADD      R0,SP,#+0
   \   00000042   0x.... 0x....      BL       NV_FlashProgramLongword
   \   00000046   0x0005             MOVS     R5,R0
   1156            address = address + sizeof(gFlashDeadBeef);
   \   00000048   0x1D36             ADDS     R6,R6,#+4
   1157            if(statWrite ==gNV_OK_c) NV_FlashProgramUnalignedLongword(&mNvConfig,address,sizeof(gOptions),(uint32_t)&gOptions);
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD106             BNE.N    ??FlashSaveOptions_0
   \   0000004E   0x.... 0x....      LDR.W    R3,??DataTable36_2
   \   00000052   0x2218             MOVS     R2,#+24
   \   00000054   0x0031             MOVS     R1,R6
   \   00000056   0xA800             ADD      R0,SP,#+0
   \   00000058   0x.... 0x....      BL       NV_FlashProgramUnalignedLongword
   1158          //  NV_FlashRead(address, (uint8_t*)&gFlashOptions,sizeof(gFlashOptions));
   1159            
   1160          }
   \                     ??FlashSaveOptions_0: (+1)
   \   0000005C   0xB008             ADD      SP,SP,#+32
   \   0000005E   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   1161          void GetFactoryOptions(tOptions* pOptions)
   1162          {
   1163              // Load the factory default configuration options
   1164              pOptions->u8RawSpinCount = 0; // i.e., don't send raw accelerometer data - updated *** 06/08/11 ***
   \                     GetFactoryOptions: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7001             STRB     R1,[R0, #+0]
   1165              pOptions->u16TimeoutsToKill = TIMEOUTS_TO_KILL;
   \   00000004   0xF44F 0x71B4      MOV      R1,#+360
   \   00000008   0x8041             STRH     R1,[R0, #+2]
   1166              pOptions->u16SampleSize = ACCEL_SAMPLE_SIZE;
   \   0000000A   0xF44F 0x51FA      MOV      R1,#+8000
   \   0000000E   0x8081             STRH     R1,[R0, #+4]
   1167              pOptions->bAsciiMode = TRUE;
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x7181             STRB     R1,[R0, #+6]
   1168              pOptions->bBlinkingLEDs = TRUE;
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x71C1             STRB     R1,[R0, #+7]
   1169              pOptions->u8OutputPower = OUTPUT_POWER;
   \   00000018   0x2164             MOVS     R1,#+100
   \   0000001A   0x7201             STRB     R1,[R0, #+8]
   1170              pOptions->u32PngTimeout = PNG_TIMEOUT;
   \   0000001C   0xF248 0x01E8      MOVW     R1,#+33000
   \   00000020   0x60C1             STR      R1,[R0, #+12]
   1171              pOptions->u32SndTimeout = SND_TIMEOUT;
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable36_3  ;; 0x28488
   \   00000026   0x6101             STR      R1,[R0, #+16]
   1172          
   1173          // Updated *** 10/26/10 ***    
   1174          #if defined (PANASONIC_REVB)
   1175              pOptions->bLNAHighGainMode = TRUE;
   1176          #elif defined (PANASONIC_YES)
   1177              pOptions->bLNAHighGainMode = TRUE;
   1178          #else
   1179              pOptions->bLNAHighGainMode = FALSE; // Note: LNA isn't even available for PANASONIC_NO
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x7501             STRB     R1,[R0, #+20]
   1180          #endif
   1181          
   1182              pOptions->u16SleepAfterAck = SLEEP_AFTER_ACK;
   \   0000002C   0xF44F 0x7196      MOV      R1,#+300
   \   00000030   0x82C1             STRH     R1,[R0, #+22]
   1183              
   1184              return;
   \   00000032   0x4770             BX       LR               ;; return
   1185          }
   1186          
   1187          
   1188          /************************************************************************************
   1189          *
   1190          * WUApp_LowPowerWhile
   1191          *
   1192          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1193          void WUApp_LowPowerWhile(void) 
   1194          {  
   \                     WUApp_LowPowerWhile: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1195              /* Backup Current configuration and set Low power configuration*/
   1196              WUApp_PrepareToEnterLowPower();
   \   00000002   0x.... 0x....      BL       WUApp_PrepareToEnterLowPower
   1197          
   1198          #if(gDefaultLowPowerMode_c == gWUAppLLSMode_c) 
   1199              /* configure MCU in LLS low power mode */
   1200              PWRLib_MCU_Enter_LLS();
   1201          #elif (gDefaultLowPowerMode_c == gWUAppVLPSMode_c)
   1202              /* configure MCU in VLPS low power mode */
   1203              PWRLib_MCU_Enter_VLPS();
   1204          #elif (gDefaultLowPowerMode_c == gWUAppVLLS2Mode_c)
   1205              /* configure MCU in VLLS2 low power mode */
   1206              PWRLib_MCU_Enter_VLLS2();
   1207          #elif (gDefaultLowPowerMode_c == gWUAppVLLS1Mode_c)
   1208              /* configure MCU in VLLS1 low power mode */
   1209              PWRLib_MCU_Enter_VLLS1();
   \   00000006   0x.... 0x....      BL       PWRLib_MCU_Enter_VLLS1
   1210          #elif (gDefaultLowPowerMode_c == gWUAppVLLS0Mode_c)
   1211              /* configure MCU in VLLS0 low power mode */
   1212              PWRLib_MCU_Enter_VLLS0();
   1213              
   1214          #endif
   1215              /* Restore backup configuration*/ 
   1216              WUApp_LPRestoreSettings();
   \   0000000A   0x.... 0x....      BL       WUApp_LPRestoreSettings
   1217           
   1218          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
   1219          
   1220          
   1221          /************************************************************************************
   1222          *
   1223          * WUApp_InitWakupSource
   1224          *                                       
   1225          ************************************************************************************/
   1226          

   \                                 In section .text, align 2, keep-with-next
   1227          void WUApp_InitWakupSource(void)
   1228          {
   \                     WUApp_InitWakupSource: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1229          #if (gDefaultWakeupSource_c == gWUAppGPIO_c) 
   1230              pu8WakeupSourceString = (uint8_t *)cau8WUGPIOWakeupString;
   1231              PWRLib_LLWU_WakeupPinEnable( (PWRLib_LLWU_WakeupPin_t) gLLWU_WakeUp_PIN_Number_c, gPWRLib_LLWU_WakeupPin_AnyEdge_c);
   1232          #elif (gDefaultWakeupSource_c == gWUAppLPTMR_c)
   1233              pu8WakeupSourceString = (uint8_t *)cau8WULPTMRWakeupString;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable35_4
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable36_4
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   1234              /* configure NVIC for LPTMR Isr */
   1235              NVIC_EnableIRQ(gLPTMR_IRQ_Number_c);
   \   0000000C   0x203A             MOVS     R0,#+58
   \   0000000E   0x.... 0x....      BL       NVIC_EnableIRQ
   1236              /* enable LPTMR as wakeup source for LLWU module */
   1237              PWRLib_LLWU_WakeupModuleEnable(gPWRLib_LLWU_WakeupModule_LPTMR_c);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       PWRLib_LLWU_WakeupModuleEnable
   1238          #elif (gDefaultWakeupSource_c == gWUAppRTC_c)
   1239              pu8WakeupSourceString = (uint8_t *)cau8WURTCWakeupString;
   1240              PWRLib_RTC_Init();
   1241              /* configure NVIC for RTC alarm Isr */
   1242              NVIC_EnableIRQ(gRTC_IRQ_Number_c);
   1243              /* enable RTC as wakeup source for LLWU module */
   1244              PWRLib_LLWU_WakeupModuleEnable(gPWRLib_LLWU_WakeupModule_RTC_Alarm_c);
   1245          #endif
   1246              NVIC_EnableIRQ(gLLWU_IRQ_Number_c);
   \   00000018   0x2015             MOVS     R0,#+21
   \   0000001A   0x.... 0x....      BL       NVIC_EnableIRQ
   1247          }
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return
   1248          
   1249          
   1250          /************************************************************************************
   1251          *
   1252          * WUApp_InitLowPowerMode
   1253          *                                       
   1254          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1255          void WUApp_InitLowPowerMode(void)
   1256          {
   1257          #if (gDefaultLowPowerMode_c == gWUAppLLSMode_c)
   1258              pu8GotoLowPowerString = (uint8_t *)cau8WUGotoLLSString;
   1259              pu8NowInLowPowerString = (uint8_t *)cau8WUIsLLSModeString;
   1260              SMC_PMPROT |= SMC_PMPROT_ALLS_MASK;         /*Enable the low-power mode "Register can be written only once after any system reset"*/
   1261          #elif (gDefaultLowPowerMode_c == gWUAppVLPSMode_c)
   1262              pu8GotoLowPowerString = (uint8_t *)cau8WUGotoVLPSString;
   1263              pu8NowInLowPowerString = (uint8_t *)cau8WUIsVLPSModeString;
   1264              SMC_PMPROT |= SMC_PMPROT_AVLP_MASK;         /*Enable the low-power mode "Register can be written only once after any system reset"*/
   1265          #elif (gDefaultLowPowerMode_c == gWUAppVLLS2Mode_c)
   1266              pu8GotoLowPowerString = (uint8_t *)cau8WUGotoVLLS2String;
   1267              pu8NowInLowPowerString = (uint8_t *)cau8WUIsVLLS2ModeString;
   1268              SMC_PMPROT |= SMC_PMPROT_AVLLS_MASK;        /*Enable the low-power mode "Register can be written only once after any system reset"*/
   1269          #elif (gDefaultLowPowerMode_c == gWUAppVLLS1Mode_c)
   1270              pu8GotoLowPowerString = (uint8_t *)cau8WUGotoVLLS1String;
   \                     WUApp_InitLowPowerMode: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable35_5
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable35_6
   \   00000008   0x6008             STR      R0,[R1, #+0]
   1271              pu8NowInLowPowerString = (uint8_t *)cau8WUIsVLLS1ModeString;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable35_7
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable35_8
   \   00000012   0x6008             STR      R0,[R1, #+0]
   1272              SMC_PMPROT |= SMC_PMPROT_AVLLS_MASK;        /*Enable the low-power mode "Register can be written only once after any system reset"*/
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable36_5  ;; 0x4007e000
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable36_5  ;; 0x4007e000
   \   00000022   0x7008             STRB     R0,[R1, #+0]
   1273          #elif (gDefaultLowPowerMode_c == gWUAppVLLS0Mode_c)
   1274              pu8GotoLowPowerString = (uint8_t *)cau8WUGotoVLLS0String;
   1275              pu8NowInLowPowerString = (uint8_t *)cau8WUIsVLLS0ModeString;
   1276              SMC_PMPROT |= SMC_PMPROT_AVLLS_MASK;        /*Enable the low-power mode "Register can be written only once after any system reset"*/
   1277          #endif
   1278          }
   \   00000024   0x4770             BX       LR               ;; return
   1279          
   1280          
   1281          
   1282          
   1283          
   1284          /************************************************************************************
   1285          * InitProject
   1286          * 
   1287          * Hardware and Global data initialization
   1288          *
   1289          ************************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1290          void InitProject(void)
   1291          {
   \                     InitProject: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
   1292              DisableInterrupts();
   \   00000006   0xB672             CPSID i
   1293             gLPConfigState =gLPConfigState;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable36_6
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable36_6
   \   00000012   0x7008             STRB     R0,[R1, #+0]
   1294             gOpt.hdr.u8Prefix[0] = 'O';
   \   00000014   0x204F             MOVS     R0,#+79
   \   00000016   0x....             LDR.N    R1,??DataTable28_33
   \   00000018   0x7008             STRB     R0,[R1, #+0]
   1295             gOpt.hdr.u8Prefix[1] = 'P';
   \   0000001A   0x2050             MOVS     R0,#+80
   \   0000001C   0x....             LDR.N    R1,??DataTable28_33
   \   0000001E   0x7048             STRB     R0,[R1, #+1]
   1296             gOpt.hdr.u8Prefix[2] = 'T';
   \   00000020   0x2054             MOVS     R0,#+84
   \   00000022   0x....             LDR.N    R1,??DataTable28_33
   \   00000024   0x7088             STRB     R0,[R1, #+2]
   1297             gOpt.hdr.u16SensorID = sensorID;
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable29_18
   \   0000002A   0x8800             LDRH     R0,[R0, #+0]
   \   0000002C   0x....             LDR.N    R1,??DataTable28_33
   \   0000002E   0x8088             STRH     R0,[R1, #+4]
   1298             gOpt.hdr.u8Length = OPT_SIZE;
   \   00000030   0x2019             MOVS     R0,#+25
   \   00000032   0x....             LDR.N    R1,??DataTable28_33
   \   00000034   0x70C8             STRB     R0,[R1, #+3]
   1299             
   1300             gPng.u8Prefix[0] = 'P';
   \   00000036   0x2050             MOVS     R0,#+80
   \   00000038   0x....             LDR.N    R1,??DataTable28_1
   \   0000003A   0x7008             STRB     R0,[R1, #+0]
   1301             gPng.u8Prefix[1] = 'N';
   \   0000003C   0x204E             MOVS     R0,#+78
   \   0000003E   0x....             LDR.N    R1,??DataTable28_1
   \   00000040   0x7048             STRB     R0,[R1, #+1]
   1302             gPng.u8Prefix[2] = 'G';
   \   00000042   0x2047             MOVS     R0,#+71
   \   00000044   0x....             LDR.N    R1,??DataTable28_1
   \   00000046   0x7088             STRB     R0,[R1, #+2]
   1303             gPng.u16SensorID = sensorID;        // initialized via compiler settings (1 - 65534)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable29_18
   \   0000004C   0x8800             LDRH     R0,[R0, #+0]
   \   0000004E   0x....             LDR.N    R1,??DataTable28_1
   \   00000050   0x8088             STRH     R0,[R1, #+4]
   1304              
   1305              
   1306            // Bob's code
   1307             uint8_t u8Status;
   1308             uint8_t u8BlinkOnFirstAck = 1;
   \   00000052   0x2401             MOVS     R4,#+1
   1309             uint16_t sleepCount;
   1310             uint16_t missedCount = 0;
   \   00000054   0x2500             MOVS     R5,#+0
   1311            // Detect if we need a factory reset
   1312             uint32_t statErase, statWrite;
   1313             NvConfig_t mNvConfig = {
   1314             gNV_FTFX_REG_BASE_c,
   1315             gNV_PFLASH_BLOCK_BASE_c,
   1316             gNV_PFLASH_BLOCK_SIZE_c,
   1317             gNV_DFLASH_BLOCK_BASE_c,
   1318             gNV_DFLASH_BLOCK_SIZE_c,
   1319             gNV_EERAM_BLOCK_BASE_c,
   1320             gNV_EERAM_BLOCK_SIZE_c,
   1321             gNV_EEE_BLOCK_SIZE_c
   1322            };
   \   00000056   0xA800             ADD      R0,SP,#+0
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable36_7
   \   0000005C   0x2220             MOVS     R2,#+32
   \   0000005E   0x.... 0x....      BL       __aeabi_memcpy4
   1323            NV_FlashInit(&mNvConfig);
   \   00000062   0xA800             ADD      R0,SP,#+0
   \   00000064   0x.... 0x....      BL       NV_FlashInit
   1324            static uint32_t sDeadBeef;
   1325          //   
   1326          //   statErase = NV_FlashEraseSector(&mNvConfig, settingsAddress,0x800);
   1327          //   statWrite = NV_FlashProgramLongword(&mNvConfig,settingsAddress,sizeof(sDeadBeef),(uint32_t)&sDeadBeef);
   1328             NV_FlashRead(settingsAddress,(uint8_t*)&gFlashDeadBeef,sizeof(gFlashDeadBeef));
   \   00000068   0x2204             MOVS     R2,#+4
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable35_2
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable35_3
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x.... 0x....      BL       NV_FlashRead
   1329             uint8_t bFactoryReset = (sDeadBeef == g_DEAD_BEEF) || (gFlashDeadBeef != g_DEAD_BEEF);
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable36_8
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable35_1
   \   00000082   0x6809             LDR      R1,[R1, #+0]
   \   00000084   0x4288             CMP      R0,R1
   \   00000086   0xD007             BEQ.N    ??InitProject_0
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable35_2
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable35_1
   \   00000092   0x6809             LDR      R1,[R1, #+0]
   \   00000094   0x4288             CMP      R0,R1
   \   00000096   0xD001             BEQ.N    ??InitProject_1
   \                     ??InitProject_0: (+1)
   \   00000098   0x2601             MOVS     R6,#+1
   \   0000009A   0xE000             B.N      ??InitProject_2
   \                     ??InitProject_1: (+1)
   \   0000009C   0x2600             MOVS     R6,#+0
   1330             sDeadBeef = g_DEAD_BEEF;
   \                     ??InitProject_2: (+1)
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable36_8
   \   000000A8   0x6008             STR      R0,[R1, #+0]
   1331             if (bFactoryReset)
   \   000000AA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000AC   0x2E00             CMP      R6,#+0
   \   000000AE   0xD004             BEQ.N    ??InitProject_3
   1332             {
   1333                 GetFactoryOptions(&gOptions);
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable36_2
   \   000000B4   0x.... 0x....      BL       GetFactoryOptions
   \   000000B8   0xE008             B.N      ??InitProject_4
   1334             }
   1335             else
   1336             {
   1337           //      gOptions = gFlashOptions;      
   1338                NV_FlashRead(settingsAddress+sizeof(gFlashDeadBeef),(uint8_t*)&gOptions,sizeof(gOptions));
   \                     ??InitProject_3: (+1)
   \   000000BA   0x2218             MOVS     R2,#+24
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable36_2
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable35_3
   \   000000C4   0x6800             LDR      R0,[R0, #+0]
   \   000000C6   0x1D00             ADDS     R0,R0,#+4
   \   000000C8   0x.... 0x....      BL       NV_FlashRead
   1339             }
   1340            InitPacket(); 
   \                     ??InitProject_4: (+1)
   \   000000CC   0x.... 0x....      BL       InitPacket
   1341           
   1342            /* SPI Initialization */ 
   1343            MC1324xDrv_SPIInit(); 
   \   000000D0   0x.... 0x....      BL       MC1324xDrv_SPIInit
   1344            (void)MLMERadioInit();
   \   000000D4   0x.... 0x....      BL       MLMERadioInit
   \   000000D8   0x4680             MOV      R8,R0
   1345            /* TMR Initialization */
   1346            TMR_Init(); 
   \   000000DA   0x.... 0x....      BL       TMR_Init
   1347            MM_Init((uint8_t*)maMacHeap, poolInfo, maMmPools);
   \   000000DE   0x.... 0x....      LDR.W    R2,??DataTable36_9
   \   000000E2   0x.... 0x....      LDR.W    R1,??DataTable36_10
   \   000000E6   0x.... 0x....      LDR.W    R0,??DataTable36_11
   \   000000EA   0x.... 0x....      BL       MM_Init
   1348            /*LED configuration*/
   1349            LED_Init();
   \   000000EE   0x.... 0x....      BL       LED_Init
   1350          #if defined(gCDCInterface_d)
   1351            USB_Init();
   1352            (void)CDC_ModuleInit();
   1353          #elif defined (gUARTInterface_d)
   1354            /* UART Initialization */
   1355            Uart_ModuleInit();
   \   000000F2   0x.... 0x....      BL       Uart_ModuleInit
   1356          #endif
   1357            Comm_SetBaud(Comm_DefaultBaud);
   \   000000F6   0xF45F 0x30E1      MOVS     R0,#+115200
   \   000000FA   0x.... 0x....      BL       Uart1_SetBaud
   1358            Comm_SetRxCallBack(CommRxCallback);
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable36_12
   \   00000102   0x.... 0x....      BL       Uart1_SetRxCallBack
   1359            
   1360            
   1361            mLEDTimerID_1 = TMR_AllocateTimer();
   \   00000106   0x.... 0x....      BL       TMR_AllocateTimer
   \   0000010A   0x.... 0x....      LDR.W    R1,??DataTable36_13
   \   0000010E   0x7008             STRB     R0,[R1, #+0]
   1362            mBufferTimerID = TMR_AllocateTimer();
   \   00000110   0x.... 0x....      BL       TMR_AllocateTimer
   \   00000114   0x.... 0x....      LDR.W    R1,??DataTable36_14
   \   00000118   0x7008             STRB     R0,[R1, #+0]
   1363          
   1364            /* Keyboard Initialization */
   1365            KeyboardInit();
   \   0000011A   0x.... 0x....      BL       KeyboardInit
   1366            GlobalDataInit();  
   \   0000011E   0x.... 0x....      BL       GlobalDataInit
   1367            
   1368          
   1369          //  evDataFromCOMM = FALSE;
   1370            
   1371            EnableInterrupts();
   \   00000122   0xB662             CPSIE i
   1372            int count = 10;
   \   00000124   0x270A             MOVS     R7,#+10
   1373            while (count--)
   \                     ??InitProject_5: (+1)
   \   00000126   0x0038             MOVS     R0,R7
   \   00000128   0x1E47             SUBS     R7,R0,#+1
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD005             BEQ.N    ??InitProject_6
   1374            {
   1375                uint16_t innerCount = 0;        
   \   0000012E   0x2000             MOVS     R0,#+0
   1376                while (--innerCount);
   \                     ??InitProject_7: (+1)
   \   00000130   0x1E40             SUBS     R0,R0,#+1
   \   00000132   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000134   0x2800             CMP      R0,#+0
   \   00000136   0xD1FB             BNE.N    ??InitProject_7
   \   00000138   0xE7F5             B.N      ??InitProject_5
   1377            }
   1378            FlashSaveOptions();
   \                     ??InitProject_6: (+1)
   \   0000013A   0x.... 0x....      BL       FlashSaveOptions
   1379            sDeadBeef = 0;
   \   0000013E   0x2000             MOVS     R0,#+0
   \   00000140   0x.... 0x....      LDR.W    R1,??DataTable36_8
   \   00000144   0x6008             STR      R0,[R1, #+0]
   1380           //  
   1381           //  // Initialize options.
   1382           //  // NOTE: we can't write to FLASH memory yet ("AppInit" not called yet, clock, etc),
   1383           //  // so we don't call "FlashSaveOptions" yet.
   1384             
   1385             #if (TRUE == gEnableConfigMenus_d)
   1386              gConfigState = gWUConfigStateMainMenu_c;
   \   00000146   0x2000             MOVS     R0,#+0
   \   00000148   0x.... 0x....      LDR.W    R1,??DataTable36_15
   \   0000014C   0x7008             STRB     R0,[R1, #+0]
   1387              gLPConfigState = gWULPStateInit_c;
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0x.... 0x....      LDR.W    R1,??DataTable36_6
   \   00000154   0x7008             STRB     R0,[R1, #+0]
   1388              u8SequencePointerCounter = 0;
   \   00000156   0x2000             MOVS     R0,#+0
   \   00000158   0x.... 0x....      LDR.W    R1,??DataTable36_16
   \   0000015C   0x7008             STRB     R0,[R1, #+0]
   1389              bReturnToMainMenuFlag = FALSE; 
   \   0000015E   0x2000             MOVS     R0,#+0
   \   00000160   0x.... 0x....      LDR.W    R1,??DataTable36_17
   \   00000164   0x7008             STRB     R0,[R1, #+0]
   1390            #else
   1391              gAppMode = gWUModeApplication_c;
   1392            #endif
   1393              
   1394            #if (gEnableLowPower_d == TRUE)        
   1395            #if (gDefaultLowPowerMode_c == gWUAppLLSMode_c)  
   1396                  pu8MainLowPowerString = (uint8_t *)cau8WULLSString;
   1397            #elif (gDefaultLowPowerMode_c == gWUAppVLPSMode_c)
   1398                  pu8MainLowPowerString = (uint8_t *)cau8WUVLPSString;
   1399            #elif (gDefaultLowPowerMode_c == gWUAppVLLS2Mode_c)
   1400                  pu8MainLowPowerString = (uint8_t *)cau8WUVLLS2String;
   1401            #elif (gDefaultLowPowerMode_c == gWUAppVLLS1Mode_c)
   1402                  pu8MainLowPowerString = (uint8_t *)cau8WUVLLS1String;
   \   00000166   0x.... 0x....      LDR.W    R0,??DataTable36_18
   \   0000016A   0x.... 0x....      LDR.W    R1,??DataTable36_19
   \   0000016E   0x6008             STR      R0,[R1, #+0]
   1403            #elif (gDefaultLowPowerMode_c == gWUAppVLLS0Mode_c)
   1404                  pu8MainLowPowerString = (uint8_t *)cau8WUVLLS0String;
   1405            #endif            
   1406            #if (gDefaultWakeupSource_c == gWUAppGPIO_c) 
   1407                  pu8MainWakeupSourceString = (uint8_t *)cau8WUGPIOString;
   1408            #elif (gDefaultWakeupSource_c == gWUAppLPTMR_c)
   1409                  pu8MainWakeupSourceString = (uint8_t *)cau8WULPTMRString;
   \   00000170   0x.... 0x....      LDR.W    R0,??DataTable36_20
   \   00000174   0x.... 0x....      LDR.W    R1,??DataTable36_21
   \   00000178   0x6008             STR      R0,[R1, #+0]
   1410            #elif (gDefaultWakeupSource_c == gWUAppRTC_c)
   1411                  pu8MainWakeupSourceString = (uint8_t *)cau8WURTCString;
   1412            #endif
   1413            #endif
   1414                            
   1415                bTxOtaBusyFlag = FALSE;
   \   0000017A   0x2000             MOVS     R0,#+0
   \   0000017C   0x.... 0x....      LDR.W    R1,??DataTable36_22
   \   00000180   0x7008             STRB     R0,[R1, #+0]
   1416                bCommGetDataTimerFlag = FALSE;
   \   00000182   0x2000             MOVS     R0,#+0
   \   00000184   0x.... 0x....      LDR.W    R1,??DataTable36_23
   \   00000188   0x7008             STRB     R0,[R1, #+0]
   1417             #if(TRUE == gEnableAckOta_d)
   1418                gDataRetries = gDefaultNumberRetries_c;
   1419                gRetryTxSize = 0;
   1420                bWait4AckFlag = FALSE;
   1421            #endif 
   1422             
   1423             
   1424          }
   \   0000018A   0xB008             ADD      SP,SP,#+32
   \   0000018C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .bss, align 4
   \                     ??sDeadBeef:
   \   00000000                      DS8 4

   \                                 In section .text, align 2, keep-with-next
   1425          void GlobalDataInit(void)
   1426          {
   1427            /*Global Data init*/
   1428            testOpMode     = gDefaultMode_c;
   \                     GlobalDataInit: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable36_24
   \   00000006   0x7008             STRB     R0,[R1, #+0]
   1429            testChannel    = gDefaultChannelNumber_c;
   \   00000008   0x200F             MOVS     R0,#+15
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable36_25
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
   1430            testPower      = gDefaultOutputPower_c;
   \   00000010   0x2017             MOVS     R0,#+23
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable36_26
   \   00000016   0x7008             STRB     R0,[R1, #+0]
   1431            testTrimmValue = gDefaultCrysTrim_c;
   \   00000018   0x2073             MOVS     R0,#+115
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable36_27
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
   1432            testPayloadLen = gDefaultPayload_c;
   \   00000020   0x2014             MOVS     R0,#+20
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable36_28
   \   00000026   0x7008             STRB     R0,[R1, #+0]
   1433            contTestRunning = gTestModeForceIdle_c;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable36_29
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
   1434            shortCutsEnabled = FALSE; 
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable36_30
   \   00000036   0x7008             STRB     R0,[R1, #+0]
   1435            connState      = gConnInitState_c;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable36_31
   \   0000003E   0x7008             STRB     R0,[R1, #+0]
   1436            cTxRxState     = gCTxRxStateInit_c;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable36_32
   \   00000046   0x7008             STRB     R0,[R1, #+0]
   1437            perTxState     = gPerTxStateInit_c;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable36_33
   \   0000004E   0x7008             STRB     R0,[R1, #+0]
   1438            perRxState     = gPerRxStateInit_c;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable36_34
   \   00000056   0x7008             STRB     R0,[R1, #+0]
   1439            rangeTxState   = gRangeTxStateInit_c;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable36_35
   \   0000005E   0x7008             STRB     R0,[R1, #+0]
   1440            rangeRxState   = gRangeRxStateInit_c;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable36_36
   \   00000066   0x7008             STRB     R0,[R1, #+0]
   1441            prevOpMode      = gDefaultMode_c;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable36_37
   \   0000006E   0x7008             STRB     R0,[R1, #+0]
   1442            txTestIndex    = gPacketErrorRateTx_c;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable36_38
   \   00000076   0x7008             STRB     R0,[R1, #+0]
   1443            rxTestIndex    = gPacketErrorRateRx_c;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable36_39
   \   0000007E   0x7008             STRB     R0,[R1, #+0]
   1444          }
   \   00000080   0x4770             BX       LR               ;; return
   1445          /**************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1446          void InitSmac(void)
   1447          {
   \                     InitSmac: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1448            gAppTxPacket = (txPacket_t*)gau8TxDataBuffer;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable36_40
   \   00000006   0x....             LDR.N    R1,??DataTable29_16
   \   00000008   0x6008             STR      R0,[R1, #+0]
   1449            gAppRxPacket = (rxPacket_t*)gau8RxDataBuffer; 
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable36_41
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable36_42
   \   00000012   0x6008             STR      R0,[R1, #+0]
   1450            gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
   \   00000014   0x207B             MOVS     R0,#+123
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable36_42
   \   0000001A   0x6809             LDR      R1,[R1, #+0]
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
   1451            
   1452            MLMESetPromiscuousMode(gPromiscuousMode_d); 
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      BL       MLMESetPromiscuousMode
   1453            (void)MLMESetChannelRequest(testChannel);
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable36_25
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x.... 0x....      BL       MLMESetChannelRequest
   \   0000002E   0x0004             MOVS     R4,R0
   1454            (void)MLMEPAOutputAdjust(testPower);
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable36_26
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0x.... 0x....      BL       MLMEPAOutputAdjust
   \   0000003A   0x0005             MOVS     R5,R0
   1455            (void)MLMEXtalAdjust(testTrimmValue); 
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable36_27
   \   00000040   0x7800             LDRB     R0,[R0, #+0]
   \   00000042   0x.... 0x....      BL       MLMEXtalAdjust
   1456          }
   \   00000046   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1457          
   1458          /**************************************************************************************/
   1459          void SerialUIStateMachine(void)
   1460          {
   1461            if((gConnSelectTest_c == connState) && evTestParameters)
   1462            {
   1463              (void)MLMESetChannelRequest(testChannel);
   1464              (void)MLMEPAOutputAdjust(testPower);
   1465              (void)MLMEXtalAdjust(testTrimmValue);
   1466              PrintTestParameters(TRUE);
   1467              evTestParameters = FALSE;
   1468            }
   1469            switch(connState){
   1470              case gConnIdleState_c:
   1471                 PrintMenu(cu8MainMenu, gDefaultCommPort_c);
   1472                 PrintTestParameters(FALSE);
   1473                 shortCutsEnabled = TRUE;           
   1474                 connState = gConnSelectTest_c;
   1475              break;
   1476              case gConnSelectTest_c:
   1477               if(evDataFromCOMM){
   1478                 if('1' == gu8CommData){
   1479                   cTxRxState = gCTxRxStateInit_c;
   1480                   connState = gConnContinuousTxRxState_c;
   1481                 }else if('2' == gu8CommData){
   1482                   perTxState = gPerTxStateInit_c;
   1483                   perRxState = gPerRxStateInit_c;
   1484                   connState = gConnPerState_c;
   1485                 }else if('3' == gu8CommData){
   1486                   rangeTxState = gRangeTxStateInit_c;
   1487                   rangeRxState = gRangeRxStateInit_c;
   1488                   connState = gConnRangeState_c;
   1489                 }else if('4' == gu8CommData){
   1490                   eRState = gERStateInit_c;
   1491                   connState = gConnRegEditState_c;
   1492                 }
   1493                 evDataFromCOMM = FALSE;
   1494               }
   1495              break;
   1496              case gConnContinuousTxRxState_c:
   1497                 if(SerialContinuousTxRxTest()) {
   1498                     connState = gConnIdleState_c;
   1499                 }
   1500              break;
   1501              case gConnPerState_c:
   1502                 if(mTxOperation_c == testOpMode){
   1503                   if(PacketErrorRateTx()){
   1504                     connState = gConnIdleState_c;
   1505                   }
   1506                 }else{
   1507                   if(PacketErrorRateRx()){
   1508                     connState = gConnIdleState_c;
   1509                   }
   1510                 }
   1511              break;
   1512              case gConnRangeState_c:
   1513                 if(mTxOperation_c == testOpMode){
   1514                   if(RangeTx()){
   1515                     connState = gConnIdleState_c;
   1516                   }
   1517                 }else{
   1518                   if(RangeRx()){
   1519                     connState = gConnIdleState_c;
   1520                   }
   1521                 }
   1522              break;
   1523              case gConnRegEditState_c:
   1524                 if(EditRegisters()) {
   1525                     connState = gConnIdleState_c;
   1526                 }
   1527              break;
   1528              default:
   1529              break;
   1530              
   1531            }
   1532            if(prevOpMode != testOpMode){
   1533              perTxState = gPerTxStateInit_c;
   1534              perRxState = gPerRxStateInit_c;
   1535              rangeTxState = gRangeTxStateInit_c;
   1536              rangeRxState = gRangeRxStateInit_c;
   1537              prevOpMode = testOpMode;
   1538            }
   1539          }
   1540          
   1541          
   1542          
   1543          /*this is used to set the mode into the lower power mode*/

   \                                 In section .text, align 2, keep-with-next
   1544          void WUApp_PrepareToEnterLowPower(void)
   1545          {
   \                     WUApp_PrepareToEnterLowPower: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1546            bool_t bTimersOff;
   1547          
   1548              /*Stop timers*/
   1549              TMR_StopTimer(mLEDTimerID_1);
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable36_13
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x.... 0x....      BL       TMR_StopTimer
   1550              TMR_StopTimer(mBufferTimerID);
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable36_14
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x.... 0x....      BL       TMR_StopTimer
   1551              TMR_FreeTimer(mLEDTimerID_1);
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable36_13
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x.... 0x....      BL       TMR_FreeTimer
   1552              TMR_FreeTimer(mBufferTimerID);
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable36_14
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x.... 0x....      BL       TMR_FreeTimer
   1553              
   1554              /* configure MCG in FLL Engaged Internal (FEI) mode */
   1555              MCG_Pee2Fei();
   \   0000002A   0x.... 0x....      BL       MCG_Pee2Fei
   1556              
   1557              /* disable transceiver CLK_OUT. */
   1558              MC1324xDrv_Set_CLK_OUT_Freq(gCLK_OUT_FREQ_DISABLE);
   \   0000002E   0x2008             MOVS     R0,#+8
   \   00000030   0x.... 0x....      BL       MC1324xDrv_Set_CLK_OUT_Freq
   1559              /* configure Radio in hibernate mode */
   1560              PWRLib_Radio_Enter_Hibernate();
   \   00000034   0x.... 0x....      BL       PWRLib_Radio_Enter_Hibernate
   1561              
   1562              //PowerOffAccel();
   1563              //DisableADC();
   1564                
   1565              u32PortAPCRBackup[0] = PORTA_PCR0;  //PTA0 JTAG CLK
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable36_43  ;; 0x40049000
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable36_44
   \   00000042   0x6008             STR      R0,[R1, #+0]
   1566              u32PortAPCRBackup[1] = PORTA_PCR1;  //PTA1 JTAG TDI
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable36_45  ;; 0x40049004
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable36_44
   \   0000004E   0x6048             STR      R0,[R1, #+4]
   1567              u32PortAPCRBackup[2] = PORTA_PCR2;  //PTA2 JTAG TDO
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable36_46  ;; 0x40049008
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable36_44
   \   0000005A   0x6088             STR      R0,[R1, #+8]
   1568              u32PortAPCRBackup[3] = PORTA_PCR3;  //PTA3 JTAG TMS
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable36_47  ;; 0x4004900c
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable36_44
   \   00000066   0x60C8             STR      R0,[R1, #+12]
   1569              u32PortAPCRBackup[4] = PORTA_PCR4;  //PTA4 JTAG NMI
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable36_48  ;; 0x40049010
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable36_44
   \   00000072   0x6108             STR      R0,[R1, #+16]
   1570              
   1571              u32PortBPCRBackup[0] = PORTB_PCR10;  //PTB10 to Radio's SPI SS
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable36_49  ;; 0x4004a028
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable36_50
   \   0000007E   0x6008             STR      R0,[R1, #+0]
   1572              u32PortBPCRBackup[1] = PORTB_PCR11;  //PTB11 to Radio's SPI CLK
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable36_51  ;; 0x4004a02c
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable36_50
   \   0000008A   0x6048             STR      R0,[R1, #+4]
   1573              u32PortBPCRBackup[2] = PORTB_PCR16;  //PTB16 to Radio's SPI MOSI
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable36_52  ;; 0x4004a040
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable36_50
   \   00000096   0x6088             STR      R0,[R1, #+8]
   1574              u32PortBPCRBackup[3] = PORTB_PCR17;  //PTB17 to Radio's SPI MISO
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable36_53  ;; 0x4004a044
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable36_50
   \   000000A2   0x60C8             STR      R0,[R1, #+12]
   1575              
   1576              u32PortCPCRBackup[0] = PORTC_PCR4;  //PTC4 //Set->Lower EEPROM's voltage
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable36_54  ;; 0x4004b010
   \   000000A8   0x6800             LDR      R0,[R0, #+0]
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable36_55
   \   000000AE   0x6008             STR      R0,[R1, #+0]
   1577              u32PortCPCRBackup[1] = PORTC_PCR5;  //PTC5 
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable36_56  ;; 0x4004b014
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0x.... 0x....      LDR.W    R1,??DataTable36_55
   \   000000BA   0x6048             STR      R0,[R1, #+4]
   1578              u32PortCPCRBackup[2] = PORTC_PCR6;  //PTC6 
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable36_57  ;; 0x4004b018
   \   000000C0   0x6800             LDR      R0,[R0, #+0]
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable36_55
   \   000000C6   0x6088             STR      R0,[R1, #+8]
   1579              u32PortCPCRBackup[3] = PORTC_PCR7;  //PTC7 
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable36_58  ;; 0x4004b01c
   \   000000CC   0x6800             LDR      R0,[R0, #+0]
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable36_55
   \   000000D2   0x60C8             STR      R0,[R1, #+12]
   1580              
   1581              
   1582              u32PortEPCRBackup[0] = PORTE_PCR0;  //PTE0 UART1_TX
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable36_59  ;; 0x4004d000
   \   000000D8   0x6800             LDR      R0,[R0, #+0]
   \   000000DA   0x.... 0x....      LDR.W    R1,??DataTable36_60
   \   000000DE   0x6008             STR      R0,[R1, #+0]
   1583              u32PortEPCRBackup[1] = PORTE_PCR1;  //PTE1 UART1_RX
   \   000000E0   0x.... 0x....      LDR.W    R0,??DataTable36_61  ;; 0x4004d004
   \   000000E4   0x6800             LDR      R0,[R0, #+0]
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable36_60
   \   000000EA   0x6048             STR      R0,[R1, #+4]
   1584              
   1585              u32SCGCxBackup[0] = SIM_SCGC4; //SCGC4
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable36_62  ;; 0x40048034
   \   000000F0   0x6800             LDR      R0,[R0, #+0]
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable36_63
   \   000000F6   0x6008             STR      R0,[R1, #+0]
   1586              u32SCGCxBackup[1] = SIM_SCGC5; //SCGC5
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable36_64  ;; 0x40048038
   \   000000FC   0x6800             LDR      R0,[R0, #+0]
   \   000000FE   0x.... 0x....      LDR.W    R1,??DataTable36_63
   \   00000102   0x6048             STR      R0,[R1, #+4]
   1587              u32SCGCxBackup[2] = SIM_SCGC6; //SCGC6
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable36_65  ;; 0x4004803c
   \   00000108   0x6800             LDR      R0,[R0, #+0]
   \   0000010A   0x.... 0x....      LDR.W    R1,??DataTable36_63
   \   0000010E   0x6088             STR      R0,[R1, #+8]
   1588              u32SCGCxBackup[3] = SIM_SCGC7; //SCGC7
   \   00000110   0x.... 0x....      LDR.W    R0,??DataTable36_66  ;; 0x40048040
   \   00000114   0x6800             LDR      R0,[R0, #+0]
   \   00000116   0x.... 0x....      LDR.W    R1,??DataTable36_63
   \   0000011A   0x60C8             STR      R0,[R1, #+12]
   1589              
   1590              u32GPIOs_PDORBackup[0] = GPIOA_PDOR;
   \   0000011C   0x.... 0x....      LDR.W    R0,??DataTable36_67  ;; 0x400ff000
   \   00000120   0x6800             LDR      R0,[R0, #+0]
   \   00000122   0x.... 0x....      LDR.W    R1,??DataTable36_68
   \   00000126   0x6008             STR      R0,[R1, #+0]
   1591              u32GPIOs_PDORBackup[1] = GPIOB_PDOR;
   \   00000128   0x.... 0x....      LDR.W    R0,??DataTable36_69  ;; 0x400ff040
   \   0000012C   0x6800             LDR      R0,[R0, #+0]
   \   0000012E   0x.... 0x....      LDR.W    R1,??DataTable36_68
   \   00000132   0x6048             STR      R0,[R1, #+4]
   1592              u32GPIOs_PDORBackup[2] = GPIOC_PDOR;
   \   00000134   0x.... 0x....      LDR.W    R0,??DataTable36_70  ;; 0x400ff080
   \   00000138   0x6800             LDR      R0,[R0, #+0]
   \   0000013A   0x.... 0x....      LDR.W    R1,??DataTable36_68
   \   0000013E   0x6088             STR      R0,[R1, #+8]
   1593              u32GPIOs_PDORBackup[3] = GPIOD_PDOR;
   \   00000140   0x.... 0x....      LDR.W    R0,??DataTable36_71  ;; 0x400ff0c0
   \   00000144   0x6800             LDR      R0,[R0, #+0]
   \   00000146   0x.... 0x....      LDR.W    R1,??DataTable36_68
   \   0000014A   0x60C8             STR      R0,[R1, #+12]
   1594              u32GPIOs_PDORBackup[4] = GPIOE_PDOR;
   \   0000014C   0x.... 0x....      LDR.W    R0,??DataTable36_72  ;; 0x400ff100
   \   00000150   0x6800             LDR      R0,[R0, #+0]
   \   00000152   0x.... 0x....      LDR.W    R1,??DataTable36_68
   \   00000156   0x6108             STR      R0,[R1, #+16]
   1595              
   1596              u32GPIOs_PDDRBackup[0] = GPIOA_PDDR;
   \   00000158   0x.... 0x....      LDR.W    R0,??DataTable36_73  ;; 0x400ff014
   \   0000015C   0x6800             LDR      R0,[R0, #+0]
   \   0000015E   0x.... 0x....      LDR.W    R1,??DataTable36_74
   \   00000162   0x6008             STR      R0,[R1, #+0]
   1597              u32GPIOs_PDDRBackup[1] = GPIOB_PDDR;
   \   00000164   0x.... 0x....      LDR.W    R0,??DataTable36_75  ;; 0x400ff054
   \   00000168   0x6800             LDR      R0,[R0, #+0]
   \   0000016A   0x.... 0x....      LDR.W    R1,??DataTable36_74
   \   0000016E   0x6048             STR      R0,[R1, #+4]
   1598              u32GPIOs_PDDRBackup[2] = GPIOC_PDDR;
   \   00000170   0x.... 0x....      LDR.W    R0,??DataTable36_76  ;; 0x400ff094
   \   00000174   0x6800             LDR      R0,[R0, #+0]
   \   00000176   0x.... 0x....      LDR.W    R1,??DataTable36_74
   \   0000017A   0x6088             STR      R0,[R1, #+8]
   1599              u32GPIOs_PDDRBackup[3] = GPIOD_PDDR;
   \   0000017C   0x.... 0x....      LDR.W    R0,??DataTable36_77  ;; 0x400ff0d4
   \   00000180   0x6800             LDR      R0,[R0, #+0]
   \   00000182   0x.... 0x....      LDR.W    R1,??DataTable36_74
   \   00000186   0x60C8             STR      R0,[R1, #+12]
   1600              u32GPIOs_PDDRBackup[4] = GPIOE_PDDR;
   \   00000188   0x.... 0x....      LDR.W    R0,??DataTable36_78  ;; 0x400ff114
   \   0000018C   0x6800             LDR      R0,[R0, #+0]
   \   0000018E   0x.... 0x....      LDR.W    R1,??DataTable36_74
   \   00000192   0x6108             STR      R0,[R1, #+16]
   1601              
   1602              /*UART pins*/
   1603              PORTE_PCR0 = PORT_PCR_MUX(0x1) | PORT_PCR_PE_MASK | PORT_PCR_PS_MASK; //PullUp/PullSelect enable (Connected to OpenSDA)
   \   00000194   0xF240 0x1003      MOVW     R0,#+259
   \   00000198   0x.... 0x....      LDR.W    R1,??DataTable36_59  ;; 0x4004d000
   \   0000019C   0x6008             STR      R0,[R1, #+0]
   1604              PORTE_PCR1 = PORT_PCR_MUX(0x1) | PORT_PCR_PE_MASK | PORT_PCR_PS_MASK; //PullUp/PullSelect enable (Connected to OpenSDA)
   \   0000019E   0xF240 0x1003      MOVW     R0,#+259
   \   000001A2   0x.... 0x....      LDR.W    R1,??DataTable36_61  ;; 0x4004d004
   \   000001A6   0x6008             STR      R0,[R1, #+0]
   1605             
   1606              PORTC_PCR0 = PORT_PCR_MUX(0x1) |PORT_PCR_PS_MASK ;                    //set PTC0 to be driven low
   \   000001A8   0xF240 0x1001      MOVW     R0,#+257
   \   000001AC   0x.... 0x....      LDR.W    R1,??DataTable36_79  ;; 0x4004b000
   \   000001B0   0x6008             STR      R0,[R1, #+0]
   1607              PORTC_PCR1 = PORT_PCR_MUX(0x1) |PORT_PCR_PS_MASK ;                    //set PTC1 to be driven low
   \   000001B2   0xF240 0x1001      MOVW     R0,#+257
   \   000001B6   0x.... 0x....      LDR.W    R1,??DataTable36_80  ;; 0x4004b004
   \   000001BA   0x6008             STR      R0,[R1, #+0]
   1608              PORTC_PCR3 = PORT_PCR_MUX(0x1) |PORT_PCR_PS_MASK ;                    //set PTC3 to be driven low
   \   000001BC   0xF240 0x1001      MOVW     R0,#+257
   \   000001C0   0x.... 0x....      LDR.W    R1,??DataTable36_81  ;; 0x4004b00c
   \   000001C4   0x6008             STR      R0,[R1, #+0]
   1609                 
   1610              /*LED pins*/ //PTD3, PTD4
   1611              //Set PTDs as GPIO
   1612              PORTD_PCR3 = PORT_PCR_MUX(0x1) | PORT_PCR_PE_MASK | PORT_PCR_PS_MASK;
   \   000001C6   0xF240 0x1003      MOVW     R0,#+259
   \   000001CA   0x.... 0x....      LDR.W    R1,??DataTable36_82  ;; 0x4004c00c
   \   000001CE   0x6008             STR      R0,[R1, #+0]
   1613              PORTD_PCR4 = PORT_PCR_MUX(0x1) | PORT_PCR_PE_MASK | PORT_PCR_PS_MASK;
   \   000001D0   0xF240 0x1003      MOVW     R0,#+259
   \   000001D4   0x.... 0x....      LDR.W    R1,??DataTable36_83  ;; 0x4004c010
   \   000001D8   0x6008             STR      R0,[R1, #+0]
   1614              
   1615              /*JTAG TDO pin*/ 
   1616              // ROBBIE - Remove this comment PORTA_PCR2 = PORT_PCR_PE_MASK | PORT_PCR_PS_MASK; //JTAG_TDO PullUp/PullSelect enable
   1617              
   1618              
   1619              /*EEPROM pins*/  //PTC5, PTC6, PTC7
   1620              //Set PTCs as GPIO
   1621              PORTC_PCR5 = PORT_PCR_MUX(0x1);
   \   000001DA   0xF44F 0x7080      MOV      R0,#+256
   \   000001DE   0x.... 0x....      LDR.W    R1,??DataTable36_56  ;; 0x4004b014
   \   000001E2   0x6008             STR      R0,[R1, #+0]
   1622              PORTC_PCR6 = PORT_PCR_MUX(0x1);
   \   000001E4   0xF44F 0x7080      MOV      R0,#+256
   \   000001E8   0x.... 0x....      LDR.W    R1,??DataTable36_57  ;; 0x4004b018
   \   000001EC   0x6008             STR      R0,[R1, #+0]
   1623              PORTC_PCR7 = PORT_PCR_MUX(0x1);
   \   000001EE   0xF44F 0x7080      MOV      R0,#+256
   \   000001F2   0x.... 0x....      LDR.W    R1,??DataTable36_58  ;; 0x4004b01c
   \   000001F6   0x6008             STR      R0,[R1, #+0]
   1624              
   1625              //Set GPIOCs as outputs
   1626              GPIOA_PDDR |= (1<<2);
   \   000001F8   0x.... 0x....      LDR.W    R0,??DataTable36_73  ;; 0x400ff014
   \   000001FC   0x6800             LDR      R0,[R0, #+0]
   \   000001FE   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000202   0x.... 0x....      LDR.W    R1,??DataTable36_73  ;; 0x400ff014
   \   00000206   0x6008             STR      R0,[R1, #+0]
   1627              GPIOD_PDDR |= (1<<3);
   \   00000208   0x.... 0x....      LDR.W    R0,??DataTable36_77  ;; 0x400ff0d4
   \   0000020C   0x6800             LDR      R0,[R0, #+0]
   \   0000020E   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000212   0x.... 0x....      LDR.W    R1,??DataTable36_77  ;; 0x400ff0d4
   \   00000216   0x6008             STR      R0,[R1, #+0]
   1628              GPIOD_PDDR |= (1<<4);
   \   00000218   0x.... 0x....      LDR.W    R0,??DataTable36_77  ;; 0x400ff0d4
   \   0000021C   0x6800             LDR      R0,[R0, #+0]
   \   0000021E   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000222   0x.... 0x....      LDR.W    R1,??DataTable36_77  ;; 0x400ff0d4
   \   00000226   0x6008             STR      R0,[R1, #+0]
   1629              GPIOC_PDDR |= (1<<5);
   \   00000228   0x.... 0x....      LDR.W    R0,??DataTable36_76  ;; 0x400ff094
   \   0000022C   0x6800             LDR      R0,[R0, #+0]
   \   0000022E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000232   0x.... 0x....      LDR.W    R1,??DataTable36_76  ;; 0x400ff094
   \   00000236   0x6008             STR      R0,[R1, #+0]
   1630              GPIOC_PDDR |= (1<<6);
   \   00000238   0x.... 0x....      LDR.W    R0,??DataTable36_76  ;; 0x400ff094
   \   0000023C   0x6800             LDR      R0,[R0, #+0]
   \   0000023E   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000242   0x.... 0x....      LDR.W    R1,??DataTable36_76  ;; 0x400ff094
   \   00000246   0x6008             STR      R0,[R1, #+0]
   1631              GPIOC_PDDR |= (1<<7);
   \   00000248   0x.... 0x....      LDR.W    R0,??DataTable36_76  ;; 0x400ff094
   \   0000024C   0x6800             LDR      R0,[R0, #+0]
   \   0000024E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000252   0x.... 0x....      LDR.W    R1,??DataTable36_76  ;; 0x400ff094
   \   00000256   0x6008             STR      R0,[R1, #+0]
   1632              
   1633              //Clear GPIOCs
   1634              GPIOA_PCOR |= (1<<2);
   \   00000258   0x.... 0x....      LDR.W    R0,??DataTable36_84  ;; 0x400ff008
   \   0000025C   0x6800             LDR      R0,[R0, #+0]
   \   0000025E   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000262   0x.... 0x....      LDR.W    R1,??DataTable36_84  ;; 0x400ff008
   \   00000266   0x6008             STR      R0,[R1, #+0]
   1635              GPIOC_PCOR |= (1<<5);
   \   00000268   0x.... 0x....      LDR.W    R0,??DataTable36_85  ;; 0x400ff088
   \   0000026C   0x6800             LDR      R0,[R0, #+0]
   \   0000026E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000272   0x.... 0x....      LDR.W    R1,??DataTable36_85  ;; 0x400ff088
   \   00000276   0x6008             STR      R0,[R1, #+0]
   1636              GPIOC_PCOR |= (1<<6);
   \   00000278   0x.... 0x....      LDR.W    R0,??DataTable36_85  ;; 0x400ff088
   \   0000027C   0x6800             LDR      R0,[R0, #+0]
   \   0000027E   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000282   0x.... 0x....      LDR.W    R1,??DataTable36_85  ;; 0x400ff088
   \   00000286   0x6008             STR      R0,[R1, #+0]
   1637              GPIOC_PCOR |= (1<<7);
   \   00000288   0x.... 0x....      LDR.W    R0,??DataTable36_85  ;; 0x400ff088
   \   0000028C   0x6800             LDR      R0,[R0, #+0]
   \   0000028E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000292   0x.... 0x....      LDR.W    R1,??DataTable36_85  ;; 0x400ff088
   \   00000296   0x6008             STR      R0,[R1, #+0]
   1638          
   1639              /*Disable Low Voltage Detection*/
   1640                 
   1641              PMC_LVDSC1 = 0x00;
   \   00000298   0x2000             MOVS     R0,#+0
   \   0000029A   0x.... 0x....      LDR.W    R1,??DataTable36_86  ;; 0x4007d000
   \   0000029E   0x7008             STRB     R0,[R1, #+0]
   1642              
   1643              
   1644              /*CLOCKS to default*/
   1645          
   1646              SIM_SCGC4 = 0xF0100030; //Default
   \   000002A0   0x.... 0x....      LDR.W    R0,??DataTable36_87  ;; 0xf0100030
   \   000002A4   0x.... 0x....      LDR.W    R1,??DataTable36_62  ;; 0x40048034
   \   000002A8   0x6008             STR      R0,[R1, #+0]
   1647          #if (gDefaultWakeupSource_c == gWUAppGPIO_c)
   1648              SIM_SCGC5 = 0x00040182 | SIM_SCGC5_PORTC_MASK; //Default + PTC Clock
   1649          #else
   1650              SIM_SCGC5 = 0x00040182; //Default
   \   000002AA   0x.... 0x....      LDR.W    R0,??DataTable36_88  ;; 0x40182
   \   000002AE   0x.... 0x....      LDR.W    R1,??DataTable36_64  ;; 0x40048038
   \   000002B2   0x6008             STR      R0,[R1, #+0]
   1651          #endif
   1652                 
   1653          #if (gDefaultWakeupSource_c == gWUAppRTC_c)
   1654              SIM_SCGC6 = 0x40000001 | SIM_SCGC6_RTC_MASK; //Default + RTC Clock
   1655          #else
   1656              SIM_SCGC6 = 0x40000001; //Default
   \   000002B4   0x.... 0x....      LDR.W    R0,??DataTable36_89  ;; 0x40000001
   \   000002B8   0x.... 0x....      LDR.W    R1,??DataTable36_65  ;; 0x4004803c
   \   000002BC   0x6008             STR      R0,[R1, #+0]
   1657          #endif
   1658              SIM_SCGC7 = 0x00000002; //Default
   \   000002BE   0x2002             MOVS     R0,#+2
   \   000002C0   0x.... 0x....      LDR.W    R1,??DataTable36_66  ;; 0x40048040
   \   000002C4   0x6008             STR      R0,[R1, #+0]
   1659              
   1660          #if (gDefaultWakeupSource_c == gWUAppGPIO_c)
   1661              bGPIOWakeupFlag = TRUE;
   1662              SIM_SCGC5 |= SIM_SCGC5_PORTC_MASK;
   1663          #elif (gDefaultWakeupSource_c == gWUAppLPTMR_c)
   1664              /*PWRLib_LPTMR_ClockStart(cPWR_LPTMRTickTime, SLEEP_AFTER_ACK);*/
   1665              PWRLib_LPTMR_ClockStart(cPWR_LPTMRTickTime, gOptions.u16SleepAfterAck);
   \   000002C6   0x.... 0x....      LDR.W    R0,??DataTable36_2
   \   000002CA   0x8AC1             LDRH     R1,[R0, #+22]
   \   000002CC   0x2048             MOVS     R0,#+72
   \   000002CE   0x.... 0x....      BL       PWRLib_LPTMR_ClockStart
   1666              bLPTMRWakeupFlag = TRUE;
   \   000002D2   0x2001             MOVS     R0,#+1
   \   000002D4   0x.... 0x....      LDR.W    R1,??DataTable36_90
   \   000002D8   0x7008             STRB     R0,[R1, #+0]
   1667          #elif (gDefaultWakeupSource_c == gWUAppRTC_c)
   1668              /* start RTC */
   1669              PWRLib_RTC_ClockStart(RTC_Duration);
   1670              bRTCWakeupFlag = TRUE;
   1671          #endif
   1672             return;
   \   000002DA   0xBD01             POP      {R0,PC}          ;; return
   1673          }
   1674           
   1675          //thisds will restore the presets from the low power mode

   \                                 In section .text, align 2, keep-with-next
   1676          void WUApp_LPRestoreSettings(void)
   1677          {
   \                     WUApp_LPRestoreSettings: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1678          
   1679          #if (gDefaultWakeupSource_c == gWUAppGPIO_c)
   1680            bGPIOWakeupFlag = FALSE;	
   1681          #elif (gDefaultWakeupSource_c == gWUAppLPTMR_c)
   1682            PWRLib_LPTMR_ClockStop();
   \   00000002   0x.... 0x....      BL       PWRLib_LPTMR_ClockStop
   1683            bLPTMRWakeupFlag = FALSE;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable36_90
   \   0000000C   0x7008             STRB     R0,[R1, #+0]
   1684          #elif (gDefaultWakeupSource_c == gWUAppRTC_c)
   1685            PWRLib_RTC_ClockStop();
   1686            bRTCWakeupFlag = FALSE;  
   1687          #endif
   1688            
   1689            
   1690            SIM_SCGC4 = u32SCGCxBackup[0]; //SCGC4
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable36_63
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable36_62  ;; 0x40048034
   \   00000018   0x6008             STR      R0,[R1, #+0]
   1691            SIM_SCGC5 = u32SCGCxBackup[1]; //SCGC5
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable36_63
   \   0000001E   0x6840             LDR      R0,[R0, #+4]
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable36_64  ;; 0x40048038
   \   00000024   0x6008             STR      R0,[R1, #+0]
   1692            SIM_SCGC6 = u32SCGCxBackup[2]; //SCGC6
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable36_63
   \   0000002A   0x6880             LDR      R0,[R0, #+8]
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable36_65  ;; 0x4004803c
   \   00000030   0x6008             STR      R0,[R1, #+0]
   1693            SIM_SCGC7 = u32SCGCxBackup[3]; //SCGC7
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable36_63
   \   00000036   0x68C0             LDR      R0,[R0, #+12]
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable36_66  ;; 0x40048040
   \   0000003C   0x6008             STR      R0,[R1, #+0]
   1694            
   1695            /*Enable Low Voltage Detection*/
   1696            PMC_LVDSC1 = 0x10;
   \   0000003E   0x2010             MOVS     R0,#+16
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable36_86  ;; 0x4007d000
   \   00000044   0x7008             STRB     R0,[R1, #+0]
   1697            
   1698            /*Restore PORTA PCR*/
   1699            PORTA_PCR0 = u32PortAPCRBackup[0]; //PTA0 JTAG CLK
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable36_44
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable36_43  ;; 0x40049000
   \   00000050   0x6008             STR      R0,[R1, #+0]
   1700            PORTA_PCR1 = u32PortAPCRBackup[1]; //PTA1 JTAG TDI
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable36_44
   \   00000056   0x6840             LDR      R0,[R0, #+4]
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable36_45  ;; 0x40049004
   \   0000005C   0x6008             STR      R0,[R1, #+0]
   1701            PORTA_PCR2 = u32PortAPCRBackup[2]; //PTA2 JTAG TDO
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable36_44
   \   00000062   0x6880             LDR      R0,[R0, #+8]
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable36_46  ;; 0x40049008
   \   00000068   0x6008             STR      R0,[R1, #+0]
   1702            PORTA_PCR3 = u32PortAPCRBackup[3]; //PTA3 JTAG TMS
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable36_44
   \   0000006E   0x68C0             LDR      R0,[R0, #+12]
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable36_47  ;; 0x4004900c
   \   00000074   0x6008             STR      R0,[R1, #+0]
   1703            PORTA_PCR3 = u32PortAPCRBackup[4]; //PTA4 JTAG NMI
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable36_44
   \   0000007A   0x6900             LDR      R0,[R0, #+16]
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable36_47  ;; 0x4004900c
   \   00000080   0x6008             STR      R0,[R1, #+0]
   1704            
   1705            /*Restore GPIOs*/
   1706            GPIOA_PDOR = u32GPIOs_PDORBackup[0];
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable36_68
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable36_67  ;; 0x400ff000
   \   0000008C   0x6008             STR      R0,[R1, #+0]
   1707            GPIOB_PDOR = u32GPIOs_PDORBackup[1];
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable36_68
   \   00000092   0x6840             LDR      R0,[R0, #+4]
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable36_69  ;; 0x400ff040
   \   00000098   0x6008             STR      R0,[R1, #+0]
   1708            GPIOC_PDOR = u32GPIOs_PDORBackup[2];
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable36_68
   \   0000009E   0x6880             LDR      R0,[R0, #+8]
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable36_70  ;; 0x400ff080
   \   000000A4   0x6008             STR      R0,[R1, #+0]
   1709            GPIOD_PDOR = u32GPIOs_PDORBackup[3];
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable36_68
   \   000000AA   0x68C0             LDR      R0,[R0, #+12]
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable36_71  ;; 0x400ff0c0
   \   000000B0   0x6008             STR      R0,[R1, #+0]
   1710            GPIOE_PDOR = u32GPIOs_PDORBackup[4];
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable36_68
   \   000000B6   0x6900             LDR      R0,[R0, #+16]
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable36_72  ;; 0x400ff100
   \   000000BC   0x6008             STR      R0,[R1, #+0]
   1711            
   1712            GPIOA_PDDR = u32GPIOs_PDDRBackup[0];
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable36_74
   \   000000C2   0x6800             LDR      R0,[R0, #+0]
   \   000000C4   0x.... 0x....      LDR.W    R1,??DataTable36_73  ;; 0x400ff014
   \   000000C8   0x6008             STR      R0,[R1, #+0]
   1713            GPIOB_PDDR = u32GPIOs_PDDRBackup[1];
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable36_74
   \   000000CE   0x6840             LDR      R0,[R0, #+4]
   \   000000D0   0x.... 0x....      LDR.W    R1,??DataTable36_75  ;; 0x400ff054
   \   000000D4   0x6008             STR      R0,[R1, #+0]
   1714            GPIOC_PDDR = u32GPIOs_PDDRBackup[2];
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable36_74
   \   000000DA   0x6880             LDR      R0,[R0, #+8]
   \   000000DC   0x.... 0x....      LDR.W    R1,??DataTable36_76  ;; 0x400ff094
   \   000000E0   0x6008             STR      R0,[R1, #+0]
   1715            GPIOD_PDDR = u32GPIOs_PDDRBackup[3];
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable36_74
   \   000000E6   0x68C0             LDR      R0,[R0, #+12]
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable36_77  ;; 0x400ff0d4
   \   000000EC   0x6008             STR      R0,[R1, #+0]
   1716            GPIOE_PDDR = u32GPIOs_PDDRBackup[4];
   \   000000EE   0x.... 0x....      LDR.W    R0,??DataTable36_74
   \   000000F2   0x6900             LDR      R0,[R0, #+16]
   \   000000F4   0x.... 0x....      LDR.W    R1,??DataTable36_78  ;; 0x400ff114
   \   000000F8   0x6008             STR      R0,[R1, #+0]
   1717              
   1718            /*Restore PORTB PCR*/ //SPI to Radio
   1719            PORTB_PCR10 = u32PortBPCRBackup[0];
   \   000000FA   0x....             LDR.N    R0,??DataTable36_50
   \   000000FC   0x6800             LDR      R0,[R0, #+0]
   \   000000FE   0x....             LDR.N    R1,??DataTable36_49  ;; 0x4004a028
   \   00000100   0x6008             STR      R0,[R1, #+0]
   1720            PORTB_PCR11 = u32PortBPCRBackup[1];
   \   00000102   0x....             LDR.N    R0,??DataTable36_50
   \   00000104   0x6840             LDR      R0,[R0, #+4]
   \   00000106   0x....             LDR.N    R1,??DataTable36_51  ;; 0x4004a02c
   \   00000108   0x6008             STR      R0,[R1, #+0]
   1721            PORTB_PCR16 = u32PortBPCRBackup[2];
   \   0000010A   0x....             LDR.N    R0,??DataTable36_50
   \   0000010C   0x6880             LDR      R0,[R0, #+8]
   \   0000010E   0x....             LDR.N    R1,??DataTable36_52  ;; 0x4004a040
   \   00000110   0x6008             STR      R0,[R1, #+0]
   1722            PORTB_PCR17 = u32PortBPCRBackup[3];
   \   00000112   0x....             LDR.N    R0,??DataTable36_50
   \   00000114   0x68C0             LDR      R0,[R0, #+12]
   \   00000116   0x....             LDR.N    R1,??DataTable36_53  ;; 0x4004a044
   \   00000118   0x6008             STR      R0,[R1, #+0]
   1723                
   1724            /*Restore PORTC PCR*/ //EEPROM
   1725            PORTC_PCR4 = u32PortCPCRBackup[0];
   \   0000011A   0x....             LDR.N    R0,??DataTable36_55
   \   0000011C   0x6800             LDR      R0,[R0, #+0]
   \   0000011E   0x....             LDR.N    R1,??DataTable36_54  ;; 0x4004b010
   \   00000120   0x6008             STR      R0,[R1, #+0]
   1726            PORTC_PCR5 = u32PortCPCRBackup[1];
   \   00000122   0x....             LDR.N    R0,??DataTable36_55
   \   00000124   0x6840             LDR      R0,[R0, #+4]
   \   00000126   0x....             LDR.N    R1,??DataTable36_56  ;; 0x4004b014
   \   00000128   0x6008             STR      R0,[R1, #+0]
   1727            PORTC_PCR6 = u32PortCPCRBackup[2];
   \   0000012A   0x....             LDR.N    R0,??DataTable36_55
   \   0000012C   0x6880             LDR      R0,[R0, #+8]
   \   0000012E   0x....             LDR.N    R1,??DataTable36_57  ;; 0x4004b018
   \   00000130   0x6008             STR      R0,[R1, #+0]
   1728            PORTC_PCR7 = u32PortCPCRBackup[3];
   \   00000132   0x....             LDR.N    R0,??DataTable36_55
   \   00000134   0x68C0             LDR      R0,[R0, #+12]
   \   00000136   0x....             LDR.N    R1,??DataTable36_58  ;; 0x4004b01c
   \   00000138   0x6008             STR      R0,[R1, #+0]
   1729            
   1730            /*Restore PORTD PCR*/ //LEDs
   1731            /*
   1732            PORTD_PCR4 = u32PortDPCRBackup[0];
   1733            PORTD_PCR5 = u32PortDPCRBackup[1];
   1734            PORTD_PCR6 = u32PortDPCRBackup[2];
   1735            PORTD_PCR7 = u32PortDPCRBackup[3];
   1736          */
   1737            /*Restore PORTE PCR*/ //UART
   1738            PORTE_PCR0 = u32PortEPCRBackup[0];
   \   0000013A   0x....             LDR.N    R0,??DataTable36_60
   \   0000013C   0x6800             LDR      R0,[R0, #+0]
   \   0000013E   0x....             LDR.N    R1,??DataTable36_59  ;; 0x4004d000
   \   00000140   0x6008             STR      R0,[R1, #+0]
   1739            PORTE_PCR1 = u32PortEPCRBackup[1];
   \   00000142   0x....             LDR.N    R0,??DataTable36_60
   \   00000144   0x6840             LDR      R0,[R0, #+4]
   \   00000146   0x....             LDR.N    R1,??DataTable36_61  ;; 0x4004d004
   \   00000148   0x6008             STR      R0,[R1, #+0]
   1740          
   1741            /* configure Radio in autodoze mode */
   1742            PWRLib_Radio_Enter_AutoDoze();
   \   0000014A   0x.... 0x....      BL       PWRLib_Radio_Enter_AutoDoze
   1743          //  PWRLib_Radio_Enter_Idle();
   1744            
   1745            /* Restore Radio's clock for input*/
   1746            MC1324xDrv_Set_CLK_OUT_Freq(gCLK_OUT_FREQ_4_MHz);
   \   0000014E   0x2003             MOVS     R0,#+3
   \   00000150   0x.... 0x....      BL       MC1324xDrv_Set_CLK_OUT_Freq
   1747              
   1748            /* PEE @ 48MHz */
   1749            gMCG_coreClkMHz = MCG_PLLInit();
   \   00000154   0x.... 0x....      BL       MCG_PLLInit
   \   00000158   0x....             LDR.N    R1,??DataTable36_91
   \   0000015A   0x6008             STR      R0,[R1, #+0]
   1750            
   1751            /*Restore Timers*/
   1752            mLEDTimerID_1 = TMR_AllocateTimer();
   \   0000015C   0x.... 0x....      BL       TMR_AllocateTimer
   \   00000160   0x....             LDR.N    R1,??DataTable36_13
   \   00000162   0x7008             STRB     R0,[R1, #+0]
   1753            mBufferTimerID = TMR_AllocateTimer(); 
   \   00000164   0x.... 0x....      BL       TMR_AllocateTimer
   \   00000168   0x....             LDR.N    R1,??DataTable36_14
   \   0000016A   0x7008             STRB     R0,[R1, #+0]
   1754            LowPowerEntered = TRUE;
   \   0000016C   0x2001             MOVS     R0,#+1
   \   0000016E   0x....             LDR.N    R1,??DataTable36_92
   \   00000170   0x7008             STRB     R0,[R1, #+0]
   1755            return;
   \   00000172   0xBD01             POP      {R0,PC}          ;; return
   1756          }
   1757          
   1758          /**************************************************************************************/
   1759          bool_t SerialContinuousTxRxTest(void)
   1760          {
   1761            bool_t bBackFlag = FALSE;
   1762            smacErrors_t smacResult;
   1763            uint8_t u8Index, u8TempEnergyValue;
   1764            
   1765            if(evTestParameters)
   1766            {
   1767              (void)MLMERXDisableRequest();
   1768              (void)MLMETestMode(gTestModeForceIdle_c);
   1769              (void)MLMESetChannelRequest(testChannel);
   1770              (void)MLMEPAOutputAdjust(testPower);
   1771              (void)MLMEXtalAdjust(testTrimmValue);
   1772              
   1773              if(gCTxRxStateSelectTest_c == cTxRxState){
   1774                PrintTestParameters(TRUE);
   1775              }else{
   1776                PrintTestParameters(FALSE);
   1777                CommUtil_Print("\r\n", gAllowToBlock_d);     
   1778              }
   1779              
   1780              if(gTestModePRBS9_c == contTestRunning){
   1781                (void)MLMETestMode(gTestModePRBS9_c);
   1782              }else if(gTestModeContinuousTxModulated_c == contTestRunning){
   1783                (void)MLMETestMode(gTestModeContinuousTxModulated_c);
   1784              }else if(gTestModeContinuousTxUnmodulated_c == contTestRunning){
   1785                (void)MLMETestMode(gTestModeContinuousTxUnmodulated_c);
   1786              }
   1787              
   1788              if(gCTxRxStateRunnigRxTest_c == cTxRxState){
   1789                bRxDone = FALSE;
   1790                gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
   1791                (void)MLMERXEnableRequest(gAppRxPacket, 0);
   1792              }
   1793              evTestParameters = FALSE;
   1794            }
   1795            
   1796            switch(cTxRxState)
   1797            {
   1798              case gCTxRxStateIdle_c:
   1799                   if((evDataFromCOMM) && ('\r' == gu8CommData))
   1800                   {
   1801                     cTxRxState = gCTxRxStateInit_c;
   1802                     evDataFromCOMM = FALSE;  
   1803                   }
   1804              break;
   1805              case gCTxRxStateInit_c:
   1806                   PrintMenu(cu8ShortCutsBar, gDefaultCommPort_c);
   1807                   PrintMenu(cu8ContinuousTestMenu, gDefaultCommPort_c);
   1808                   
   1809                   (void)MLMETestMode(gTestModeForceIdle_c);  
   1810                   
   1811                   while(MLMESetChannelRequest(testChannel)); 
   1812                   
   1813                   (void)MLMETestMode(contTestRunning);
   1814                   CommUtil_Print(cu8ContinuousTestTags[contTestRunning], gAllowToBlock_d);
   1815                   CommUtil_Print("\r\n\r\n", gAllowToBlock_d);       
   1816                   PrintTestParameters(FALSE);
   1817                   shortCutsEnabled = TRUE;           
   1818                   cTxRxState = gCTxRxStateSelectTest_c; 
   1819              break;
   1820              case gCTxRxStateSelectTest_c:
   1821                   if(evDataFromCOMM)
   1822                   {           
   1823                     if('1' == gu8CommData){
   1824                       contTestRunning = gTestModeForceIdle_c;              
   1825                       cTxRxState = gCTxRxStateInit_c;
   1826                     }else if('2' == gu8CommData){
   1827                       contTestRunning = gTestModePRBS9_c;               
   1828                       cTxRxState = gCTxRxStateInit_c;
   1829                     }else if('3' == gu8CommData){
   1830                       contTestRunning = gTestModeContinuousTxModulated_c;               
   1831                       cTxRxState = gCTxRxStateInit_c;
   1832                     }else if('4' == gu8CommData){
   1833                       if(gTestModeContinuousTxUnmodulated_c != contTestRunning) 
   1834                       { 
   1835                        contTestRunning = gTestModeContinuousTxUnmodulated_c;               
   1836                        cTxRxState = gCTxRxStateInit_c;
   1837                       }
   1838                     }else if('5' == gu8CommData)
   1839                     {
   1840                       (void)MLMETestMode(gTestModeForceIdle_c);     
   1841                       contTestRunning = gTestModeForceIdle_c;
   1842                       CommUtil_Print("\f\r\nPress [p] to stop receiving promiscuous packets \r\n", gAllowToBlock_d);
   1843                              
   1844                       MLMESetPromiscuousMode(TRUE);    
   1845                       
   1846                       bRxDone = FALSE;
   1847                       gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
   1848                       (void)MLMERXEnableRequest(gAppRxPacket, 0);
   1849                       cTxRxState = gCTxRxStateRunnigRxTest_c;
   1850                     }else if('6' == gu8CommData){
   1851                       (void)MLMETestMode(gTestModeForceIdle_c);
   1852                       contTestRunning = gTestModeForceIdle_c;
   1853                       CommUtil_Print("\f\r\nPress [p] to stop the Continuous ED test\r\n", gAllowToBlock_d);
   1854                       contTestRunning = gTestModeForceIdle_c;                
   1855                       cTxRxState = gCTxRxStateRunnigEdTest_c;
   1856                     }else if('7' == gu8CommData){
   1857                       (void)MLMETestMode(gTestModeForceIdle_c);
   1858                       contTestRunning = gTestModeForceIdle_c;
   1859                       CommUtil_Print("\f\r\nPress [p] to stop the Continuous SCAN test\r\n", gAllowToBlock_d);
   1860                       bScanDone = FALSE;
   1861                       smacResult = MLMEScanRequest(0xFFFF, gScanModeED_c, au8ScanResults);
   1862                       (void)smacResult;
   1863                       contTestRunning = gTestModeForceIdle_c;                
   1864                       cTxRxState = gCTxRxStateRunnigScanTest_c;
   1865                     }else if('p' == gu8CommData){ 
   1866                       (void)MLMETestMode(gTestModeForceIdle_c);
   1867                       (void)MLMESetChannelRequest(testChannel);
   1868                       bBackFlag = TRUE;
   1869                     }
   1870                     evDataFromCOMM = FALSE;
   1871                   }
   1872              break;
   1873              case gCTxRxStateRunnigRxTest_c:
   1874                   if(bRxDone){
   1875                     if (gAppRxPacket->rxStatus == rxSuccessStatus_c){
   1876                       CommUtil_Print("New Packet: ", gAllowToBlock_d);
   1877                       for(u8Index = 0; u8Index < (gAppRxPacket->u8DataLength); u8Index++){
   1878                         PrintByteOnHexFormatBlocking(gAppRxPacket->smacPdu.u8Data[u8Index], TRUE, gAllowToBlock_d);
   1879                       }
   1880                       CommUtil_Print("\b \r\n", gAllowToBlock_d);
   1881                     }
   1882                     bRxDone = FALSE;
   1883                     gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
   1884                     (void)MLMERXEnableRequest(gAppRxPacket, 0);
   1885                   }
   1886                   if((evDataFromCOMM) && ('p' == gu8CommData)){
   1887                     (void)MLMERXDisableRequest();
   1888                     (void)MLMETestMode(gTestModeForceIdle_c);
   1889                     MLMESetPromiscuousMode(FALSE);
   1890                     CommUtil_Print("\r\n\r\n Press [enter] to go back to the Continuous test menu ", gAllowToBlock_d);
   1891                     cTxRxState = gCTxRxStateIdle_c;
   1892                     evDataFromCOMM = FALSE;
   1893                   }
   1894              break;
   1895              case gCTxRxStateRunnigEdTest_c:
   1896                   delayMs(100);delayMs(100);
   1897                   CommUtil_Print("Energy on the Channel ", gAllowToBlock_d);
   1898                   PrintWordOnDecimalFormatBlocking((uint16_t)testChannel, 0, FALSE, gDefaultCommPort_c);
   1899                   CommUtil_Print(" : ", gAllowToBlock_d);
   1900                   (void)MLMEEnergyDetect(&u8TempEnergyValue);
   1901                   PrintWordOnDecimalFormatBlocking(u8TempEnergyValue,0,TRUE, gDefaultCommPort_c);
   1902                   CommUtil_Print("dBm\r\n", gAllowToBlock_d);
   1903                   if((evDataFromCOMM) && ('p' == gu8CommData)){
   1904                     CommUtil_Print("\r\n\r\n Press [enter] to go back to the Continuous test menu ", gAllowToBlock_d);
   1905                     cTxRxState = gCTxRxStateIdle_c;
   1906                     evDataFromCOMM = FALSE;
   1907                   }
   1908              break;
   1909              case gCTxRxStateRunnigScanTest_c:
   1910                   if(bScanDone){
   1911                     CommUtil_Print("Results : ", gAllowToBlock_d);
   1912                     for(u8Index = 0; u8Index < 16 ; u8Index++){
   1913                       PrintWordOnDecimalFormatBlocking((uint16_t)(au8ScanResults[u8Index]),0,TRUE, gDefaultCommPort_c);
   1914                       CommUtil_Print(",", gAllowToBlock_d);   
   1915                     }
   1916                     CommUtil_Print("\b \r\n", gAllowToBlock_d);
   1917                     if((evDataFromCOMM) && ('p' == gu8CommData)){
   1918                       CommUtil_Print("\r\n\r\n Press [enter] to go back to the Continuous test menu ", gAllowToBlock_d);
   1919                       cTxRxState = gCTxRxStateIdle_c;
   1920                       evDataFromCOMM = FALSE;
   1921                     }else{
   1922                       delayMs(100);delayMs(100);delayMs(50);
   1923                       bScanDone = FALSE;
   1924                       smacResult = MLMEScanRequest(0xFFFF, gScanModeED_c, au8ScanResults);
   1925                     }
   1926                   }
   1927              break;
   1928              default:
   1929              break;
   1930            }
   1931            return bBackFlag;
   1932          }
   1933          
   1934          /**************************************************************************************/
   1935          bool_t PacketErrorRateTx(void)
   1936          {
   1937            const uint16_t u16TotalPacketsOptions[] = {1,25,100,500,1000,2000,5000,10000,65535};
   1938            static uint16_t u16TotalPackets;
   1939            static uint16_t u16SentPackets;
   1940            uint8_t u8Index;
   1941            bool_t bBackFlag = FALSE;
   1942            
   1943            if(evTestParameters)
   1944            {
   1945              (void)MLMERXDisableRequest();
   1946              (void)MLMESetChannelRequest(testChannel);
   1947              (void)MLMEPAOutputAdjust(testPower);
   1948              (void)MLMEXtalAdjust(testTrimmValue);
   1949              PrintTestParameters(TRUE);
   1950              evTestParameters = FALSE;
   1951            }
   1952            
   1953            switch(perTxState)
   1954            {
   1955              case gPerTxStateInit_c:
   1956                     PrintMenu(cu8ShortCutsBar, gDefaultCommPort_c);
   1957                     PrintMenu(cu8PerTxTestMenu, gDefaultCommPort_c);
   1958                     PrintTestParameters(FALSE);
   1959                     shortCutsEnabled = TRUE;           
   1960                     perTxState = gPerTxStateSelectPacketNum_c;        
   1961              break;
   1962              case gPerTxStateSelectPacketNum_c:
   1963                   if(evDataFromCOMM){
   1964                     if((gu8CommData >= '0') && (gu8CommData <= '8')){
   1965                       u16TotalPackets = u16TotalPacketsOptions[gu8CommData - '0'];
   1966                       shortCutsEnabled = FALSE;  
   1967                       perTxState = gPerTxStateStartTest_c;
   1968                  }else if('p' == gu8CommData){ 
   1969                       bBackFlag = TRUE;
   1970                     }
   1971          			 evDataFromCOMM = FALSE;
   1972                   }
   1973              break;
   1974              case gPerTxStateStartTest_c:
   1975                   gAppTxPacket->u8DataLength = testPayloadLen;
   1976                   u16SentPackets = 0;
   1977                   gAppTxPacket->smacPdu.u8Data[0] = (u16TotalPackets >> 8);
   1978                   gAppTxPacket->smacPdu.u8Data[1] = (uint8_t)u16TotalPackets;
   1979                   gAppTxPacket->smacPdu.u8Data[2] = ((u16SentPackets+1) >> 8);
   1980                   gAppTxPacket->smacPdu.u8Data[3] = (uint8_t)(u16SentPackets+1);
   1981                   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[4]), "SMAC PER Demo",13);
   1982                   if(17 < testPayloadLen){
   1983                     for(u8Index=17;u8Index<testPayloadLen;u8Index++){
   1984                       gAppTxPacket->smacPdu.u8Data[u8Index] = (u8Index%10)+'0';            
   1985                     }
   1986                   }
   1987                   bTxDone = FALSE;
   1988          
   1989                   (void)MCPSDataRequest(gAppTxPacket);
   1990                   u16SentPackets++;
   1991                   CommUtil_Print("\f\r\n Running PER Tx, Sending ", gAllowToBlock_d);
   1992                   PrintWordOnDecimalFormatBlocking(u16TotalPackets, 0, FALSE, gDefaultCommPort_c);
   1993                   CommUtil_Print(" Packets", gAllowToBlock_d);
   1994                   perTxState = gPerTxStateRunningTest_c;
   1995              break;
   1996              case gPerTxStateRunningTest_c:
   1997                   if(bTxDone){
   1998                     if(u16SentPackets == u16TotalPackets)
   1999                     {
   2000                       MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[4]), "DONE",4);
   2001                       gAppTxPacket->u8DataLength = 8;
   2002                       u16SentPackets = 0;
   2003                       u16TotalPackets = mTotalFinalFrames_c;
   2004                       gAppTxPacket->u8DataLength = 8;
   2005                       perTxState = gPerTxStateSendingLastFrames_c;
   2006                     }else
   2007                     {
   2008                      gAppTxPacket->smacPdu.u8Data[2] = ((u16SentPackets+1) >> 8);
   2009                      gAppTxPacket->smacPdu.u8Data[3] = (uint8_t)(u16SentPackets+1);
   2010                      gAppTxPacket->u8DataLength = testPayloadLen;
   2011                     }
   2012                      bTxDone = FALSE;
   2013                     delayMs(10);
   2014                      (void)MCPSDataRequest(gAppTxPacket);
   2015                      u16SentPackets++;
   2016                    }
   2017              break;
   2018              case gPerTxStateSendingLastFrames_c:
   2019                   if(bTxDone)
   2020                   {
   2021                     bTxDone = FALSE;
   2022                     if(u16SentPackets == u16TotalPackets)
   2023                     {
   2024                         CommUtil_Print("\r\n PER Tx DONE \r\n", gAllowToBlock_d);
   2025                         CommUtil_Print("\r\n\r\n Press [enter] to go back to the PER Tx test menu ", gAllowToBlock_d);
   2026                         perTxState = gPerTxStateIdle_c;
   2027                     }else
   2028                     {
   2029                       gAppTxPacket->u8DataLength = 8;
   2030                       delayMs(10);
   2031                       (void)MCPSDataRequest(gAppTxPacket);
   2032                       u16SentPackets++;
   2033                        } 
   2034                    }	 
   2035              break;	
   2036              case gPerTxStateIdle_c:
   2037                   if((evDataFromCOMM) && ('\r' == gu8CommData))
   2038                   {
   2039                     perTxState = gPerTxStateInit_c;
   2040                     evDataFromCOMM = FALSE;
   2041                   }
   2042              break;
   2043             default:
   2044              break;
   2045            }
   2046          
   2047            return bBackFlag;
   2048          }
   2049          
   2050          /**************************************************************************************/
   2051          bool_t PacketErrorRateRx(void)
   2052          {
   2053            static uint16_t u16ReceivedPackets;
   2054            static uint16_t u16PacketsIndex;  
   2055            static uint16_t u16TotalPackets;
   2056            static uint16_t u16FinalPacketsCount;
   2057            static uint32_t u32LQISum;
   2058            uint8_t  u8AverageLQI, u8TempLQIvalue;
   2059          
   2060            bool_t bBackFlag = FALSE;
   2061            if(evTestParameters){
   2062              (void)MLMESetChannelRequest(testChannel);
   2063              (void)MLMEPAOutputAdjust(testPower);
   2064              (void)MLMEXtalAdjust(testTrimmValue);
   2065              PrintTestParameters(TRUE);
   2066              evTestParameters = FALSE;
   2067            }
   2068          
   2069            switch(perRxState)
   2070            {
   2071              case gPerRxStateInit_c:
   2072                  u16TotalPackets = 0;
   2073                  u16ReceivedPackets = 0;
   2074                  u16PacketsIndex = 0;
   2075                  u32LQISum = 0;
   2076                  PrintMenu(cu8ShortCutsBar, gDefaultCommPort_c);
   2077                  PrintMenu(cu8PerRxTestMenu, gDefaultCommPort_c);
   2078                  PrintTestParameters(FALSE);
   2079                  shortCutsEnabled = TRUE;           
   2080                  perRxState = gPerRxWaitStartTest_c;
   2081              break;
   2082              case gPerRxWaitStartTest_c:
   2083                   if(evDataFromCOMM){
   2084                     if(' ' == gu8CommData){
   2085                           CommUtil_Print("\f\n\rPER Test Rx Running\r\n\r\n", gAllowToBlock_d);
   2086                           SetRadioRxOnTimeOut15ms();
   2087                           shortCutsEnabled = FALSE;  
   2088                           perRxState = gPerRxStateStartTest_c;
   2089                        }else if('p' == gu8CommData){ 
   2090                        bBackFlag = TRUE;
   2091                     }
   2092                     evDataFromCOMM = FALSE;
   2093                   }
   2094              break;
   2095              case gPerRxStateStartTest_c:
   2096                   if(bRxDone){
   2097                     if (gAppRxPacket->rxStatus == rxSuccessStatus_c){
   2098                       if(stringComp("SMAC PER Demo",&gAppRxPacket->smacPdu.u8Data[4],13)){
   2099                         u16TotalPackets = ((uint16_t)gAppRxPacket->smacPdu.u8Data[0] <<8) + gAppRxPacket->smacPdu.u8Data[1];
   2100                         u16PacketsIndex = ((uint16_t)gAppRxPacket->smacPdu.u8Data[2] <<8) + gAppRxPacket->smacPdu.u8Data[3];
   2101                         u16ReceivedPackets++;
   2102                         (void)MLMELinkQuality(&u8TempLQIvalue);
   2103                         u32LQISum += u8TempLQIvalue;
   2104                         u8AverageLQI = (uint8_t)(u32LQISum/u16ReceivedPackets);
   2105                         (void)u8AverageLQI;
   2106                           CommUtil_Print("Packet ", gAllowToBlock_d);
   2107                         PrintWordOnDecimalFormatBlocking(u16ReceivedPackets, 2, FALSE, gDefaultCommPort_c);
   2108                         CommUtil_Print("\r\n", gAllowToBlock_d);
   2109                         if(u16PacketsIndex == u16TotalPackets){
   2110                           u16FinalPacketsCount = 0; 
   2111                           perRxState = gPerRxStateReceivingLastFrames_c;
   2112                     }
   2113                       }else if(stringComp("DONE",&gAppRxPacket->smacPdu.u8Data[4],4)){
   2114                         u16FinalPacketsCount = 0; 
   2115                         perRxState = gPerRxStateReceivingLastFrames_c;
   2116                       }
   2117                     }else{ 
   2118                       if(u16TotalPackets){
   2119                         u16PacketsIndex++;
   2120                         if(u16PacketsIndex == u16TotalPackets){
   2121                           u16FinalPacketsCount = 0; 
   2122                       perRxState = gPerRxStateReceivingLastFrames_c;
   2123                      }
   2124                       }
   2125                     }
   2126                     SetRadioRxOnTimeOut15ms();
   2127                   }
   2128                   if(evDataFromCOMM){
   2129                     if(' ' == gu8CommData){
   2130                       (void)MLMERXDisableRequest();
   2131                       CommUtil_Print("\n\rPER Test Rx Stopped\r\n\r\n", gAllowToBlock_d);
   2132                       PrintPerRxFinalLine(u16ReceivedPackets,u16TotalPackets);
   2133                       perRxState = gPerRxStateIdle_c;
   2134                     } 
   2135                     evDataFromCOMM = FALSE;
   2136                   }         
   2137              break;
   2138              case gPerRxStateReceivingLastFrames_c:
   2139                   if(bRxDone){
   2140                     u16FinalPacketsCount++; 
   2141                     if(mTotalFinalFrames_c == u16FinalPacketsCount){
   2142                     CommUtil_Print("\n\rPER Test Finished\r\n\r\n", gAllowToBlock_d);
   2143                     PrintPerRxFinalLine(u16ReceivedPackets,u16TotalPackets);              
   2144                     perRxState = gPerRxStateIdle_c;
   2145                     }else{  
   2146                       SetRadioRxOnTimeOut15ms();
   2147                     }
   2148                   }
   2149              break;
   2150              case gPerRxStateIdle_c:
   2151                   if((evDataFromCOMM) && ('\r' == gu8CommData)){
   2152                     perRxState = gPerRxStateInit_c;
   2153                   }
   2154                   evDataFromCOMM = FALSE;
   2155              break;
   2156              default:
   2157              break;
   2158            }
   2159            return bBackFlag;
   2160          }
   2161          
   2162          /**************************************************************************************/
   2163          bool_t RangeTx(void)
   2164          {
   2165            bool_t bBackFlag = FALSE;
   2166            static uint32_t u32LQISum;
   2167            static uint16_t u16ReceivedPackets;
   2168            static uint16_t u16PacketsDropped;
   2169            uint8_t  u8AverageLQI;
   2170            uint8_t  u8CurrentLQI;
   2171            
   2172            if(evTestParameters){
   2173              (void)MLMESetChannelRequest(testChannel);
   2174              (void)MLMEPAOutputAdjust(testPower);
   2175              (void)MLMEXtalAdjust(testTrimmValue);
   2176              PrintTestParameters(TRUE);
   2177              evTestParameters = FALSE;
   2178            }
   2179            
   2180            switch(rangeTxState)
   2181            {
   2182              case gRangeTxStateInit_c:
   2183                   u32LQISum = 0;
   2184                   u16ReceivedPackets = 0;
   2185                   u16PacketsDropped = 0;
   2186                     PrintMenu(cu8ShortCutsBar, gDefaultCommPort_c);
   2187                     PrintMenu(cu8RangeTxTestMenu, gDefaultCommPort_c);
   2188                     PrintTestParameters(FALSE);
   2189                     shortCutsEnabled = TRUE;           
   2190                     rangeTxState = gRangeTxWaitStartTest_c;
   2191              break;
   2192              case gRangeTxWaitStartTest_c:
   2193                   if(evDataFromCOMM){
   2194                     if(' ' == gu8CommData){
   2195                       shortCutsEnabled = FALSE; 
   2196                       CommUtil_Print("\f\r\nRange Test Tx Running\r\n", gAllowToBlock_d);
   2197                       rangeTxState = gRangeTxStateStartTest_c;
   2198                     }else if('p' == gu8CommData){ 
   2199                       bBackFlag = TRUE;
   2200                     }
   2201                     evDataFromCOMM = FALSE;
   2202                   }
   2203              break;
   2204              case gRangeTxStateStartTest_c:
   2205                   delayMs(100);
   2206                   delayMs(100);
   2207                   bTxDone = FALSE;
   2208                   gAppTxPacket->u8DataLength = 16;
   2209                   gAppTxPacket->smacPdu.u8Data[0]  = 0;
   2210                   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[1]), "SMAC Range Demo",15);
   2211                   (void)MCPSDataRequest(gAppTxPacket);
   2212                   rangeTxState = gRangeTxStateRunningTest_c;
   2213              break;
   2214              case gRangeTxStateRunningTest_c:
   2215                   if(bTxDone){
   2216                     SetRadioRxOnTimeOut15ms();
   2217                     rangeTxState = gRangeTxStatePrintTestResults_c;
   2218                   }
   2219              break;
   2220              case gRangeTxStatePrintTestResults_c:
   2221                   if(bRxDone){
   2222                     if(gAppRxPacket->rxStatus == rxSuccessStatus_c){ 
   2223                       if(stringComp("SMAC Range Demo",&gAppRxPacket->smacPdu.u8Data[1],15)){
   2224                         u8CurrentLQI = (gAppRxPacket->smacPdu.u8Data[0]); 
   2225                         u32LQISum += u8CurrentLQI;  
   2226                         u16ReceivedPackets++;
   2227                         u8AverageLQI = (uint8_t)(u32LQISum/u16ReceivedPackets);
   2228                           CommUtil_Print("\r\n LQI = ", gAllowToBlock_d);
   2229                           PrintWordOnDecimalFormatBlocking((uint16_t)u8CurrentLQI,1,FALSE, gDefaultCommPort_c);               
   2230                       }else{
   2231                         SetRadioRxOnTimeOut15ms();
   2232                       }
   2233                     }else{
   2234                         u16PacketsDropped++;
   2235                         CommUtil_Print("\r\nPacket Dropped", gAllowToBlock_d);
   2236                     }
   2237                     if(evDataFromCOMM && (' ' == gu8CommData)){
   2238                       CommUtil_Print("\n\r\n\rRange Test Tx Stopped\r\n\r\n", gAllowToBlock_d);
   2239                       u8AverageLQI = (uint8_t)(u32LQISum/u16ReceivedPackets);
   2240                       CommUtil_Print("Average LQI     ", gAllowToBlock_d);
   2241                       PrintWordOnDecimalFormatBlocking((uint16_t)u8AverageLQI,1,FALSE, gDefaultCommPort_c);  
   2242                       CommUtil_Print("\r\nPackets dropped ", gAllowToBlock_d);
   2243                       PrintWordOnDecimalFormatBlocking(u16PacketsDropped,1,FALSE, gDefaultCommPort_c);  
   2244                       CommUtil_Print("\r\n\r\n Press [enter] to go back to the Range Tx test menu", gAllowToBlock_d);
   2245                       rangeTxState = gRangeTxStateIdle_c;
   2246                     }else{
   2247                       rangeTxState = gRangeTxStateStartTest_c;
   2248                     }
   2249                     evDataFromCOMM = FALSE;
   2250                   }
   2251              break;
   2252              case gRangeTxStateIdle_c:
   2253                   if((evDataFromCOMM) && ('\r' == gu8CommData))
   2254                   {
   2255                     rangeTxState = gRangeTxStateInit_c;
   2256                   }
   2257                   evDataFromCOMM = FALSE;
   2258              break;
   2259              default:
   2260              break;
   2261            }
   2262            return bBackFlag;
   2263          }
   2264          
   2265          /**************************************************************************************/
   2266          bool_t RangeRx(void)
   2267          {
   2268            bool_t bBackFlag = FALSE;
   2269            static uint32_t u32LQISum;
   2270            static uint16_t u16ReceivedPackets;
   2271            uint8_t  u8AverageLQI, u8TempLQIvalue;
   2272            uint8_t  u8CurrentLQI;
   2273          
   2274            if(evTestParameters){
   2275              (void)MLMESetChannelRequest(testChannel);
   2276              (void)MLMEPAOutputAdjust(testPower);
   2277              (void)MLMEXtalAdjust(testTrimmValue);
   2278              PrintTestParameters(TRUE);
   2279              evTestParameters = FALSE;
   2280            }
   2281          
   2282            switch(rangeRxState)
   2283            {
   2284              case gRangeRxStateInit_c:
   2285                   u32LQISum = 0;
   2286                   u16ReceivedPackets = 0;
   2287                     PrintMenu(cu8ShortCutsBar, gDefaultCommPort_c);
   2288                     PrintMenu(cu8RangeRxTestMenu, gDefaultCommPort_c);
   2289                     PrintTestParameters(FALSE);
   2290                     shortCutsEnabled = TRUE;           
   2291                     rangeRxState = gRangeRxWaitStartTest_c;
   2292              break;
   2293              case gRangeRxWaitStartTest_c:
   2294                   if(evDataFromCOMM){
   2295                     if(' ' == gu8CommData){
   2296                       shortCutsEnabled = FALSE; 
   2297                       CommUtil_Print("\f\r\nRange Test Rx Running\r\n", gAllowToBlock_d);
   2298                       rangeRxState = gRangeRxStateStartTest_c;
   2299                     }else if('p' == gu8CommData){ 
   2300                       bBackFlag = TRUE;
   2301                     }
   2302                     evDataFromCOMM = FALSE;
   2303                   }
   2304              break;
   2305              case gRangeRxStateStartTest_c:
   2306                   SetRadioRxOnNoTimeOut();
   2307                   rangeRxState = gRangeRxStateRunningTest_c;
   2308              break;
   2309              case gRangeRxStateRunningTest_c:
   2310                   if(evDataFromCOMM && (' ' == gu8CommData))
   2311                   {             
   2312                     (void)MLMERXDisableRequest();
   2313                     CommUtil_Print("\n\r\n\rRange Test Rx Stopped\r\n\r\n", gAllowToBlock_d);
   2314                     u8AverageLQI = (uint8_t)(u32LQISum/u16ReceivedPackets);
   2315                     CommUtil_Print("Average LQI     ", gAllowToBlock_d);
   2316                     PrintWordOnDecimalFormatBlocking((uint16_t)u8AverageLQI,1,FALSE, gDefaultCommPort_c);  
   2317                     CommUtil_Print("\r\n\r\n Press [enter] to go back to the Range Rx test menu", gAllowToBlock_d);
   2318                     rangeRxState = gRangeRxStateIdle_c;
   2319                   }
   2320                   evDataFromCOMM = FALSE;
   2321                   if(bRxDone){
   2322                     if(gAppRxPacket->rxStatus == rxSuccessStatus_c){ 
   2323                       if(stringComp("SMAC Range Demo",&gAppRxPacket->smacPdu.u8Data[1],15)){
   2324                         bTxDone = FALSE;
   2325          			   delayMs(2);
   2326                         (void)MLMELinkQuality(&u8TempLQIvalue);
   2327                         gAppTxPacket->smacPdu.u8Data[0] = u8TempLQIvalue;
   2328                         MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[1]), "SMAC Range Demo",15);
   2329                         gAppTxPacket->u8DataLength = 16;
   2330                         (void)MCPSDataRequest(gAppTxPacket);
   2331                         rangeRxState = gRangeRxStatePrintTestResults_c;
   2332                       }else{
   2333                         SetRadioRxOnNoTimeOut();
   2334                       }
   2335                     }else{
   2336                       SetRadioRxOnNoTimeOut();
   2337                     }
   2338                   }
   2339              break;
   2340              case gRangeRxStatePrintTestResults_c:
   2341                   if(bTxDone)
   2342                   {
   2343                     (void)MLMELinkQuality(&u8CurrentLQI); 
   2344                     u32LQISum += u8CurrentLQI;
   2345                     u16ReceivedPackets++;
   2346                     u8AverageLQI = (uint8_t)(u32LQISum/u16ReceivedPackets);
   2347                       CommUtil_Print("\r\n LQI = ", gAllowToBlock_d);
   2348                       PrintWordOnDecimalFormatBlocking((uint16_t)u8CurrentLQI,1,FALSE, gDefaultCommPort_c);               
   2349                     rangeRxState = gRangeRxStateStartTest_c;
   2350                   }
   2351              break;
   2352              case gRangeRxStateIdle_c:
   2353                   if((evDataFromCOMM) && ('\r' == gu8CommData))
   2354                   {
   2355                     rangeRxState = gRangeRxStateInit_c;
   2356                   }
   2357                   evDataFromCOMM = FALSE;
   2358              break;
   2359              default:
   2360              break;
   2361            }
   2362            return bBackFlag;
   2363          }
   2364          
   2365          /**************************************************************************************/
   2366          /**************************************************************************************/
   2367          bool_t EditRegisters(void)
   2368          {
   2369            bool_t bBackFlag = FALSE;
   2370            if(evTestParameters){
   2371              (void)MLMESetChannelRequest(testChannel);
   2372              (void)MLMEPAOutputAdjust(testPower);
   2373              (void)MLMEXtalAdjust(testTrimmValue);
   2374              PrintTestParameters(TRUE);
   2375              evTestParameters = FALSE;
   2376            }
   2377          
   2378            switch(eRState)
   2379            {
   2380              case gERStateInit_c:
   2381                   PrintMenu(cu8ShortCutsBar, gDefaultCommPort_c);
   2382                   PrintMenu(cu8RadioRegistersEditMenu, gDefaultCommPort_c);
   2383                   PrintTestParameters(FALSE);
   2384                   shortCutsEnabled = TRUE;           
   2385                   eRState = gERWaitSelection_c;
   2386              break;
   2387              case gERWaitSelection_c:
   2388                   if(evDataFromCOMM){
   2389                     if('1' == gu8CommData){
   2390                       oDRState = gODRStateInit_c;
   2391                       eRState = gERStateOverrideDirectReg_c;
   2392                     }else if('2' == gu8CommData){
   2393                       rDRState = gRDRStateInit_c;
   2394                       eRState = gERStateReadDirectReg_c;
   2395                     }else if('3' == gu8CommData){
   2396                       oIRState = gOIRStateInit_c;
   2397                       eRState = gERStateOverrideIndirectReg_c;
   2398                     }else if('4' == gu8CommData){
   2399                       rIRState = gRIRStateInit_c;
   2400                       eRState = gERStateReadIndirectReg_c;
   2401                     }else if('p' == gu8CommData){ 
   2402                       bBackFlag = TRUE;
   2403                     }
   2404                     evDataFromCOMM = FALSE;
   2405                   }
   2406              break;
   2407              case gERStateOverrideDirectReg_c:
   2408                   if(OverrideDirectRegisters()) {
   2409                       eRState = gERStateInit_c;
   2410                   }    
   2411              break;
   2412              case gERStateOverrideIndirectReg_c:
   2413                   if(OverrideIndirectRegisters()) {
   2414                       eRState = gERStateInit_c;
   2415                   }    
   2416              break;
   2417              case gERStateReadDirectReg_c:
   2418                   if(ReadDirectRegisters()) {
   2419                       eRState = gERStateInit_c;
   2420                   }    
   2421              break;
   2422              case gERStateReadIndirectReg_c:
   2423                   if(ReadIndirectRegisters()) {
   2424                       eRState = gERStateInit_c;
   2425                   }    
   2426              break;
   2427              default:
   2428              break;
   2429            }
   2430            return bBackFlag;
   2431          }
   2432          
   2433          
   2434          /**************************************************************************************/
   2435          bool_t OverrideDirectRegisters(void)
   2436          {
   2437            bool_t bBackFlag = FALSE;
   2438            static uint8_t au8RxString[5];
   2439            static uint8_t u8Index;
   2440            static uint8_t u8RegAddress;
   2441            static uint8_t u8RegValue;
   2442            
   2443            
   2444            switch(oDRState)
   2445            {
   2446              case gODRStateInit_c:
   2447                   CommUtil_Print("\f\r\nOverride Direct Registers\r\n", gAllowToBlock_d);
   2448                   CommUtil_Print("\r\n-Press [p] Previous Menu\r\n", gAllowToBlock_d);
   2449                   shortCutsEnabled = FALSE;   
   2450                   oDRState = gODRStateStart_c;
   2451              break;
   2452              case gODRStateStart_c:
   2453                   CommUtil_Print("\r\n -write the Register address in Hex and [enter]: 0x", gAllowToBlock_d);
   2454                   u8Index = 0;
   2455                   oDRState = gODRWaitForTheAddress_c; 
   2456              break;
   2457              case gODRWaitForTheAddress_c:
   2458                   if(evDataFromCOMM){
   2459                     if((!isAsciiHex(gu8CommData)) && ('\r' != gu8CommData)){
   2460                       if('p' == gu8CommData){ 
   2461                         bBackFlag = TRUE;
   2462                       }else{
   2463                         CommUtil_Print("\r\n -Invalid Character!! ", gAllowToBlock_d);
   2464                         oDRState = gODRStateStart_c;              
   2465                       }
   2466                     }else if((2 == u8Index) && ('\r' != gu8CommData)){ 
   2467                       CommUtil_Print("\r\n -Value out of Range!! ", gAllowToBlock_d);
   2468                       oDRState = gODRStateStart_c;
   2469                     }else if(isAsciiHex(gu8CommData)){
   2470                       au8RxString[u8Index++] = gu8CommData;
   2471                     }else{
   2472                       au8RxString[u8Index] = 0;
   2473                       u8RegAddress = HexString2Dec16(au8RxString);
   2474                       CommUtil_Print("\r\n -write the Register value to override in Hex and [enter]: 0x", gAllowToBlock_d);
   2475                       u8Index = 0;
   2476                       oDRState = gODRWaitForTheValue_c; 
   2477                     }
   2478                     evDataFromCOMM = FALSE;
   2479                   }
   2480              break;
   2481              case gODRWaitForTheValue_c:
   2482                   if(evDataFromCOMM){
   2483                     if((!isAsciiHex(gu8CommData)) && ('\r' != gu8CommData)){
   2484                       if('p' == gu8CommData){ 
   2485                         bBackFlag = TRUE;
   2486                       }else{
   2487                         CommUtil_Print("\r\n -Invalid Character!! ", gAllowToBlock_d);
   2488                         oDRState = gODRStateStart_c;              
   2489                       }
   2490                     }else if((2 == u8Index) && ('\r' != gu8CommData)){ 
   2491                       CommUtil_Print("\r\n -Value out of Range!! ", gAllowToBlock_d);
   2492                       oDRState = gODRStateStart_c;              
   2493                     }else if(isAsciiHex(gu8CommData)){
   2494                       au8RxString[u8Index++] = gu8CommData;
   2495                     }else{
   2496                       au8RxString[u8Index] = 0;
   2497                       u8RegValue = (uint8_t)(HexString2Dec16(au8RxString) & 0x00FF);
   2498                       MC1324xDrv_DirectAccessSPIWrite(u8RegAddress,u8RegValue);
   2499                       
   2500                       CommUtil_Print("\r\n Register overridden \r\n", gAllowToBlock_d);
   2501                       u8Index = 0;
   2502                       oDRState = gODRStateStart_c; 
   2503                     }
   2504                     evDataFromCOMM = FALSE;
   2505                   }
   2506              break;
   2507              default:
   2508              break;
   2509            }
   2510            return bBackFlag;  
   2511          }
   2512          
   2513          /**************************************************************************************/
   2514          bool_t OverrideIndirectRegisters(void)
   2515          {
   2516            bool_t bBackFlag = FALSE;
   2517            static uint8_t au8RxString[3];
   2518            static uint8_t u8Index;
   2519            static uint8_t u8RegAddress;
   2520            static uint8_t u8RegValue;
   2521            
   2522            
   2523            switch(oIRState)
   2524            {
   2525              case gOIRStateInit_c:
   2526                   CommUtil_Print("\f\r\nOverride Indirect Registers\r\n", gAllowToBlock_d);
   2527                   CommUtil_Print("\r\n-Press [p] Previous Menu\r\n", gAllowToBlock_d);
   2528                   shortCutsEnabled = FALSE;   
   2529                   oIRState = gOIRStateStart_c;
   2530              break;
   2531              case gOIRStateStart_c:
   2532                   CommUtil_Print("\r\n -write the Register address in Hex and [enter]: 0x", gAllowToBlock_d);
   2533                   u8Index = 0;
   2534                   oIRState = gOIRWaitForTheAddress_c; 
   2535              break;
   2536              case gOIRWaitForTheAddress_c:
   2537                   if(evDataFromCOMM){
   2538                     if((!isAsciiHex(gu8CommData)) && ('\r' != gu8CommData)){
   2539                       if('p' == gu8CommData){ 
   2540                         bBackFlag = TRUE;
   2541                       }else{
   2542                         CommUtil_Print("\r\n -Invalid Character!! ", gAllowToBlock_d);
   2543                         oIRState = gOIRStateStart_c;              
   2544                       }
   2545                     }else if((2 == u8Index) && ('\r' != gu8CommData)){ 
   2546                       CommUtil_Print("\r\n -Value out of Range!! ", gAllowToBlock_d);
   2547                       oIRState = gOIRStateStart_c;   
   2548                     }else if(isAsciiHex(gu8CommData)){
   2549                       au8RxString[u8Index++] = gu8CommData;
   2550                     }else{
   2551                       au8RxString[u8Index] = 0;
   2552                       u8RegAddress = (uint8_t)(HexString2Dec16(au8RxString) & 0x00FF);
   2553                       CommUtil_Print("\r\n -write the Register value to override in Hex and [enter]: 0x", gAllowToBlock_d);
   2554                       u8Index = 0;
   2555                       oIRState = gOIRWaitForTheValue_c; 
   2556                     }
   2557                     evDataFromCOMM = FALSE;
   2558                   }
   2559              break;
   2560              case gOIRWaitForTheValue_c:
   2561                   if(evDataFromCOMM)
   2562                   {
   2563                     if((!isAsciiHex(gu8CommData)) && ('\r' != gu8CommData)){
   2564                       if('p' == gu8CommData){ 
   2565                         bBackFlag = TRUE;
   2566                       }else{
   2567                         CommUtil_Print("\r\n -Invalid Character!! ", gAllowToBlock_d);
   2568                         oIRState = gOIRStateStart_c;              
   2569                       }
   2570                     }else if((2 == u8Index) && ('\r' != gu8CommData)){ 
   2571                       CommUtil_Print("\r\n -Value out of Range!! ", gAllowToBlock_d);
   2572                       bBackFlag = TRUE;
   2573                     }else if(isAsciiHex(gu8CommData)){
   2574                       au8RxString[u8Index++] = gu8CommData;
   2575                     }else{
   2576                       au8RxString[u8Index] = 0;
   2577                       u8RegValue = (uint8_t)(HexString2Dec16(au8RxString) & 0x00FF);
   2578                       MC1324xDrv_IndirectAccessSPIWrite(u8RegAddress, u8RegValue);
   2579                       CommUtil_Print("\r\n Register overridden \r\n", gAllowToBlock_d);
   2580                       u8Index = 0;
   2581                       oIRState = gOIRStateStart_c; 
   2582                     }
   2583                     evDataFromCOMM = FALSE;
   2584                   }
   2585              break;
   2586              default:
   2587              break;
   2588            }
   2589            return bBackFlag;  
   2590          }
   2591          
   2592          
   2593          /**************************************************************************************/
   2594          bool_t ReadDirectRegisters(void)
   2595          {
   2596            bool_t bBackFlag = FALSE;
   2597            static uint8_t au8RxString[5];
   2598            static uint8_t u8Index;
   2599            static uint8_t u8RegAddress;
   2600            static uint8_t u8RegValue;
   2601            
   2602            switch(rDRState)
   2603            {
   2604              case gRDRStateInit_c:
   2605                   CommUtil_Print("\f\r\rRead Direct Registers\r\n", gAllowToBlock_d);
   2606                   CommUtil_Print("\r\n-Press [p] Previous Menu\r\n", gAllowToBlock_d);
   2607                   shortCutsEnabled = FALSE;   
   2608                   rDRState = gRDRStateStart_c;
   2609              break;
   2610              case gRDRStateStart_c:
   2611                   CommUtil_Print("\r\n -write the Register address in Hex and [enter]: 0x", gAllowToBlock_d);
   2612                   u8Index = 0;
   2613                   rDRState = gRDRWaitForTheAddress_c; 
   2614              break;
   2615              case gRDRWaitForTheAddress_c:
   2616                   if(evDataFromCOMM){
   2617                     if((!isAsciiHex(gu8CommData)) && ('\r' != gu8CommData)){
   2618                       if('p' == gu8CommData){ 
   2619                         bBackFlag = TRUE;
   2620                       }else{
   2621                         CommUtil_Print("\r\n -Invalid Character!! ", gAllowToBlock_d);
   2622                         rDRState = gRDRStateStart_c;              
   2623                       }
   2624                     }else if((2 == u8Index) && ('\r' != gu8CommData)){ 
   2625                       CommUtil_Print("\r\n -Value out of Range!! ", gAllowToBlock_d);
   2626                       rDRState = gRDRStateStart_c;
   2627                     }else if(isAsciiHex(gu8CommData)){
   2628                       au8RxString[u8Index++] = gu8CommData;
   2629                     }else{
   2630                       au8RxString[u8Index] = 0;
   2631                       u8RegAddress = HexString2Dec16(au8RxString);
   2632                       u8RegValue = MC1324xDrv_DirectAccessSPIRead(u8RegAddress);
   2633                       
   2634                       CommUtil_Print("\r\n -Register value : 0x", gAllowToBlock_d);
   2635                       PrintByteOnHexFormatBlocking(u8RegValue,FALSE, gDefaultCommPort_c);
   2636                       CommUtil_Print("\r\n", gAllowToBlock_d);
   2637                       
   2638                       rDRState = gRDRStateStart_c; 
   2639                     }
   2640                     evDataFromCOMM = FALSE;
   2641                   }
   2642              break;
   2643              default:
   2644              break;
   2645            }
   2646            return bBackFlag;  
   2647          }
   2648          
   2649          /**************************************************************************************/
   2650          bool_t ReadIndirectRegisters(void)
   2651          {
   2652            bool_t bBackFlag = FALSE;
   2653            static uint8_t au8RxString[5];
   2654            static uint8_t u8Index;
   2655            static uint8_t u8RegAddress;
   2656            static uint8_t u8RegValue;
   2657            
   2658            switch(rIRState)
   2659            {
   2660              case gRIRStateInit_c:
   2661                   CommUtil_Print("\f\r\rRead Indirect Registers\r\n", gAllowToBlock_d);
   2662                   CommUtil_Print("\r\n-Press [p] Previous Menu\r\n", gAllowToBlock_d);
   2663                   shortCutsEnabled = FALSE;   
   2664                   rIRState = gRIRStateStart_c;
   2665              break;
   2666              case gRIRStateStart_c:
   2667                   CommUtil_Print("\r\n -write the Register address in Hex and [enter]: 0x", gAllowToBlock_d);
   2668                   u8Index = 0;
   2669                   rIRState = gRIRWaitForTheAddress_c; 
   2670              break;
   2671              case gRIRWaitForTheAddress_c:
   2672                   if(evDataFromCOMM){
   2673                     if((!isAsciiHex(gu8CommData)) && ('\r' != gu8CommData))
   2674                     {
   2675                       if('p' == gu8CommData){ 
   2676                         bBackFlag = TRUE;
   2677                       }else{
   2678                         CommUtil_Print("\r\n -Invalid Character!! ", gAllowToBlock_d);
   2679                         rIRState = gRIRStateStart_c;              
   2680                       }
   2681                     }else if((2 == u8Index) && ('\r' != gu8CommData)){ 
   2682                       CommUtil_Print("\r\n -Value out of Range!! ", gAllowToBlock_d);
   2683                       rIRState = gRIRStateStart_c; 
   2684                     }else if(isAsciiHex(gu8CommData)){
   2685                       au8RxString[u8Index++] = gu8CommData;
   2686                     }else{
   2687                       au8RxString[u8Index] = 0;
   2688                       u8RegAddress = (uint8_t)(HexString2Dec16(au8RxString) & 0x00FF);
   2689                       u8RegValue = MC1324xDrv_IndirectAccessSPIRead(u8RegAddress);
   2690                       
   2691                       CommUtil_Print("\r\n -Register value : 0x", gAllowToBlock_d);
   2692                       PrintByteOnHexFormatBlocking(u8RegValue, FALSE, gDefaultCommPort_c);
   2693                       CommUtil_Print("\r\n", gAllowToBlock_d);
   2694                       rIRState = gRIRStateStart_c; 
   2695                     }
   2696                     evDataFromCOMM = FALSE;
   2697                   }
   2698              break;
   2699              default:
   2700              break;
   2701            }
   2702            return bBackFlag;  
   2703          } 
   2704          
   2705          /**************************************************************************************/
   2706          void PrintTestParameters(bool_t bEraseLine)
   2707          {
   2708            uint8_t u8lineLen = 63;
   2709            uint8_t u8Index;
   2710           
   2711            if(bEraseLine)
   2712            {
   2713              for(u8Index = 0;u8Index<u8lineLen;u8Index++)
   2714              {
   2715                CommUtil_Print("\b", gAllowToBlock_d);
   2716              }
   2717            }
   2718            
   2719            CommUtil_Print("Mode ", gAllowToBlock_d);
   2720            if(mTxOperation_c == testOpMode){
   2721              CommUtil_Print("Tx", gAllowToBlock_d);
   2722            }else{
   2723              CommUtil_Print("Rx", gAllowToBlock_d);
   2724            }
   2725            CommUtil_Print(", Channel ", gAllowToBlock_d);
   2726            PrintWordOnDecimalFormatBlocking((uint16_t)testChannel,2, FALSE, gDefaultCommPort_c);
   2727            CommUtil_Print(", Power ", gAllowToBlock_d);
   2728            PrintWordOnDecimalFormatBlocking((uint16_t)testPower,2, FALSE, gDefaultCommPort_c);
   2729            CommUtil_Print(", Crystal Trim ", gAllowToBlock_d);
   2730            PrintWordOnDecimalFormatBlocking((uint16_t)testTrimmValue,3, FALSE, gDefaultCommPort_c);
   2731            CommUtil_Print(", Payload ", gAllowToBlock_d);
   2732            PrintWordOnDecimalFormatBlocking((uint16_t)testPayloadLen,3, FALSE, gDefaultCommPort_c);
   2733            CommUtil_Print(" >", gAllowToBlock_d);
   2734          }
   2735          
   2736          /**************************************************************************************/
   2737          void SetRadioRxOnTimeOut15ms(void)
   2738          {
   2739            bRxDone = FALSE;
   2740            gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
   2741            smacErrors_t status = MLMERXEnableRequest(gAppRxPacket, 45000);
   2742            while(status!=gErrorNoError_c){
   2743              status = MLMERXEnableRequest(gAppRxPacket, 45000);
   2744            }
   2745          }
   2746          
   2747          /**************************************************************************************/
   2748          void SetRadioRxOnNoTimeOut(void)
   2749          {
   2750            bRxDone = FALSE;
   2751            gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
   2752            (void)MLMERXEnableRequest(gAppRxPacket, 0);
   2753          }
   2754          
   2755          /**************************************************************************************/
   2756          void PrintPerRxFinalLine(uint16_t u16Received, uint16_t u16Total)
   2757          {
   2758            CommUtil_Print("Received ", gAllowToBlock_d);
   2759            PrintWordOnDecimalFormatBlocking(u16Received, 2, FALSE, gDefaultCommPort_c);
   2760            CommUtil_Print(" of ", gAllowToBlock_d);
   2761            PrintWordOnDecimalFormatBlocking(u16Total, 2, FALSE, gDefaultCommPort_c);
   2762            CommUtil_Print(" packets transmitted \r\n", gAllowToBlock_d);
   2763            CommUtil_Print("\r\n Press [enter] to go back to the Per Rx test menu", gAllowToBlock_d);
   2764          }
   2765          
   2766          
   2767          /************************************************************************************
   2768          * User's Callbacks
   2769          ************************************************************************************/
   2770          
   2771          /* Place your callbacks here */
   2772          
   2773          
   2774          /************************************************************************************
   2775          * CommTxCallback
   2776          * 
   2777          *
   2778          *
   2779          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2780          void CommTxCallback(void)
   2781          {
   2782              bCommTxDone = TRUE;  
   \                     CommTxCallback: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x....             LDR.N    R1,??DataTable36_93
   \   00000004   0x7008             STRB     R0,[R1, #+0]
   2783          }
   \   00000006   0x4770             BX       LR               ;; return
   2784          
   2785          /************************************************************************************
   2786          * CommRxCallback
   2787          * 
   2788          *
   2789          *
   2790          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2791          void CommRxCallback()
   2792          {
   \                     CommRxCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2793              Comm_GetByteFromRxBuffer(&gu8CommData);
   \   00000002   0x....             LDR.N    R0,??DataTable36_94
   \   00000004   0x.... 0x....      BL       Uart1_GetByteFromRxBuffer
   2794              if(shortCutsEnabled){
   \   00000008   0x....             LDR.N    R0,??DataTable36_30
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD004             BEQ.N    ??CommRxCallback_0
   2795                ShortCutsParser(gu8CommData);  
   \   00000010   0x....             LDR.N    R0,??DataTable36_94
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x.... 0x....      BL       ShortCutsParser
   \   00000018   0xE002             B.N      ??CommRxCallback_1
   2796              }else{
   2797                evDataFromCOMM = TRUE;
   \                     ??CommRxCallback_0: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x....             LDR.N    R1,??DataTable36_1
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
   2798              }
   2799          }
   \                     ??CommRxCallback_1: (+1)
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
   2800          
   2801          
   2802          /************************************************************************************
   2803          * SMAC Callbacks
   2804          ************************************************************************************/
   2805          
   2806          /************************************************************************************
   2807          * MCPSDataConfirm
   2808          * 
   2809          *
   2810          *
   2811          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2812          void MCPSDataConfirm(txStatus_t TransmissionResult)
   2813          {  
   2814              bTxDone = TRUE;
   \                     MCPSDataConfirm: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x....             LDR.N    R2,??DataTable36_95
   \   00000004   0x7011             STRB     R1,[R2, #+0]
   2815          }
   \   00000006   0x4770             BX       LR               ;; return
   2816           
   2817          
   2818          /************************************************************************************
   2819          * MCPSDataIndication
   2820          * 
   2821          *
   2822          *
   2823          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2824          void MCPSDataIndication(rxPacket_t *gsRxPacket)
   2825          {  
   2826            bRxDone = TRUE;
   \                     MCPSDataIndication: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x....             LDR.N    R2,??DataTable36_96
   \   00000004   0x7011             STRB     R1,[R2, #+0]
   2827            appState=RECEIVE_FINISHED;
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x....             LDR.N    R2,??DataTable36
   \   0000000A   0x7011             STRB     R1,[R2, #+0]
   2828          }
   \   0000000C   0x4770             BX       LR               ;; return
   2829          
   2830          
   2831          /************************************************************************************
   2832          * MLMEScanConfirm
   2833          * 
   2834          *
   2835          *
   2836          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2837          void MLMEScanConfirm(channels_t ClearestChann)
   2838          {
   2839            bestChannel = ClearestChann; 
   \                     MLMEScanConfirm: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable36_97
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   2840            bScanDone = TRUE;
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x....             LDR.N    R2,??DataTable36_98
   \   00000008   0x7011             STRB     R1,[R2, #+0]
   2841          }
   \   0000000A   0x4770             BX       LR               ;; return
   2842          
   2843          /************************************************************************************
   2844          * MLMEResetIndication
   2845          * 
   2846          *
   2847          *
   2848          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2849          void MLMEResetIndication(void)
   2850          {
   2851            
   2852          }
   \                     MLMEResetIndication: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2853          
   2854          /************************************************************************************
   2855          * MLMEWakeConfirm
   2856          * 
   2857          *
   2858          *
   2859          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2860          void MLMEWakeConfirm(void)
   2861          {
   2862            
   2863          }
   \                     MLMEWakeConfirm: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2864          
   2865          /**************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2866          void ShortCutsParser(uint8_t u8CommData)
   2867          {
   2868            evTestParameters = TRUE;
   \                     ShortCutsParser: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x....             LDR.N    R2,??DataTable36_99
   \   00000004   0x7011             STRB     R1,[R2, #+0]
   2869            evDataFromCOMM = FALSE;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x....             LDR.N    R2,??DataTable36_1
   \   0000000A   0x7011             STRB     R1,[R2, #+0]
   2870            switch(u8CommData){
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x0001             MOVS     R1,R0
   \   00000010   0x2961             CMP      R1,#+97
   \   00000012   0xD034             BEQ.N    ??ShortCutsParser_0
   \   00000014   0x296D             CMP      R1,#+109
   \   00000016   0xD065             BEQ.N    ??ShortCutsParser_1
   \   00000018   0x296E             CMP      R1,#+110
   \   0000001A   0xD056             BEQ.N    ??ShortCutsParser_2
   \   0000001C   0x2971             CMP      R1,#+113
   \   0000001E   0xD014             BEQ.N    ??ShortCutsParser_3
   \   00000020   0x2972             CMP      R1,#+114
   \   00000022   0xD00E             BEQ.N    ??ShortCutsParser_4
   \   00000024   0x2973             CMP      R1,#+115
   \   00000026   0xD037             BEQ.N    ??ShortCutsParser_5
   \   00000028   0x2974             CMP      R1,#+116
   \   0000002A   0xD006             BEQ.N    ??ShortCutsParser_6
   \   0000002C   0x2977             CMP      R1,#+119
   \   0000002E   0xD019             BEQ.N    ??ShortCutsParser_7
   \   00000030   0x2978             CMP      R1,#+120
   \   00000032   0xD044             BEQ.N    ??ShortCutsParser_8
   \   00000034   0x297A             CMP      R1,#+122
   \   00000036   0xD03C             BEQ.N    ??ShortCutsParser_9
   \   00000038   0xE061             B.N      ??ShortCutsParser_10
   2871              case 't':
   2872                testOpMode = mTxOperation_c;
   \                     ??ShortCutsParser_6: (+1)
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x....             LDR.N    R2,??DataTable36_24
   \   0000003E   0x7011             STRB     R1,[R2, #+0]
   2873              break;
   \   00000040   0xE063             B.N      ??ShortCutsParser_11
   2874              case 'r':
   2875                testOpMode = mRxOperation_c;
   \                     ??ShortCutsParser_4: (+1)
   \   00000042   0x2101             MOVS     R1,#+1
   \   00000044   0x....             LDR.N    R2,??DataTable36_24
   \   00000046   0x7011             STRB     R1,[R2, #+0]
   2876              break;
   \   00000048   0xE05F             B.N      ??ShortCutsParser_11
   2877              case 'q': 
   2878                testChannel++;
   \                     ??ShortCutsParser_3: (+1)
   \   0000004A   0x....             LDR.N    R1,??DataTable36_25
   \   0000004C   0x7809             LDRB     R1,[R1, #+0]
   \   0000004E   0x1C49             ADDS     R1,R1,#+1
   \   00000050   0x....             LDR.N    R2,??DataTable36_25
   \   00000052   0x7011             STRB     R1,[R2, #+0]
   2879                if(gChannel26_c < testChannel){
   \   00000054   0x....             LDR.N    R1,??DataTable36_25
   \   00000056   0x7809             LDRB     R1,[R1, #+0]
   \   00000058   0x291B             CMP      R1,#+27
   \   0000005A   0xDB02             BLT.N    ??ShortCutsParser_12
   2880                  testChannel = gChannel11_c;
   \   0000005C   0x210B             MOVS     R1,#+11
   \   0000005E   0x....             LDR.N    R2,??DataTable36_25
   \   00000060   0x7011             STRB     R1,[R2, #+0]
   2881                }
   2882              break;
   \                     ??ShortCutsParser_12: (+1)
   \   00000062   0xE052             B.N      ??ShortCutsParser_11
   2883              case 'w':
   2884                testChannel--;
   \                     ??ShortCutsParser_7: (+1)
   \   00000064   0x....             LDR.N    R1,??DataTable36_25
   \   00000066   0x7809             LDRB     R1,[R1, #+0]
   \   00000068   0x1E49             SUBS     R1,R1,#+1
   \   0000006A   0x....             LDR.N    R2,??DataTable36_25
   \   0000006C   0x7011             STRB     R1,[R2, #+0]
   2885                if(gChannel11_c > testChannel){
   \   0000006E   0x....             LDR.N    R1,??DataTable36_25
   \   00000070   0x7809             LDRB     R1,[R1, #+0]
   \   00000072   0x290B             CMP      R1,#+11
   \   00000074   0xDA02             BGE.N    ??ShortCutsParser_13
   2886                  testChannel = gChannel26_c;
   \   00000076   0x211A             MOVS     R1,#+26
   \   00000078   0x....             LDR.N    R2,??DataTable36_25
   \   0000007A   0x7011             STRB     R1,[R2, #+0]
   2887                }
   2888              break;
   \                     ??ShortCutsParser_13: (+1)
   \   0000007C   0xE045             B.N      ??ShortCutsParser_11
   2889              case 'a':
   2890                testPower++;
   \                     ??ShortCutsParser_0: (+1)
   \   0000007E   0x....             LDR.N    R1,??DataTable36_26
   \   00000080   0x7809             LDRB     R1,[R1, #+0]
   \   00000082   0x1C49             ADDS     R1,R1,#+1
   \   00000084   0x....             LDR.N    R2,??DataTable36_26
   \   00000086   0x7011             STRB     R1,[R2, #+0]
   2891                if(gMaxOutputPower_c < testPower){
   \   00000088   0x....             LDR.N    R1,??DataTable36_26
   \   0000008A   0x7809             LDRB     R1,[R1, #+0]
   \   0000008C   0x2920             CMP      R1,#+32
   \   0000008E   0xDB02             BLT.N    ??ShortCutsParser_14
   2892                  testPower = gMinOutputPower_c;
   \   00000090   0x2103             MOVS     R1,#+3
   \   00000092   0x....             LDR.N    R2,??DataTable36_26
   \   00000094   0x7011             STRB     R1,[R2, #+0]
   2893                }
   2894              break;
   \                     ??ShortCutsParser_14: (+1)
   \   00000096   0xE038             B.N      ??ShortCutsParser_11
   2895              case 's':
   2896                testPower--;
   \                     ??ShortCutsParser_5: (+1)
   \   00000098   0x....             LDR.N    R1,??DataTable36_26
   \   0000009A   0x7809             LDRB     R1,[R1, #+0]
   \   0000009C   0x1E49             SUBS     R1,R1,#+1
   \   0000009E   0x....             LDR.N    R2,??DataTable36_26
   \   000000A0   0x7011             STRB     R1,[R2, #+0]
   2897                if(gMinOutputPower_c > testPower){
   \   000000A2   0x....             LDR.N    R1,??DataTable36_26
   \   000000A4   0x7809             LDRB     R1,[R1, #+0]
   \   000000A6   0x2903             CMP      R1,#+3
   \   000000A8   0xDA02             BGE.N    ??ShortCutsParser_15
   2898                  testPower = gMaxOutputPower_c;
   \   000000AA   0x211F             MOVS     R1,#+31
   \   000000AC   0x....             LDR.N    R2,??DataTable36_26
   \   000000AE   0x7011             STRB     R1,[R2, #+0]
   2899                }
   2900              break;
   \                     ??ShortCutsParser_15: (+1)
   \   000000B0   0xE02B             B.N      ??ShortCutsParser_11
   2901              case 'z':
   2902                testTrimmValue++;
   \                     ??ShortCutsParser_9: (+1)
   \   000000B2   0x....             LDR.N    R1,??DataTable36_27
   \   000000B4   0x7809             LDRB     R1,[R1, #+0]
   \   000000B6   0x1C49             ADDS     R1,R1,#+1
   \   000000B8   0x....             LDR.N    R2,??DataTable36_27
   \   000000BA   0x7011             STRB     R1,[R2, #+0]
   2903              break;
   \   000000BC   0xE025             B.N      ??ShortCutsParser_11
   2904              case 'x':
   2905                testTrimmValue--;
   \                     ??ShortCutsParser_8: (+1)
   \   000000BE   0x....             LDR.N    R1,??DataTable36_27
   \   000000C0   0x7809             LDRB     R1,[R1, #+0]
   \   000000C2   0x1E49             SUBS     R1,R1,#+1
   \   000000C4   0x....             LDR.N    R2,??DataTable36_27
   \   000000C6   0x7011             STRB     R1,[R2, #+0]
   2906              break;
   \   000000C8   0xE01F             B.N      ??ShortCutsParser_11
   2907              case 'n':
   2908                testPayloadLen++;
   \                     ??ShortCutsParser_2: (+1)
   \   000000CA   0x....             LDR.N    R1,??DataTable36_28
   \   000000CC   0x7809             LDRB     R1,[R1, #+0]
   \   000000CE   0x1C49             ADDS     R1,R1,#+1
   \   000000D0   0x....             LDR.N    R2,??DataTable36_28
   \   000000D2   0x7011             STRB     R1,[R2, #+0]
   2909                if(gMaxSmacSDULength_c < testPayloadLen){
   \   000000D4   0x....             LDR.N    R1,??DataTable36_28
   \   000000D6   0x7809             LDRB     R1,[R1, #+0]
   \   000000D8   0x297C             CMP      R1,#+124
   \   000000DA   0xDB02             BLT.N    ??ShortCutsParser_16
   2910                  testPayloadLen = 1;
   \   000000DC   0x2101             MOVS     R1,#+1
   \   000000DE   0x....             LDR.N    R2,??DataTable36_28
   \   000000E0   0x7011             STRB     R1,[R2, #+0]
   2911                }    
   2912              break;
   \                     ??ShortCutsParser_16: (+1)
   \   000000E2   0xE012             B.N      ??ShortCutsParser_11
   2913              case 'm':
   2914                testPayloadLen--;
   \                     ??ShortCutsParser_1: (+1)
   \   000000E4   0x....             LDR.N    R1,??DataTable36_28
   \   000000E6   0x7809             LDRB     R1,[R1, #+0]
   \   000000E8   0x1E49             SUBS     R1,R1,#+1
   \   000000EA   0x....             LDR.N    R2,??DataTable36_28
   \   000000EC   0x7011             STRB     R1,[R2, #+0]
   2915                if(1 > testPayloadLen){
   \   000000EE   0x....             LDR.N    R1,??DataTable36_28
   \   000000F0   0x7809             LDRB     R1,[R1, #+0]
   \   000000F2   0x2900             CMP      R1,#+0
   \   000000F4   0xD102             BNE.N    ??ShortCutsParser_17
   2916                  testPayloadLen = gMaxSmacSDULength_c;
   \   000000F6   0x217B             MOVS     R1,#+123
   \   000000F8   0x....             LDR.N    R2,??DataTable36_28
   \   000000FA   0x7011             STRB     R1,[R2, #+0]
   2917                }    
   2918              break;
   \                     ??ShortCutsParser_17: (+1)
   \   000000FC   0xE005             B.N      ??ShortCutsParser_11
   2919              default:
   2920                evDataFromCOMM = TRUE;
   \                     ??ShortCutsParser_10: (+1)
   \   000000FE   0x2101             MOVS     R1,#+1
   \   00000100   0x....             LDR.N    R2,??DataTable36_1
   \   00000102   0x7011             STRB     R1,[R2, #+0]
   2921                evTestParameters = FALSE;
   \   00000104   0x2100             MOVS     R1,#+0
   \   00000106   0x....             LDR.N    R2,??DataTable36_99
   \   00000108   0x7011             STRB     R1,[R2, #+0]
   2922              break;
   2923            }
   2924          }
   \                     ??ShortCutsParser_11: (+1)
   \   0000010A   0x4770             BX       LR               ;; return
   2925          
   2926          
   2927          /************************************************************************************
   2928          *
   2929          * AppTimerCallback
   2930          *
   2931          ************************************************************************************/
   2932          

   \                                 In section .text, align 2, keep-with-next
   2933          void AppLedTimerCallback (tmrTimerID_t timerId)
   2934          {
   \                     AppLedTimerCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2935            (void)timerId;  /* prevent compiler warning */
   2936              LED_StopFlashingAllLeds();
   \   00000004   0x.... 0x....      BL       LED_StopFlashingAllLeds
   2937              //LED_TurnOffAllLeds();
   2938          }
   \   00000008   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x400FF0C8         DC32     0x400ff0c8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     TempSumx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     TempSumy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     TempSumz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     AXIS

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x........         DC32     PIT_ITTERATIONS

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x........         DC32     connState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x........         DC32     testTrimmValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x........         DC32     sentPackets

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x400FF0C4         DC32     0x400ff0c4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     sensorID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     appState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x........         DC32     evDataFromCOMM

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     gSnd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x........         DC32     gOptions

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x........         DC32     gIsAck

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x........         DC32     gAppRxPacket

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x........         DC32     LowPowerEntered

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x........         DC32     gOpt+0x8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x........         DC32     gOpt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0x........         DC32     gLPConfigState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   0x........         DC32     bGotoLowPwrFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   0x........         DC32     gLastLPConfigState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   0x........         DC32     pu8GotoLowPowerString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   0x........         DC32     cau8WUContinueAskString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \   00000000   0x........         DC32     pu8NowInLowPowerString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \   00000000   0x........         DC32     pu8WakeupSourceString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x400FF0D4         DC32     0x400ff0d4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x00028488         DC32     0x28488

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x........         DC32     AppLedTimerCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x........         DC32     mLEDInterval1_c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x........         DC32     mLEDTimerID_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0x........         DC32     cau8WUInvalidValueString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   0x........         DC32     cau8WUWait4Option

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   0x40048038         DC32     0x40048038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \   00000000   0x4004C004         DC32     0x4004c004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_9:
   \   00000000   0x4004C014         DC32     0x4004c014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x........         DC32     gRxTimeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     gAppTxPacket

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x00014BAD         DC32     0x14bad

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \   00000000   0x40037000         DC32     0x40037000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_5:
   \   00000000   0x40037100         DC32     0x40037100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_6:
   \   00000000   0x40037108         DC32     0x40037108

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     gSnd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     gConfigState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x400FF0C0         DC32     0x400ff0c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x1FFF9200         DC32     0x1fff9200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x1FFF80F1         DC32     0x1fff80f1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x4003710C         DC32     0x4003710c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x........         DC32     ??b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_2:
   \   00000000   0x........         DC32     gAppTxPacket

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x........         DC32     gIsMyAck

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \   00000000   0x........         DC32     gPng

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_2:
   \   00000000   0x........         DC32     gPng+0x1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_3:
   \   00000000   0x........         DC32     gPng+0x2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_4:
   \   00000000   0x........         DC32     gPng+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_5:
   \   00000000   0x........         DC32     gSnd+0x1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_6:
   \   00000000   0x........         DC32     gSnd+0x2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_7:
   \   00000000   0x........         DC32     gSnd+0x3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_8:
   \   00000000   0x........         DC32     gSnd+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_9:
   \   00000000   0x........         DC32     gSnd+0x6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_10:
   \   00000000   0x........         DC32     gSnd+0x8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_11:
   \   00000000   0x........         DC32     gSnd+0xA

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_12:
   \   00000000   0x........         DC32     gSnd+0xC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_13:
   \   00000000   0x........         DC32     gSnd+0x10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_14:
   \   00000000   0x........         DC32     gSnd+0x14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_15:
   \   00000000   0x........         DC32     gSnd+0x18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_16:
   \   00000000   0x........         DC32     gSnd+0x1A

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_17:
   \   00000000   0x........         DC32     gSnd+0x1C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_18:
   \   00000000   0x........         DC32     gSnd+0x20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_19:
   \   00000000   0x........         DC32     gSnd+0x24

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_20:
   \   00000000   0x........         DC32     gSnd+0x28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_21:
   \   00000000   0x........         DC32     gSnd+0x2A

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_22:
   \   00000000   0x........         DC32     gSnd+0x2C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_23:
   \   00000000   0x........         DC32     gSnd+0x30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_24:
   \   00000000   0x........         DC32     gSnd+0x34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_25:
   \   00000000   0x........         DC32     gSnd+0x38

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_26:
   \   00000000   0x........         DC32     gSnd+0x3A

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_27:
   \   00000000   0x........         DC32     gSnd+0x3C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_28:
   \   00000000   0x........         DC32     gSnd+0x3E

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_29:
   \   00000000   0x........         DC32     gSnd+0x40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_30:
   \   00000000   0x........         DC32     gSnd+0x42

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_31:
   \   00000000   0x........         DC32     gSnd+0x43

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_32:
   \   00000000   0x........         DC32     gSnd+0x44

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_33:
   \   00000000   0x........         DC32     gOpt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   0x........         DC32     gOpt+0x1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_1:
   \   00000000   0x........         DC32     gOpt+0x2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_2:
   \   00000000   0x........         DC32     gOpt+0x3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_3:
   \   00000000   0x........         DC32     gOpt+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_4:
   \   00000000   0x........         DC32     gOpt+0x8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_5:
   \   00000000   0x........         DC32     gOpt+0xA

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_6:
   \   00000000   0x........         DC32     gOpt+0xC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_7:
   \   00000000   0x........         DC32     gOpt+0xE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_8:
   \   00000000   0x........         DC32     gOpt+0xF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_9:
   \   00000000   0x........         DC32     gOpt+0x10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_10:
   \   00000000   0x........         DC32     gOpt+0x14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_11:
   \   00000000   0x........         DC32     gOpt+0x18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_12:
   \   00000000   0x........         DC32     gOpt+0x1C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_13:
   \   00000000   0x........         DC32     gOpt+0x1E

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_14:
   \   00000000   0x........         DC32     sentPackets

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_15:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_16:
   \   00000000   0x........         DC32     gAppTxPacket

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_17:
   \   00000000   0x........         DC32     gSnd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_18:
   \   00000000   0x........         DC32     sensorID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_19:
   \   00000000   0x0010F447         DC32     0x10f447

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_20:
   \   00000000   0x0021E88E         DC32     0x21e88e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_21:
   \   00000000   0x0032DCD5         DC32     0x32dcd5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x069F6BC7         DC32     0x69f6bc7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \   00000000   0x0D3ED78E         DC32     0xd3ed78e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_1:
   \   00000000   0x13DE4355         DC32     0x13de4355

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_1:
   \   00000000   0x........         DC32     g_DEAD_BEEF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_2:
   \   00000000   0x........         DC32     gFlashDeadBeef

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_3:
   \   00000000   0x........         DC32     settingsAddress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_4:
   \   00000000   0x........         DC32     cau8WULPTMRWakeupString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_5:
   \   00000000   0x........         DC32     cau8WUGotoVLLS1String

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_6:
   \   00000000   0x........         DC32     pu8GotoLowPowerString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_7:
   \   00000000   0x........         DC32     cau8WUIsVLLS1ModeString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_8:
   \   00000000   0x........         DC32     pu8NowInLowPowerString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36:
   \   00000000   0x........         DC32     appState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_1:
   \   00000000   0x........         DC32     evDataFromCOMM

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_2:
   \   00000000   0x........         DC32     gOptions

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_3:
   \   00000000   0x00028488         DC32     0x28488

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_4:
   \   00000000   0x........         DC32     pu8WakeupSourceString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_5:
   \   00000000   0x4007E000         DC32     0x4007e000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_6:
   \   00000000   0x........         DC32     gLPConfigState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_7:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_8:
   \   00000000   0x........         DC32     ??sDeadBeef

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_9:
   \   00000000   0x........         DC32     maMmPools

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_10:
   \   00000000   0x........         DC32     poolInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_11:
   \   00000000   0x........         DC32     maMacHeap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_12:
   \   00000000   0x........         DC32     CommRxCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_13:
   \   00000000   0x........         DC32     mLEDTimerID_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_14:
   \   00000000   0x........         DC32     mBufferTimerID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_15:
   \   00000000   0x........         DC32     gConfigState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_16:
   \   00000000   0x........         DC32     u8SequencePointerCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_17:
   \   00000000   0x........         DC32     bReturnToMainMenuFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_18:
   \   00000000   0x........         DC32     cau8WUVLLS1String

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_19:
   \   00000000   0x........         DC32     pu8MainLowPowerString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_20:
   \   00000000   0x........         DC32     cau8WULPTMRString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_21:
   \   00000000   0x........         DC32     pu8MainWakeupSourceString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_22:
   \   00000000   0x........         DC32     bTxOtaBusyFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_23:
   \   00000000   0x........         DC32     bCommGetDataTimerFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_24:
   \   00000000   0x........         DC32     testOpMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_25:
   \   00000000   0x........         DC32     testChannel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_26:
   \   00000000   0x........         DC32     testPower

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_27:
   \   00000000   0x........         DC32     testTrimmValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_28:
   \   00000000   0x........         DC32     testPayloadLen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_29:
   \   00000000   0x........         DC32     contTestRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_30:
   \   00000000   0x........         DC32     shortCutsEnabled

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_31:
   \   00000000   0x........         DC32     connState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_32:
   \   00000000   0x........         DC32     cTxRxState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_33:
   \   00000000   0x........         DC32     perTxState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_34:
   \   00000000   0x........         DC32     perRxState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_35:
   \   00000000   0x........         DC32     rangeTxState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_36:
   \   00000000   0x........         DC32     rangeRxState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_37:
   \   00000000   0x........         DC32     prevOpMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_38:
   \   00000000   0x........         DC32     txTestIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_39:
   \   00000000   0x........         DC32     rxTestIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_40:
   \   00000000   0x........         DC32     gau8TxDataBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_41:
   \   00000000   0x........         DC32     gau8RxDataBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_42:
   \   00000000   0x........         DC32     gAppRxPacket

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_43:
   \   00000000   0x40049000         DC32     0x40049000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_44:
   \   00000000   0x........         DC32     u32PortAPCRBackup

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_45:
   \   00000000   0x40049004         DC32     0x40049004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_46:
   \   00000000   0x40049008         DC32     0x40049008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_47:
   \   00000000   0x4004900C         DC32     0x4004900c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_48:
   \   00000000   0x40049010         DC32     0x40049010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_49:
   \   00000000   0x4004A028         DC32     0x4004a028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_50:
   \   00000000   0x........         DC32     u32PortBPCRBackup

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_51:
   \   00000000   0x4004A02C         DC32     0x4004a02c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_52:
   \   00000000   0x4004A040         DC32     0x4004a040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_53:
   \   00000000   0x4004A044         DC32     0x4004a044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_54:
   \   00000000   0x4004B010         DC32     0x4004b010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_55:
   \   00000000   0x........         DC32     u32PortCPCRBackup

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_56:
   \   00000000   0x4004B014         DC32     0x4004b014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_57:
   \   00000000   0x4004B018         DC32     0x4004b018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_58:
   \   00000000   0x4004B01C         DC32     0x4004b01c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_59:
   \   00000000   0x4004D000         DC32     0x4004d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_60:
   \   00000000   0x........         DC32     u32PortEPCRBackup

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_61:
   \   00000000   0x4004D004         DC32     0x4004d004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_62:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_63:
   \   00000000   0x........         DC32     u32SCGCxBackup

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_64:
   \   00000000   0x40048038         DC32     0x40048038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_65:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_66:
   \   00000000   0x40048040         DC32     0x40048040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_67:
   \   00000000   0x400FF000         DC32     0x400ff000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_68:
   \   00000000   0x........         DC32     u32GPIOs_PDORBackup

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_69:
   \   00000000   0x400FF040         DC32     0x400ff040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_70:
   \   00000000   0x400FF080         DC32     0x400ff080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_71:
   \   00000000   0x400FF0C0         DC32     0x400ff0c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_72:
   \   00000000   0x400FF100         DC32     0x400ff100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_73:
   \   00000000   0x400FF014         DC32     0x400ff014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_74:
   \   00000000   0x........         DC32     u32GPIOs_PDDRBackup

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_75:
   \   00000000   0x400FF054         DC32     0x400ff054

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_76:
   \   00000000   0x400FF094         DC32     0x400ff094

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_77:
   \   00000000   0x400FF0D4         DC32     0x400ff0d4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_78:
   \   00000000   0x400FF114         DC32     0x400ff114

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_79:
   \   00000000   0x4004B000         DC32     0x4004b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_80:
   \   00000000   0x4004B004         DC32     0x4004b004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_81:
   \   00000000   0x4004B00C         DC32     0x4004b00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_82:
   \   00000000   0x4004C00C         DC32     0x4004c00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_83:
   \   00000000   0x4004C010         DC32     0x4004c010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_84:
   \   00000000   0x400FF008         DC32     0x400ff008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_85:
   \   00000000   0x400FF088         DC32     0x400ff088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_86:
   \   00000000   0x4007D000         DC32     0x4007d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_87:
   \   00000000   0xF0100030         DC32     0xf0100030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_88:
   \   00000000   0x00040182         DC32     0x40182

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_89:
   \   00000000   0x40000001         DC32     0x40000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_90:
   \   00000000   0x........         DC32     bLPTMRWakeupFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_91:
   \   00000000   0x........         DC32     gMCG_coreClkMHz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_92:
   \   00000000   0x........         DC32     LowPowerEntered

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_93:
   \   00000000   0x........         DC32     bCommTxDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_94:
   \   00000000   0x........         DC32     gu8CommData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_95:
   \   00000000   0x........         DC32     bTxDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_96:
   \   00000000   0x........         DC32     bRxDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_97:
   \   00000000   0x........         DC32     bestChannel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_98:
   \   00000000   0x........         DC32     bScanDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_99:
   \   00000000   0x........         DC32     evTestParameters

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x0C 0x0D          DC8 "\014\015\012 Running PER Tx, Sending "
   \              0x0A 0x20    
   \              0x52 0x75    
   \              0x6E 0x6E    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x50 0x45    
   \              0x52 0x20    
   \              0x54 0x78    
   \              0x2C 0x20    
   \              0x53 0x65    
   \              0x6E 0x64    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x20 0x50          DC8 " Packets"
   \              0x61 0x63    
   \              0x6B 0x65    
   \              0x74 0x73    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x53 0x4E          DC8 53H, 4EH, 44H, 9, 25H, 75H, 9, 25H
   \              0x44 0x09    
   \              0x25 0x75    
   \              0x09 0x25    
   \   00000008   0x75 0x09          DC8 75H, 9, 25H, 75H, 9, 25H, 75H, 9
   \              0x25 0x75    
   \              0x09 0x25    
   \              0x75 0x09    
   \   00000010   0x25 0x75          DC8 25H, 75H, 9, 25H, 75H, 9, 25H, 75H
   \              0x09 0x25    
   \              0x75 0x09    
   \              0x25 0x75    
   \   00000018   0x09 0x25          DC8 9, 25H, 75H, 9, 25H, 75H, 9, 25H
   \              0x75 0x09    
   \              0x25 0x75    
   \              0x09 0x25    
   \   00000020   0x75 0x09          DC8 75H, 9, 25H, 75H, 9, 25H, 75H, 9
   \              0x25 0x75    
   \              0x09 0x25    
   \              0x75 0x09    
   \   00000028   0x25 0x75          DC8 25H, 75H, 9, 25H, 64H, 9, 25H, 75H
   \              0x09 0x25    
   \              0x64 0x09    
   \              0x25 0x75    
   \   00000030   0x09 0x25          DC8 9, 25H, 64H, 9, 25H, 75H, 9, 25H
   \              0x64 0x09    
   \              0x25 0x75    
   \              0x09 0x25    
   \   00000038   0x75 0x09          DC8 75H, 9, 25H, 75H, 9, 25H, 75H, 9
   \              0x25 0x75    
   \              0x09 0x25    
   \              0x75 0x09    
   \   00000040   0x25 0x75          DC8 25H, 75H, 0DH, 0AH, 0
   \              0x0D 0x0A    
   \              0x00         
   \   00000045   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x40020000         DC32 1073872896, 0, 524288, 0, 0, 0, 0, 0
   \              0x00000000   
   \              0x00080000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x40020000         DC32 1073872896, 0, 524288, 0, 0, 0, 0, 0
   \              0x00000000   
   \              0x00080000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   2939          
   2940          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   AppLedTimerCallback
         8   -> LED_StopFlashingAllLeds
       8   ChangeOptions
         8   -> FlashSaveOptions
         8   -> SendCurrentOptions
         8   -> __aeabi_memcpy4
         8   -> memcmp
      32   ChooseBestChannel
        32   -> CopyPngPacketToSMAC
        32   -> GetLinkQdBm
        32   -> GetRandomNibble
        32   -> MCPSDataRequest
        32   -> MLMESetChannelRequest
        32   -> PngSwapEndianness
        32   -> ReceivePacket
        32   -> SendCurrentOptions
       8   CommRxCallback
         8   -> ShortCutsParser
         8   -> Uart1_GetByteFromRxBuffer
       0   CommTxCallback
       8   CopyBinaryPacketToSMAC
         8   -> MemoryCpy
       8   CopyOptPacketToSMAC
         8   -> MemoryCpy
      16   CopyOptionsFromRecvPacket
        16   -> MemoryCpy
       8   CopyPngPacketToSMAC
         8   -> MemoryCpy
      48   FlashSaveOptions
        48   -> NV_FlashEraseSector
        48   -> NV_FlashProgramLongword
        48   -> NV_FlashProgramUnalignedLongword
        48   -> __aeabi_memcpy4
      16   GetDeviceData
        16   -> ConversionAComplete
        16   -> GetConversionValue
        16   -> INIT_PIT
        16   -> NVIC_DisableIRQ
        16   -> NVIC_EnableIRQ
        16   -> StartBattConversion
        16   -> StartTempConversion
       0   GetFactoryOptions
       8   GetLinkQdBm
         8   -> MLMELinkQuality
       0   GetRandomNibble
       0   GlobalDataInit
       8   INIT_PIT
         8   -> NVIC_DisableIRQ
         8   -> NVIC_EnableIRQ
         8   -> NVIC_SetPriority
       0   InitAccelControlls
       0   InitPacket
      56   InitProject
        56   -> FlashSaveOptions
        56   -> GetFactoryOptions
        56   -> GlobalDataInit
        56   -> InitPacket
        56   -> KeyboardInit
        56   -> LED_Init
        56   -> MC1324xDrv_SPIInit
        56   -> MLMERadioInit
        56   -> MM_Init
        56   -> NV_FlashInit
        56   -> NV_FlashRead
        56   -> TMR_AllocateTimer
        56   -> TMR_Init
        56   -> Uart1_SetBaud
        56   -> Uart1_SetRxCallBack
        56   -> Uart_ModuleInit
        56   -> __aeabi_memcpy4
      16   InitSmac
        16   -> MLMEPAOutputAdjust
        16   -> MLMESetChannelRequest
        16   -> MLMESetPromiscuousMode
        16   -> MLMEXtalAdjust
       0   MCPSDataConfirm
       0   MCPSDataIndication
       0   MLMEResetIndication
       0   MLMEScanConfirm
       0   MLMEWakeConfirm
       0   OptSwapEndianness
      16   PIT_ISR
        16   -> ConversionAComplete
        16   -> GetConversionValue
        16   -> StartXConversion
        16   -> StartYConversion
        16   -> StartZConversion
       0   PngSwapEndianness
       8   PrintPacketID
         8   -> CommUtil_Print
         8   -> PrintWordOnDecimalFormatBlocking
       8   ReceivePacket
         8   -> MLMERXEnableRequest
      88   SendASCIIPacket
        88   -> InitPacket
        88   -> MCPSDataRequest
        88   -> sprintf
       8   SendBinaryPacket
         8   -> CopyBinaryPacketToSMAC
         8   -> GetLinkQdBm
         8   -> MCPSDataRequest
         8   -> SndSwapEndianness
       8   SendCurrentOptions
         8   -> CopyOptPacketToSMAC
         8   -> MCPSDataRequest
         8   -> OptSwapEndianness
         8   -> __aeabi_memcpy4
       0   ShortCutsParser
       0   SndSwapEndianness
       0   ValidateOptions
       0   WUApp_InitLowPowerMode
       8   WUApp_InitWakupSource
         8   -> NVIC_EnableIRQ
         8   -> PWRLib_LLWU_WakeupModuleEnable
       8   WUApp_LPRestoreSettings
         8   -> MC1324xDrv_Set_CLK_OUT_Freq
         8   -> MCG_PLLInit
         8   -> PWRLib_LPTMR_ClockStop
         8   -> PWRLib_Radio_Enter_AutoDoze
         8   -> TMR_AllocateTimer
       8   WUApp_LowPowerWhile
         8   -> PWRLib_MCU_Enter_VLLS1
         8   -> WUApp_LPRestoreSettings
         8   -> WUApp_PrepareToEnterLowPower
       8   WUApp_LowPwrStateMachine
         8   -> LED_StartSerialFlash
         8   -> PrintMenu
         8   -> TMR_StartSingleShotTimer
         8   -> WUApp_InitLowPowerMode
         8   -> WUApp_InitWakupSource
         8   -> WUApp_LowPowerWhile
       8   WUApp_PrepareToEnterLowPower
         8   -> MC1324xDrv_Set_CLK_OUT_Freq
         8   -> MCG_Pee2Fei
         8   -> PWRLib_LPTMR_ClockStart
         8   -> PWRLib_Radio_Enter_Hibernate
         8   -> TMR_FreeTimer
         8   -> TMR_StopTimer
       0   getRandomNumberInRange
      88   main
        88   -> ADCInit
        88   -> ChooseBestChannel
        88   -> CopyOptionsFromRecvPacket
        88   -> GetDeviceData
        88   -> GetFactoryOptions
        88   -> INIT_PIT
        88   -> InitAccelControlls
        88   -> InitPacket
        88   -> InitProject
        88   -> InitSmac
        88   -> MLMEPAOutputAdjust
        88   -> MLMESetChannelRequest
        88   -> MLMEXtalAdjust
        88   -> OptSwapEndianness
        88   -> ReceivePacket
        88   -> SendBinaryPacket
        88   -> ValidateOptions
        88   -> WUApp_LowPwrStateMachine


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable14
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable17_9
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable19
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable24
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_2
       4  ??DataTable26
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_10
       4  ??DataTable28_11
       4  ??DataTable28_12
       4  ??DataTable28_13
       4  ??DataTable28_14
       4  ??DataTable28_15
       4  ??DataTable28_16
       4  ??DataTable28_17
       4  ??DataTable28_18
       4  ??DataTable28_19
       4  ??DataTable28_2
       4  ??DataTable28_20
       4  ??DataTable28_21
       4  ??DataTable28_22
       4  ??DataTable28_23
       4  ??DataTable28_24
       4  ??DataTable28_25
       4  ??DataTable28_26
       4  ??DataTable28_27
       4  ??DataTable28_28
       4  ??DataTable28_29
       4  ??DataTable28_3
       4  ??DataTable28_30
       4  ??DataTable28_31
       4  ??DataTable28_32
       4  ??DataTable28_33
       4  ??DataTable28_4
       4  ??DataTable28_5
       4  ??DataTable28_6
       4  ??DataTable28_7
       4  ??DataTable28_8
       4  ??DataTable28_9
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable29_10
       4  ??DataTable29_11
       4  ??DataTable29_12
       4  ??DataTable29_13
       4  ??DataTable29_14
       4  ??DataTable29_15
       4  ??DataTable29_16
       4  ??DataTable29_17
       4  ??DataTable29_18
       4  ??DataTable29_19
       4  ??DataTable29_2
       4  ??DataTable29_20
       4  ??DataTable29_21
       4  ??DataTable29_3
       4  ??DataTable29_4
       4  ??DataTable29_5
       4  ??DataTable29_6
       4  ??DataTable29_7
       4  ??DataTable29_8
       4  ??DataTable29_9
       4  ??DataTable30
       4  ??DataTable31
       4  ??DataTable31_1
       4  ??DataTable35
       4  ??DataTable35_1
       4  ??DataTable35_2
       4  ??DataTable35_3
       4  ??DataTable35_4
       4  ??DataTable35_5
       4  ??DataTable35_6
       4  ??DataTable35_7
       4  ??DataTable35_8
       4  ??DataTable36
       4  ??DataTable36_1
       4  ??DataTable36_10
       4  ??DataTable36_11
       4  ??DataTable36_12
       4  ??DataTable36_13
       4  ??DataTable36_14
       4  ??DataTable36_15
       4  ??DataTable36_16
       4  ??DataTable36_17
       4  ??DataTable36_18
       4  ??DataTable36_19
       4  ??DataTable36_2
       4  ??DataTable36_20
       4  ??DataTable36_21
       4  ??DataTable36_22
       4  ??DataTable36_23
       4  ??DataTable36_24
       4  ??DataTable36_25
       4  ??DataTable36_26
       4  ??DataTable36_27
       4  ??DataTable36_28
       4  ??DataTable36_29
       4  ??DataTable36_3
       4  ??DataTable36_30
       4  ??DataTable36_31
       4  ??DataTable36_32
       4  ??DataTable36_33
       4  ??DataTable36_34
       4  ??DataTable36_35
       4  ??DataTable36_36
       4  ??DataTable36_37
       4  ??DataTable36_38
       4  ??DataTable36_39
       4  ??DataTable36_4
       4  ??DataTable36_40
       4  ??DataTable36_41
       4  ??DataTable36_42
       4  ??DataTable36_43
       4  ??DataTable36_44
       4  ??DataTable36_45
       4  ??DataTable36_46
       4  ??DataTable36_47
       4  ??DataTable36_48
       4  ??DataTable36_49
       4  ??DataTable36_5
       4  ??DataTable36_50
       4  ??DataTable36_51
       4  ??DataTable36_52
       4  ??DataTable36_53
       4  ??DataTable36_54
       4  ??DataTable36_55
       4  ??DataTable36_56
       4  ??DataTable36_57
       4  ??DataTable36_58
       4  ??DataTable36_59
       4  ??DataTable36_6
       4  ??DataTable36_60
       4  ??DataTable36_61
       4  ??DataTable36_62
       4  ??DataTable36_63
       4  ??DataTable36_64
       4  ??DataTable36_65
       4  ??DataTable36_66
       4  ??DataTable36_67
       4  ??DataTable36_68
       4  ??DataTable36_69
       4  ??DataTable36_7
       4  ??DataTable36_70
       4  ??DataTable36_71
       4  ??DataTable36_72
       4  ??DataTable36_73
       4  ??DataTable36_74
       4  ??DataTable36_75
       4  ??DataTable36_76
       4  ??DataTable36_77
       4  ??DataTable36_78
       4  ??DataTable36_79
       4  ??DataTable36_8
       4  ??DataTable36_80
       4  ??DataTable36_81
       4  ??DataTable36_82
       4  ??DataTable36_83
       4  ??DataTable36_84
       4  ??DataTable36_85
       4  ??DataTable36_86
       4  ??DataTable36_87
       4  ??DataTable36_88
       4  ??DataTable36_89
       4  ??DataTable36_9
       4  ??DataTable36_90
       4  ??DataTable36_91
       4  ??DataTable36_92
       4  ??DataTable36_93
       4  ??DataTable36_94
       4  ??DataTable36_95
       4  ??DataTable36_96
       4  ??DataTable36_97
       4  ??DataTable36_98
       4  ??DataTable36_99
      32  ?_0
      12  ?_1
      72  ?_2
      32  ?_3
      32  ?_4
       4  AXIS
      10  AppLedTimerCallback
      54  ChangeOptions
     228  ChooseBestChannel
      34  CommRxCallback
       8  CommTxCallback
     476  CopyBinaryPacketToSMAC
     252  CopyOptPacketToSMAC
     196  CopyOptionsFromRecvPacket
      68  CopyPngPacketToSMAC
      96  FlashSaveOptions
     230  GetDeviceData
      52  GetFactoryOptions
      16  GetLinkQdBm
      58  GetRandomNibble
     130  GlobalDataInit
      72  INIT_PIT
     114  InitAccelControlls
     278  InitPacket
     400  InitProject
      72  InitSmac
       4  LPTMR_Duration
       1  LowPowerEntered
       8  MCPSDataConfirm
      14  MCPSDataIndication
       2  MLMEResetIndication
      12  MLMEScanConfirm
       2  MLMEWakeConfirm
     104  OptSwapEndianness
     246  PIT_ISR
       4  PIT_ITTERATIONS
      28  PngSwapEndianness
      40  PrintPacketID
       4  RTC_Duration
     210  ReceivePacket
     194  SendASCIIPacket
      54  SendBinaryPacket
      66  SendCurrentOptions
     268  ShortCutsParser
     724  SndSwapEndianness
       4  TempSumx
       4  TempSumy
       4  TempSumz
     146  ValidateOptions
      38  WUApp_InitLowPowerMode
      32  WUApp_InitWakupSource
     372  WUApp_LPRestoreSettings
      16  WUApp_LowPowerWhile
     258  WUApp_LowPwrStateMachine
     732  WUApp_PrepareToEnterLowPower
       1  appState
      16  au8ScanResults
       1  b
       1  bCommGetDataTimerFlag
       1  bCommTxDone
       1  bFirstNibbleFlag
       1  bGPIOWakeupFlag
       1  bGotoLowPwrFlag
       1  bLPTMRWakeupFlag
       1  bRTCWakeupFlag
       1  bReturnToMainMenuFlag
       1  bRxDone
       1  bScanDone
       1  bTxDone
       1  bTxOtaBusyFlag
       1  bestChannel
       1  cTxRxState
       1  connState
       1  contTestRunning
       1  eRState
       1  evDataFromCOMM
       1  evTestParameters
       4  gAppRxPacket
       4  gAppTxPacket
       1  gConfigState
       4  gFlashDeadBeef
      24  gFlashOptions
       1  gIsAck
       1  gIsMyAck
       1  gLPConfigState
       1  gLastConfigState
       1  gLastLPConfigState
      32  gOpt
      24  gOptions
       8  gPng
      96  gRawSnd
       4  gRxTimeout
      72  gSnd
       4  g_DEAD_BEEF
     132  gau8RxDataBuffer
     128  gau8TxDataBuffer
      34  getRandomNumberInRange
       1  gu8CommData
       1  mBufferInterval_c
       1  mBufferTimerID
       2  mLEDInterval1_c
       1  mLEDTimerID_1
     782  main
       1  oDRState
       1  oIRState
       1  perRxState
       1  perTxState
       1  prevOpMode
       4  pu8GotoLowPowerString
       4  pu8MainLowPowerString
       4  pu8MainWakeupSourceString
       4  pu8NowInLowPowerString
       4  pu8WakeupSourceString
       1  rDRState
       1  rIRState
       1  rangeRxState
       1  rangeTxState
       1  rxTestIndex
       4  sDeadBeef
       2  sensorID
       2  sentPackets
       4  settingsAddress
       1  shortCutsEnabled
       1  testChannel
       1  testOpMode
       1  testPayloadLen
       1  testPower
       1  testTrimmValue
       1  txTestIndex
      32  u32GPIOs_PDDRBackup
      32  u32GPIOs_PDORBackup
      32  u32PortAPCRBackup
      32  u32PortBPCRBackup
      32  u32PortCPCRBackup
      32  u32PortDPCRBackup
      32  u32PortEPCRBackup
      20  u32SCGCxBackup
       1  u8ConfigDecValue
       1  u8ConfigHexValue
       1  u8SequencePointerCounter

 
   889 bytes in section .bss
    13 bytes in section .data
   188 bytes in section .rodata
 8 114 bytes in section .text
 
 8 114 bytes of CODE  memory
   188 bytes of CONST memory
   902 bytes of DATA  memory

Errors: none
Warnings: 4
