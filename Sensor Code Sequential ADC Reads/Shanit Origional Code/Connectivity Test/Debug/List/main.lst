###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        02/Sep/2018  13:33:17
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\Application\Source\main.c
#    Command line =  
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\Application\Source\main.c" -D IAR --preprocess "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\List\" -lC "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\List\" -lB "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\List\" --diag_suppress
#        Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\Obj\" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\CDC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\Descriptor\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\USB\Class\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Sys Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
#    List file    =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\List\main.lst
#    Object file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\Obj\main.o
#
###############################################################################

F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\Application\Source\main.c
      1          /*****************************************************************************
      2          * Connectivity test demo main file.
      3          * 
      4          * Copyright (c) 2012, Freescale, Inc. All rights reserved.
      5          *
      6          * 
      7          * No part of this document must be reproduced in any form - including copied,
      8          * transcribed, printed or by any electronic means - without specific written
      9          * permission from Freescale Semiconductor.
     10          *
     11          *  The Connectivity Test Demo  is  mainly  used  to perform radio performance 
     12          *  test in hardware for wireless implementations. It allows users to exercise 
     13          *  all the radio functionality and to get results for some important wireless 
     14          *  tests as Packet Error Rate and Range test.
     15          *  
     16          *  The main functions provided by Connectivity test are:
     17          *  - Perform Range test.
     18          *  - Perform Packet Error Rate test.
     19          *  - Manage radio parameters as Channel, Power and Crystal Trim.
     20          *  - Perform Radio Tests as Continuous Modulated TX, Continuous PRBS9 packets 
     21          *    Tx, Un-modulated TX, Continuous Rx and Channel energy Detect.
     22          *  - Manage to read and write radio registers by address.
     23          *
     24          *****************************************************************************/
     25          
     26          #include "ApplicationConf.h"             /*Defines the Application default parameters*/
     27          #include "SMAC.h"
     28          #include <stdio.h>
     29          #include <stdlib.h>
     30          #include <string.h>
     31          
     32          /************************************************************************************
     33          *************************************************************************************
     34          * Private prototypes 
     35          *************************************************************************************
     36          ************************************************************************************/
     37          static void InitProject(void);
     38          void InitSmac(void);
     39          static void PrintTestParameters(bool_t bEraseLine);
     40          static void SerialUIStateMachine(void);
     41          static bool_t SerialContinuousTxRxTest(void);
     42          static bool_t PacketErrorRateTx(void);
     43          static bool_t PacketErrorRateRx(void);
     44          static void SetRadioRxOnTimeOut15ms(void);
     45          static void SetRadioRxOnNoTimeOut(void);
     46          static void PrintPerRxFinalLine(uint16_t u16Received, uint16_t u16Total);
     47          static bool_t RangeTx(void);
     48          static bool_t RangeRx(void);
     49          
     50          static bool_t EditRegisters(void);
     51          static bool_t OverrideDirectRegisters(void);
     52          static bool_t OverrideIndirectRegisters(void);
     53          static bool_t ReadDirectRegisters(void);
     54          static bool_t ReadIndirectRegisters(void);
     55          

   \                                 In section .data, align 1
     56          tmrTimerID_t mLEDTimerID_1 = gTmrInvalidTimerID_c;
   \                     mLEDTimerID_1:
   \   00000000   0xFF               DC8 255

   \                                 In section .data, align 1
     57          tmrTimerID_t mBufferTimerID = gTmrInvalidTimerID_c;
   \                     mBufferTimerID:
   \   00000000   0xFF               DC8 255

   \                                 In section .data, align 2
     58          uint16_t mLEDInterval1_c = 1150;
   \                     mLEDInterval1_c:
   \   00000000   0x047E             DC16 1150

   \                                 In section .data, align 1
     59          uint8_t mBufferInterval_c = 1;
   \                     mBufferInterval_c:
   \   00000000   0x01               DC8 1
     60          
     61          void MLMEScanConfirm(channels_t ClearestChann);
     62          void MLMEResetIndication(void);
     63          void MLMEWakeConfirm(void);
     64          void CommRxCallback();
     65          void ShortCutsParser(uint8_t u8CommData);
     66          void CommTxCallback(void);
     67          void MCPSDataConfirm(txStatus_t TransmissionResult);
     68          void MCPSDataIndication(rxPacket_t *gsRxPacket);
     69          void GlobalDataInit(void);
     70          /* Place your callbacks prototypes declarations here */
     71          void InitPacket();
     72          smacErrors_t SendASCIIPacket();
     73          smacErrors_t SendBinaryPacket();
     74          void ReceivePacket();
     75          void PrintPacketID(uint16_t packetID);
     76          void CopyBinaryPacketToSMAC();
     77          void SndSwapEndianness();
     78          void PngSwapEndianness();
     79          void OptSwapEndianness(tOptions* opt);
     80          void GetFactoryOptions(tOptions *pOptions);
     81          void FlashSaveOptions();
     82          void ChangeOptions(tOptions* pOptions);
     83          int ValidateOptions(tOptions *pOptions);
     84          smacErrors_t SendCurrentOptions();
     85          void CopyOptPacketToSMAC();
     86          void CopyOptionsFromRecvPacket(tOptions* pOptions);
     87          void CopyPngPacketToSMAC();
     88          uint8_t ChooseBestChannel();
     89          uint8_t GetRandomNibble();
     90          int8_t GetLinkQdBm();
     91          /************************************************************************************
     92          *************************************************************************************
     93          * Module Constants
     94          *************************************************************************************
     95          ************************************************************************************/
     96          /*initilize the functions to turn on and off the power to the Accel Module*/
     97          #define AccellPowerOn()         (gLED_PortDataSetReg_c |= gAccelPower);
     98          #define AccellEnableOn()         (gLED_PortDataSetReg_c |= gAccelEnable);
     99          
    100          /*initilize the functions that will turn on the power to teh accell module */
    101          #define AccellPowerOff()        (gLED_PortDataClearReg_c |= gAccelPower);
    102          #define AccellEnableOff()          (gLED_PortDataClearReg_c |= gAccelEnable);
    103          
    104          /************************************************************************************
    105          *************************************************************************************
    106          * Public memory declarations
    107          *************************************************************************************
    108          ************************************************************************************/
    109          
    110          #if (TRUE == gEnableConfigMenus_d)

   \                                 In section .bss, align 1
    111            wuConfigState_t gConfigState;
   \                     gConfigState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    112            wuConfigState_t gLastConfigState;
   \                     gLastConfigState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    113            wuLPConfigState_t gLPConfigState;
   \                     gLPConfigState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    114            wuLPConfigState_t gLastLPConfigState;
   \                     gLastLPConfigState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    115            bool_t  bGotoLowPwrFlag;
   \                     bGotoLowPwrFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    116            bool_t  bFirstNibbleFlag;
   \                     bFirstNibbleFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    117            uint8_t u8ConfigHexValue;
   \                     u8ConfigHexValue:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    118            uint8_t u8ConfigDecValue;
   \                     u8ConfigDecValue:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    119            uint8_t u8SequencePointerCounter;
   \                     u8SequencePointerCounter:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    120            bool_t bReturnToMainMenuFlag;
   \                     bReturnToMainMenuFlag:
   \   00000000                      DS8 1
    121          #endif
    122          
    123          #if (gEnableLowPower_d == TRUE)    

   \                                 In section .bss, align 4
    124          uint8_t *pu8MainLowPowerString;
   \                     pu8MainLowPowerString:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    125          uint8_t * pu8MainWakeupSourceString;
   \                     pu8MainWakeupSourceString:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    126          uint8_t * pu8GotoLowPowerString;
   \                     pu8GotoLowPowerString:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    127          uint8_t * pu8NowInLowPowerString;
   \                     pu8NowInLowPowerString:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    128          uint8_t * pu8WakeupSourceString;
   \                     pu8WakeupSourceString:
   \   00000000                      DS8 4
    129          

   \                                 In section .bss, align 4
    130          uint32_t u32PortAPCRBackup[8];
   \                     u32PortAPCRBackup:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
    131          uint32_t u32PortBPCRBackup[8];
   \                     u32PortBPCRBackup:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
    132          uint32_t u32PortCPCRBackup[8];
   \                     u32PortCPCRBackup:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
    133          uint32_t u32PortDPCRBackup[8];
   \                     u32PortDPCRBackup:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
    134          uint32_t u32PortEPCRBackup[8];
   \                     u32PortEPCRBackup:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
    135          uint32_t u32SCGCxBackup[5];
   \                     u32SCGCxBackup:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
    136          uint32_t u32GPIOs_PDORBackup[8];
   \                     u32GPIOs_PDORBackup:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
    137          uint32_t u32GPIOs_PDDRBackup[8];
   \                     u32GPIOs_PDDRBackup:
   \   00000000                      DS8 32

   \                                 In section .data, align 4
    138          zbClock24_t LPTMR_Duration = 360; //LowPowerTimer
   \                     LPTMR_Duration:
   \   00000000   0x00000168         DC32 360

   \                                 In section .data, align 4
    139          zbClock24_t RTC_Duration = 10;
   \                     RTC_Duration:
   \   00000000   0x0000000A         DC32 10

   \                                 In section .bss, align 1
    140          bool_t  bGPIOWakeupFlag = FALSE;
   \                     bGPIOWakeupFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    141          bool_t  bLPTMRWakeupFlag = FALSE;
   \                     bLPTMRWakeupFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    142          bool_t  bRTCWakeupFlag = FALSE;
   \                     bRTCWakeupFlag:
   \   00000000                      DS8 1
    143          #endif
    144          

   \                                 In section .bss, align 4
    145          static uint8_t gau8RxDataBuffer[130]; 
   \                     gau8RxDataBuffer:
   \   00000000                      DS8 132

   \                                 In section .bss, align 4
    146          static uint8_t gau8TxDataBuffer[128]; 
   \                     gau8TxDataBuffer:
   \   00000000                      DS8 128
    147          

   \                                 In section .bss, align 4
    148          static txPacket_t * gAppTxPacket;
   \                     gAppTxPacket:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    149          static rxPacket_t * gAppRxPacket;
   \                     gAppRxPacket:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    150          static tSnd        gSnd;
   \                     gSnd:
   \   00000000                      DS8 72

   \                                 In section .bss, align 4
    151          tOptions    gOptions;
   \                     gOptions:
   \   00000000                      DS8 24

   \                                 In section .bss, align 4
    152          tOpt        gOpt;
   \                     gOpt:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
    153          tPng        gPng;
   \                     gPng:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
    154          tRawSnd     gRawSnd;      
   \                     gRawSnd:
   \   00000000                      DS8 96
    155          

   \                                 In section .bss, align 1
    156          volatile int8_t appState;
   \                     appState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    157          uint8_t       gIsAck;
   \                     gIsAck:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    158          uint8_t       gIsMyAck;
   \                     gIsMyAck:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    159          uint32_t      gRxTimeout;
   \                     gRxTimeout:
   \   00000000                      DS8 4

   \                                 In section .rodata, align 4
    160          const uint32_t g_DEAD_BEEF = 0xDEADBEEF;  // unlikely-to-exist bit pattern
   \                     g_DEAD_BEEF:
   \   00000000   0xDEADBEEF         DC32 3735928559

   \                                 In section .rodata, align 4
    161          const uint32_t settingsAddress = 0x0007F800;
   \                     settingsAddress:
   \   00000000   0x0007F800         DC32 522240
    162          //uint32_t      gFlashDeadBeef  @0x0007F800;

   \                                 In section .bss, align 4
    163          uint32_t      gFlashDeadBeef;
   \                     gFlashDeadBeef:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    164          tOptions    gFlashOptions;    // Note: on same FLASH memory page as "gFlashDeadBeef"
   \                     gFlashOptions:
   \   00000000                      DS8 24

   \                                 In section .bss, align 2
    165          uint16_t sensorID;
   \                     sensorID:
   \   00000000                      DS8 2
    166          

   \                                 In section .bss, align 1
    167          bool_t bTxDone;
   \                     bTxDone:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    168          bool_t bRxDone;
   \                     bRxDone:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    169          bool_t bScanDone;
   \                     bScanDone:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    170          channels_t bestChannel;
   \                     bestChannel:
   \   00000000                      DS8 1
    171          

   \                                 In section .bss, align 1
    172          bool_t  bCommTxDone;  
   \                     bCommTxDone:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    173          uint8_t gu8CommData;
   \                     gu8CommData:
   \   00000000                      DS8 1
    174          

   \                                 In section .bss, align 1
    175          operationModes_t testOpMode;
   \                     testOpMode:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    176          operationModes_t prevOpMode;
   \                     prevOpMode:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    177          channels_t       testChannel;
   \                     testChannel:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    178          uint8_t          testPower;
   \                     testPower:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    179          uint8_t          testTrimmValue;
   \                     testTrimmValue:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    180          uint8_t          testPayloadLen;
   \                     testPayloadLen:
   \   00000000                      DS8 1
    181          

   \                                 In section .bss, align 1
    182          smacTestMode_t contTestRunning;
   \                     contTestRunning:
   \   00000000                      DS8 1
    183          

   \                                 In section .bss, align 1
    184          bool_t evDataFromCOMM;
   \                     evDataFromCOMM:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    185          bool_t evTestParameters;
   \                     evTestParameters:
   \   00000000                      DS8 1
    186          

   \                                 In section .bss, align 1
    187          bool_t shortCutsEnabled;
   \                     shortCutsEnabled:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    188          ConnectivityStates_t       connState;
   \                     connState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    189          ContinuousTxRxTestStates_t cTxRxState;
   \                     cTxRxState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    190          PerTxStates_t              perTxState;
   \                     perTxState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    191          PerRxStates_t              perRxState;
   \                     perRxState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    192          RangeTxStates_t            rangeTxState;
   \                     rangeTxState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    193          RangeRxStates_t            rangeRxState;
   \                     rangeRxState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    194          EditRegsStates_t    eRState; 
   \                     eRState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    195          ODRStates_t         oDRState;
   \                     oDRState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    196          OIRStates_t         oIRState;
   \                     oIRState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    197          RDRStates_t         rDRState;
   \                     rDRState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    198          RIRStates_t         rIRState;
   \                     rIRState:
   \   00000000                      DS8 1
    199          

   \                                 In section .bss, align 1
    200          bool_t bTxOtaBusyFlag;
   \                     bTxOtaBusyFlag:
   \   00000000                      DS8 1
    201          

   \                                 In section .bss, align 4
    202          int     PIT_ITTERATIONS;
   \                     PIT_ITTERATIONS:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    203          int     AXIS ;
   \                     AXIS:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    204          uint32_t  TempSumx ;
   \                     TempSumx:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    205          uint32_t  TempSumy ;
   \                     TempSumy:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    206          uint32_t  TempSumz ;
   \                     TempSumz:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
    207          bool_t bCommGetDataTimerFlag;
   \                     bCommGetDataTimerFlag:
   \   00000000                      DS8 1
    208          

   \                                 In section .bss, align 1
    209          bool_t LowPowerEntered = FALSE;
   \                     LowPowerEntered:
   \   00000000                      DS8 1
    210          

   \                                 In section .bss, align 4
    211          uint8_t au8ScanResults[16];
   \                     au8ScanResults:
   \   00000000                      DS8 16
    212          

   \                                 In section .bss, align 1
    213          txTests_t txTestIndex;
   \                     txTestIndex:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    214          RxTests_t rxTestIndex;
   \                     rxTestIndex:
   \   00000000                      DS8 1

   \                                 In section .bss, align 2
    215          uint16_t sentPackets;
   \                     sentPackets:
   \   00000000                      DS8 2
    216          #define MMCAU_TEST  FALSE    
    217          
    218          #if TRUE == MMCAU_TEST
    219            #define AES192                    192
    220            unsigned char key_expansion[60*4];
    221            /*24 bytes key: "UltraMegaSecretPassword1"*/
    222            unsigned char   key192[AES192/8] = { 0x55, 0x6c, 0x74, 0x72, 0x61, 0x4d, 0x65, 0x67, 
    223                                                 0x61, 0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x50, 
    224          	                               0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x31 };
    225          #endif
    226          
    227          
    228          /************************************************************************************
    229          *************************************************************************************
    230          * Main application functions
    231          *************************************************************************************
    232          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    233          void main(void)
    234          {
   \                     main: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB08D             SUB      SP,SP,#+52
    235            int XDiff;
    236            int YDiff;
    237            int ZDiff;
    238            
    239            int LoopItterations = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    240            
    241            int threshHold = 120;
   \   00000008   0x2778             MOVS     R7,#+120
    242            sensorID=6543; 
   \   0000000A   0xF641 0x108F      MOVW     R0,#+6543
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000012   0x8008             STRH     R0,[R1, #+0]
    243            TempSumx = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable13
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    244            TempSumy = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \   00000022   0x6008             STR      R0,[R1, #+0]
    245            TempSumz = 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    246            AXIS = 0; 
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   00000032   0x6008             STR      R0,[R1, #+0]
    247            PIT_ITTERATIONS =0;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    248            
    249            InitProject(); 
   \   0000003C   0x.... 0x....      BL       InitProject
    250            /* SMAC Initialization */
    251            InitSmac(); 
   \   00000040   0x.... 0x....      BL       InitSmac
    252            
    253            //initalize the accelerometter
    254            InitAccelControlls();
   \   00000044   0x.... 0x....      BL       InitAccelControlls
    255            ADCInit();
   \   00000048   0x.... 0x....      BL       ADCInit
    256            
    257           //right now this should be equal to a pit running every .000125 seconds so it will run 8000 itterations in 1 second
    258            INIT_PIT((uint32_t) 5999);        //((50,000,000)/(1/TIME)) -1 = TimeForInitFucntion Here Time is equal to  intot initthis can be changed for different sample times if the number is increased the sample time is increased
   \   0000004C   0xF241 0x706F      MOVW     R0,#+5999
   \   00000050   0x.... 0x....      BL       INIT_PIT
    259            /*this time is for 8000Hz */
    260            
    261            //blink the leds
    262            RedStatLedOn();
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x400ff0c8
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x400ff0c8
   \   00000062   0x6008             STR      R0,[R1, #+0]
    263            GreenStatLedOn();
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x400ff0c8
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x400ff0c8
   \   00000072   0x6008             STR      R0,[R1, #+0]
    264            
    265          #if defined(gCDCInterface_d)    //Wait for user to open the VirtualCom
    266            while(!Comm_Open());
    267          #endif
    268            /*Prints the Welcome screens in the COMM*/  
    269            //PrintMenu(cu8FreescaleLogo, gDefaultCommPort_c);
    270            
    271            #if TRUE == MMCAU_TEST
    272             cau_aes_set_key(key192, AES192, key_expansion);
    273            #endif
    274            
    275            /*Waits until de user selects press Enter*/    
    276           // while(!(evDataFromCOMM && ('\r' == gu8CommData))); 
    277            connState = gConnIdleState_c; 
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable12_1
   \   0000007A   0x7008             STRB     R0,[R1, #+0]
    278            int32_t cin[30];
    279            int in;
    280            
    281            gSnd.channel=gChannel11_c;
   \   0000007C   0x200B             MOVS     R0,#+11
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000082   0xF881 0x0043      STRB     R0,[R1, #+67]
    282            uint16_t flashCount=0;
   \   00000086   0xF05F 0x0800      MOVS     R8,#+0
    283            (void)MLMESetChannelRequest(gSnd.channel);
                                               ^
Warning[Pe188]: enumerated type mixed with another type
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000008E   0xF890 0x0043      LDRB     R0,[R0, #+67]
   \   00000092   0x.... 0x....      BL       MLMESetChannelRequest
   \   00000096   0x4681             MOV      R9,R0
    284            (void)MLMEPAOutputAdjust(gMaxOutputPower_c);
   \   00000098   0x201F             MOVS     R0,#+31
   \   0000009A   0x.... 0x....      BL       MLMEPAOutputAdjust
   \   0000009E   0x4682             MOV      R10,R0
    285            (void)MLMEXtalAdjust(testTrimmValue);
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable13_5
   \   000000A4   0x7800             LDRB     R0,[R0, #+0]
   \   000000A6   0x.... 0x....      BL       MLMEXtalAdjust
   \   000000AA   0x4683             MOV      R11,R0
    286            //MLMESetPromiscuousMode(TRUE);
    287            sentPackets=0;
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable13_6
   \   000000B2   0x8008             STRH     R0,[R1, #+0]
    288          
    289            (void)ChooseBestChannel();
   \   000000B4   0x.... 0x....      BL       ChooseBestChannel
    290            appState=TRANSMIT_MODE;
   \   000000B8   0x2100             MOVS     R1,#+0
   \   000000BA   0x.... 0x....      LDR.W    R2,??DataTable15
   \   000000BE   0x7011             STRB     R1,[R2, #+0]
    291            
    292              RedStatLedOff();
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable13_7  ;; 0x400ff0c4
   \   000000C4   0x6809             LDR      R1,[R1, #+0]
   \   000000C6   0xF051 0x0110      ORRS     R1,R1,#0x10
   \   000000CA   0x.... 0x....      LDR.W    R2,??DataTable13_7  ;; 0x400ff0c4
   \   000000CE   0x6011             STR      R1,[R2, #+0]
    293            GreenStatLedOff();
   \   000000D0   0x.... 0x....      LDR.W    R1,??DataTable13_7  ;; 0x400ff0c4
   \   000000D4   0x6809             LDR      R1,[R1, #+0]
   \   000000D6   0xF051 0x0108      ORRS     R1,R1,#0x8
   \   000000DA   0x.... 0x....      LDR.W    R2,??DataTable13_7  ;; 0x400ff0c4
   \   000000DE   0x6011             STR      R1,[R2, #+0]
    294            
    295            PIT_ITTERATIONS =0;
   \   000000E0   0x2100             MOVS     R1,#+0
   \   000000E2   0x.... 0x....      LDR.W    R2,??DataTable13_4
   \   000000E6   0x6011             STR      R1,[R2, #+0]
    296            
    297            AccellEnableOn();
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable13_7  ;; 0x400ff0c4
   \   000000EC   0x6809             LDR      R1,[R1, #+0]
   \   000000EE   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   000000F2   0x.... 0x....      LDR.W    R2,??DataTable13_7  ;; 0x400ff0c4
   \   000000F6   0x6011             STR      R1,[R2, #+0]
    298            AccellPowerOn();
   \   000000F8   0x.... 0x....      LDR.W    R1,??DataTable13_7  ;; 0x400ff0c4
   \   000000FC   0x6809             LDR      R1,[R1, #+0]
   \   000000FE   0xF051 0x0120      ORRS     R1,R1,#0x20
   \   00000102   0x.... 0x....      LDR.W    R2,??DataTable13_7  ;; 0x400ff0c4
   \   00000106   0x6011             STR      R1,[R2, #+0]
    299            
    300            
    301            
    302            for(;;){
    303              
    304             TempSumx = 0;
   \                     ??main_0: (+1)
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0x.... 0x....      LDR.W    R1,??DataTable13
   \   0000010E   0x6008             STR      R0,[R1, #+0]
    305             TempSumy = 0;
   \   00000110   0x2000             MOVS     R0,#+0
   \   00000112   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \   00000116   0x6008             STR      R0,[R1, #+0]
    306             TempSumz = 0;
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000011E   0x6008             STR      R0,[R1, #+0]
    307             gSnd.xmax =0;
   \   00000120   0x2000             MOVS     R0,#+0
   \   00000122   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000126   0x8148             STRH     R0,[R1, #+10]
    308             gSnd.ymax =0;
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000012E   0x8348             STRH     R0,[R1, #+26]
    309             gSnd.zmax =0;
   \   00000130   0x2000             MOVS     R0,#+0
   \   00000132   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000136   0x8548             STRH     R0,[R1, #+42]
    310             gSnd.xmin = 4000;
   \   00000138   0xF44F 0x607A      MOV      R0,#+4000
   \   0000013C   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000140   0x8108             STRH     R0,[R1, #+8]
    311             gSnd.ymin = 4000;
   \   00000142   0xF44F 0x607A      MOV      R0,#+4000
   \   00000146   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000014A   0x8308             STRH     R0,[R1, #+24]
    312             gSnd.zmin = 4000;
   \   0000014C   0xF44F 0x607A      MOV      R0,#+4000
   \   00000150   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000154   0x8508             STRH     R0,[R1, #+40]
    313              
    314              
    315              uint16_t sleepTime = 1000*gOptions.u16SleepAfterAck;
   \   00000156   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   0000015A   0x8AC0             LDRH     R0,[R0, #+22]
   \   0000015C   0xF44F 0x717A      MOV      R1,#+1000
   \   00000160   0xFB10 0xF901      SMULBB   R9,R0,R1
    316              
    317               
    318               // Prepare the usual stats SND packet
    319               // get temp and vibration data, put in packet
    320               GetDeviceData();
   \   00000164   0x.... 0x....      BL       GetDeviceData
    321              
    322              
    323              //delayMs(3000);
    324              XDiff = gSnd.xmax - gSnd.xmin;
   \   00000168   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000016C   0x8940             LDRH     R0,[R0, #+10]
   \   0000016E   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000172   0x8909             LDRH     R1,[R1, #+8]
   \   00000174   0x1A40             SUBS     R0,R0,R1
   \   00000176   0x9000             STR      R0,[SP, #+0]
    325              YDiff = gSnd.ymax - gSnd.ymin;
   \   00000178   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000017C   0x8B40             LDRH     R0,[R0, #+26]
   \   0000017E   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000182   0x8B09             LDRH     R1,[R1, #+24]
   \   00000184   0x1A40             SUBS     R0,R0,R1
   \   00000186   0x0004             MOVS     R4,R0
    326              ZDiff = gSnd.zmax - gSnd.zmin;
   \   00000188   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000018C   0x8D40             LDRH     R0,[R0, #+42]
   \   0000018E   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000192   0x8D09             LDRH     R1,[R1, #+40]
   \   00000194   0x1A40             SUBS     R0,R0,R1
   \   00000196   0x0005             MOVS     R5,R0
    327              
    328              
    329              if( (XDiff > threshHold || XDiff < -threshHold) || (YDiff > threshHold || YDiff < -threshHold) || (ZDiff > threshHold || ZDiff < -threshHold))
   \   00000198   0x9800             LDR      R0,[SP, #+0]
   \   0000019A   0x4287             CMP      R7,R0
   \   0000019C   0xDB0A             BLT.N    ??main_1
   \   0000019E   0x9800             LDR      R0,[SP, #+0]
   \   000001A0   0x42F8             CMN      R0,R7
   \   000001A2   0xDB07             BLT.N    ??main_1
   \   000001A4   0x42A7             CMP      R7,R4
   \   000001A6   0xDB05             BLT.N    ??main_1
   \   000001A8   0x42FC             CMN      R4,R7
   \   000001AA   0xDB03             BLT.N    ??main_1
   \   000001AC   0x42AF             CMP      R7,R5
   \   000001AE   0xDB01             BLT.N    ??main_1
   \   000001B0   0x42FD             CMN      R5,R7
   \   000001B2   0xDA45             BGE.N    ??main_2
    330              {
    331                sentPackets++;
   \                     ??main_1: (+1)
   \   000001B4   0x.... 0x....      LDR.W    R0,??DataTable13_6
   \   000001B8   0x8800             LDRH     R0,[R0, #+0]
   \   000001BA   0x1C40             ADDS     R0,R0,#+1
   \   000001BC   0x.... 0x....      LDR.W    R1,??DataTable13_6
   \   000001C0   0x8008             STRH     R0,[R1, #+0]
    332                flashCount=0;
   \   000001C2   0x2000             MOVS     R0,#+0
   \   000001C4   0x4680             MOV      R8,R0
    333                //LED_SetLed(LED2, gLedOn_c);
    334                
    335                smacErrors_t status=SendBinaryPacket();
   \   000001C6   0x.... 0x....      BL       SendBinaryPacket
   \   000001CA   0x4682             MOV      R10,R0
    336                if(status==gErrorNoError_c){
   \   000001CC   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001D0   0xF1BA 0x0F00      CMP      R10,#+0
   \   000001D4   0xD101             BNE.N    ??main_3
    337                  ReceivePacket();
   \   000001D6   0x.... 0x....      BL       ReceivePacket
    338                }
    339                while(--flashCount);
   \                     ??main_3: (+1)
   \   000001DA   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   000001DE   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000001E2   0xF1B8 0x0F00      CMP      R8,#+0
   \   000001E6   0xD1F8             BNE.N    ??main_3
    340                
    341                evDataFromCOMM=FALSE;
   \   000001E8   0x2000             MOVS     R0,#+0
   \   000001EA   0x.... 0x....      LDR.W    R1,??DataTable15_1
   \   000001EE   0x7008             STRB     R0,[R1, #+0]
    342                //PrintPacketID(sentPackets);
    343                tOptions pOptions;
    344                if(appState==RECEIVE_FINISHED && gIsAck) {
   \   000001F0   0x.... 0x....      LDR.W    R0,??DataTable15
   \   000001F4   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   000001F8   0x2802             CMP      R0,#+2
   \   000001FA   0xD11F             BNE.N    ??main_4
   \   000001FC   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   00000200   0x7800             LDRB     R0,[R0, #+0]
   \   00000202   0x2800             CMP      R0,#+0
   \   00000204   0xD01A             BEQ.N    ??main_4
    345                  if(gAppRxPacket->u8DataLength>ACK_HEADER_SIZE){
   \   00000206   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   0000020A   0x6800             LDR      R0,[R0, #+0]
   \   0000020C   0x7880             LDRB     R0,[R0, #+2]
   \   0000020E   0x2806             CMP      R0,#+6
   \   00000210   0xDB14             BLT.N    ??main_4
    346                    if(gAppRxPacket->u8DataLength==ACK_OPT_SIZE){
   \   00000212   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   00000216   0x6800             LDR      R0,[R0, #+0]
   \   00000218   0x7880             LDRB     R0,[R0, #+2]
   \   0000021A   0x2818             CMP      R0,#+24
   \   0000021C   0xD10B             BNE.N    ??main_5
    347                      CopyOptionsFromRecvPacket(&pOptions);
   \   0000021E   0xA807             ADD      R0,SP,#+28
   \   00000220   0x.... 0x....      BL       CopyOptionsFromRecvPacket
    348                      
    349                      OptSwapEndianness(&pOptions);
   \   00000224   0xA807             ADD      R0,SP,#+28
   \   00000226   0x.... 0x....      BL       OptSwapEndianness
    350                      if (!ValidateOptions(&pOptions)) continue;
   \   0000022A   0xA807             ADD      R0,SP,#+28
   \   0000022C   0x.... 0x....      BL       ValidateOptions
   \   00000230   0x2800             CMP      R0,#+0
   \   00000232   0xD103             BNE.N    ??main_4
   \   00000234   0xE768             B.N      ??main_0
    351                    }
    352                    else {
    353                      GetFactoryOptions(&pOptions);
   \                     ??main_5: (+1)
   \   00000236   0xA807             ADD      R0,SP,#+28
   \   00000238   0x.... 0x....      BL       GetFactoryOptions
    354                    }
    355                    //ChangeOptions(&pOptions);
    356                  }
    357                  
    358                }
    359                LoopItterations =0;
   \                     ??main_4: (+1)
   \   0000023C   0x2000             MOVS     R0,#+0
   \   0000023E   0x0006             MOVS     R6,R0
    360              }
    361              
    362              
    363              
    364              if(LoopItterations == 120)
   \                     ??main_2: (+1)
   \   00000240   0x2E78             CMP      R6,#+120
   \   00000242   0xD15D             BNE.N    ??main_6
    365              {
    366                //need to send a heartbeat message
    367                gSnd.xmax = 0;
   \   00000244   0x2000             MOVS     R0,#+0
   \   00000246   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000024A   0x8148             STRH     R0,[R1, #+10]
    368                gSnd.xmin = 0;
   \   0000024C   0x2000             MOVS     R0,#+0
   \   0000024E   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000252   0x8108             STRH     R0,[R1, #+8]
    369                gSnd.ymax = 0;
   \   00000254   0x2000             MOVS     R0,#+0
   \   00000256   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000025A   0x8348             STRH     R0,[R1, #+26]
    370                gSnd.ymin = 0;
   \   0000025C   0x2000             MOVS     R0,#+0
   \   0000025E   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000262   0x8308             STRH     R0,[R1, #+24]
    371                gSnd.zmax = 0;
   \   00000264   0x2000             MOVS     R0,#+0
   \   00000266   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000026A   0x8548             STRH     R0,[R1, #+42]
    372                gSnd.zmin = 0;
   \   0000026C   0x2000             MOVS     R0,#+0
   \   0000026E   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000272   0x8508             STRH     R0,[R1, #+40]
    373                
    374                
    375                sentPackets++;
   \   00000274   0x.... 0x....      LDR.W    R0,??DataTable13_6
   \   00000278   0x8800             LDRH     R0,[R0, #+0]
   \   0000027A   0x1C40             ADDS     R0,R0,#+1
   \   0000027C   0x.... 0x....      LDR.W    R1,??DataTable13_6
   \   00000280   0x8008             STRH     R0,[R1, #+0]
    376                flashCount=0;
   \   00000282   0x2000             MOVS     R0,#+0
   \   00000284   0x4680             MOV      R8,R0
    377                //LED_SetLed(LED2, gLedOn_c);
    378                
    379                smacErrors_t status=SendBinaryPacket();
   \   00000286   0x.... 0x....      BL       SendBinaryPacket
   \   0000028A   0x4682             MOV      R10,R0
    380                if(status==gErrorNoError_c){
   \   0000028C   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000290   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000294   0xD101             BNE.N    ??main_7
    381                  ReceivePacket();
   \   00000296   0x.... 0x....      BL       ReceivePacket
    382                }
    383                while(--flashCount);
   \                     ??main_7: (+1)
   \   0000029A   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   0000029E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000002A2   0xF1B8 0x0F00      CMP      R8,#+0
   \   000002A6   0xD1F8             BNE.N    ??main_7
    384                
    385                evDataFromCOMM=FALSE;
   \   000002A8   0x2000             MOVS     R0,#+0
   \   000002AA   0x.... 0x....      LDR.W    R1,??DataTable15_1
   \   000002AE   0x7008             STRB     R0,[R1, #+0]
    386                //PrintPacketID(sentPackets);
    387                tOptions pOptions;
    388                if(appState==RECEIVE_FINISHED && gIsAck) {
   \   000002B0   0x.... 0x....      LDR.W    R0,??DataTable15
   \   000002B4   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   000002B8   0x2802             CMP      R0,#+2
   \   000002BA   0xD11F             BNE.N    ??main_8
   \   000002BC   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   000002C0   0x7800             LDRB     R0,[R0, #+0]
   \   000002C2   0x2800             CMP      R0,#+0
   \   000002C4   0xD01A             BEQ.N    ??main_8
    389                  if(gAppRxPacket->u8DataLength>ACK_HEADER_SIZE){
   \   000002C6   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   000002CA   0x6800             LDR      R0,[R0, #+0]
   \   000002CC   0x7880             LDRB     R0,[R0, #+2]
   \   000002CE   0x2806             CMP      R0,#+6
   \   000002D0   0xDB14             BLT.N    ??main_8
    390                    if(gAppRxPacket->u8DataLength==ACK_OPT_SIZE){
   \   000002D2   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   000002D6   0x6800             LDR      R0,[R0, #+0]
   \   000002D8   0x7880             LDRB     R0,[R0, #+2]
   \   000002DA   0x2818             CMP      R0,#+24
   \   000002DC   0xD10B             BNE.N    ??main_9
    391                      CopyOptionsFromRecvPacket(&pOptions);
   \   000002DE   0xA801             ADD      R0,SP,#+4
   \   000002E0   0x.... 0x....      BL       CopyOptionsFromRecvPacket
    392                      
    393                      OptSwapEndianness(&pOptions);
   \   000002E4   0xA801             ADD      R0,SP,#+4
   \   000002E6   0x.... 0x....      BL       OptSwapEndianness
    394                      if (!ValidateOptions(&pOptions)) continue;
   \   000002EA   0xA801             ADD      R0,SP,#+4
   \   000002EC   0x.... 0x....      BL       ValidateOptions
   \   000002F0   0x2800             CMP      R0,#+0
   \   000002F2   0xD103             BNE.N    ??main_8
   \   000002F4   0xE708             B.N      ??main_0
    395                    }
    396                    else {
    397                      GetFactoryOptions(&pOptions);
   \                     ??main_9: (+1)
   \   000002F6   0xA801             ADD      R0,SP,#+4
   \   000002F8   0x.... 0x....      BL       GetFactoryOptions
    398                    }
    399                    //ChangeOptions(&pOptions);
    400                  }
    401                  
    402                }
    403                LoopItterations =0;
   \                     ??main_8: (+1)
   \   000002FC   0x2000             MOVS     R0,#+0
   \   000002FE   0x0006             MOVS     R6,R0
    404                
    405              }
    406              /*this needs to be here to reset the packet ID every time*/
    407              LoopItterations = LoopItterations +1;
   \                     ??main_6: (+1)
   \   00000300   0x1C76             ADDS     R6,R6,#+1
    408              
    409              InitPacket(); 
   \   00000302   0x.... 0x....      BL       InitPacket
    410              
    411              
    412              //------------------------------------------------------------------------------------
    413              //Temporary Code to just push the controller into low power mode on every itteration through the code.
    414              //this was just set to make sure we could go into low power mode.
    415              
    416              while(!LowPowerEntered){
   \                     ??main_10: (+1)
   \   00000306   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \   0000030A   0x7800             LDRB     R0,[R0, #+0]
   \   0000030C   0x2800             CMP      R0,#+0
   \   0000030E   0xF47F 0xAEFB      BNE.W    ??main_0
    417                  //this loop will put the controller into sleep mode
    418                  //the sleeo mode will then cause a reset when it wakes back up.
    419                  gLED_PortDataDirReg_c = 0x0u;
   \   00000312   0x2000             MOVS     R0,#+0
   \   00000314   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x400ff0d4
   \   00000318   0x6008             STR      R0,[R1, #+0]
    420                  
    421                  WUApp_LowPwrStateMachine();
   \   0000031A   0x.... 0x....      BL       WUApp_LowPwrStateMachine
   \   0000031E   0xE7F2             B.N      ??main_10
    422                }
    423              
    424            }/* For(;;)*/
    425            
    426          }/*Main*/

   \                                 In section .text, align 2, keep-with-next
    427          int ValidateOptions(tOptions *pOptions){
   \                     ValidateOptions: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    428            if((pOptions->u8RawSpinCount!=0) && (pOptions->u8RawSpinCount > 64 || pOptions->u8RawSpinCount < 5)) return 0;   // updated *** 06/08/11 *** (formerly "u8Reserved1")
   \   00000002   0x7808             LDRB     R0,[R1, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD007             BEQ.N    ??ValidateOptions_0
   \   00000008   0x7808             LDRB     R0,[R1, #+0]
   \   0000000A   0x2841             CMP      R0,#+65
   \   0000000C   0xDA02             BGE.N    ??ValidateOptions_1
   \   0000000E   0x7808             LDRB     R0,[R1, #+0]
   \   00000010   0x2805             CMP      R0,#+5
   \   00000012   0xDA01             BGE.N    ??ValidateOptions_0
   \                     ??ValidateOptions_1: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE03B             B.N      ??ValidateOptions_2
    429            if(pOptions->u16TimeoutsToKill > 3600 || pOptions->u16TimeoutsToKill < 1) return 0;
   \                     ??ValidateOptions_0: (+1)
   \   00000018   0x8848             LDRH     R0,[R1, #+2]
   \   0000001A   0xF5B0 0x6F61      CMP      R0,#+3600
   \   0000001E   0xDC02             BGT.N    ??ValidateOptions_3
   \   00000020   0x8848             LDRH     R0,[R1, #+2]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD101             BNE.N    ??ValidateOptions_4
   \                     ??ValidateOptions_3: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE032             B.N      ??ValidateOptions_2
    430            if(pOptions->u16SampleSize != ACCEL_SAMPLE_SIZE) return 0;
   \                     ??ValidateOptions_4: (+1)
   \   0000002A   0x8888             LDRH     R0,[R1, #+4]
   \   0000002C   0xF5B0 0x5FFA      CMP      R0,#+8000
   \   00000030   0xD001             BEQ.N    ??ValidateOptions_5
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xE02C             B.N      ??ValidateOptions_2
    431            if(pOptions->bAsciiMode > 1) return 0;
   \                     ??ValidateOptions_5: (+1)
   \   00000036   0x7988             LDRB     R0,[R1, #+6]
   \   00000038   0x2802             CMP      R0,#+2
   \   0000003A   0xDB01             BLT.N    ??ValidateOptions_6
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE027             B.N      ??ValidateOptions_2
    432            if(pOptions->bBlinkingLEDs > 1) return 0;
   \                     ??ValidateOptions_6: (+1)
   \   00000040   0x79C8             LDRB     R0,[R1, #+7]
   \   00000042   0x2802             CMP      R0,#+2
   \   00000044   0xDB01             BLT.N    ??ValidateOptions_7
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xE022             B.N      ??ValidateOptions_2
    433            if(pOptions->u8OutputPower != OUTPUT_POWER) return 0;
   \                     ??ValidateOptions_7: (+1)
   \   0000004A   0x7A08             LDRB     R0,[R1, #+8]
   \   0000004C   0x2864             CMP      R0,#+100
   \   0000004E   0xD001             BEQ.N    ??ValidateOptions_8
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xE01D             B.N      ??ValidateOptions_2
    434            if(pOptions->u32PngTimeout != PNG_TIMEOUT) return 0;
   \                     ??ValidateOptions_8: (+1)
   \   00000054   0x68C8             LDR      R0,[R1, #+12]
   \   00000056   0xF248 0x02E8      MOVW     R2,#+33000
   \   0000005A   0x4290             CMP      R0,R2
   \   0000005C   0xD001             BEQ.N    ??ValidateOptions_9
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xE016             B.N      ??ValidateOptions_2
    435            if(pOptions->u32SndTimeout != SND_TIMEOUT) return 0;
   \                     ??ValidateOptions_9: (+1)
   \   00000062   0x6908             LDR      R0,[R1, #+16]
   \   00000064   0x.... 0x....      LDR.W    R2,??DataTable17_1  ;; 0x28488
   \   00000068   0x4290             CMP      R0,R2
   \   0000006A   0xD001             BEQ.N    ??ValidateOptions_10
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xE00F             B.N      ??ValidateOptions_2
    436            if(pOptions->bLNAHighGainMode != 1) return 0; // i.e. Low Noise Amplifier - updated *** 10/26/10 *** (formerly "u8Reserved2")
   \                     ??ValidateOptions_10: (+1)
   \   00000070   0x7D08             LDRB     R0,[R1, #+20]
   \   00000072   0x2801             CMP      R0,#+1
   \   00000074   0xD001             BEQ.N    ??ValidateOptions_11
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xE00A             B.N      ??ValidateOptions_2
    437            if(pOptions->u16SleepAfterAck > 3000|| pOptions->u16SleepAfterAck < 3) return 0;
   \                     ??ValidateOptions_11: (+1)
   \   0000007A   0x8AC8             LDRH     R0,[R1, #+22]
   \   0000007C   0xF640 0x32B9      MOVW     R2,#+3001
   \   00000080   0x4290             CMP      R0,R2
   \   00000082   0xDA02             BGE.N    ??ValidateOptions_12
   \   00000084   0x8AC8             LDRH     R0,[R1, #+22]
   \   00000086   0x2803             CMP      R0,#+3
   \   00000088   0xDA01             BGE.N    ??ValidateOptions_13
   \                     ??ValidateOptions_12: (+1)
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xE000             B.N      ??ValidateOptions_2
    438            return 1;
   \                     ??ValidateOptions_13: (+1)
   \   0000008E   0x2001             MOVS     R0,#+1
   \                     ??ValidateOptions_2: (+1)
   \   00000090   0x4770             BX       LR               ;; return
    439          }/*ValidateOptions*/
    440          

   \                                 In section .text, align 2, keep-with-next
    441          void ChangeOptions(tOptions* pOptions)
    442          {
   \                     ChangeOptions: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    443              
    444            // Are the new options different from the old/current options?
    445            if (memcmp(pOptions, &gOptions, sizeof(tOptions)) != 0)
   \   00000004   0x2218             MOVS     R2,#+24
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       memcmp
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD00D             BEQ.N    ??ChangeOptions_0
    446              {
    447          //        TRACE("\r\nConfiguration OPTIONS will be changed\r\n");
    448                  
    449                  // Save the new options
    450                  gOptions = *pOptions;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   00000018   0x0021             MOVS     R1,R4
   \   0000001A   0x2218             MOVS     R2,#+24
   \   0000001C   0x.... 0x....      BL       __aeabi_memcpy4
    451                  
    452                  // Save new options to FLASH memory
    453                  FlashSaveOptions();
   \   00000020   0x.... 0x....      BL       FlashSaveOptions
    454                  
    455                  // Make sure all of the options changes will be in effect
    456          //        RadioInitNew(); // added *** 10/27/10 ***
    457          //        (void)MLMEMC13192PAOutputAdjust(gOptions.u8OutputPower);
    458                  gRxTimeout = gOptions.u32SndTimeout;    // usual timeout value, i.e., timeout for SND packets
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   00000028   0x6900             LDR      R0,[R0, #+16]
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable18
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    459                  
    460                  // Updated *** 06/20/11 ***
    461                  // Whenever options change, flush the sending of raw data packets
    462           /*
    463                  gRawSnd.rawSpinCount = gOptions.u8RawSpinCount;
    464                  gRawSnd.axis = 3;     // Note: 1 = X-axis, 2 = Y-axis, 3 = Z-axis
    465                  gRawSnd.blockNo = 16; // Note: raw data is sent in blocks numbered 1 thru 16 (0 means not ready)
    466          */        
    467              }
    468              
    469              // Inform pan coordinator of our new configuration options
    470              SendCurrentOptions();
   \                     ??ChangeOptions_0: (+1)
   \   00000030   0x.... 0x....      BL       SendCurrentOptions
    471          
    472              return;
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    473          }//ChangeOptions
    474          

   \                                 In section .text, align 2, keep-with-next
    475          smacErrors_t SendCurrentOptions(){
   \                     SendCurrentOptions: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    476              
    477              gOpt.options = gOptions;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   0000000A   0x2218             MOVS     R2,#+24
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy4
    478              OptSwapEndianness(&gOpt.options);
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   00000014   0x.... 0x....      BL       OptSwapEndianness
    479              gOpt.hdr.u16SensorID = gOpt.hdr.u16SensorID << 8 | gOpt.hdr.u16SensorID>>8;
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   0000001C   0x8880             LDRH     R0,[R0, #+4]
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable16_6
   \   00000022   0x8889             LDRH     R1,[R1, #+4]
   \   00000024   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000026   0x0A09             LSRS     R1,R1,#+8
   \   00000028   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable16_6
   \   00000030   0x8088             STRH     R0,[R1, #+4]
    480              
    481              CopyOptPacketToSMAC();
   \   00000032   0x.... 0x....      BL       CopyOptPacketToSMAC
    482              // Get ready to send the configuration options SND packet
    483           //   gAppTxPacket->u8DataLength = sizeof(gOpt);
    484          //    gAppTxPacket->smacPdu.u8Data = (uint8_t*)&gOpt;
    485              return MCPSDataRequest(gAppTxPacket); // transmit data
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x.... 0x....      BL       MCPSDataRequest
   \   00000040   0xBD02             POP      {R1,PC}          ;; return
    486              
    487              // Note: even though the pan coordinator may acknowledge this message,
    488              // we don't need to wait for it, because the sensor data SND messages
    489              // are sent much more frequently, so we'll ignore any ACK here.
    490            
    491              
    492          }//SendCurrentOptions
    493          
    494          
    495          
    496          
    497          #if (gEnableLowPower_d == TRUE)
    498          /************************************************************************************
    499          *
    500          * WUApp_LowPwrStateMachine
    501          *
    502          ************************************************************************************/
    503          #if (TRUE == gEnableConfigMenus_d)

   \                                 In section .text, align 2, keep-with-next
    504          void WUApp_LowPwrStateMachine (void) 
    505          {
   \                     WUApp_LowPwrStateMachine: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    506            switch (gLPConfigState)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable16_7
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD005             BEQ.N    ??WUApp_LowPwrStateMachine_0
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD01B             BEQ.N    ??WUApp_LowPwrStateMachine_1
   \   00000010   0xD30B             BCC.N    ??WUApp_LowPwrStateMachine_2
   \   00000012   0x2803             CMP      R0,#+3
   \   00000014   0xD056             BEQ.N    ??WUApp_LowPwrStateMachine_3
   \   00000016   0xE06B             B.N      ??WUApp_LowPwrStateMachine_4
    507            {
    508              case gWULPStateInit_c:
    509                     gLPConfigState = gWULPStateGotoLowPower_c;	 
   \                     ??WUApp_LowPwrStateMachine_0: (+1)
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
    510                     WUApp_InitLowPowerMode(); /*Select low power mode to using in the state machine*/ 
   \   00000020   0x.... 0x....      BL       WUApp_InitLowPowerMode
    511                     WUApp_InitWakupSource();  /*Select the way MCU wakeup from low power*/
   \   00000024   0x.... 0x....      BL       WUApp_InitWakupSource
    512                     /*this is the part that i can change how and when to wake up the processor i think this is important fo waking the proccessor!!!!!!!!!!!!!!!#*/
    513              break;
   \   00000028   0xE06A             B.N      ??WUApp_LowPwrStateMachine_5
    514              
    515              case gWULPStateWait4Options_c:
    516                      
    517                      evDataFromCOMM = FALSE;                  
   \                     ??WUApp_LowPwrStateMachine_2: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable15_1
   \   00000030   0x7008             STRB     R0,[R1, #+0]
    518                      bGotoLowPwrFlag = TRUE;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable16_8
   \   00000038   0x7008             STRB     R0,[R1, #+0]
    519                      gLPConfigState = gLastLPConfigState;
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable16_9
   \   0000003E   0x7800             LDRB     R0,[R0, #+0]
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \   00000044   0x7008             STRB     R0,[R1, #+0]
    520                      
    521              break;
   \   00000046   0xE05B             B.N      ??WUApp_LowPwrStateMachine_5
    522              
    523              case gWULPStateGotoLowPower_c:
    524                      if (!bGotoLowPwrFlag){
   \                     ??WUApp_LowPwrStateMachine_1: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD115             BNE.N    ??WUApp_LowPwrStateMachine_6
    525                        PrintMenu((char * const *)pu8GotoLowPowerString, gDefaultCommPort_c);
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable16_10
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x.... 0x....      BL       PrintMenu
    526                        PrintMenu(cau8WUContinueAskString, gDefaultCommPort_c);
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable16_11
   \   00000064   0x.... 0x....      BL       PrintMenu
    527                        gLastLPConfigState = gLPConfigState;
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable16_7
   \   0000006C   0x7800             LDRB     R0,[R0, #+0]
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable16_9
   \   00000072   0x7008             STRB     R0,[R1, #+0]
    528                        gLPConfigState = gWULPStateWait4Options_c;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \   0000007A   0x7008             STRB     R0,[R1, #+0]
   \   0000007C   0xE021             B.N      ??WUApp_LowPwrStateMachine_7
    529                      }
    530                      else{
    531                        PrintMenu ((char * const *)pu8NowInLowPowerString, gDefaultCommPort_c);
   \                     ??WUApp_LowPwrStateMachine_6: (+1)
   \   0000007E   0x2101             MOVS     R1,#+1
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable16_12
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x.... 0x....      BL       PrintMenu
    532                        PrintMenu ((char * const *)pu8WakeupSourceString, gDefaultCommPort_c);
   \   0000008A   0x2101             MOVS     R1,#+1
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0x.... 0x....      BL       PrintMenu
    533                        WUApp_LowPowerWhile(); /*Go to Low Power and remain until wake up*/
   \   00000096   0x.... 0x....      BL       WUApp_LowPowerWhile
    534                        
    535                        /*If didn't wakeup from reset, continue here.*/
    536                        LED_StartSerialFlash();
   \   0000009A   0x.... 0x....      BL       LED_StartSerialFlash
    537                        TMR_StartSingleShotTimer(mLEDTimerID_1, mLEDInterval1_c, AppLedTimerCallback);
   \   0000009E   0x.... 0x....      LDR.W    R2,??DataTable17_2
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable17_3
   \   000000A6   0x8801             LDRH     R1,[R0, #+0]
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   000000AC   0x7800             LDRB     R0,[R0, #+0]
   \   000000AE   0x.... 0x....      BL       TMR_StartSingleShotTimer
    538          
    539                        bGotoLowPwrFlag = FALSE; 
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable16_8
   \   000000B8   0x7008             STRB     R0,[R1, #+0]
    540                        gConfigState = gWUConfigStateMainMenu_c;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable20
   \   000000C0   0x7008             STRB     R0,[R1, #+0]
    541                      }        
    542              break;    
   \                     ??WUApp_LowPwrStateMachine_7: (+1)
   \   000000C2   0xE01D             B.N      ??WUApp_LowPwrStateMachine_5
    543           
    544              case gWULPStateInvalid_c:
    545                      PrintMenu(cau8WUInvalidValueString, gDefaultCommPort_c); 
   \                     ??WUApp_LowPwrStateMachine_3: (+1)
   \   000000C4   0x2101             MOVS     R1,#+1
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable17_5
   \   000000CA   0x.... 0x....      BL       PrintMenu
    546                      if(gWULPStateWait4Options_c == gLastLPConfigState){
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable16_9
   \   000000D2   0x7800             LDRB     R0,[R0, #+0]
   \   000000D4   0x2801             CMP      R0,#+1
   \   000000D6   0xD104             BNE.N    ??WUApp_LowPwrStateMachine_8
    547                            PrintMenu(cau8WUWait4Option, gDefaultCommPort_c);
   \   000000D8   0x2101             MOVS     R1,#+1
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable17_6
   \   000000DE   0x.... 0x....      BL       PrintMenu
    548                      }
    549                      gLPConfigState = gLastLPConfigState;
   \                     ??WUApp_LowPwrStateMachine_8: (+1)
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable16_9
   \   000000E6   0x7800             LDRB     R0,[R0, #+0]
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \   000000EC   0x7008             STRB     R0,[R1, #+0]
    550              break;
   \   000000EE   0xE007             B.N      ??WUApp_LowPwrStateMachine_5
    551              
    552              default:
    553                gLPConfigState = gWULPStateGotoLowPower_c;
   \                     ??WUApp_LowPwrStateMachine_4: (+1)
   \   000000F0   0x2002             MOVS     R0,#+2
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \   000000F6   0x7008             STRB     R0,[R1, #+0]
    554                gConfigState = gWUConfigStateMainMenu_c;  /* Exit valve in case of Error */	        
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable20
   \   000000FE   0x7008             STRB     R0,[R1, #+0]
    555              break;
    556              
    557            } 
    558          }
   \                     ??WUApp_LowPwrStateMachine_5: (+1)
   \   00000100   0xBD01             POP      {R0,PC}          ;; return
    559          #endif
    560          #endif
    561          
    562          
    563          
    564          

   \                                 In section .text, align 2, keep-with-next
    565          void InitAccelControlls(){
    566           /*
    567          Initilizes the GPIO's that controll the  power in the Accelerommeter.
    568          This initilizes PTD1 and PTD 5 as GPIO's with output functionality and active low performance.
    569          */
    570                  //enable the clock gating to the module.
    571                  gLED_ClkGatingReg_c |= gLED_ClkGatingBit_c; 
   \                     InitAccelControlls: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable17_7  ;; 0x40048038
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable17_7  ;; 0x40048038
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    572                  //enable the conenctions, and enable the clock to the PTD output
    573                  gAccelEnableControlReg_c &= ~PORT_PCR_MUX_MASK;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable17_8  ;; 0x4004c004
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF430 0x60E0      BICS     R0,R0,#0x700
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable17_8  ;; 0x4004c004
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    574                  gAccelEnableControlReg_c |= PORT_PCR_MUX(gLED_PinCtrlAltFunc_c);
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable17_8  ;; 0x4004c004
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable17_8  ;; 0x4004c004
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    575                  gAccelPowerControlReg_c &= ~PORT_PCR_MUX_MASK;
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable17_9  ;; 0x4004c014
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0xF430 0x60E0      BICS     R0,R0,#0x700
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable17_9  ;; 0x4004c014
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    576                  gAccelPowerControlReg_c |= PORT_PCR_MUX(gLED_PinCtrlAltFunc_c);
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable17_9  ;; 0x4004c014
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable17_9  ;; 0x4004c014
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    577                  
    578                  
    579                  /*Pins direction -> output */
    580                  gLED_PortDataDirReg_c |= (gAccelPower | gAccelEnable);
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x400ff0d4
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0xF050 0x0022      ORRS     R0,R0,#0x22
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x400ff0d4
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    581                  /*turn off all outputs */
    582                  gLED_PortDataOutReg_c |= (gAccelPower | gAccelEnable);
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable20_1  ;; 0x400ff0c0
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0xF050 0x0022      ORRS     R0,R0,#0x22
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable20_1  ;; 0x400ff0c0
   \   0000006E   0x6008             STR      R0,[R1, #+0]
    583            
    584          }/*void InitAccelControlls()*/
   \   00000070   0x4770             BX       LR               ;; return
    585          
    586          

   \                                 In section .text, align 2, keep-with-next
    587          void GetDeviceData()
    588          {
   \                     GetDeviceData: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    589            
    590            int TempTempVal =0;
   \   00000002   0x2400             MOVS     R4,#+0
    591            int TempBat =0;
   \   00000004   0x2500             MOVS     R5,#+0
    592            //filteringCode  =0;
    593            
    594              /*for the regular data smapling we might want to make the change so that it will sample at the rate in gOptions.sampleRate
    595                the filtering code below needs to run at 20Khz at all times though that will not change*/
    596            
    597              AXIS =1 ;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    598             /*first want to get the max average and other values at 8KHz and then teansition into 20KHz*/
    599              INIT_PIT((uint32_t) 5999);        /*this is the 8K Hz*/
   \   0000000E   0xF241 0x706F      MOVW     R0,#+5999
   \   00000012   0x.... 0x....      BL       INIT_PIT
    600              NVIC_EnableIRQ(48);
   \   00000016   0x2030             MOVS     R0,#+48
   \   00000018   0x.... 0x....      BL       NVIC_EnableIRQ
    601              
    602              
    603              AXIS = 1;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   00000022   0x6008             STR      R0,[R1, #+0]
    604              PIT_ITTERATIONS =0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    605              
    606              while(PIT_ITTERATIONS < ACCEL_SAMPLE_SIZE)
   \                     ??GetDeviceData_0: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable13_4
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF5B0 0x5FFA      CMP      R0,#+8000
   \   00000036   0xDBF9             BLT.N    ??GetDeviceData_0
    607              {
    608                // X Y and Z to complete wait for the conversions to finish before continuing
    609              }
    610              AXIS =0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    611              gSnd.xmean = (uint16_t)((TempSumx + (ACCEL_SAMPLE_SIZE >>1))/ ACCEL_SAMPLE_SIZE);
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF510 0x607A      ADDS     R0,R0,#+4000
   \   0000004A   0xF44F 0x51FA      MOV      R1,#+8000
   \   0000004E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000056   0x8188             STRH     R0,[R1, #+12]
    612              
    613              
    614              gSnd.ymean = (uint16_t)((TempSumy + (ACCEL_SAMPLE_SIZE >>1))/ ACCEL_SAMPLE_SIZE);
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0xF510 0x607A      ADDS     R0,R0,#+4000
   \   00000062   0xF44F 0x51FA      MOV      R1,#+8000
   \   00000066   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000006E   0x8388             STRH     R0,[R1, #+28]
    615              
    616              
    617              gSnd.zmean = (uint16_t)((TempSumz + (ACCEL_SAMPLE_SIZE >>1))/ ACCEL_SAMPLE_SIZE);
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0xF510 0x607A      ADDS     R0,R0,#+4000
   \   0000007A   0xF44F 0x51FA      MOV      R1,#+8000
   \   0000007E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000086   0x8588             STRH     R0,[R1, #+44]
    618              
    619             /*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    620              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    621              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    622              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    623              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    624              *
    625              *This is where the filtering code needs to be enetered when we want to implement filtering again.
    626              *
    627              *
    628              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    629              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    630              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    631              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    632              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    633              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    634              */
    635              
    636              /*stop the timer and finish the temp and battery conversion and then send the data that was packed*/
    637              NVIC_DisableIRQ(48);
   \   00000088   0x2030             MOVS     R0,#+48
   \   0000008A   0x.... 0x....      BL       NVIC_DisableIRQ
    638                
    639                
    640              
    641              StartTempConversion();
   \   0000008E   0x.... 0x....      BL       StartTempConversion
    642              
    643              while(ConversionAComplete()==0){
   \                     ??GetDeviceData_1: (+1)
   \   00000092   0x.... 0x....      BL       ConversionAComplete
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD0FB             BEQ.N    ??GetDeviceData_1
    644              }
    645              TempTempVal = GetConversionValue();
   \   0000009A   0x.... 0x....      BL       GetConversionValue
   \   0000009E   0x0004             MOVS     R4,R0
    646              gSnd.temperature = 373 - (int16_t)((uint32_t)(TempTempVal) * 37800/84909)  ;
   \   000000A0   0xF240 0x1075      MOVW     R0,#+373
   \   000000A4   0xF249 0x31A8      MOVW     R1,#+37800
   \   000000A8   0xFB01 0xF104      MUL      R1,R1,R4
   \   000000AC   0x.... 0x....      LDR.W    R2,??DataTable18_2  ;; 0x14bad
   \   000000B0   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   000000B4   0x1A40             SUBS     R0,R0,R1
   \   000000B6   0x.... 0x....      LDR.W    R1,??DataTable16
   \   000000BA   0x8708             STRH     R0,[R1, #+56]
    647              
    648              /*now that the conversions are finished measure the voltage over the battery using adc 7 */
    649              StartBattConversion();
   \   000000BC   0x.... 0x....      BL       StartBattConversion
    650              while(ConversionAComplete()==0){
   \                     ??GetDeviceData_2: (+1)
   \   000000C0   0x.... 0x....      BL       ConversionAComplete
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD0FB             BEQ.N    ??GetDeviceData_2
    651              }
    652              TempBat = GetConversionValue();
   \   000000C8   0x.... 0x....      BL       GetConversionValue
   \   000000CC   0x0005             MOVS     R5,R0
    653              gSnd.battery_mV = (uint16_t)((uint32_t)(TempBat) * 4200 / 1023);
   \   000000CE   0xF241 0x0068      MOVW     R0,#+4200
   \   000000D2   0xFB00 0xF005      MUL      R0,R0,R5
   \   000000D6   0xF240 0x31FF      MOVW     R1,#+1023
   \   000000DA   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable16
   \   000000E2   0x8748             STRH     R0,[R1, #+58]
    654          
    655              
    656              
    657              
    658          }/*void GetDeviceData()*/
   \   000000E4   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    659          
    660          /*
    661          
    662          inits the pit timmer
    663          */

   \                                 In section .text, align 2, keep-with-next
    664          void INIT_PIT(uint32_t SampleSpeed)
    665          {
   \                     INIT_PIT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    666            NVIC_DisableIRQ(48);
   \   00000004   0x2030             MOVS     R0,#+48
   \   00000006   0x.... 0x....      BL       NVIC_DisableIRQ
    667            
    668            //set bit 24 in scgc6
    669            SIM_SCGC6 |= (uint32_t)(1<<23);
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x4004803c
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF450 0x0000      ORRS     R0,R0,#0x800000
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable18_3  ;; 0x4004803c
   \   00000018   0x6008             STR      R0,[R1, #+0]
    670            
    671            
    672            PIT_MCR = (uint32_t)0x1;                  //enable the freexe bit and enable the clock for standard pit timer
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable18_4  ;; 0x40037000
   \   00000020   0x6008             STR      R0,[R1, #+0]
    673            PIT_LDVAL0 = SampleSpeed;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable18_5  ;; 0x40037100
   \   00000026   0x6004             STR      R4,[R0, #+0]
    674            PIT_TCTRL0 = (uint32_t)0x3;                   //enable the timer and inable the timer interupt diable the cahin mode
   \   00000028   0x2003             MOVS     R0,#+3
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable18_6  ;; 0x40037108
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    675            
    676            
    677            
    678            PIT_TFLG0  = (uint32_t)0x1;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable24  ;; 0x4003710c
   \   00000036   0x6008             STR      R0,[R1, #+0]
    679            NVIC_SetPriority(48, 0);
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x2030             MOVS     R0,#+48
   \   0000003C   0x.... 0x....      BL       NVIC_SetPriority
    680            NVIC_EnableIRQ(48);
   \   00000040   0x2030             MOVS     R0,#+48
   \   00000042   0x.... 0x....      BL       NVIC_EnableIRQ
    681          }
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
    682          
    683          
    684          
    685          /*This is the Pit ISR, It will take samples of the ADC 8000 times in 1 second these two values will eventually 
    686          be modifiable using vibe.
    687          
    688          There will be a Golbal boolean that needs to be set when the value is at 8000 itterations, it needs to be reset when the program starts up
    689          
    690          */
    691          

   \                                 In section .text, align 2, keep-with-next
    692          void PIT_ISR()
    693          {
   \                     PIT_ISR: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    694            int TempXVal =0;
   \   00000002   0x2400             MOVS     R4,#+0
    695            int TempYVal =0;
   \   00000004   0x2500             MOVS     R5,#+0
    696            int TempZVal =0;  
   \   00000006   0x2600             MOVS     R6,#+0
    697            
    698            
    699            /*GreenStatLedOn();*/
    700          
    701          /*this is just set to do the 8 k samples it will not run the filtering code.
    702            */
    703            
    704                  /*need to take the sampling at 8KHz and find the min and max values here*/
    705                  /*need take 10,000 samples for the x conversion and save the raw values into the q15_t temp value thing */
    706                if(PIT_ITTERATIONS <= ACCEL_SAMPLE_SIZE && AXIS==1)
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable13_4
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF5B0 0x5FFA      CMP      R0,#+8000
   \   00000012   0xDC6B             BGT.N    ??PIT_ISR_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD166             BNE.N    ??PIT_ISR_0
    707                {
    708                //take the converstion values forom the a to d converter an then increment the number of ittereantion
    709                    StartXConversion();
   \   0000001E   0x.... 0x....      BL       StartXConversion
    710                    while(ConversionAComplete()==0){
   \                     ??PIT_ISR_1: (+1)
   \   00000022   0x.... 0x....      BL       ConversionAComplete
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD0FB             BEQ.N    ??PIT_ISR_1
    711                    }
    712                    TempXVal = GetConversionValue();
   \   0000002A   0x.... 0x....      BL       GetConversionValue
   \   0000002E   0x0004             MOVS     R4,R0
    713                     
    714                    
    715                    if(TempXVal > gSnd.xmax)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000034   0x8940             LDRH     R0,[R0, #+10]
   \   00000036   0x42A0             CMP      R0,R4
   \   00000038   0xDA02             BGE.N    ??PIT_ISR_2
    716                    {
    717                      gSnd.xmax = TempXVal;
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000003E   0x8144             STRH     R4,[R0, #+10]
    718                    }
    719                    if(TempXVal < gSnd.xmin)
   \                     ??PIT_ISR_2: (+1)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000044   0x8900             LDRH     R0,[R0, #+8]
   \   00000046   0x4284             CMP      R4,R0
   \   00000048   0xDA02             BGE.N    ??PIT_ISR_3
    720                    {
    721                      gSnd.xmin = TempXVal;
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000004E   0x8104             STRH     R4,[R0, #+8]
    722                    }
    723                    TempSumx += TempXVal;  
   \                     ??PIT_ISR_3: (+1)
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x1820             ADDS     R0,R4,R0
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable13
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    724                
    725                
    726                    StartYConversion();
   \   0000005E   0x.... 0x....      BL       StartYConversion
    727                    while(ConversionAComplete()==0){
   \                     ??PIT_ISR_4: (+1)
   \   00000062   0x.... 0x....      BL       ConversionAComplete
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD0FB             BEQ.N    ??PIT_ISR_4
    728                    }   
    729                    TempYVal = GetConversionValue();
   \   0000006A   0x.... 0x....      BL       GetConversionValue
   \   0000006E   0x0005             MOVS     R5,R0
    730                         
    731                    /*check th eY max and the Y Min */
    732                    if(TempYVal > gSnd.ymax)
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000074   0x8B40             LDRH     R0,[R0, #+26]
   \   00000076   0x42A8             CMP      R0,R5
   \   00000078   0xDA02             BGE.N    ??PIT_ISR_5
    733                    {
    734                      gSnd.ymax = TempYVal;
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000007E   0x8345             STRH     R5,[R0, #+26]
    735                    }
    736                    if(TempYVal < gSnd.ymin)
   \                     ??PIT_ISR_5: (+1)
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000084   0x8B00             LDRH     R0,[R0, #+24]
   \   00000086   0x4285             CMP      R5,R0
   \   00000088   0xDA02             BGE.N    ??PIT_ISR_6
    737                    {
    738                      gSnd.ymin = TempYVal;
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000008E   0x8305             STRH     R5,[R0, #+24]
    739                    }
    740                    TempSumy += TempYVal;
   \                     ??PIT_ISR_6: (+1)
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0x1828             ADDS     R0,R5,R0
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \   0000009C   0x6008             STR      R0,[R1, #+0]
    741                
    742                
    743                    StartZConversion();
   \   0000009E   0x.... 0x....      BL       StartZConversion
    744                    while(ConversionAComplete()==0){
   \                     ??PIT_ISR_7: (+1)
   \   000000A2   0x.... 0x....      BL       ConversionAComplete
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD0FB             BEQ.N    ??PIT_ISR_7
    745                    }
    746                    TempZVal = GetConversionValue();
   \   000000AA   0x.... 0x....      BL       GetConversionValue
   \   000000AE   0x0006             MOVS     R6,R0
    747                    /*Check the Z max and the Z min*/
    748                    if(TempZVal > gSnd.zmax)
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000B4   0x8D40             LDRH     R0,[R0, #+42]
   \   000000B6   0x42B0             CMP      R0,R6
   \   000000B8   0xDA02             BGE.N    ??PIT_ISR_8
    749                    {
    750                      gSnd.zmax = TempZVal;
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000BE   0x8546             STRH     R6,[R0, #+42]
    751                    }
    752                    if(TempZVal < gSnd.zmin)
   \                     ??PIT_ISR_8: (+1)
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000C4   0x8D00             LDRH     R0,[R0, #+40]
   \   000000C6   0x4286             CMP      R6,R0
   \   000000C8   0xDA02             BGE.N    ??PIT_ISR_9
    753                    {
    754                      gSnd.zmin = TempZVal;
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000CE   0x8506             STRH     R6,[R0, #+40]
    755                    }
    756                    TempSumz += TempZVal; 
   \                     ??PIT_ISR_9: (+1)
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0x1830             ADDS     R0,R6,R0
   \   000000D8   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000000DC   0x6008             STR      R0,[R1, #+0]
    757                
    758                
    759                
    760                
    761                PIT_ITTERATIONS ++;
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable13_4
   \   000000E2   0x6800             LDR      R0,[R0, #+0]
   \   000000E4   0x1C40             ADDS     R0,R0,#+1
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   000000EA   0x6008             STR      R0,[R1, #+0]
    762                }
    763                  
    764             
    765          
    766            
    767            /*the changing of axis will be handled in the main code. this needs to be done there since I need to calculate other tings there using the filter as well. */
    768            PIT_TFLG0  = (uint32_t)0x1;           //clears the interupt flag and will start a new 
   \                     ??PIT_ISR_0: (+1)
   \   000000EC   0x2001             MOVS     R0,#+1
   \   000000EE   0x.... 0x....      LDR.W    R1,??DataTable24  ;; 0x4003710c
   \   000000F2   0x6008             STR      R0,[R1, #+0]
    769            /*GreenStatLedOff();*/
    770          }
   \   000000F4   0xBD70             POP      {R4-R6,PC}       ;; return
    771          
    772          
    773          //return random number 0-15

   \                                 In section .text, align 2, keep-with-next
    774          uint8_t GetRandomNibble()
    775          {
    776              static uint8_t b=0;
    777              uint8_t* p = (uint8_t*) 0x1fff9200;
   \                     GetRandomNibble: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable20_2  ;; 0x1fff9200
    778             
    779              while (p> (uint8_t*) 0x1fff80f0)
   \                     ??GetRandomNibble_0: (+1)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable20_3  ;; 0x1fff80f1
   \   00000008   0x4281             CMP      R1,R0
   \   0000000A   0xD309             BCC.N    ??GetRandomNibble_1
    780              {
    781                --p;
   \   0000000C   0x1E49             SUBS     R1,R1,#+1
    782                
    783                  b ^= *p;    // xor "b" with next byte of memory
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x780A             LDRB     R2,[R1, #+0]
   \   00000016   0x4050             EORS     R0,R2,R0
   \   00000018   0x.... 0x....      LDR.W    R2,??DataTable25
   \   0000001C   0x7010             STRB     R0,[R2, #+0]
   \   0000001E   0xE7F1             B.N      ??GetRandomNibble_0
    784              }
    785              return (b >> 4) ^ (b & 15); // return left-nibble xor'ed with right-nibble (4 random bits)
   \                     ??GetRandomNibble_1: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable25
   \   0000002C   0x7812             LDRB     R2,[R2, #+0]
   \   0000002E   0xF012 0x020F      ANDS     R2,R2,#0xF
   \   00000032   0xEA92 0x1010      EORS     R0,R2,R0, LSR #+4
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x4770             BX       LR               ;; return
    786          }

   \                                 In section .bss, align 1
   \                     ??b:
   \   00000000                      DS8 1

   \                                 In section .text, align 2, keep-with-next
    787          int8_t GetLinkQdBm()
    788          {
   \                     GetLinkQdBm: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    789              // Get link quality (dBm) from last successful RX packet
    790            uint8_t quality;
    791           //   return (int8_t)((-(int16_t)MLMELinkQuality()) >> 1); // Note: "floor", not truncation
    792            MLMELinkQuality(&quality);
   \   00000002   0xA800             ADD      R0,SP,#+0
   \   00000004   0x.... 0x....      BL       MLMELinkQuality
    793            return quality;
   \   00000008   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
    794          }

   \                                 In section .text, align 2, keep-with-next
    795          uint8_t getRandomNumberInRange(uint8_t low,uint8_t high){
    796            if(high <= low) return low;
   \                     getRandomNumberInRange: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD301             BCC.N    ??getRandomNumberInRange_0
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0xE009             B.N      ??getRandomNumberInRange_1
    797            uint32_t random;
    798          //  RNG_GetRandomNo(&random);
    799          //  CR[INTM]=1;
    800            return low + (uint8_t)(random % (high - low + 1));    
                                          ^
Warning[Pe549]: variable "random" is used before its value is set
   \                     ??getRandomNumberInRange_0: (+1)
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x1A09             SUBS     R1,R1,R0
   \   00000012   0x1C49             ADDS     R1,R1,#+1
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0xFBB2 0xF2F1      UDIV     R2,R2,R1
   \   0000001A   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??getRandomNumberInRange_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return
    801          }
    802          

   \                                 In section .text, align 2, keep-with-next
    803          uint8_t ChooseBestChannel()
    804          {
   \                     ChooseBestChannel: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
    805            //RNG_Init();  
    806              uint8_t   channelStatus = INITIAL_VALUE;   // something other than SUCCESS
   \   00000004   0x2400             MOVS     R4,#+0
    807              uint8_t   channel = 0;
   \   00000006   0x2500             MOVS     R5,#+0
    808              uint8_t   iter;
    809              channels_t iChannel;
    810              //
    811              // Updated *** 10/26/10 ***
    812              // Note: all calls now go thru "GetLinkQdBm"
    813              //
    814              int8_t    maxLinkQdBm;
    815              
    816              
    817              // Get ready to send the PNG packet
    818              gAppTxPacket->u8DataLength = PNG_SIZE;
   \   00000008   0x2005             MOVS     R0,#+5
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable18_1
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   \   00000010   0x7008             STRB     R0,[R1, #+0]
    819              PngSwapEndianness();
   \   00000012   0x.... 0x....      BL       PngSwapEndianness
    820              CopyPngPacketToSMAC();
   \   00000016   0x.... 0x....      BL       CopyPngPacketToSMAC
    821              
    822              // Note: we don't want to wait very long between testing each channel,
    823              // so temporarily change the timeout to a low value
    824              gRxTimeout = gOptions.u32PngTimeout;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   0000001E   0x68C0             LDR      R0,[R0, #+12]
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable18
   \   00000024   0x6008             STR      R0,[R1, #+0]
    825              
    826              // Find channel with the best link quality
    827              maxLinkQdBm = -128;
   \   00000026   0xF07F 0x007F      MVNS     R0,#+127
   \   0000002A   0x4680             MOV      R8,R0
    828              channel=GetRandomNibble();
   \   0000002C   0x.... 0x....      BL       GetRandomNibble
   \   00000030   0x0005             MOVS     R5,R0
    829              smacErrors_t smacStatus;
    830              for (iter = 0; iter < 64; iter++) {
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x0006             MOVS     R6,R0
   \                     ??ChooseBestChannel_0: (+1)
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x2E40             CMP      R6,#+64
   \   0000003A   0xDA3C             BGE.N    ??ChooseBestChannel_1
    831                  smacStatus=gErrorBusy_c;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x4681             MOV      R9,R0
    832                  channel = (channel + 1) & 15;
   \   00000040   0x1C68             ADDS     R0,R5,#+1
   \   00000042   0xF010 0x050F      ANDS     R5,R0,#0xF
    833           //       channel=0;
    834                  iChannel=channel+gChannel11_c;
                                 ^
Warning[Pe188]: enumerated type mixed with another type
   \   00000046   0xF115 0x000B      ADDS     R0,R5,#+11
   \   0000004A   0x0007             MOVS     R7,R0
    835                  
    836                  while(smacStatus!=gErrorNoError_c){
   \                     ??ChooseBestChannel_2: (+1)
   \   0000004C   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000050   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000054   0xD005             BEQ.N    ??ChooseBestChannel_3
    837                    smacStatus=MLMESetChannelRequest(iChannel);
   \   00000056   0x0038             MOVS     R0,R7
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0x.... 0x....      BL       MLMESetChannelRequest
   \   0000005E   0x4681             MOV      R9,R0
   \   00000060   0xE7F4             B.N      ??ChooseBestChannel_2
    838                  }
    839                  smacStatus=gErrorBusy_c;
   \                     ??ChooseBestChannel_3: (+1)
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0x4681             MOV      R9,R0
    840                  //while(smacStatus!=gErrorNoError_c){
    841                    smacStatus=MCPSDataRequest(gAppTxPacket); // transmit data
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x.... 0x....      BL       MCPSDataRequest
   \   00000070   0x4681             MOV      R9,R0
    842                  //}
    843                  // NOTE: we have to keep looping here, because our PNG packets may be sent back
    844                  // to us by a REPEATER, but we should ignore them (only intereseted in ACK packets)
    845                  if(smacStatus==gErrorNoError_c){
   \   00000072   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000076   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000007A   0xD11A             BNE.N    ??ChooseBestChannel_4
    846                  
    847                  do 
    848                  {
    849                      ReceivePacket();
   \                     ??ChooseBestChannel_5: (+1)
   \   0000007C   0x.... 0x....      BL       ReceivePacket
    850                      if (gIsMyAck) 
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable26
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD00D             BEQ.N    ??ChooseBestChannel_6
    851                      {
    852                          int8_t linkQdBm = GetLinkQdBm();
   \   0000008A   0x.... 0x....      BL       GetLinkQdBm
    853                          if (linkQdBm > maxLinkQdBm)
   \   0000008E   0xFA4F 0xF888      SXTB     R8,R8            ;; SignExt  R8,R8,#+24,#+24
   \   00000092   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000094   0x4580             CMP      R8,R0
   \   00000096   0xDA06             BGE.N    ??ChooseBestChannel_6
    854                          {
    855                              maxLinkQdBm = linkQdBm;
   \   00000098   0x4680             MOV      R8,R0
    856                              gSnd.channel = iChannel;
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000009E   0xF881 0x7043      STRB     R7,[R1, #+67]
    857                              channelStatus = SUCCESS;
   \   000000A2   0x2177             MOVS     R1,#+119
   \   000000A4   0x000C             MOVS     R4,R1
    858                          }
    859                          //printf("Channel %d Link Quality %d",iChannel,linkQdBm);
    860                      }
    861                  }
    862                  while (gAppRxPacket->rxStatus != rxTimeOutStatus_c);
   \                     ??ChooseBestChannel_6: (+1)
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0x7840             LDRB     R0,[R0, #+1]
   \   000000AE   0x2803             CMP      R0,#+3
   \   000000B0   0xD1E4             BNE.N    ??ChooseBestChannel_5
    863                  }
    864              }
   \                     ??ChooseBestChannel_4: (+1)
   \   000000B2   0x1C76             ADDS     R6,R6,#+1
   \   000000B4   0xE7BF             B.N      ??ChooseBestChannel_0
    865              
    866              // Remember to restore the usual timeout value, i.e., the timeout for SND packets
    867              gRxTimeout = gOptions.u32SndTimeout;
   \                     ??ChooseBestChannel_1: (+1)
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   000000BA   0x6900             LDR      R0,[R0, #+16]
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable18
   \   000000C0   0x6008             STR      R0,[R1, #+0]
    868              
    869              // Reset channel (even if none were successful, since then it's original gChannelNumber)
    870              if (MLMESetChannelRequest(gSnd.channel) != SUCCESS) // select channel here (0-15)
                                               ^
Warning[Pe188]: enumerated type mixed with another type
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000C6   0xF890 0x0043      LDRB     R0,[R0, #+67]
   \   000000CA   0x.... 0x....      BL       MLMESetChannelRequest
   \   000000CE   0x4682             MOV      R10,R0
    871              { 
    872                  //printf("can't set channel %d",gSnd.channel);
    873              }
    874              
    875            	// Added *** 10/27/10 ***
    876              // NOTE: the most meaningful "linkQdBm" value in the first SND packet after
    877              // channel scan is "maxLinkQdBm" - see also "ReceivePacket".
    878              gSnd.linkQdBm = maxLinkQdBm;
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000D4   0xF880 0x803C      STRB     R8,[R0, #+60]
    879          
    880              // Finally, send our current options to the pan coordinator
    881              SendCurrentOptions();
   \   000000D8   0x.... 0x....      BL       SendCurrentOptions
    882              
    883              return channelStatus;  // return SUCCESS if selected channel is good
   \   000000DC   0x0020             MOVS     R0,R4
   \   000000DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E0   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    884          }
    885          

   \                                 In section .text, align 2, keep-with-next
    886          void ReceivePacket(){
   \                     ReceivePacket: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    887            appState = WAIT_FOR_ACK;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable15
   \   00000008   0x7008             STRB     R0,[R1, #+0]
    888            gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
   \   0000000A   0x207B             MOVS     R0,#+123
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x7008             STRB     R0,[R1, #+0]
    889            smacErrors_t status = MLMERXEnableRequest(gAppRxPacket, gRxTimeout);
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x.... 0x....      BL       MLMERXEnableRequest
   \   00000024   0x0004             MOVS     R4,R0
    890            while(status!=gErrorNoError_c){
   \                     ??ReceivePacket_0: (+1)
   \   00000026   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000028   0x2C00             CMP      R4,#+0
   \   0000002A   0xD009             BEQ.N    ??ReceivePacket_1
    891              status = MLMERXEnableRequest(gAppRxPacket, gRxTimeout);
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000030   0x6801             LDR      R1,[R0, #+0]
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x.... 0x....      BL       MLMERXEnableRequest
   \   0000003C   0x0004             MOVS     R4,R0
   \   0000003E   0xE7F2             B.N      ??ReceivePacket_0
    892            }
    893            
    894            while(appState == WAIT_FOR_ACK);
   \                     ??ReceivePacket_1: (+1)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000044   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD0F9             BEQ.N    ??ReceivePacket_1
    895            if(gAppRxPacket->rxStatus==rxSuccessStatus_c) {
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x7840             LDRB     R0,[R0, #+1]
   \   00000054   0x2802             CMP      R0,#+2
   \   00000056   0xD13B             BNE.N    ??ReceivePacket_2
    896              //LED_SetLed(LED3, gLedOn_c);
    897              if (gAppRxPacket->smacPdu.u8Data[0] == 'A' &&
    898                  gAppRxPacket->smacPdu.u8Data[1] == 'C' && 
    899                  gAppRxPacket->smacPdu.u8Data[2] == 'K' &&
    900                  gAppRxPacket->u8DataLength >= ACK_HEADER_SIZE)
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x7940             LDRB     R0,[R0, #+5]
   \   00000060   0x2841             CMP      R0,#+65
   \   00000062   0xD12D             BNE.N    ??ReceivePacket_3
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x7980             LDRB     R0,[R0, #+6]
   \   0000006C   0x2843             CMP      R0,#+67
   \   0000006E   0xD127             BNE.N    ??ReceivePacket_3
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0x79C0             LDRB     R0,[R0, #+7]
   \   00000078   0x284B             CMP      R0,#+75
   \   0000007A   0xD121             BNE.N    ??ReceivePacket_3
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0x7880             LDRB     R0,[R0, #+2]
   \   00000084   0x2805             CMP      R0,#+5
   \   00000086   0xDB1B             BLT.N    ??ReceivePacket_3
    901              {
    902                  gIsAck = TRUE;
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable16_2
   \   0000008E   0x7008             STRB     R0,[R1, #+0]
    903                  uint16_t ackID = (*(uint16_t*)&gAppRxPacket->smacPdu.u8Data[3]);
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0x8900             LDRH     R0,[R0, #+8]
    904                  ackID = (ackID << 8) | (ackID >> 8);
   \   00000098   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000009A   0x0A01             LSRS     R1,R0,#+8
   \   0000009C   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
    905                  gIsMyAck = (ackID == sensorID);
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable14
   \   000000A4   0x8809             LDRH     R1,[R1, #+0]
   \   000000A6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000A8   0x4288             CMP      R0,R1
   \   000000AA   0xD104             BNE.N    ??ReceivePacket_4
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable26
   \   000000B2   0x7008             STRB     R0,[R1, #+0]
   \   000000B4   0xE00C             B.N      ??ReceivePacket_2
   \                     ??ReceivePacket_4: (+1)
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable26
   \   000000BC   0x7008             STRB     R0,[R1, #+0]
   \   000000BE   0xE007             B.N      ??ReceivePacket_2
    906                  //if(gIsMyAck) LED_SetLed(LED1, gLedOn_c);
    907                 
    908              }
    909              else
    910              {
    911                  gIsAck = FALSE;
   \                     ??ReceivePacket_3: (+1)
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable16_2
   \   000000C6   0x7008             STRB     R0,[R1, #+0]
    912                  gIsMyAck = FALSE;
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable26
   \   000000CE   0x7008             STRB     R0,[R1, #+0]
    913              }
    914            }
    915            if(gAppRxPacket->rxStatus==rxTimeOutStatus_c) {
    916              //LED_SetLed(LED4, gLedOn_c); 
    917            }
    918            
    919          }
   \                     ??ReceivePacket_2: (+1)
   \   000000D0   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    920          void PrintPacketID(uint16_t packetID){
   \                     PrintPacketID: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    921            CommUtil_Print("\f\r\n Running PER Tx, Sending ", gAllowToBlock_d);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   0000000A   0x.... 0x....      BL       CommUtil_Print
    922            PrintWordOnDecimalFormatBlocking(packetID, 0, FALSE, gDefaultCommPort_c);
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000018   0x.... 0x....      BL       PrintWordOnDecimalFormatBlocking
    923            CommUtil_Print(" Packets", gAllowToBlock_d);
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable28
   \   00000022   0x.... 0x....      BL       CommUtil_Print
    924              
    925          }
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    926          
    927          

   \                                 In section .text, align 2, keep-with-next
    928          void SndSwapEndianness(){
    929            //uint16
    930            gSnd.hdr.u16SensorID  = (gSnd.hdr.u16SensorID << 8) | (gSnd.hdr.u16SensorID >> 8 );
   \                     SndSwapEndianness: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000004   0x8880             LDRH     R0,[R0, #+4]
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000000A   0x8889             LDRH     R1,[R1, #+4]
   \   0000000C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   0x0A09             LSRS     R1,R1,#+8
   \   00000010   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000018   0x8088             STRH     R0,[R1, #+4]
    931            gSnd.packetID         = (gSnd.packetID        << 8) | (gSnd.packetID       >> 8 );
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000001E   0x88C0             LDRH     R0,[R0, #+6]
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000024   0x88C9             LDRH     R1,[R1, #+6]
   \   00000026   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000028   0x0A09             LSRS     R1,R1,#+8
   \   0000002A   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000032   0x80C8             STRH     R0,[R1, #+6]
    932            gSnd.xmin             = (gSnd.xmin            << 8) | (gSnd.xmin           >> 8 );
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000038   0x8900             LDRH     R0,[R0, #+8]
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000003E   0x8909             LDRH     R1,[R1, #+8]
   \   00000040   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000042   0x0A09             LSRS     R1,R1,#+8
   \   00000044   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000004C   0x8108             STRH     R0,[R1, #+8]
    933            gSnd.xmax             = (gSnd.xmax            << 8) | (gSnd.xmax           >> 8 );
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000052   0x8940             LDRH     R0,[R0, #+10]
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000058   0x8949             LDRH     R1,[R1, #+10]
   \   0000005A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000005C   0x0A09             LSRS     R1,R1,#+8
   \   0000005E   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000066   0x8148             STRH     R0,[R1, #+10]
    934            gSnd.xmean            = (gSnd.xmean           << 8) | (gSnd.xmean          >> 8 );
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000006C   0x8980             LDRH     R0,[R0, #+12]
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000072   0x8989             LDRH     R1,[R1, #+12]
   \   00000074   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000076   0x0A09             LSRS     R1,R1,#+8
   \   00000078   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000080   0x8188             STRH     R0,[R1, #+12]
    935            gSnd.ymin             = (gSnd.ymin            << 8) | (gSnd.ymin           >> 8 );
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000086   0x8B00             LDRH     R0,[R0, #+24]
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000008C   0x8B09             LDRH     R1,[R1, #+24]
   \   0000008E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000090   0x0A09             LSRS     R1,R1,#+8
   \   00000092   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000009A   0x8308             STRH     R0,[R1, #+24]
    936            gSnd.ymax             = (gSnd.ymax            << 8) | (gSnd.ymax           >> 8 );
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000000A0   0x8B40             LDRH     R0,[R0, #+26]
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000000A6   0x8B49             LDRH     R1,[R1, #+26]
   \   000000A8   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000AA   0x0A09             LSRS     R1,R1,#+8
   \   000000AC   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000000B4   0x8348             STRH     R0,[R1, #+26]
    937            gSnd.ymean            = (gSnd.ymean           << 8) | (gSnd.ymean          >> 8 );
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000000BA   0x8B80             LDRH     R0,[R0, #+28]
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000000C0   0x8B89             LDRH     R1,[R1, #+28]
   \   000000C2   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000C4   0x0A09             LSRS     R1,R1,#+8
   \   000000C6   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000000CE   0x8388             STRH     R0,[R1, #+28]
    938            gSnd.zmin             = (gSnd.zmin            << 8) | (gSnd.zmin           >> 8 );
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000000D4   0x8D00             LDRH     R0,[R0, #+40]
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000000DA   0x8D09             LDRH     R1,[R1, #+40]
   \   000000DC   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000DE   0x0A09             LSRS     R1,R1,#+8
   \   000000E0   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000000E8   0x8508             STRH     R0,[R1, #+40]
    939            gSnd.zmax             = (gSnd.zmax            << 8) | (gSnd.zmax           >> 8 );
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000000EE   0x8D40             LDRH     R0,[R0, #+42]
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000000F4   0x8D49             LDRH     R1,[R1, #+42]
   \   000000F6   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000F8   0x0A09             LSRS     R1,R1,#+8
   \   000000FA   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000FE   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000102   0x8548             STRH     R0,[R1, #+42]
    940            gSnd.zmean            = (gSnd.zmean           << 8) | (gSnd.zmean          >> 8 );
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000108   0x8D80             LDRH     R0,[R0, #+44]
   \   0000010A   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000010E   0x8D89             LDRH     R1,[R1, #+44]
   \   00000110   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000112   0x0A09             LSRS     R1,R1,#+8
   \   00000114   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000118   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000011C   0x8588             STRH     R0,[R1, #+44]
    941            gSnd.battery_mV       = (gSnd.battery_mV      << 8) | (gSnd.battery_mV     >> 8 );
   \   0000011E   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000122   0x8F40             LDRH     R0,[R0, #+58]
   \   00000124   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000128   0x8F49             LDRH     R1,[R1, #+58]
   \   0000012A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000012C   0x0A09             LSRS     R1,R1,#+8
   \   0000012E   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000132   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000136   0x8748             STRH     R0,[R1, #+58]
    942            gSnd.totalTimeouts    = (gSnd.totalTimeouts   << 8) | (gSnd.totalTimeouts  >> 8 );
   \   00000138   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000013C   0x8FC0             LDRH     R0,[R0, #+62]
   \   0000013E   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000142   0x8FC9             LDRH     R1,[R1, #+62]
   \   00000144   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000146   0x0A09             LSRS     R1,R1,#+8
   \   00000148   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000014C   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000150   0x87C8             STRH     R0,[R1, #+62]
    943            gSnd.maxMissedCount   = (gSnd.maxMissedCount  << 8) | (gSnd.maxMissedCount >> 8 );
   \   00000152   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000156   0xF8B0 0x0040      LDRH     R0,[R0, #+64]
   \   0000015A   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000015E   0xF8B1 0x1040      LDRH     R1,[R1, #+64]
   \   00000162   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000164   0x0A09             LSRS     R1,R1,#+8
   \   00000166   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000016A   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000016E   0xF8A1 0x0040      STRH     R0,[R1, #+64]
    944            
    945            //int16
    946            gSnd.temperature      = (gSnd.temperature << 8) | ((gSnd.temperature >> 8) & 0xFF);
   \   00000172   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000176   0x8F00             LDRH     R0,[R0, #+56]
   \   00000178   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000017C   0xF9B1 0x1038      LDRSH    R1,[R1, #+56]
   \   00000180   0xF3C1 0x2107      UBFX     R1,R1,#+8,#+8
   \   00000184   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000188   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000018C   0x8708             STRH     R0,[R1, #+56]
    947            
    948            //uint32
    949            gSnd.xsum0 = ((gSnd.xsum0 << 8) & 0xFF00FF00 ) | ((gSnd.xsum0 >> 8) & 0xFF00FF ); 
   \   0000018E   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000192   0x6900             LDR      R0,[R0, #+16]
   \   00000194   0x0200             LSLS     R0,R0,#+8
   \   00000196   0xF030 0x10FF      BICS     R0,R0,#0xFF00FF
   \   0000019A   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000019E   0x6909             LDR      R1,[R1, #+16]
   \   000001A0   0x0A09             LSRS     R1,R1,#+8
   \   000001A2   0xF011 0x11FF      ANDS     R1,R1,#0xFF00FF
   \   000001A6   0x4308             ORRS     R0,R1,R0
   \   000001A8   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000001AC   0x6108             STR      R0,[R1, #+16]
    950            gSnd.xsum0 = (gSnd.xsum0 << 16) | (gSnd.xsum0 >> 16);
   \   000001AE   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000001B2   0x6900             LDR      R0,[R0, #+16]
   \   000001B4   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000001B8   0x6909             LDR      R1,[R1, #+16]
   \   000001BA   0xEA5F 0x4031      RORS     R0,R1,#+16
   \   000001BE   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000001C2   0x6108             STR      R0,[R1, #+16]
    951            gSnd.xsum1 = ((gSnd.xsum1 << 8) & 0xFF00FF00 ) | ((gSnd.xsum1 >> 8) & 0xFF00FF ); 
   \   000001C4   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000001C8   0x6940             LDR      R0,[R0, #+20]
   \   000001CA   0x0200             LSLS     R0,R0,#+8
   \   000001CC   0xF030 0x10FF      BICS     R0,R0,#0xFF00FF
   \   000001D0   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000001D4   0x6949             LDR      R1,[R1, #+20]
   \   000001D6   0x0A09             LSRS     R1,R1,#+8
   \   000001D8   0xF011 0x11FF      ANDS     R1,R1,#0xFF00FF
   \   000001DC   0x4308             ORRS     R0,R1,R0
   \   000001DE   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000001E2   0x6148             STR      R0,[R1, #+20]
    952            gSnd.xsum1 =  (gSnd.xsum1 << 16) | (gSnd.xsum1 >> 16);
   \   000001E4   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000001E8   0x6940             LDR      R0,[R0, #+20]
   \   000001EA   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000001EE   0x6949             LDR      R1,[R1, #+20]
   \   000001F0   0xEA5F 0x4031      RORS     R0,R1,#+16
   \   000001F4   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000001F8   0x6148             STR      R0,[R1, #+20]
    953            gSnd.ysum0 = ((gSnd.ysum0 << 8) & 0xFF00FF00 ) | ((gSnd.ysum0 >> 8) & 0xFF00FF ); 
   \   000001FA   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000001FE   0x6A00             LDR      R0,[R0, #+32]
   \   00000200   0x0200             LSLS     R0,R0,#+8
   \   00000202   0xF030 0x10FF      BICS     R0,R0,#0xFF00FF
   \   00000206   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000020A   0x6A09             LDR      R1,[R1, #+32]
   \   0000020C   0x0A09             LSRS     R1,R1,#+8
   \   0000020E   0xF011 0x11FF      ANDS     R1,R1,#0xFF00FF
   \   00000212   0x4308             ORRS     R0,R1,R0
   \   00000214   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000218   0x6208             STR      R0,[R1, #+32]
    954            gSnd.ysum0 = (gSnd.ysum0 << 16) | (gSnd.ysum0 >> 16);
   \   0000021A   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000021E   0x6A00             LDR      R0,[R0, #+32]
   \   00000220   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000224   0x6A09             LDR      R1,[R1, #+32]
   \   00000226   0xEA5F 0x4031      RORS     R0,R1,#+16
   \   0000022A   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000022E   0x6208             STR      R0,[R1, #+32]
    955            gSnd.ysum1 = ((gSnd.ysum1 << 8) & 0xFF00FF00 ) | ((gSnd.ysum1 >> 8) & 0xFF00FF ); 
   \   00000230   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000234   0x6A40             LDR      R0,[R0, #+36]
   \   00000236   0x0200             LSLS     R0,R0,#+8
   \   00000238   0xF030 0x10FF      BICS     R0,R0,#0xFF00FF
   \   0000023C   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000240   0x6A49             LDR      R1,[R1, #+36]
   \   00000242   0x0A09             LSRS     R1,R1,#+8
   \   00000244   0xF011 0x11FF      ANDS     R1,R1,#0xFF00FF
   \   00000248   0x4308             ORRS     R0,R1,R0
   \   0000024A   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000024E   0x6248             STR      R0,[R1, #+36]
    956            gSnd.ysum1 =  (gSnd.ysum1 << 16) | (gSnd.ysum1 >> 16);  
   \   00000250   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000254   0x6A40             LDR      R0,[R0, #+36]
   \   00000256   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000025A   0x6A49             LDR      R1,[R1, #+36]
   \   0000025C   0xEA5F 0x4031      RORS     R0,R1,#+16
   \   00000260   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000264   0x6248             STR      R0,[R1, #+36]
    957            gSnd.zsum0 = ((gSnd.zsum0 << 8) & 0xFF00FF00 ) | ((gSnd.zsum0 >> 8) & 0xFF00FF ); 
   \   00000266   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000026A   0x6B00             LDR      R0,[R0, #+48]
   \   0000026C   0x0200             LSLS     R0,R0,#+8
   \   0000026E   0xF030 0x10FF      BICS     R0,R0,#0xFF00FF
   \   00000272   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000276   0x6B09             LDR      R1,[R1, #+48]
   \   00000278   0x0A09             LSRS     R1,R1,#+8
   \   0000027A   0xF011 0x11FF      ANDS     R1,R1,#0xFF00FF
   \   0000027E   0x4308             ORRS     R0,R1,R0
   \   00000280   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000284   0x6308             STR      R0,[R1, #+48]
    958            gSnd.zsum0 = (gSnd.zsum0 << 16) | (gSnd.zsum0 >> 16);
   \   00000286   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000028A   0x6B00             LDR      R0,[R0, #+48]
   \   0000028C   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000290   0x6B09             LDR      R1,[R1, #+48]
   \   00000292   0xEA5F 0x4031      RORS     R0,R1,#+16
   \   00000296   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000029A   0x6308             STR      R0,[R1, #+48]
    959            gSnd.zsum1 = ((gSnd.zsum1 << 8) & 0xFF00FF00 ) | ((gSnd.zsum1 >> 8) & 0xFF00FF ); 
   \   0000029C   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000002A0   0x6B40             LDR      R0,[R0, #+52]
   \   000002A2   0x0200             LSLS     R0,R0,#+8
   \   000002A4   0xF030 0x10FF      BICS     R0,R0,#0xFF00FF
   \   000002A8   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000002AC   0x6B49             LDR      R1,[R1, #+52]
   \   000002AE   0x0A09             LSRS     R1,R1,#+8
   \   000002B0   0xF011 0x11FF      ANDS     R1,R1,#0xFF00FF
   \   000002B4   0x4308             ORRS     R0,R1,R0
   \   000002B6   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000002BA   0x6348             STR      R0,[R1, #+52]
    960            gSnd.zsum1 =  (gSnd.zsum1 << 16) | (gSnd.zsum1 >> 16);
   \   000002BC   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000002C0   0x6B40             LDR      R0,[R0, #+52]
   \   000002C2   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000002C6   0x6B49             LDR      R1,[R1, #+52]
   \   000002C8   0xEA5F 0x4031      RORS     R0,R1,#+16
   \   000002CC   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000002D0   0x6348             STR      R0,[R1, #+52]
    961            
    962          }
   \   000002D2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    963          void CopyOptionsFromRecvPacket(tOptions* pOptions){
   \                     CopyOptionsFromRecvPacket: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    964          
    965            uint32_t offset = ACK_HEADER_SIZE;      
   \   00000004   0x2505             MOVS     R5,#+5
    966            MemoryCpy(&pOptions->u8RawSpinCount, &gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->u8RawSpinCount));  
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x....             LDR.N    R0,??DataTable16_3
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x1828             ADDS     R0,R5,R0
   \   0000000E   0x1D41             ADDS     R1,R0,#+5
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       MemoryCpy
    967            offset += sizeof(uint8_t);
   \   00000016   0x1C6D             ADDS     R5,R5,#+1
    968            MemoryCpy(&pOptions->u16TimeoutsToKill, &gAppRxPacket->smacPdu.u8Data[offset],sizeof(pOptions->u16TimeoutsToKill));
   \   00000018   0x2202             MOVS     R2,#+2
   \   0000001A   0x....             LDR.N    R0,??DataTable16_3
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x1828             ADDS     R0,R5,R0
   \   00000020   0x1D41             ADDS     R1,R0,#+5
   \   00000022   0x1CA0             ADDS     R0,R4,#+2
   \   00000024   0x.... 0x....      BL       MemoryCpy
    969            offset += sizeof(uint16_t);
   \   00000028   0x1CAD             ADDS     R5,R5,#+2
    970            MemoryCpy(&pOptions->u16SampleSize, &gAppRxPacket->smacPdu.u8Data[offset],sizeof(pOptions->u16SampleSize));
   \   0000002A   0x2202             MOVS     R2,#+2
   \   0000002C   0x....             LDR.N    R0,??DataTable16_3
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x1828             ADDS     R0,R5,R0
   \   00000032   0x1D41             ADDS     R1,R0,#+5
   \   00000034   0x1D20             ADDS     R0,R4,#+4
   \   00000036   0x.... 0x....      BL       MemoryCpy
    971            offset += sizeof(uint16_t);
   \   0000003A   0x1CAD             ADDS     R5,R5,#+2
    972            MemoryCpy(&pOptions->bAsciiMode, &gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->bAsciiMode));
   \   0000003C   0x2201             MOVS     R2,#+1
   \   0000003E   0x....             LDR.N    R0,??DataTable16_3
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x1828             ADDS     R0,R5,R0
   \   00000044   0x1D41             ADDS     R1,R0,#+5
   \   00000046   0x1DA0             ADDS     R0,R4,#+6
   \   00000048   0x.... 0x....      BL       MemoryCpy
    973            offset += sizeof(uint8_t);
   \   0000004C   0x1C6D             ADDS     R5,R5,#+1
    974            MemoryCpy(&pOptions->bBlinkingLEDs, &gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->bBlinkingLEDs));
   \   0000004E   0x2201             MOVS     R2,#+1
   \   00000050   0x....             LDR.N    R0,??DataTable16_3
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x1828             ADDS     R0,R5,R0
   \   00000056   0x1D41             ADDS     R1,R0,#+5
   \   00000058   0x1DE0             ADDS     R0,R4,#+7
   \   0000005A   0x.... 0x....      BL       MemoryCpy
    975            offset += sizeof(uint8_t);                                           
   \   0000005E   0x1C6D             ADDS     R5,R5,#+1
    976            MemoryCpy(&pOptions->u8OutputPower, &gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->u8OutputPower));
   \   00000060   0x2201             MOVS     R2,#+1
   \   00000062   0x....             LDR.N    R0,??DataTable16_3
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0x1828             ADDS     R0,R5,R0
   \   00000068   0x1D41             ADDS     R1,R0,#+5
   \   0000006A   0xF114 0x0008      ADDS     R0,R4,#+8
   \   0000006E   0x.... 0x....      BL       MemoryCpy
    977            offset += sizeof(uint8_t);                                        
   \   00000072   0x1C6D             ADDS     R5,R5,#+1
    978            MemoryCpy(&pOptions->u32PngTimeout, &gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->u32PngTimeout));
   \   00000074   0x2204             MOVS     R2,#+4
   \   00000076   0x....             LDR.N    R0,??DataTable16_3
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x1828             ADDS     R0,R5,R0
   \   0000007C   0x1D41             ADDS     R1,R0,#+5
   \   0000007E   0xF114 0x000C      ADDS     R0,R4,#+12
   \   00000082   0x.... 0x....      BL       MemoryCpy
    979            offset += sizeof(uint32_t);                                        
   \   00000086   0x1D2D             ADDS     R5,R5,#+4
    980            MemoryCpy(&pOptions->u32SndTimeout, &gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->u32SndTimeout));
   \   00000088   0x2204             MOVS     R2,#+4
   \   0000008A   0x....             LDR.N    R0,??DataTable16_3
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0x1828             ADDS     R0,R5,R0
   \   00000090   0x1D41             ADDS     R1,R0,#+5
   \   00000092   0xF114 0x0010      ADDS     R0,R4,#+16
   \   00000096   0x.... 0x....      BL       MemoryCpy
    981            offset += sizeof(uint32_t);
   \   0000009A   0x1D2D             ADDS     R5,R5,#+4
    982            MemoryCpy(&pOptions->bLNAHighGainMode,&gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->bLNAHighGainMode)); // i.e. Low Noise Amplifier - updated *** 10/26/10 *** (formerly "u8Reserved2")
   \   0000009C   0x2201             MOVS     R2,#+1
   \   0000009E   0x....             LDR.N    R0,??DataTable16_3
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x1828             ADDS     R0,R5,R0
   \   000000A4   0x1D41             ADDS     R1,R0,#+5
   \   000000A6   0xF114 0x0014      ADDS     R0,R4,#+20
   \   000000AA   0x.... 0x....      BL       MemoryCpy
    983            offset += sizeof(uint8_t);
   \   000000AE   0x1C6D             ADDS     R5,R5,#+1
    984            MemoryCpy(&pOptions->u16SleepAfterAck,&gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->u16SleepAfterAck));
   \   000000B0   0x2202             MOVS     R2,#+2
   \   000000B2   0x....             LDR.N    R0,??DataTable16_3
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0x1828             ADDS     R0,R5,R0
   \   000000B8   0x1D41             ADDS     R1,R0,#+5
   \   000000BA   0xF114 0x0016      ADDS     R0,R4,#+22
   \   000000BE   0x.... 0x....      BL       MemoryCpy
    985            
    986          
    987          }
   \   000000C2   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
    988          void OptSwapEndianness(tOptions* pOptions){
    989            
    990            
    991            
    992            pOptions->u16TimeoutsToKill   = ((pOptions->u16TimeoutsToKill)       << 8) | ((pOptions->u16TimeoutsToKill) >> 8);
   \                     OptSwapEndianness: (+1)
   \   00000000   0x8841             LDRH     R1,[R0, #+2]
   \   00000002   0x8842             LDRH     R2,[R0, #+2]
   \   00000004   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000006   0x0A12             LSRS     R2,R2,#+8
   \   00000008   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   0000000C   0x8041             STRH     R1,[R0, #+2]
    993            pOptions->u16SampleSize       = ((pOptions->u16SampleSize)           << 8) | ((pOptions->u16SampleSize)     >> 8);
   \   0000000E   0x8881             LDRH     R1,[R0, #+4]
   \   00000010   0x8882             LDRH     R2,[R0, #+4]
   \   00000012   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000014   0x0A12             LSRS     R2,R2,#+8
   \   00000016   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   0000001A   0x8081             STRH     R1,[R0, #+4]
    994            pOptions->u16SleepAfterAck    = ((pOptions->u16SleepAfterAck)        << 8) | ((pOptions->u16SleepAfterAck)  >> 8);
   \   0000001C   0x8AC1             LDRH     R1,[R0, #+22]
   \   0000001E   0x8AC2             LDRH     R2,[R0, #+22]
   \   00000020   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000022   0x0A12             LSRS     R2,R2,#+8
   \   00000024   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   00000028   0x82C1             STRH     R1,[R0, #+22]
    995            
    996            pOptions->u32PngTimeout = (((pOptions->u32PngTimeout) << 8) & 0xFF00FF00 ) | (((pOptions->u32PngTimeout) >> 8) & 0xFF00FF );
   \   0000002A   0x68C1             LDR      R1,[R0, #+12]
   \   0000002C   0x0209             LSLS     R1,R1,#+8
   \   0000002E   0xF031 0x11FF      BICS     R1,R1,#0xFF00FF
   \   00000032   0x68C2             LDR      R2,[R0, #+12]
   \   00000034   0x0A12             LSRS     R2,R2,#+8
   \   00000036   0xF012 0x12FF      ANDS     R2,R2,#0xFF00FF
   \   0000003A   0x4311             ORRS     R1,R2,R1
   \   0000003C   0x60C1             STR      R1,[R0, #+12]
    997            pOptions->u32PngTimeout = (pOptions->u32PngTimeout << 16) | (pOptions->u32PngTimeout >> 16);
   \   0000003E   0x68C1             LDR      R1,[R0, #+12]
   \   00000040   0x68C2             LDR      R2,[R0, #+12]
   \   00000042   0xEA5F 0x4132      RORS     R1,R2,#+16
   \   00000046   0x60C1             STR      R1,[R0, #+12]
    998            
    999            pOptions->u32SndTimeout = (((pOptions->u32SndTimeout) << 8) & 0xFF00FF00 ) | (((pOptions->u32SndTimeout) >> 8) & 0xFF00FF );
   \   00000048   0x6901             LDR      R1,[R0, #+16]
   \   0000004A   0x0209             LSLS     R1,R1,#+8
   \   0000004C   0xF031 0x11FF      BICS     R1,R1,#0xFF00FF
   \   00000050   0x6902             LDR      R2,[R0, #+16]
   \   00000052   0x0A12             LSRS     R2,R2,#+8
   \   00000054   0xF012 0x12FF      ANDS     R2,R2,#0xFF00FF
   \   00000058   0x4311             ORRS     R1,R2,R1
   \   0000005A   0x6101             STR      R1,[R0, #+16]
   1000            pOptions->u32SndTimeout = (pOptions->u32SndTimeout << 16) | (pOptions->u32SndTimeout >> 16);
   \   0000005C   0x6901             LDR      R1,[R0, #+16]
   \   0000005E   0x6902             LDR      R2,[R0, #+16]
   \   00000060   0xEA5F 0x4132      RORS     R1,R2,#+16
   \   00000064   0x6101             STR      R1,[R0, #+16]
   1001            
   1002            
   1003            
   1004          }
   \   00000066   0x4770             BX       LR               ;; return
   1005          

   \                                 In section .text, align 2, keep-with-next
   1006          void PngSwapEndianness(){
   1007            gPng.u16SensorID = (gPng.u16SensorID << 8) | (gPng.u16SensorID >> 8);
   \                     PngSwapEndianness: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \   00000004   0x8880             LDRH     R0,[R0, #+4]
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable28_1
   \   0000000A   0x8889             LDRH     R1,[R1, #+4]
   \   0000000C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   0x0A09             LSRS     R1,R1,#+8
   \   00000010   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable28_1
   \   00000018   0x8088             STRH     R0,[R1, #+4]
   1008          }
   \   0000001A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1009          void CopyPngPacketToSMAC(){
   \                     CopyPngPacketToSMAC: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1010            MemoryCpy(&gAppTxPacket->smacPdu.u8Data[0],       (uint8_t*)&gPng.u8Prefix[0],       sizeof(gPng.u8Prefix[0]));
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable28_1
   \   00000008   0x....             LDR.N    R0,??DataTable18_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x1CC0             ADDS     R0,R0,#+3
   \   0000000E   0x.... 0x....      BL       MemoryCpy
   1011            MemoryCpy(&gAppTxPacket->smacPdu.u8Data[1],       (uint8_t*)&gPng.u8Prefix[1],       sizeof(gPng.u8Prefix[1]));
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable28_2
   \   00000018   0x....             LDR.N    R0,??DataTable18_1
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x1D00             ADDS     R0,R0,#+4
   \   0000001E   0x.... 0x....      BL       MemoryCpy
   1012            MemoryCpy(&gAppTxPacket->smacPdu.u8Data[2],       (uint8_t*)&gPng.u8Prefix[2],       sizeof(gPng.u8Prefix[2]));
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable28_3
   \   00000028   0x....             LDR.N    R0,??DataTable18_1
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x1D40             ADDS     R0,R0,#+5
   \   0000002E   0x.... 0x....      BL       MemoryCpy
   1013            MemoryCpy(&gAppTxPacket->smacPdu.u8Data[3],       (uint8_t*)&gPng.u16SensorID,       sizeof(gPng.u16SensorID));
   \   00000032   0x2202             MOVS     R2,#+2
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable28_4
   \   00000038   0x....             LDR.N    R0,??DataTable18_1
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x1D80             ADDS     R0,R0,#+6
   \   0000003E   0x.... 0x....      BL       MemoryCpy
   1014                     
   1015          }
   \   00000042   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   1016          void CopyBinaryPacketToSMAC(){
   \                     CopyBinaryPacketToSMAC: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1017            
   1018            
   1019            
   1020              
   1021            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[0]),  (uint8_t*)&gSnd.hdr.u8Prefix[0]        ,sizeof(gSnd.hdr.u8Prefix[0]));
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000008   0x....             LDR.N    R0,??DataTable18_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x1CC0             ADDS     R0,R0,#+3
   \   0000000E   0x.... 0x....      BL       MemoryCpy
   1022            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[1]),  (uint8_t*)&gSnd.hdr.u8Prefix[1]        ,sizeof(gSnd.hdr.u8Prefix[1]));
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable28_5
   \   00000018   0x....             LDR.N    R0,??DataTable18_1
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x1D00             ADDS     R0,R0,#+4
   \   0000001E   0x.... 0x....      BL       MemoryCpy
   1023            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[2]),  (uint8_t*)&gSnd.hdr.u8Prefix[2]        ,sizeof(gSnd.hdr.u8Prefix[2]));
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable28_6
   \   00000028   0x....             LDR.N    R0,??DataTable18_1
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x1D40             ADDS     R0,R0,#+5
   \   0000002E   0x.... 0x....      BL       MemoryCpy
   1024            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[3]),  (uint8_t*)&gSnd.hdr.u8Length           ,sizeof(gSnd.hdr.u8Length   ));
   \   00000032   0x2201             MOVS     R2,#+1
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable28_7
   \   00000038   0x....             LDR.N    R0,??DataTable18_1
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x1D80             ADDS     R0,R0,#+6
   \   0000003E   0x.... 0x....      BL       MemoryCpy
   1025            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[4]),  (uint8_t*)&gSnd.hdr.u16SensorID        ,sizeof(gSnd.hdr.u16SensorID));
   \   00000042   0x2202             MOVS     R2,#+2
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable28_8
   \   00000048   0x....             LDR.N    R0,??DataTable18_1
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x1DC0             ADDS     R0,R0,#+7
   \   0000004E   0x.... 0x....      BL       MemoryCpy
   1026            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[6]),  (uint8_t*)&gSnd.packetID               ,sizeof(gSnd.packetID       ));
   \   00000052   0x2202             MOVS     R2,#+2
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable28_9
   \   00000058   0x....             LDR.N    R0,??DataTable18_1
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x3009             ADDS     R0,R0,#+9
   \   0000005E   0x.... 0x....      BL       MemoryCpy
   1027            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[8]),  (uint8_t*)&gSnd.xmin                   ,sizeof(gSnd.xmin           ));
   \   00000062   0x2202             MOVS     R2,#+2
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable28_10
   \   00000068   0x....             LDR.N    R0,??DataTable18_1
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x300B             ADDS     R0,R0,#+11
   \   0000006E   0x.... 0x....      BL       MemoryCpy
   1028            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[10]), (uint8_t*)&gSnd.xmax                   ,sizeof(gSnd.xmax           ));
   \   00000072   0x2202             MOVS     R2,#+2
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable28_11
   \   00000078   0x....             LDR.N    R0,??DataTable18_1
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x300D             ADDS     R0,R0,#+13
   \   0000007E   0x.... 0x....      BL       MemoryCpy
   1029            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[12]), (uint8_t*)&gSnd.xmean                  ,sizeof(gSnd.xmean          ));
   \   00000082   0x2202             MOVS     R2,#+2
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable28_12
   \   00000088   0x....             LDR.N    R0,??DataTable18_1
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x300F             ADDS     R0,R0,#+15
   \   0000008E   0x.... 0x....      BL       MemoryCpy
   1030            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[14]), (uint8_t*)&gSnd.xsum0                  ,sizeof(gSnd.xsum0          ));
   \   00000092   0x2204             MOVS     R2,#+4
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable28_13
   \   00000098   0x....             LDR.N    R0,??DataTable18_1
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0x3011             ADDS     R0,R0,#+17
   \   0000009E   0x.... 0x....      BL       MemoryCpy
   1031            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[18]), (uint8_t*)&gSnd.xsum1                  ,sizeof(gSnd.xsum1          ));
   \   000000A2   0x2204             MOVS     R2,#+4
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable28_14
   \   000000A8   0x....             LDR.N    R0,??DataTable18_1
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0x3015             ADDS     R0,R0,#+21
   \   000000AE   0x.... 0x....      BL       MemoryCpy
   1032            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[22]), (uint8_t*)&gSnd.ymin                   ,sizeof(gSnd.ymin           ));
   \   000000B2   0x2202             MOVS     R2,#+2
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable28_15
   \   000000B8   0x....             LDR.N    R0,??DataTable18_1
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0x3019             ADDS     R0,R0,#+25
   \   000000BE   0x.... 0x....      BL       MemoryCpy
   1033            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[24]), (uint8_t*)&gSnd.ymax                   ,sizeof(gSnd.ymax           ));
   \   000000C2   0x2202             MOVS     R2,#+2
   \   000000C4   0x.... 0x....      LDR.W    R1,??DataTable28_16
   \   000000C8   0x....             LDR.N    R0,??DataTable18_1
   \   000000CA   0x6800             LDR      R0,[R0, #+0]
   \   000000CC   0x301B             ADDS     R0,R0,#+27
   \   000000CE   0x.... 0x....      BL       MemoryCpy
   1034            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[26]), (uint8_t*)&gSnd.ymean                  ,sizeof(gSnd.ymean          ));
   \   000000D2   0x2202             MOVS     R2,#+2
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable28_17
   \   000000D8   0x....             LDR.N    R0,??DataTable18_1
   \   000000DA   0x6800             LDR      R0,[R0, #+0]
   \   000000DC   0x301D             ADDS     R0,R0,#+29
   \   000000DE   0x.... 0x....      BL       MemoryCpy
   1035            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[28]), (uint8_t*)&gSnd.ysum0                  ,sizeof(gSnd.ysum0          ));
   \   000000E2   0x2204             MOVS     R2,#+4
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable28_18
   \   000000E8   0x....             LDR.N    R0,??DataTable18_1
   \   000000EA   0x6800             LDR      R0,[R0, #+0]
   \   000000EC   0x301F             ADDS     R0,R0,#+31
   \   000000EE   0x.... 0x....      BL       MemoryCpy
   1036            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[32]), (uint8_t*)&gSnd.ysum1                  ,sizeof(gSnd.ysum1          ));
   \   000000F2   0x2204             MOVS     R2,#+4
   \   000000F4   0x.... 0x....      LDR.W    R1,??DataTable28_19
   \   000000F8   0x....             LDR.N    R0,??DataTable18_1
   \   000000FA   0x6800             LDR      R0,[R0, #+0]
   \   000000FC   0x3023             ADDS     R0,R0,#+35
   \   000000FE   0x.... 0x....      BL       MemoryCpy
   1037            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[36]), (uint8_t*)&gSnd.zmin                   ,sizeof(gSnd.zmin           ));
   \   00000102   0x2202             MOVS     R2,#+2
   \   00000104   0x.... 0x....      LDR.W    R1,??DataTable28_20
   \   00000108   0x....             LDR.N    R0,??DataTable18_1
   \   0000010A   0x6800             LDR      R0,[R0, #+0]
   \   0000010C   0x3027             ADDS     R0,R0,#+39
   \   0000010E   0x.... 0x....      BL       MemoryCpy
   1038            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[38]), (uint8_t*)&gSnd.zmax                   ,sizeof(gSnd.zmax           ));
   \   00000112   0x2202             MOVS     R2,#+2
   \   00000114   0x.... 0x....      LDR.W    R1,??DataTable28_21
   \   00000118   0x....             LDR.N    R0,??DataTable18_1
   \   0000011A   0x6800             LDR      R0,[R0, #+0]
   \   0000011C   0x3029             ADDS     R0,R0,#+41
   \   0000011E   0x.... 0x....      BL       MemoryCpy
   1039            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[40]), (uint8_t*)&gSnd.zmean                  ,sizeof(gSnd.zmean          ));
   \   00000122   0x2202             MOVS     R2,#+2
   \   00000124   0x.... 0x....      LDR.W    R1,??DataTable28_22
   \   00000128   0x....             LDR.N    R0,??DataTable18_1
   \   0000012A   0x6800             LDR      R0,[R0, #+0]
   \   0000012C   0x302B             ADDS     R0,R0,#+43
   \   0000012E   0x.... 0x....      BL       MemoryCpy
   1040            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[42]), (uint8_t*)&gSnd.zsum0                  ,sizeof(gSnd.zsum0          ));
   \   00000132   0x2204             MOVS     R2,#+4
   \   00000134   0x.... 0x....      LDR.W    R1,??DataTable28_23
   \   00000138   0x....             LDR.N    R0,??DataTable18_1
   \   0000013A   0x6800             LDR      R0,[R0, #+0]
   \   0000013C   0x302D             ADDS     R0,R0,#+45
   \   0000013E   0x.... 0x....      BL       MemoryCpy
   1041            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[46]), (uint8_t*)&gSnd.zsum1                  ,sizeof(gSnd.zsum1          ));
   \   00000142   0x2204             MOVS     R2,#+4
   \   00000144   0x.... 0x....      LDR.W    R1,??DataTable28_24
   \   00000148   0x....             LDR.N    R0,??DataTable18_1
   \   0000014A   0x6800             LDR      R0,[R0, #+0]
   \   0000014C   0x3031             ADDS     R0,R0,#+49
   \   0000014E   0x.... 0x....      BL       MemoryCpy
   1042            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[50]), (uint8_t*)&gSnd.temperature            ,sizeof(gSnd.temperature    ));
   \   00000152   0x2202             MOVS     R2,#+2
   \   00000154   0x.... 0x....      LDR.W    R1,??DataTable28_25
   \   00000158   0x....             LDR.N    R0,??DataTable18_1
   \   0000015A   0x6800             LDR      R0,[R0, #+0]
   \   0000015C   0x3035             ADDS     R0,R0,#+53
   \   0000015E   0x.... 0x....      BL       MemoryCpy
   1043            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[52]), (uint8_t*)&gSnd.battery_mV             ,sizeof(gSnd.battery_mV     ));
   \   00000162   0x2202             MOVS     R2,#+2
   \   00000164   0x.... 0x....      LDR.W    R1,??DataTable28_26
   \   00000168   0x....             LDR.N    R0,??DataTable18_1
   \   0000016A   0x6800             LDR      R0,[R0, #+0]
   \   0000016C   0x3037             ADDS     R0,R0,#+55
   \   0000016E   0x.... 0x....      BL       MemoryCpy
   1044            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[54]), (uint8_t*)&gSnd.linkQdBm               ,sizeof(gSnd.linkQdBm       ));
   \   00000172   0x2201             MOVS     R2,#+1
   \   00000174   0x.... 0x....      LDR.W    R1,??DataTable28_27
   \   00000178   0x....             LDR.N    R0,??DataTable18_1
   \   0000017A   0x6800             LDR      R0,[R0, #+0]
   \   0000017C   0x3039             ADDS     R0,R0,#+57
   \   0000017E   0x.... 0x....      BL       MemoryCpy
   1045            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[55]), (uint8_t*)&gSnd.totalTimeouts          ,sizeof(gSnd.totalTimeouts  ));
   \   00000182   0x2202             MOVS     R2,#+2
   \   00000184   0x.... 0x....      LDR.W    R1,??DataTable28_28
   \   00000188   0x....             LDR.N    R0,??DataTable18_1
   \   0000018A   0x6800             LDR      R0,[R0, #+0]
   \   0000018C   0x303A             ADDS     R0,R0,#+58
   \   0000018E   0x.... 0x....      BL       MemoryCpy
   1046            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[57]), (uint8_t*)&gSnd.maxMissedCount         ,sizeof(gSnd.maxMissedCount ));
   \   00000192   0x2202             MOVS     R2,#+2
   \   00000194   0x.... 0x....      LDR.W    R1,??DataTable28_29
   \   00000198   0x....             LDR.N    R0,??DataTable18_1
   \   0000019A   0x6800             LDR      R0,[R0, #+0]
   \   0000019C   0x303C             ADDS     R0,R0,#+60
   \   0000019E   0x.... 0x....      BL       MemoryCpy
   1047            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[59]), (uint8_t*)&gSnd.voltageWarning         ,sizeof(gSnd.voltageWarning ));
   \   000001A2   0x2201             MOVS     R2,#+1
   \   000001A4   0x.... 0x....      LDR.W    R1,??DataTable28_30
   \   000001A8   0x....             LDR.N    R0,??DataTable18_1
   \   000001AA   0x6800             LDR      R0,[R0, #+0]
   \   000001AC   0x303E             ADDS     R0,R0,#+62
   \   000001AE   0x.... 0x....      BL       MemoryCpy
   1048            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[60]), (uint8_t*)&gSnd.channel                ,sizeof(gSnd.channel        ));
   \   000001B2   0x2201             MOVS     R2,#+1
   \   000001B4   0x.... 0x....      LDR.W    R1,??DataTable28_31
   \   000001B8   0x....             LDR.N    R0,??DataTable18_1
   \   000001BA   0x6800             LDR      R0,[R0, #+0]
   \   000001BC   0x303F             ADDS     R0,R0,#+63
   \   000001BE   0x.... 0x....      BL       MemoryCpy
   1049            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[61]), (uint8_t*)&gSnd.version                ,sizeof(gSnd.version        ));
   \   000001C2   0x2201             MOVS     R2,#+1
   \   000001C4   0x.... 0x....      LDR.W    R1,??DataTable28_32
   \   000001C8   0x....             LDR.N    R0,??DataTable18_1
   \   000001CA   0x6800             LDR      R0,[R0, #+0]
   \   000001CC   0x3040             ADDS     R0,R0,#+64
   \   000001CE   0x.... 0x....      BL       MemoryCpy
   1050             
   1051            gAppTxPacket->u8DataLength = SND_SIZE;
   \   000001D2   0x203E             MOVS     R0,#+62
   \   000001D4   0x....             LDR.N    R1,??DataTable18_1
   \   000001D6   0x6809             LDR      R1,[R1, #+0]
   \   000001D8   0x7008             STRB     R0,[R1, #+0]
   1052          }
   \   000001DA   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   1053          void CopyOptPacketToSMAC(){
   \                     CopyOptPacketToSMAC: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1054            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[0]),   (uint8_t*)&gOpt.hdr.u8Prefix[0]        ,sizeof(gOpt.hdr.u8Prefix[0]));
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable28_33
   \   00000008   0x....             LDR.N    R0,??DataTable18_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x1CC0             ADDS     R0,R0,#+3
   \   0000000E   0x.... 0x....      BL       MemoryCpy
   1055            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[1]),   (uint8_t*)&gOpt.hdr.u8Prefix[1]        ,sizeof(gOpt.hdr.u8Prefix[1]));
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable29
   \   00000018   0x....             LDR.N    R0,??DataTable18_1
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x1D00             ADDS     R0,R0,#+4
   \   0000001E   0x.... 0x....      BL       MemoryCpy
   1056            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[2]),   (uint8_t*)&gOpt.hdr.u8Prefix[2]        ,sizeof(gOpt.hdr.u8Prefix[2]));
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable29_1
   \   00000028   0x....             LDR.N    R0,??DataTable18_1
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x1D40             ADDS     R0,R0,#+5
   \   0000002E   0x.... 0x....      BL       MemoryCpy
   1057            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[3]),   (uint8_t*)&gOpt.hdr.u8Length           ,sizeof(gOpt.hdr.u8Length   ));
   \   00000032   0x2201             MOVS     R2,#+1
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable29_2
   \   00000038   0x....             LDR.N    R0,??DataTable18_1
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x1D80             ADDS     R0,R0,#+6
   \   0000003E   0x.... 0x....      BL       MemoryCpy
   1058            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[4]),   (uint8_t*)&gOpt.hdr.u16SensorID        ,sizeof(gOpt.hdr.u16SensorID));
   \   00000042   0x2202             MOVS     R2,#+2
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable29_3
   \   00000048   0x....             LDR.N    R0,??DataTable18_1
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x1DC0             ADDS     R0,R0,#+7
   \   0000004E   0x.... 0x....      BL       MemoryCpy
   1059            
   1060            
   1061            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[6]),   (uint8_t*)&gOpt.options.u8RawSpinCount        ,sizeof(gOpt.options.u8RawSpinCount    ));   // updated *** 06/08/11 *** (formerly "u8Reserved1")
   \   00000052   0x2201             MOVS     R2,#+1
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable29_4
   \   00000058   0x....             LDR.N    R0,??DataTable18_1
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x3009             ADDS     R0,R0,#+9
   \   0000005E   0x.... 0x....      BL       MemoryCpy
   1062            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[7]),   (uint8_t*)&gOpt.options.u16TimeoutsToKill     ,sizeof(gOpt.options.u16TimeoutsToKill ));
   \   00000062   0x2202             MOVS     R2,#+2
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable29_5
   \   00000068   0x....             LDR.N    R0,??DataTable18_1
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x300A             ADDS     R0,R0,#+10
   \   0000006E   0x.... 0x....      BL       MemoryCpy
   1063            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[9]),   (uint8_t*)&gOpt.options.u16SampleSize         ,sizeof(gOpt.options.u16SampleSize     ));
   \   00000072   0x2202             MOVS     R2,#+2
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable29_6
   \   00000078   0x....             LDR.N    R0,??DataTable18_1
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x300C             ADDS     R0,R0,#+12
   \   0000007E   0x.... 0x....      BL       MemoryCpy
   1064            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[11]),   (uint8_t*)&gOpt.options.bAsciiMode            ,sizeof(gOpt.options.bAsciiMode        ));
   \   00000082   0x2201             MOVS     R2,#+1
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable29_7
   \   00000088   0x....             LDR.N    R0,??DataTable18_1
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x300E             ADDS     R0,R0,#+14
   \   0000008E   0x.... 0x....      BL       MemoryCpy
   1065            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[12]),   (uint8_t*)&gOpt.options.bBlinkingLEDs         ,sizeof(gOpt.options.bBlinkingLEDs     ));
   \   00000092   0x2201             MOVS     R2,#+1
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable29_8
   \   00000098   0x....             LDR.N    R0,??DataTable18_1
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0x300F             ADDS     R0,R0,#+15
   \   0000009E   0x.... 0x....      BL       MemoryCpy
   1066            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[13]),  (uint8_t*)&gOpt.options.u8OutputPower         ,sizeof(gOpt.options.u8OutputPower     ));
   \   000000A2   0x2201             MOVS     R2,#+1
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable29_9
   \   000000A8   0x....             LDR.N    R0,??DataTable18_1
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0x3010             ADDS     R0,R0,#+16
   \   000000AE   0x.... 0x....      BL       MemoryCpy
   1067            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[14]),  (uint8_t*)&gOpt.options.u32PngTimeout         ,sizeof(gOpt.options.u32PngTimeout     ));
   \   000000B2   0x2204             MOVS     R2,#+4
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable29_10
   \   000000B8   0x....             LDR.N    R0,??DataTable18_1
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0x3011             ADDS     R0,R0,#+17
   \   000000BE   0x.... 0x....      BL       MemoryCpy
   1068            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[18]),  (uint8_t*)&gOpt.options.u32SndTimeout         ,sizeof(gOpt.options.u32SndTimeout     ));
   \   000000C2   0x2204             MOVS     R2,#+4
   \   000000C4   0x.... 0x....      LDR.W    R1,??DataTable29_11
   \   000000C8   0x....             LDR.N    R0,??DataTable18_1
   \   000000CA   0x6800             LDR      R0,[R0, #+0]
   \   000000CC   0x3015             ADDS     R0,R0,#+21
   \   000000CE   0x.... 0x....      BL       MemoryCpy
   1069            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[22]),  (uint8_t*)&gOpt.options.bLNAHighGainMode      ,sizeof(gOpt.options.bLNAHighGainMode  )); // i.e. Low Noise Amplifier - updated *** 10/26/10 *** (formerly "u8Reserved2")
   \   000000D2   0x2201             MOVS     R2,#+1
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable29_12
   \   000000D8   0x....             LDR.N    R0,??DataTable18_1
   \   000000DA   0x6800             LDR      R0,[R0, #+0]
   \   000000DC   0x3019             ADDS     R0,R0,#+25
   \   000000DE   0x.... 0x....      BL       MemoryCpy
   1070            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[23]),  (uint8_t*)&gOpt.options.u16SleepAfterAck      ,sizeof(gOpt.options.u16SleepAfterAck  ));
   \   000000E2   0x2202             MOVS     R2,#+2
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable29_13
   \   000000E8   0x....             LDR.N    R0,??DataTable18_1
   \   000000EA   0x6800             LDR      R0,[R0, #+0]
   \   000000EC   0x301A             ADDS     R0,R0,#+26
   \   000000EE   0x.... 0x....      BL       MemoryCpy
   1071            gAppTxPacket->u8DataLength = OPT_SIZE;
   \   000000F2   0x2019             MOVS     R0,#+25
   \   000000F4   0x....             LDR.N    R1,??DataTable18_1
   \   000000F6   0x6809             LDR      R1,[R1, #+0]
   \   000000F8   0x7008             STRB     R0,[R1, #+0]
   1072            
   1073          }
   \   000000FA   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   1074          smacErrors_t SendASCIIPacket(){
   \                     SendASCIIPacket: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB094             SUB      SP,SP,#+80
   1075            InitPacket();
   \   00000004   0x.... 0x....      BL       InitPacket
   1076            gSnd.packetID=sentPackets;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable29_14
   \   0000000C   0x8800             LDRH     R0,[R0, #+0]
   \   0000000E   0x....             LDR.N    R1,??DataTable19
   \   00000010   0x80C8             STRH     R0,[R1, #+6]
   1077            int len = sprintf(&gAppTxPacket->smacPdu.u8Data[0],
   1078                      "SND\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%d\t%u\t%d\t%u\t%u\t%u\t%u\t%u\r\n",
   1079                      gSnd.hdr.u16SensorID, gSnd.packetID,
   1080                      gSnd.xmin, gSnd.xmax, gSnd.xmean,
   1081                      gSnd.ymin, gSnd.ymax, gSnd.ymean, 
   1082                      gSnd.ysum0, gSnd.ysum1,
   1083                      gSnd.zmin, gSnd.zmax, gSnd.zmean,
   1084                      gSnd.temperature, gSnd.battery_mV, gSnd.linkQdBm,
   1085                      gSnd.totalTimeouts, gSnd.maxMissedCount,
   1086                      gSnd.voltageWarning, gSnd.channel, gSnd.version);
   \   00000012   0x....             LDR.N    R0,??DataTable19
   \   00000014   0xF890 0x0044      LDRB     R0,[R0, #+68]
   \   00000018   0x9012             STR      R0,[SP, #+72]
   \   0000001A   0x....             LDR.N    R0,??DataTable19
   \   0000001C   0xF890 0x0043      LDRB     R0,[R0, #+67]
   \   00000020   0x9011             STR      R0,[SP, #+68]
   \   00000022   0x....             LDR.N    R0,??DataTable19
   \   00000024   0xF890 0x0042      LDRB     R0,[R0, #+66]
   \   00000028   0x9010             STR      R0,[SP, #+64]
   \   0000002A   0x....             LDR.N    R0,??DataTable19
   \   0000002C   0xF8B0 0x0040      LDRH     R0,[R0, #+64]
   \   00000030   0x900F             STR      R0,[SP, #+60]
   \   00000032   0x....             LDR.N    R0,??DataTable19
   \   00000034   0x8FC0             LDRH     R0,[R0, #+62]
   \   00000036   0x900E             STR      R0,[SP, #+56]
   \   00000038   0x....             LDR.N    R0,??DataTable19
   \   0000003A   0xF990 0x003C      LDRSB    R0,[R0, #+60]
   \   0000003E   0x900D             STR      R0,[SP, #+52]
   \   00000040   0x....             LDR.N    R0,??DataTable19
   \   00000042   0x8F40             LDRH     R0,[R0, #+58]
   \   00000044   0x900C             STR      R0,[SP, #+48]
   \   00000046   0x....             LDR.N    R0,??DataTable19
   \   00000048   0xF9B0 0x0038      LDRSH    R0,[R0, #+56]
   \   0000004C   0x900B             STR      R0,[SP, #+44]
   \   0000004E   0x....             LDR.N    R0,??DataTable19
   \   00000050   0x8D80             LDRH     R0,[R0, #+44]
   \   00000052   0x900A             STR      R0,[SP, #+40]
   \   00000054   0x....             LDR.N    R0,??DataTable19
   \   00000056   0x8D40             LDRH     R0,[R0, #+42]
   \   00000058   0x9009             STR      R0,[SP, #+36]
   \   0000005A   0x....             LDR.N    R0,??DataTable19
   \   0000005C   0x8D00             LDRH     R0,[R0, #+40]
   \   0000005E   0x9008             STR      R0,[SP, #+32]
   \   00000060   0x....             LDR.N    R0,??DataTable19
   \   00000062   0x6A40             LDR      R0,[R0, #+36]
   \   00000064   0x9007             STR      R0,[SP, #+28]
   \   00000066   0x....             LDR.N    R0,??DataTable19
   \   00000068   0x6A00             LDR      R0,[R0, #+32]
   \   0000006A   0x9006             STR      R0,[SP, #+24]
   \   0000006C   0x....             LDR.N    R0,??DataTable19
   \   0000006E   0x8B80             LDRH     R0,[R0, #+28]
   \   00000070   0x9005             STR      R0,[SP, #+20]
   \   00000072   0x....             LDR.N    R0,??DataTable19
   \   00000074   0x8B40             LDRH     R0,[R0, #+26]
   \   00000076   0x9004             STR      R0,[SP, #+16]
   \   00000078   0x....             LDR.N    R0,??DataTable19
   \   0000007A   0x8B00             LDRH     R0,[R0, #+24]
   \   0000007C   0x9003             STR      R0,[SP, #+12]
   \   0000007E   0x....             LDR.N    R0,??DataTable19
   \   00000080   0x8980             LDRH     R0,[R0, #+12]
   \   00000082   0x9002             STR      R0,[SP, #+8]
   \   00000084   0x....             LDR.N    R0,??DataTable19
   \   00000086   0x8940             LDRH     R0,[R0, #+10]
   \   00000088   0x9001             STR      R0,[SP, #+4]
   \   0000008A   0x....             LDR.N    R0,??DataTable19
   \   0000008C   0x8900             LDRH     R0,[R0, #+8]
   \   0000008E   0x9000             STR      R0,[SP, #+0]
   \   00000090   0x....             LDR.N    R0,??DataTable19
   \   00000092   0x88C3             LDRH     R3,[R0, #+6]
   \   00000094   0x....             LDR.N    R0,??DataTable19
   \   00000096   0x8882             LDRH     R2,[R0, #+4]
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable29_15
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable29_16
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x1CC0             ADDS     R0,R0,#+3
   \   000000A4   0x.... 0x....      BL       sprintf
   \   000000A8   0x0004             MOVS     R4,R0
   1087            gAppTxPacket->u8DataLength = len;
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable29_16
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0x7004             STRB     R4,[R0, #+0]
   1088            smacErrors_t status=MCPSDataRequest(gAppTxPacket);    
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable29_16
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0x.... 0x....      BL       MCPSDataRequest
   1089            return status;
   \   000000BC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BE   0xB014             ADD      SP,SP,#+80
   \   000000C0   0xBD10             POP      {R4,PC}          ;; return
   1090              
   1091          }

   \                                 In section .text, align 2, keep-with-next
   1092          smacErrors_t SendBinaryPacket(){
   \                     SendBinaryPacket: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1093            //InitPacket();
   1094            gSnd.packetID=sentPackets;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable29_14
   \   00000006   0x8800             LDRH     R0,[R0, #+0]
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   0000000C   0x80C8             STRH     R0,[R1, #+6]
   1095            gSnd.linkQdBm=GetLinkQdBm();
   \   0000000E   0x.... 0x....      BL       GetLinkQdBm
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   00000016   0xF881 0x003C      STRB     R0,[R1, #+60]
   1096            SndSwapEndianness();
   \   0000001A   0x.... 0x....      BL       SndSwapEndianness
   1097            CopyBinaryPacketToSMAC();  
   \   0000001E   0x.... 0x....      BL       CopyBinaryPacketToSMAC
   1098            smacErrors_t status=MCPSDataRequest(gAppTxPacket);    
   \   00000022   0x....             LDR.N    R0,??DataTable25_2
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x.... 0x....      BL       MCPSDataRequest
   1099            appState = WAIT_FOR_ACK;
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0x.... 0x....      LDR.W    R2,??DataTable36
   \   00000030   0x7011             STRB     R1,[R2, #+0]
   1100            return status;
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0xBD02             POP      {R1,PC}          ;; return
   1101          }
   1102          

   \                                 In section .text, align 2, keep-with-next
   1103          void InitPacket(){
   1104            gSnd.hdr.u8Prefix[0] = 'S';
   \                     InitPacket: (+1)
   \   00000000   0x2053             MOVS     R0,#+83
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   00000006   0x7008             STRB     R0,[R1, #+0]
   1105            gSnd.hdr.u8Prefix[1] = 'N';
   \   00000008   0x204E             MOVS     R0,#+78
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   0000000E   0x7048             STRB     R0,[R1, #+1]
   1106            gSnd.hdr.u8Prefix[2] = 'D';       
   \   00000010   0x2044             MOVS     R0,#+68
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   00000016   0x7088             STRB     R0,[R1, #+2]
   1107            gSnd.hdr.u8Length = SND_SIZE;
   \   00000018   0x203E             MOVS     R0,#+62
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   0000001E   0x70C8             STRB     R0,[R1, #+3]
   1108            gSnd.hdr.u16SensorID = sensorID;  
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable29_18
   \   00000024   0x8800             LDRH     R0,[R0, #+0]
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   0000002A   0x8088             STRH     R0,[R1, #+4]
   1109            
   1110            gSnd.xsum0 = 1111111;
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable29_19  ;; 0x10f447
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   00000034   0x6108             STR      R0,[R1, #+16]
   1111            gSnd.ysum0 = 2222222;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable29_20  ;; 0x21e88e
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   0000003E   0x6208             STR      R0,[R1, #+32]
   1112            gSnd.zsum0 = 3333333;
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable29_21  ;; 0x32dcd5
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   00000048   0x6308             STR      R0,[R1, #+48]
   1113            gSnd.xsum1 = 111111111;
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable29_22  ;; 0x69f6bc7
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   00000052   0x6148             STR      R0,[R1, #+20]
   1114            gSnd.ysum1 = 222222222;
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0xd3ed78e
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   0000005C   0x6248             STR      R0,[R1, #+36]
   1115            gSnd.zsum1 = 333333333;
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable31  ;; 0x13de4355
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   00000066   0x6348             STR      R0,[R1, #+52]
   1116            gSnd.xmin = 1000;
   \   00000068   0xF44F 0x707A      MOV      R0,#+1000
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   00000070   0x8108             STRH     R0,[R1, #+8]
   1117            gSnd.ymin = 2000;
   \   00000072   0xF44F 0x60FA      MOV      R0,#+2000
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   0000007A   0x8308             STRH     R0,[R1, #+24]
   1118            gSnd.zmin = 3000;
   \   0000007C   0xF640 0x30B8      MOVW     R0,#+3000
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   00000084   0x8508             STRH     R0,[R1, #+40]
   1119            gSnd.xmax = 9991;
   \   00000086   0xF242 0x7007      MOVW     R0,#+9991
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   0000008E   0x8148             STRH     R0,[R1, #+10]
   1120            gSnd.ymax = 9992;
   \   00000090   0xF242 0x7008      MOVW     R0,#+9992
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   00000098   0x8348             STRH     R0,[R1, #+26]
   1121            gSnd.zmax = 9993;
   \   0000009A   0xF242 0x7009      MOVW     R0,#+9993
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   000000A2   0x8548             STRH     R0,[R1, #+42]
   1122            gSnd.xmean = 111;
   \   000000A4   0x206F             MOVS     R0,#+111
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   000000AA   0x8188             STRH     R0,[R1, #+12]
   1123            gSnd.ymean = 222;
   \   000000AC   0x20DE             MOVS     R0,#+222
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   000000B2   0x8388             STRH     R0,[R1, #+28]
   1124            gSnd.zmean = 333;
   \   000000B4   0xF240 0x104D      MOVW     R0,#+333
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   000000BC   0x8588             STRH     R0,[R1, #+44]
   1125            gSnd.packetID=666;
   \   000000BE   0xF240 0x209A      MOVW     R0,#+666
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   000000C6   0x80C8             STRH     R0,[R1, #+6]
   1126            gSnd.temperature=375;
   \   000000C8   0xF240 0x1077      MOVW     R0,#+375
   \   000000CC   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   000000D0   0x8708             STRH     R0,[R1, #+56]
   1127            gSnd.battery_mV=3000;
   \   000000D2   0xF640 0x30B8      MOVW     R0,#+3000
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   000000DA   0x8748             STRH     R0,[R1, #+58]
   1128           // gSnd.linkQdBm=-75;
   1129            gSnd.totalTimeouts=3;
   \   000000DC   0x2003             MOVS     R0,#+3
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   000000E2   0x87C8             STRH     R0,[R1, #+62]
   1130            gSnd.maxMissedCount=3;
   \   000000E4   0x2003             MOVS     R0,#+3
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   000000EA   0xF8A1 0x0040      STRH     R0,[R1, #+64]
   1131            gSnd.voltageWarning=2;
   \   000000EE   0x2002             MOVS     R0,#+2
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   000000F4   0xF881 0x0042      STRB     R0,[R1, #+66]
   1132            gSnd.channel=gChannel11_c - 11;
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   000000FE   0xF881 0x0043      STRB     R0,[R1, #+67]
   1133            gSnd.version=9;
   \   00000102   0x2009             MOVS     R0,#+9
   \   00000104   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   00000108   0xF881 0x0044      STRB     R0,[R1, #+68]
   1134            
   1135            evDataFromCOMM = FALSE;
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable36_1
   \   00000112   0x7008             STRB     R0,[R1, #+0]
   1136          }
   \   00000114   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1137          void FlashSaveOptions(){
   \                     FlashSaveOptions: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   1138            
   1139            uint32_t statErase, statRead, statWrite;
   1140            NvConfig_t mNvConfig = {
   1141             gNV_FTFX_REG_BASE_c,
   1142             gNV_PFLASH_BLOCK_BASE_c,
   1143             gNV_PFLASH_BLOCK_SIZE_c,
   1144             gNV_DFLASH_BLOCK_BASE_c,
   1145             gNV_DFLASH_BLOCK_SIZE_c,
   1146             gNV_EERAM_BLOCK_BASE_c,
   1147             gNV_EERAM_BLOCK_SIZE_c,
   1148             gNV_EEE_BLOCK_SIZE_c
   1149            };
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable35
   \   0000000A   0x2220             MOVS     R2,#+32
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy4
   1150            gFlashDeadBeef=g_DEAD_BEEF;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable35_2
   \   0000001A   0x6008             STR      R0,[R1, #+0]
   1151            statErase = NV_FlashEraseSector(&mNvConfig, settingsAddress,0x800);
   \   0000001C   0xF44F 0x6200      MOV      R2,#+2048
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable35_3
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0xA800             ADD      R0,SP,#+0
   \   00000028   0x.... 0x....      BL       NV_FlashEraseSector
   \   0000002C   0x0004             MOVS     R4,R0
   1152            uint32_t address = settingsAddress;
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable35_3
   \   00000032   0x6806             LDR      R6,[R0, #+0]
   1153            statWrite = NV_FlashProgramLongword(&mNvConfig,settingsAddress,sizeof(gFlashDeadBeef),(uint32_t)&gFlashDeadBeef);
   \   00000034   0x.... 0x....      LDR.W    R3,??DataTable35_2
   \   00000038   0x2204             MOVS     R2,#+4
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable35_3
   \   0000003E   0x6801             LDR      R1,[R0, #+0]
   \   00000040   0xA800             ADD      R0,SP,#+0
   \   00000042   0x.... 0x....      BL       NV_FlashProgramLongword
   \   00000046   0x0005             MOVS     R5,R0
   1154            address = address + sizeof(gFlashDeadBeef);
   \   00000048   0x1D36             ADDS     R6,R6,#+4
   1155            if(statWrite ==gNV_OK_c) NV_FlashProgramUnalignedLongword(&mNvConfig,address,sizeof(gOptions),(uint32_t)&gOptions);
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD106             BNE.N    ??FlashSaveOptions_0
   \   0000004E   0x.... 0x....      LDR.W    R3,??DataTable36_2
   \   00000052   0x2218             MOVS     R2,#+24
   \   00000054   0x0031             MOVS     R1,R6
   \   00000056   0xA800             ADD      R0,SP,#+0
   \   00000058   0x.... 0x....      BL       NV_FlashProgramUnalignedLongword
   1156          //  NV_FlashRead(address, (uint8_t*)&gFlashOptions,sizeof(gFlashOptions));
   1157            
   1158          }
   \                     ??FlashSaveOptions_0: (+1)
   \   0000005C   0xB008             ADD      SP,SP,#+32
   \   0000005E   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   1159          void GetFactoryOptions(tOptions* pOptions)
   1160          {
   1161              // Load the factory default configuration options
   1162              pOptions->u8RawSpinCount = 0; // i.e., don't send raw accelerometer data - updated *** 06/08/11 ***
   \                     GetFactoryOptions: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7001             STRB     R1,[R0, #+0]
   1163              pOptions->u16TimeoutsToKill = TIMEOUTS_TO_KILL;
   \   00000004   0xF44F 0x71B4      MOV      R1,#+360
   \   00000008   0x8041             STRH     R1,[R0, #+2]
   1164              pOptions->u16SampleSize = ACCEL_SAMPLE_SIZE;
   \   0000000A   0xF44F 0x51FA      MOV      R1,#+8000
   \   0000000E   0x8081             STRH     R1,[R0, #+4]
   1165              pOptions->bAsciiMode = TRUE;
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x7181             STRB     R1,[R0, #+6]
   1166              pOptions->bBlinkingLEDs = TRUE;
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x71C1             STRB     R1,[R0, #+7]
   1167              pOptions->u8OutputPower = OUTPUT_POWER;
   \   00000018   0x2164             MOVS     R1,#+100
   \   0000001A   0x7201             STRB     R1,[R0, #+8]
   1168              pOptions->u32PngTimeout = PNG_TIMEOUT;
   \   0000001C   0xF248 0x01E8      MOVW     R1,#+33000
   \   00000020   0x60C1             STR      R1,[R0, #+12]
   1169              pOptions->u32SndTimeout = SND_TIMEOUT;
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable36_3  ;; 0x28488
   \   00000026   0x6101             STR      R1,[R0, #+16]
   1170          
   1171          // Updated *** 10/26/10 ***    
   1172          #if defined (PANASONIC_REVB)
   1173              pOptions->bLNAHighGainMode = TRUE;
   1174          #elif defined (PANASONIC_YES)
   1175              pOptions->bLNAHighGainMode = TRUE;
   1176          #else
   1177              pOptions->bLNAHighGainMode = FALSE; // Note: LNA isn't even available for PANASONIC_NO
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x7501             STRB     R1,[R0, #+20]
   1178          #endif
   1179          
   1180              pOptions->u16SleepAfterAck = SLEEP_AFTER_ACK;
   \   0000002C   0x2103             MOVS     R1,#+3
   \   0000002E   0x82C1             STRH     R1,[R0, #+22]
   1181              
   1182              return;
   \   00000030   0x4770             BX       LR               ;; return
   1183          }
   1184          
   1185          
   1186          /************************************************************************************
   1187          *
   1188          * WUApp_LowPowerWhile
   1189          *
   1190          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1191          void WUApp_LowPowerWhile(void) 
   1192          {  
   \                     WUApp_LowPowerWhile: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1193              /* Backup Current configuration and set Low power configuration*/
   1194              WUApp_PrepareToEnterLowPower();
   \   00000002   0x.... 0x....      BL       WUApp_PrepareToEnterLowPower
   1195          
   1196          #if(gDefaultLowPowerMode_c == gWUAppLLSMode_c) 
   1197              /* configure MCU in LLS low power mode */
   1198              PWRLib_MCU_Enter_LLS();
   1199          #elif (gDefaultLowPowerMode_c == gWUAppVLPSMode_c)
   1200              /* configure MCU in VLPS low power mode */
   1201              PWRLib_MCU_Enter_VLPS();
   1202          #elif (gDefaultLowPowerMode_c == gWUAppVLLS2Mode_c)
   1203              /* configure MCU in VLLS2 low power mode */
   1204              PWRLib_MCU_Enter_VLLS2();
   1205          #elif (gDefaultLowPowerMode_c == gWUAppVLLS1Mode_c)
   1206              /* configure MCU in VLLS1 low power mode */
   1207              PWRLib_MCU_Enter_VLLS1();
   \   00000006   0x.... 0x....      BL       PWRLib_MCU_Enter_VLLS1
   1208          #elif (gDefaultLowPowerMode_c == gWUAppVLLS0Mode_c)
   1209              /* configure MCU in VLLS0 low power mode */
   1210              PWRLib_MCU_Enter_VLLS0();
   1211              
   1212          #endif
   1213              /* Restore backup configuration*/ 
   1214              WUApp_LPRestoreSettings();
   \   0000000A   0x.... 0x....      BL       WUApp_LPRestoreSettings
   1215           
   1216          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
   1217          
   1218          
   1219          /************************************************************************************
   1220          *
   1221          * WUApp_InitWakupSource
   1222          *                                       
   1223          ************************************************************************************/
   1224          

   \                                 In section .text, align 2, keep-with-next
   1225          void WUApp_InitWakupSource(void)
   1226          {
   \                     WUApp_InitWakupSource: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1227          #if (gDefaultWakeupSource_c == gWUAppGPIO_c) 
   1228              pu8WakeupSourceString = (uint8_t *)cau8WUGPIOWakeupString;
   1229              PWRLib_LLWU_WakeupPinEnable( (PWRLib_LLWU_WakeupPin_t) gLLWU_WakeUp_PIN_Number_c, gPWRLib_LLWU_WakeupPin_AnyEdge_c);
   1230          #elif (gDefaultWakeupSource_c == gWUAppLPTMR_c)
   1231              pu8WakeupSourceString = (uint8_t *)cau8WULPTMRWakeupString;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable35_4
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable36_4
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   1232              /* configure NVIC for LPTMR Isr */
   1233              NVIC_EnableIRQ(gLPTMR_IRQ_Number_c);
   \   0000000C   0x203A             MOVS     R0,#+58
   \   0000000E   0x.... 0x....      BL       NVIC_EnableIRQ
   1234              /* enable LPTMR as wakeup source for LLWU module */
   1235              PWRLib_LLWU_WakeupModuleEnable(gPWRLib_LLWU_WakeupModule_LPTMR_c);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       PWRLib_LLWU_WakeupModuleEnable
   1236          #elif (gDefaultWakeupSource_c == gWUAppRTC_c)
   1237              pu8WakeupSourceString = (uint8_t *)cau8WURTCWakeupString;
   1238              PWRLib_RTC_Init();
   1239              /* configure NVIC for RTC alarm Isr */
   1240              NVIC_EnableIRQ(gRTC_IRQ_Number_c);
   1241              /* enable RTC as wakeup source for LLWU module */
   1242              PWRLib_LLWU_WakeupModuleEnable(gPWRLib_LLWU_WakeupModule_RTC_Alarm_c);
   1243          #endif
   1244              NVIC_EnableIRQ(gLLWU_IRQ_Number_c);
   \   00000018   0x2015             MOVS     R0,#+21
   \   0000001A   0x.... 0x....      BL       NVIC_EnableIRQ
   1245          }
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return
   1246          
   1247          
   1248          /************************************************************************************
   1249          *
   1250          * WUApp_InitLowPowerMode
   1251          *                                       
   1252          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1253          void WUApp_InitLowPowerMode(void)
   1254          {
   1255          #if (gDefaultLowPowerMode_c == gWUAppLLSMode_c)
   1256              pu8GotoLowPowerString = (uint8_t *)cau8WUGotoLLSString;
   1257              pu8NowInLowPowerString = (uint8_t *)cau8WUIsLLSModeString;
   1258              SMC_PMPROT |= SMC_PMPROT_ALLS_MASK;         /*Enable the low-power mode "Register can be written only once after any system reset"*/
   1259          #elif (gDefaultLowPowerMode_c == gWUAppVLPSMode_c)
   1260              pu8GotoLowPowerString = (uint8_t *)cau8WUGotoVLPSString;
   1261              pu8NowInLowPowerString = (uint8_t *)cau8WUIsVLPSModeString;
   1262              SMC_PMPROT |= SMC_PMPROT_AVLP_MASK;         /*Enable the low-power mode "Register can be written only once after any system reset"*/
   1263          #elif (gDefaultLowPowerMode_c == gWUAppVLLS2Mode_c)
   1264              pu8GotoLowPowerString = (uint8_t *)cau8WUGotoVLLS2String;
   1265              pu8NowInLowPowerString = (uint8_t *)cau8WUIsVLLS2ModeString;
   1266              SMC_PMPROT |= SMC_PMPROT_AVLLS_MASK;        /*Enable the low-power mode "Register can be written only once after any system reset"*/
   1267          #elif (gDefaultLowPowerMode_c == gWUAppVLLS1Mode_c)
   1268              pu8GotoLowPowerString = (uint8_t *)cau8WUGotoVLLS1String;
   \                     WUApp_InitLowPowerMode: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable35_5
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable35_6
   \   00000008   0x6008             STR      R0,[R1, #+0]
   1269              pu8NowInLowPowerString = (uint8_t *)cau8WUIsVLLS1ModeString;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable35_7
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable35_8
   \   00000012   0x6008             STR      R0,[R1, #+0]
   1270              SMC_PMPROT |= SMC_PMPROT_AVLLS_MASK;        /*Enable the low-power mode "Register can be written only once after any system reset"*/
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable36_5  ;; 0x4007e000
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable36_5  ;; 0x4007e000
   \   00000022   0x7008             STRB     R0,[R1, #+0]
   1271          #elif (gDefaultLowPowerMode_c == gWUAppVLLS0Mode_c)
   1272              pu8GotoLowPowerString = (uint8_t *)cau8WUGotoVLLS0String;
   1273              pu8NowInLowPowerString = (uint8_t *)cau8WUIsVLLS0ModeString;
   1274              SMC_PMPROT |= SMC_PMPROT_AVLLS_MASK;        /*Enable the low-power mode "Register can be written only once after any system reset"*/
   1275          #endif
   1276          }
   \   00000024   0x4770             BX       LR               ;; return
   1277          
   1278          
   1279          
   1280          
   1281          
   1282          /************************************************************************************
   1283          * InitProject
   1284          * 
   1285          * Hardware and Global data initialization
   1286          *
   1287          ************************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1288          void InitProject(void)
   1289          {
   \                     InitProject: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
   1290              DisableInterrupts();
   \   00000006   0xB672             CPSID i
   1291             gLPConfigState =gLPConfigState;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable36_6
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable36_6
   \   00000012   0x7008             STRB     R0,[R1, #+0]
   1292             gOpt.hdr.u8Prefix[0] = 'O';
   \   00000014   0x204F             MOVS     R0,#+79
   \   00000016   0x....             LDR.N    R1,??DataTable28_33
   \   00000018   0x7008             STRB     R0,[R1, #+0]
   1293             gOpt.hdr.u8Prefix[1] = 'P';
   \   0000001A   0x2050             MOVS     R0,#+80
   \   0000001C   0x....             LDR.N    R1,??DataTable28_33
   \   0000001E   0x7048             STRB     R0,[R1, #+1]
   1294             gOpt.hdr.u8Prefix[2] = 'T';
   \   00000020   0x2054             MOVS     R0,#+84
   \   00000022   0x....             LDR.N    R1,??DataTable28_33
   \   00000024   0x7088             STRB     R0,[R1, #+2]
   1295             gOpt.hdr.u16SensorID = sensorID;
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable29_18
   \   0000002A   0x8800             LDRH     R0,[R0, #+0]
   \   0000002C   0x....             LDR.N    R1,??DataTable28_33
   \   0000002E   0x8088             STRH     R0,[R1, #+4]
   1296             gOpt.hdr.u8Length = OPT_SIZE;
   \   00000030   0x2019             MOVS     R0,#+25
   \   00000032   0x....             LDR.N    R1,??DataTable28_33
   \   00000034   0x70C8             STRB     R0,[R1, #+3]
   1297             
   1298             gPng.u8Prefix[0] = 'P';
   \   00000036   0x2050             MOVS     R0,#+80
   \   00000038   0x....             LDR.N    R1,??DataTable28_1
   \   0000003A   0x7008             STRB     R0,[R1, #+0]
   1299             gPng.u8Prefix[1] = 'N';
   \   0000003C   0x204E             MOVS     R0,#+78
   \   0000003E   0x....             LDR.N    R1,??DataTable28_1
   \   00000040   0x7048             STRB     R0,[R1, #+1]
   1300             gPng.u8Prefix[2] = 'G';
   \   00000042   0x2047             MOVS     R0,#+71
   \   00000044   0x....             LDR.N    R1,??DataTable28_1
   \   00000046   0x7088             STRB     R0,[R1, #+2]
   1301             gPng.u16SensorID = sensorID;        // initialized via compiler settings (1 - 65534)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable29_18
   \   0000004C   0x8800             LDRH     R0,[R0, #+0]
   \   0000004E   0x....             LDR.N    R1,??DataTable28_1
   \   00000050   0x8088             STRH     R0,[R1, #+4]
   1302              
   1303              
   1304            // Bob's code
   1305             uint8_t u8Status;
   1306             uint8_t u8BlinkOnFirstAck = 1;
   \   00000052   0x2401             MOVS     R4,#+1
   1307             uint16_t sleepCount;
   1308             uint16_t missedCount = 0;
   \   00000054   0x2500             MOVS     R5,#+0
   1309            // Detect if we need a factory reset
   1310             uint32_t statErase, statWrite;
   1311             NvConfig_t mNvConfig = {
   1312             gNV_FTFX_REG_BASE_c,
   1313             gNV_PFLASH_BLOCK_BASE_c,
   1314             gNV_PFLASH_BLOCK_SIZE_c,
   1315             gNV_DFLASH_BLOCK_BASE_c,
   1316             gNV_DFLASH_BLOCK_SIZE_c,
   1317             gNV_EERAM_BLOCK_BASE_c,
   1318             gNV_EERAM_BLOCK_SIZE_c,
   1319             gNV_EEE_BLOCK_SIZE_c
   1320            };
   \   00000056   0xA800             ADD      R0,SP,#+0
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable36_7
   \   0000005C   0x2220             MOVS     R2,#+32
   \   0000005E   0x.... 0x....      BL       __aeabi_memcpy4
   1321            NV_FlashInit(&mNvConfig);
   \   00000062   0xA800             ADD      R0,SP,#+0
   \   00000064   0x.... 0x....      BL       NV_FlashInit
   1322            static uint32_t sDeadBeef;
   1323          //   
   1324          //   statErase = NV_FlashEraseSector(&mNvConfig, settingsAddress,0x800);
   1325          //   statWrite = NV_FlashProgramLongword(&mNvConfig,settingsAddress,sizeof(sDeadBeef),(uint32_t)&sDeadBeef);
   1326             NV_FlashRead(settingsAddress,(uint8_t*)&gFlashDeadBeef,sizeof(gFlashDeadBeef));
   \   00000068   0x2204             MOVS     R2,#+4
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable35_2
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable35_3
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x.... 0x....      BL       NV_FlashRead
   1327             uint8_t bFactoryReset = (sDeadBeef == g_DEAD_BEEF) || (gFlashDeadBeef != g_DEAD_BEEF);
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable36_8
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable35_1
   \   00000082   0x6809             LDR      R1,[R1, #+0]
   \   00000084   0x4288             CMP      R0,R1
   \   00000086   0xD007             BEQ.N    ??InitProject_0
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable35_2
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable35_1
   \   00000092   0x6809             LDR      R1,[R1, #+0]
   \   00000094   0x4288             CMP      R0,R1
   \   00000096   0xD001             BEQ.N    ??InitProject_1
   \                     ??InitProject_0: (+1)
   \   00000098   0x2601             MOVS     R6,#+1
   \   0000009A   0xE000             B.N      ??InitProject_2
   \                     ??InitProject_1: (+1)
   \   0000009C   0x2600             MOVS     R6,#+0
   1328             sDeadBeef = g_DEAD_BEEF;
   \                     ??InitProject_2: (+1)
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable36_8
   \   000000A8   0x6008             STR      R0,[R1, #+0]
   1329             if (bFactoryReset)
   \   000000AA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000AC   0x2E00             CMP      R6,#+0
   \   000000AE   0xD004             BEQ.N    ??InitProject_3
   1330             {
   1331                 GetFactoryOptions(&gOptions);
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable36_2
   \   000000B4   0x.... 0x....      BL       GetFactoryOptions
   \   000000B8   0xE008             B.N      ??InitProject_4
   1332             }
   1333             else
   1334             {
   1335           //      gOptions = gFlashOptions;      
   1336                NV_FlashRead(settingsAddress+sizeof(gFlashDeadBeef),(uint8_t*)&gOptions,sizeof(gOptions));
   \                     ??InitProject_3: (+1)
   \   000000BA   0x2218             MOVS     R2,#+24
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable36_2
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable35_3
   \   000000C4   0x6800             LDR      R0,[R0, #+0]
   \   000000C6   0x1D00             ADDS     R0,R0,#+4
   \   000000C8   0x.... 0x....      BL       NV_FlashRead
   1337             }
   1338            InitPacket(); 
   \                     ??InitProject_4: (+1)
   \   000000CC   0x.... 0x....      BL       InitPacket
   1339           
   1340            /* SPI Initialization */ 
   1341            MC1324xDrv_SPIInit(); 
   \   000000D0   0x.... 0x....      BL       MC1324xDrv_SPIInit
   1342            (void)MLMERadioInit();
   \   000000D4   0x.... 0x....      BL       MLMERadioInit
   \   000000D8   0x4680             MOV      R8,R0
   1343            /* TMR Initialization */
   1344            TMR_Init(); 
   \   000000DA   0x.... 0x....      BL       TMR_Init
   1345            MM_Init((uint8_t*)maMacHeap, poolInfo, maMmPools);
   \   000000DE   0x.... 0x....      LDR.W    R2,??DataTable36_9
   \   000000E2   0x.... 0x....      LDR.W    R1,??DataTable36_10
   \   000000E6   0x.... 0x....      LDR.W    R0,??DataTable36_11
   \   000000EA   0x.... 0x....      BL       MM_Init
   1346            /*LED configuration*/
   1347            LED_Init();
   \   000000EE   0x.... 0x....      BL       LED_Init
   1348          #if defined(gCDCInterface_d)
   1349            USB_Init();
   1350            (void)CDC_ModuleInit();
   1351          #elif defined (gUARTInterface_d)
   1352            /* UART Initialization */
   1353            Uart_ModuleInit();
   \   000000F2   0x.... 0x....      BL       Uart_ModuleInit
   1354          #endif
   1355            Comm_SetBaud(Comm_DefaultBaud);
   \   000000F6   0xF45F 0x30E1      MOVS     R0,#+115200
   \   000000FA   0x.... 0x....      BL       Uart1_SetBaud
   1356            Comm_SetRxCallBack(CommRxCallback);
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable36_12
   \   00000102   0x.... 0x....      BL       Uart1_SetRxCallBack
   1357            
   1358            
   1359            mLEDTimerID_1 = TMR_AllocateTimer();
   \   00000106   0x.... 0x....      BL       TMR_AllocateTimer
   \   0000010A   0x.... 0x....      LDR.W    R1,??DataTable36_13
   \   0000010E   0x7008             STRB     R0,[R1, #+0]
   1360            mBufferTimerID = TMR_AllocateTimer();
   \   00000110   0x.... 0x....      BL       TMR_AllocateTimer
   \   00000114   0x.... 0x....      LDR.W    R1,??DataTable36_14
   \   00000118   0x7008             STRB     R0,[R1, #+0]
   1361          
   1362            /* Keyboard Initialization */
   1363            KeyboardInit();
   \   0000011A   0x.... 0x....      BL       KeyboardInit
   1364            GlobalDataInit();  
   \   0000011E   0x.... 0x....      BL       GlobalDataInit
   1365            
   1366          
   1367          //  evDataFromCOMM = FALSE;
   1368            
   1369            EnableInterrupts();
   \   00000122   0xB662             CPSIE i
   1370            int count = 10;
   \   00000124   0x270A             MOVS     R7,#+10
   1371            while (count--)
   \                     ??InitProject_5: (+1)
   \   00000126   0x0038             MOVS     R0,R7
   \   00000128   0x1E47             SUBS     R7,R0,#+1
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD005             BEQ.N    ??InitProject_6
   1372            {
   1373                uint16_t innerCount = 0;        
   \   0000012E   0x2000             MOVS     R0,#+0
   1374                while (--innerCount);
   \                     ??InitProject_7: (+1)
   \   00000130   0x1E40             SUBS     R0,R0,#+1
   \   00000132   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000134   0x2800             CMP      R0,#+0
   \   00000136   0xD1FB             BNE.N    ??InitProject_7
   \   00000138   0xE7F5             B.N      ??InitProject_5
   1375            }
   1376            FlashSaveOptions();
   \                     ??InitProject_6: (+1)
   \   0000013A   0x.... 0x....      BL       FlashSaveOptions
   1377            sDeadBeef = 0;
   \   0000013E   0x2000             MOVS     R0,#+0
   \   00000140   0x.... 0x....      LDR.W    R1,??DataTable36_8
   \   00000144   0x6008             STR      R0,[R1, #+0]
   1378           //  
   1379           //  // Initialize options.
   1380           //  // NOTE: we can't write to FLASH memory yet ("AppInit" not called yet, clock, etc),
   1381           //  // so we don't call "FlashSaveOptions" yet.
   1382             
   1383             #if (TRUE == gEnableConfigMenus_d)
   1384              gConfigState = gWUConfigStateMainMenu_c;
   \   00000146   0x2000             MOVS     R0,#+0
   \   00000148   0x.... 0x....      LDR.W    R1,??DataTable36_15
   \   0000014C   0x7008             STRB     R0,[R1, #+0]
   1385              gLPConfigState = gWULPStateInit_c;
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0x.... 0x....      LDR.W    R1,??DataTable36_6
   \   00000154   0x7008             STRB     R0,[R1, #+0]
   1386              u8SequencePointerCounter = 0;
   \   00000156   0x2000             MOVS     R0,#+0
   \   00000158   0x.... 0x....      LDR.W    R1,??DataTable36_16
   \   0000015C   0x7008             STRB     R0,[R1, #+0]
   1387              bReturnToMainMenuFlag = FALSE; 
   \   0000015E   0x2000             MOVS     R0,#+0
   \   00000160   0x.... 0x....      LDR.W    R1,??DataTable36_17
   \   00000164   0x7008             STRB     R0,[R1, #+0]
   1388            #else
   1389              gAppMode = gWUModeApplication_c;
   1390            #endif
   1391              
   1392            #if (gEnableLowPower_d == TRUE)        
   1393            #if (gDefaultLowPowerMode_c == gWUAppLLSMode_c)  
   1394                  pu8MainLowPowerString = (uint8_t *)cau8WULLSString;
   1395            #elif (gDefaultLowPowerMode_c == gWUAppVLPSMode_c)
   1396                  pu8MainLowPowerString = (uint8_t *)cau8WUVLPSString;
   1397            #elif (gDefaultLowPowerMode_c == gWUAppVLLS2Mode_c)
   1398                  pu8MainLowPowerString = (uint8_t *)cau8WUVLLS2String;
   1399            #elif (gDefaultLowPowerMode_c == gWUAppVLLS1Mode_c)
   1400                  pu8MainLowPowerString = (uint8_t *)cau8WUVLLS1String;
   \   00000166   0x.... 0x....      LDR.W    R0,??DataTable36_18
   \   0000016A   0x.... 0x....      LDR.W    R1,??DataTable36_19
   \   0000016E   0x6008             STR      R0,[R1, #+0]
   1401            #elif (gDefaultLowPowerMode_c == gWUAppVLLS0Mode_c)
   1402                  pu8MainLowPowerString = (uint8_t *)cau8WUVLLS0String;
   1403            #endif            
   1404            #if (gDefaultWakeupSource_c == gWUAppGPIO_c) 
   1405                  pu8MainWakeupSourceString = (uint8_t *)cau8WUGPIOString;
   1406            #elif (gDefaultWakeupSource_c == gWUAppLPTMR_c)
   1407                  pu8MainWakeupSourceString = (uint8_t *)cau8WULPTMRString;
   \   00000170   0x.... 0x....      LDR.W    R0,??DataTable36_20
   \   00000174   0x.... 0x....      LDR.W    R1,??DataTable36_21
   \   00000178   0x6008             STR      R0,[R1, #+0]
   1408            #elif (gDefaultWakeupSource_c == gWUAppRTC_c)
   1409                  pu8MainWakeupSourceString = (uint8_t *)cau8WURTCString;
   1410            #endif
   1411            #endif
   1412                            
   1413                bTxOtaBusyFlag = FALSE;
   \   0000017A   0x2000             MOVS     R0,#+0
   \   0000017C   0x.... 0x....      LDR.W    R1,??DataTable36_22
   \   00000180   0x7008             STRB     R0,[R1, #+0]
   1414                bCommGetDataTimerFlag = FALSE;
   \   00000182   0x2000             MOVS     R0,#+0
   \   00000184   0x.... 0x....      LDR.W    R1,??DataTable36_23
   \   00000188   0x7008             STRB     R0,[R1, #+0]
   1415             #if(TRUE == gEnableAckOta_d)
   1416                gDataRetries = gDefaultNumberRetries_c;
   1417                gRetryTxSize = 0;
   1418                bWait4AckFlag = FALSE;
   1419            #endif 
   1420             
   1421             
   1422          }
   \   0000018A   0xB008             ADD      SP,SP,#+32
   \   0000018C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .bss, align 4
   \                     ??sDeadBeef:
   \   00000000                      DS8 4

   \                                 In section .text, align 2, keep-with-next
   1423          void GlobalDataInit(void)
   1424          {
   1425            /*Global Data init*/
   1426            testOpMode     = gDefaultMode_c;
   \                     GlobalDataInit: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable36_24
   \   00000006   0x7008             STRB     R0,[R1, #+0]
   1427            testChannel    = gDefaultChannelNumber_c;
   \   00000008   0x200F             MOVS     R0,#+15
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable36_25
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
   1428            testPower      = gDefaultOutputPower_c;
   \   00000010   0x2017             MOVS     R0,#+23
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable36_26
   \   00000016   0x7008             STRB     R0,[R1, #+0]
   1429            testTrimmValue = gDefaultCrysTrim_c;
   \   00000018   0x2073             MOVS     R0,#+115
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable36_27
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
   1430            testPayloadLen = gDefaultPayload_c;
   \   00000020   0x2014             MOVS     R0,#+20
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable36_28
   \   00000026   0x7008             STRB     R0,[R1, #+0]
   1431            contTestRunning = gTestModeForceIdle_c;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable36_29
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
   1432            shortCutsEnabled = FALSE; 
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable36_30
   \   00000036   0x7008             STRB     R0,[R1, #+0]
   1433            connState      = gConnInitState_c;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable36_31
   \   0000003E   0x7008             STRB     R0,[R1, #+0]
   1434            cTxRxState     = gCTxRxStateInit_c;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable36_32
   \   00000046   0x7008             STRB     R0,[R1, #+0]
   1435            perTxState     = gPerTxStateInit_c;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable36_33
   \   0000004E   0x7008             STRB     R0,[R1, #+0]
   1436            perRxState     = gPerRxStateInit_c;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable36_34
   \   00000056   0x7008             STRB     R0,[R1, #+0]
   1437            rangeTxState   = gRangeTxStateInit_c;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable36_35
   \   0000005E   0x7008             STRB     R0,[R1, #+0]
   1438            rangeRxState   = gRangeRxStateInit_c;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable36_36
   \   00000066   0x7008             STRB     R0,[R1, #+0]
   1439            prevOpMode      = gDefaultMode_c;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable36_37
   \   0000006E   0x7008             STRB     R0,[R1, #+0]
   1440            txTestIndex    = gPacketErrorRateTx_c;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable36_38
   \   00000076   0x7008             STRB     R0,[R1, #+0]
   1441            rxTestIndex    = gPacketErrorRateRx_c;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable36_39
   \   0000007E   0x7008             STRB     R0,[R1, #+0]
   1442          }
   \   00000080   0x4770             BX       LR               ;; return
   1443          /**************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1444          void InitSmac(void)
   1445          {
   \                     InitSmac: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1446            gAppTxPacket = (txPacket_t*)gau8TxDataBuffer;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable36_40
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable29_16
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   1447            gAppRxPacket = (rxPacket_t*)gau8RxDataBuffer; 
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable36_41
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable36_42
   \   00000014   0x6008             STR      R0,[R1, #+0]
   1448            gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
   \   00000016   0x207B             MOVS     R0,#+123
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable36_42
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
   1449            
   1450            MLMESetPromiscuousMode(gPromiscuousMode_d); 
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      BL       MLMESetPromiscuousMode
   1451            (void)MLMESetChannelRequest(testChannel);
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable36_25
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x.... 0x....      BL       MLMESetChannelRequest
   \   00000030   0x0004             MOVS     R4,R0
   1452            (void)MLMEPAOutputAdjust(testPower);
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable36_26
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0x.... 0x....      BL       MLMEPAOutputAdjust
   \   0000003C   0x0005             MOVS     R5,R0
   1453            (void)MLMEXtalAdjust(testTrimmValue); 
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable36_27
   \   00000042   0x7800             LDRB     R0,[R0, #+0]
   \   00000044   0x.... 0x....      BL       MLMEXtalAdjust
   1454          }
   \   00000048   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1455          
   1456          /**************************************************************************************/
   1457          void SerialUIStateMachine(void)
   1458          {
   1459            if((gConnSelectTest_c == connState) && evTestParameters)
   1460            {
   1461              (void)MLMESetChannelRequest(testChannel);
   1462              (void)MLMEPAOutputAdjust(testPower);
   1463              (void)MLMEXtalAdjust(testTrimmValue);
   1464              PrintTestParameters(TRUE);
   1465              evTestParameters = FALSE;
   1466            }
   1467            switch(connState){
   1468              case gConnIdleState_c:
   1469                 PrintMenu(cu8MainMenu, gDefaultCommPort_c);
   1470                 PrintTestParameters(FALSE);
   1471                 shortCutsEnabled = TRUE;           
   1472                 connState = gConnSelectTest_c;
   1473              break;
   1474              case gConnSelectTest_c:
   1475               if(evDataFromCOMM){
   1476                 if('1' == gu8CommData){
   1477                   cTxRxState = gCTxRxStateInit_c;
   1478                   connState = gConnContinuousTxRxState_c;
   1479                 }else if('2' == gu8CommData){
   1480                   perTxState = gPerTxStateInit_c;
   1481                   perRxState = gPerRxStateInit_c;
   1482                   connState = gConnPerState_c;
   1483                 }else if('3' == gu8CommData){
   1484                   rangeTxState = gRangeTxStateInit_c;
   1485                   rangeRxState = gRangeRxStateInit_c;
   1486                   connState = gConnRangeState_c;
   1487                 }else if('4' == gu8CommData){
   1488                   eRState = gERStateInit_c;
   1489                   connState = gConnRegEditState_c;
   1490                 }
   1491                 evDataFromCOMM = FALSE;
   1492               }
   1493              break;
   1494              case gConnContinuousTxRxState_c:
   1495                 if(SerialContinuousTxRxTest()) {
   1496                     connState = gConnIdleState_c;
   1497                 }
   1498              break;
   1499              case gConnPerState_c:
   1500                 if(mTxOperation_c == testOpMode){
   1501                   if(PacketErrorRateTx()){
   1502                     connState = gConnIdleState_c;
   1503                   }
   1504                 }else{
   1505                   if(PacketErrorRateRx()){
   1506                     connState = gConnIdleState_c;
   1507                   }
   1508                 }
   1509              break;
   1510              case gConnRangeState_c:
   1511                 if(mTxOperation_c == testOpMode){
   1512                   if(RangeTx()){
   1513                     connState = gConnIdleState_c;
   1514                   }
   1515                 }else{
   1516                   if(RangeRx()){
   1517                     connState = gConnIdleState_c;
   1518                   }
   1519                 }
   1520              break;
   1521              case gConnRegEditState_c:
   1522                 if(EditRegisters()) {
   1523                     connState = gConnIdleState_c;
   1524                 }
   1525              break;
   1526              default:
   1527              break;
   1528              
   1529            }
   1530            if(prevOpMode != testOpMode){
   1531              perTxState = gPerTxStateInit_c;
   1532              perRxState = gPerRxStateInit_c;
   1533              rangeTxState = gRangeTxStateInit_c;
   1534              rangeRxState = gRangeRxStateInit_c;
   1535              prevOpMode = testOpMode;
   1536            }
   1537          }
   1538          
   1539          
   1540          
   1541          /*this is used to set the mode into the lower power mode*/

   \                                 In section .text, align 2, keep-with-next
   1542          void WUApp_PrepareToEnterLowPower(void)
   1543          {
   \                     WUApp_PrepareToEnterLowPower: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1544            bool_t bTimersOff;
   1545          
   1546              /*Stop timers*/
   1547              TMR_StopTimer(mLEDTimerID_1);
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable36_13
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x.... 0x....      BL       TMR_StopTimer
   1548              TMR_StopTimer(mBufferTimerID);
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable36_14
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x.... 0x....      BL       TMR_StopTimer
   1549              TMR_FreeTimer(mLEDTimerID_1);
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable36_13
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x.... 0x....      BL       TMR_FreeTimer
   1550              TMR_FreeTimer(mBufferTimerID);
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable36_14
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x.... 0x....      BL       TMR_FreeTimer
   1551              
   1552              /* configure MCG in FLL Engaged Internal (FEI) mode */
   1553              MCG_Pee2Fei();
   \   0000002A   0x.... 0x....      BL       MCG_Pee2Fei
   1554              
   1555              /* disable transceiver CLK_OUT. */
   1556              MC1324xDrv_Set_CLK_OUT_Freq(gCLK_OUT_FREQ_DISABLE);
   \   0000002E   0x2008             MOVS     R0,#+8
   \   00000030   0x.... 0x....      BL       MC1324xDrv_Set_CLK_OUT_Freq
   1557              /* configure Radio in hibernate mode */
   1558              PWRLib_Radio_Enter_Hibernate();
   \   00000034   0x.... 0x....      BL       PWRLib_Radio_Enter_Hibernate
   1559              
   1560              //PowerOffAccel();
   1561              //DisableADC();
   1562                
   1563              u32PortAPCRBackup[0] = PORTA_PCR0;  //PTA0 JTAG CLK
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable36_43  ;; 0x40049000
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable36_44
   \   00000042   0x6008             STR      R0,[R1, #+0]
   1564              u32PortAPCRBackup[1] = PORTA_PCR1;  //PTA1 JTAG TDI
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable36_45  ;; 0x40049004
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable36_44
   \   0000004E   0x6048             STR      R0,[R1, #+4]
   1565              u32PortAPCRBackup[2] = PORTA_PCR2;  //PTA2 JTAG TDO
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable36_46  ;; 0x40049008
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable36_44
   \   0000005A   0x6088             STR      R0,[R1, #+8]
   1566              u32PortAPCRBackup[3] = PORTA_PCR3;  //PTA3 JTAG TMS
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable36_47  ;; 0x4004900c
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable36_44
   \   00000066   0x60C8             STR      R0,[R1, #+12]
   1567              u32PortAPCRBackup[4] = PORTA_PCR4;  //PTA4 JTAG NMI
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable36_48  ;; 0x40049010
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable36_44
   \   00000072   0x6108             STR      R0,[R1, #+16]
   1568              
   1569              u32PortBPCRBackup[0] = PORTB_PCR10;  //PTB10 to Radio's SPI SS
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable36_49  ;; 0x4004a028
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable36_50
   \   0000007E   0x6008             STR      R0,[R1, #+0]
   1570              u32PortBPCRBackup[1] = PORTB_PCR11;  //PTB11 to Radio's SPI CLK
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable36_51  ;; 0x4004a02c
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable36_50
   \   0000008A   0x6048             STR      R0,[R1, #+4]
   1571              u32PortBPCRBackup[2] = PORTB_PCR16;  //PTB16 to Radio's SPI MOSI
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable36_52  ;; 0x4004a040
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable36_50
   \   00000096   0x6088             STR      R0,[R1, #+8]
   1572              u32PortBPCRBackup[3] = PORTB_PCR17;  //PTB17 to Radio's SPI MISO
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable36_53  ;; 0x4004a044
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable36_50
   \   000000A2   0x60C8             STR      R0,[R1, #+12]
   1573              
   1574              u32PortCPCRBackup[0] = PORTC_PCR4;  //PTC4 //Set->Lower EEPROM's voltage
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable36_54  ;; 0x4004b010
   \   000000A8   0x6800             LDR      R0,[R0, #+0]
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable36_55
   \   000000AE   0x6008             STR      R0,[R1, #+0]
   1575              u32PortCPCRBackup[1] = PORTC_PCR5;  //PTC5 
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable36_56  ;; 0x4004b014
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0x.... 0x....      LDR.W    R1,??DataTable36_55
   \   000000BA   0x6048             STR      R0,[R1, #+4]
   1576              u32PortCPCRBackup[2] = PORTC_PCR6;  //PTC6 
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable36_57  ;; 0x4004b018
   \   000000C0   0x6800             LDR      R0,[R0, #+0]
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable36_55
   \   000000C6   0x6088             STR      R0,[R1, #+8]
   1577              u32PortCPCRBackup[3] = PORTC_PCR7;  //PTC7 
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable36_58  ;; 0x4004b01c
   \   000000CC   0x6800             LDR      R0,[R0, #+0]
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable36_55
   \   000000D2   0x60C8             STR      R0,[R1, #+12]
   1578              
   1579              
   1580              u32PortEPCRBackup[0] = PORTE_PCR0;  //PTE0 UART1_TX
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable36_59  ;; 0x4004d000
   \   000000D8   0x6800             LDR      R0,[R0, #+0]
   \   000000DA   0x.... 0x....      LDR.W    R1,??DataTable36_60
   \   000000DE   0x6008             STR      R0,[R1, #+0]
   1581              u32PortEPCRBackup[1] = PORTE_PCR1;  //PTE1 UART1_RX
   \   000000E0   0x.... 0x....      LDR.W    R0,??DataTable36_61  ;; 0x4004d004
   \   000000E4   0x6800             LDR      R0,[R0, #+0]
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable36_60
   \   000000EA   0x6048             STR      R0,[R1, #+4]
   1582              
   1583              u32SCGCxBackup[0] = SIM_SCGC4; //SCGC4
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable36_62  ;; 0x40048034
   \   000000F0   0x6800             LDR      R0,[R0, #+0]
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable36_63
   \   000000F6   0x6008             STR      R0,[R1, #+0]
   1584              u32SCGCxBackup[1] = SIM_SCGC5; //SCGC5
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable36_64  ;; 0x40048038
   \   000000FC   0x6800             LDR      R0,[R0, #+0]
   \   000000FE   0x.... 0x....      LDR.W    R1,??DataTable36_63
   \   00000102   0x6048             STR      R0,[R1, #+4]
   1585              u32SCGCxBackup[2] = SIM_SCGC6; //SCGC6
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable36_65  ;; 0x4004803c
   \   00000108   0x6800             LDR      R0,[R0, #+0]
   \   0000010A   0x.... 0x....      LDR.W    R1,??DataTable36_63
   \   0000010E   0x6088             STR      R0,[R1, #+8]
   1586              u32SCGCxBackup[3] = SIM_SCGC7; //SCGC7
   \   00000110   0x.... 0x....      LDR.W    R0,??DataTable36_66  ;; 0x40048040
   \   00000114   0x6800             LDR      R0,[R0, #+0]
   \   00000116   0x.... 0x....      LDR.W    R1,??DataTable36_63
   \   0000011A   0x60C8             STR      R0,[R1, #+12]
   1587              
   1588              u32GPIOs_PDORBackup[0] = GPIOA_PDOR;
   \   0000011C   0x.... 0x....      LDR.W    R0,??DataTable36_67  ;; 0x400ff000
   \   00000120   0x6800             LDR      R0,[R0, #+0]
   \   00000122   0x.... 0x....      LDR.W    R1,??DataTable36_68
   \   00000126   0x6008             STR      R0,[R1, #+0]
   1589              u32GPIOs_PDORBackup[1] = GPIOB_PDOR;
   \   00000128   0x.... 0x....      LDR.W    R0,??DataTable36_69  ;; 0x400ff040
   \   0000012C   0x6800             LDR      R0,[R0, #+0]
   \   0000012E   0x.... 0x....      LDR.W    R1,??DataTable36_68
   \   00000132   0x6048             STR      R0,[R1, #+4]
   1590              u32GPIOs_PDORBackup[2] = GPIOC_PDOR;
   \   00000134   0x.... 0x....      LDR.W    R0,??DataTable36_70  ;; 0x400ff080
   \   00000138   0x6800             LDR      R0,[R0, #+0]
   \   0000013A   0x.... 0x....      LDR.W    R1,??DataTable36_68
   \   0000013E   0x6088             STR      R0,[R1, #+8]
   1591              u32GPIOs_PDORBackup[3] = GPIOD_PDOR;
   \   00000140   0x.... 0x....      LDR.W    R0,??DataTable36_71  ;; 0x400ff0c0
   \   00000144   0x6800             LDR      R0,[R0, #+0]
   \   00000146   0x.... 0x....      LDR.W    R1,??DataTable36_68
   \   0000014A   0x60C8             STR      R0,[R1, #+12]
   1592              u32GPIOs_PDORBackup[4] = GPIOE_PDOR;
   \   0000014C   0x.... 0x....      LDR.W    R0,??DataTable36_72  ;; 0x400ff100
   \   00000150   0x6800             LDR      R0,[R0, #+0]
   \   00000152   0x.... 0x....      LDR.W    R1,??DataTable36_68
   \   00000156   0x6108             STR      R0,[R1, #+16]
   1593              
   1594              u32GPIOs_PDDRBackup[0] = GPIOA_PDDR;
   \   00000158   0x.... 0x....      LDR.W    R0,??DataTable36_73  ;; 0x400ff014
   \   0000015C   0x6800             LDR      R0,[R0, #+0]
   \   0000015E   0x.... 0x....      LDR.W    R1,??DataTable36_74
   \   00000162   0x6008             STR      R0,[R1, #+0]
   1595              u32GPIOs_PDDRBackup[1] = GPIOB_PDDR;
   \   00000164   0x.... 0x....      LDR.W    R0,??DataTable36_75  ;; 0x400ff054
   \   00000168   0x6800             LDR      R0,[R0, #+0]
   \   0000016A   0x.... 0x....      LDR.W    R1,??DataTable36_74
   \   0000016E   0x6048             STR      R0,[R1, #+4]
   1596              u32GPIOs_PDDRBackup[2] = GPIOC_PDDR;
   \   00000170   0x.... 0x....      LDR.W    R0,??DataTable36_76  ;; 0x400ff094
   \   00000174   0x6800             LDR      R0,[R0, #+0]
   \   00000176   0x.... 0x....      LDR.W    R1,??DataTable36_74
   \   0000017A   0x6088             STR      R0,[R1, #+8]
   1597              u32GPIOs_PDDRBackup[3] = GPIOD_PDDR;
   \   0000017C   0x.... 0x....      LDR.W    R0,??DataTable36_77  ;; 0x400ff0d4
   \   00000180   0x6800             LDR      R0,[R0, #+0]
   \   00000182   0x.... 0x....      LDR.W    R1,??DataTable36_74
   \   00000186   0x60C8             STR      R0,[R1, #+12]
   1598              u32GPIOs_PDDRBackup[4] = GPIOE_PDDR;
   \   00000188   0x.... 0x....      LDR.W    R0,??DataTable36_78  ;; 0x400ff114
   \   0000018C   0x6800             LDR      R0,[R0, #+0]
   \   0000018E   0x.... 0x....      LDR.W    R1,??DataTable36_74
   \   00000192   0x6108             STR      R0,[R1, #+16]
   1599              
   1600              /*UART pins*/
   1601              PORTE_PCR0 = PORT_PCR_MUX(0x1) | PORT_PCR_PE_MASK | PORT_PCR_PS_MASK; //PullUp/PullSelect enable (Connected to OpenSDA)
   \   00000194   0xF240 0x1003      MOVW     R0,#+259
   \   00000198   0x.... 0x....      LDR.W    R1,??DataTable36_59  ;; 0x4004d000
   \   0000019C   0x6008             STR      R0,[R1, #+0]
   1602              PORTE_PCR1 = PORT_PCR_MUX(0x1) | PORT_PCR_PE_MASK | PORT_PCR_PS_MASK; //PullUp/PullSelect enable (Connected to OpenSDA)
   \   0000019E   0xF240 0x1003      MOVW     R0,#+259
   \   000001A2   0x.... 0x....      LDR.W    R1,??DataTable36_61  ;; 0x4004d004
   \   000001A6   0x6008             STR      R0,[R1, #+0]
   1603             
   1604              PORTC_PCR0 = PORT_PCR_MUX(0x1) |PORT_PCR_PS_MASK ;                    //set PTC0 to be driven low
   \   000001A8   0xF240 0x1001      MOVW     R0,#+257
   \   000001AC   0x.... 0x....      LDR.W    R1,??DataTable36_79  ;; 0x4004b000
   \   000001B0   0x6008             STR      R0,[R1, #+0]
   1605              PORTC_PCR1 = PORT_PCR_MUX(0x1) |PORT_PCR_PS_MASK ;                    //set PTC1 to be driven low
   \   000001B2   0xF240 0x1001      MOVW     R0,#+257
   \   000001B6   0x.... 0x....      LDR.W    R1,??DataTable36_80  ;; 0x4004b004
   \   000001BA   0x6008             STR      R0,[R1, #+0]
   1606              PORTC_PCR3 = PORT_PCR_MUX(0x1) |PORT_PCR_PS_MASK ;                    //set PTC3 to be driven low
   \   000001BC   0xF240 0x1001      MOVW     R0,#+257
   \   000001C0   0x.... 0x....      LDR.W    R1,??DataTable36_81  ;; 0x4004b00c
   \   000001C4   0x6008             STR      R0,[R1, #+0]
   1607                 
   1608              /*LED pins*/ //PTD3, PTD4
   1609              //Set PTDs as GPIO
   1610              PORTD_PCR3 = PORT_PCR_MUX(0x1) | PORT_PCR_PE_MASK | PORT_PCR_PS_MASK;
   \   000001C6   0xF240 0x1003      MOVW     R0,#+259
   \   000001CA   0x.... 0x....      LDR.W    R1,??DataTable36_82  ;; 0x4004c00c
   \   000001CE   0x6008             STR      R0,[R1, #+0]
   1611              PORTD_PCR4 = PORT_PCR_MUX(0x1) | PORT_PCR_PE_MASK | PORT_PCR_PS_MASK;
   \   000001D0   0xF240 0x1003      MOVW     R0,#+259
   \   000001D4   0x.... 0x....      LDR.W    R1,??DataTable36_83  ;; 0x4004c010
   \   000001D8   0x6008             STR      R0,[R1, #+0]
   1612              
   1613              /*JTAG TDO pin*/ 
   1614              PORTA_PCR2 = PORT_PCR_PE_MASK | PORT_PCR_PS_MASK; //JTAG_TDO PullUp/PullSelect enable
   \   000001DA   0x2003             MOVS     R0,#+3
   \   000001DC   0x.... 0x....      LDR.W    R1,??DataTable36_46  ;; 0x40049008
   \   000001E0   0x6008             STR      R0,[R1, #+0]
   1615              
   1616              
   1617              /*EEPROM pins*/  //PTC5, PTC6, PTC7
   1618              //Set PTCs as GPIO
   1619              PORTC_PCR5 = PORT_PCR_MUX(0x1);
   \   000001E2   0xF44F 0x7080      MOV      R0,#+256
   \   000001E6   0x.... 0x....      LDR.W    R1,??DataTable36_56  ;; 0x4004b014
   \   000001EA   0x6008             STR      R0,[R1, #+0]
   1620              PORTC_PCR6 = PORT_PCR_MUX(0x1);
   \   000001EC   0xF44F 0x7080      MOV      R0,#+256
   \   000001F0   0x.... 0x....      LDR.W    R1,??DataTable36_57  ;; 0x4004b018
   \   000001F4   0x6008             STR      R0,[R1, #+0]
   1621              PORTC_PCR7 = PORT_PCR_MUX(0x1);
   \   000001F6   0xF44F 0x7080      MOV      R0,#+256
   \   000001FA   0x.... 0x....      LDR.W    R1,??DataTable36_58  ;; 0x4004b01c
   \   000001FE   0x6008             STR      R0,[R1, #+0]
   1622              
   1623              //Set GPIOCs as outputs
   1624              GPIOA_PDDR |= (1<<2);
   \   00000200   0x.... 0x....      LDR.W    R0,??DataTable36_73  ;; 0x400ff014
   \   00000204   0x6800             LDR      R0,[R0, #+0]
   \   00000206   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000020A   0x.... 0x....      LDR.W    R1,??DataTable36_73  ;; 0x400ff014
   \   0000020E   0x6008             STR      R0,[R1, #+0]
   1625              GPIOD_PDDR |= (1<<3);
   \   00000210   0x.... 0x....      LDR.W    R0,??DataTable36_77  ;; 0x400ff0d4
   \   00000214   0x6800             LDR      R0,[R0, #+0]
   \   00000216   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000021A   0x.... 0x....      LDR.W    R1,??DataTable36_77  ;; 0x400ff0d4
   \   0000021E   0x6008             STR      R0,[R1, #+0]
   1626              GPIOD_PDDR |= (1<<4);
   \   00000220   0x.... 0x....      LDR.W    R0,??DataTable36_77  ;; 0x400ff0d4
   \   00000224   0x6800             LDR      R0,[R0, #+0]
   \   00000226   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000022A   0x.... 0x....      LDR.W    R1,??DataTable36_77  ;; 0x400ff0d4
   \   0000022E   0x6008             STR      R0,[R1, #+0]
   1627              GPIOC_PDDR |= (1<<5);
   \   00000230   0x.... 0x....      LDR.W    R0,??DataTable36_76  ;; 0x400ff094
   \   00000234   0x6800             LDR      R0,[R0, #+0]
   \   00000236   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000023A   0x.... 0x....      LDR.W    R1,??DataTable36_76  ;; 0x400ff094
   \   0000023E   0x6008             STR      R0,[R1, #+0]
   1628              GPIOC_PDDR |= (1<<6);
   \   00000240   0x.... 0x....      LDR.W    R0,??DataTable36_76  ;; 0x400ff094
   \   00000244   0x6800             LDR      R0,[R0, #+0]
   \   00000246   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000024A   0x.... 0x....      LDR.W    R1,??DataTable36_76  ;; 0x400ff094
   \   0000024E   0x6008             STR      R0,[R1, #+0]
   1629              GPIOC_PDDR |= (1<<7);
   \   00000250   0x.... 0x....      LDR.W    R0,??DataTable36_76  ;; 0x400ff094
   \   00000254   0x6800             LDR      R0,[R0, #+0]
   \   00000256   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000025A   0x.... 0x....      LDR.W    R1,??DataTable36_76  ;; 0x400ff094
   \   0000025E   0x6008             STR      R0,[R1, #+0]
   1630              
   1631              //Clear GPIOCs
   1632              GPIOA_PCOR |= (1<<2);
   \   00000260   0x.... 0x....      LDR.W    R0,??DataTable36_84  ;; 0x400ff008
   \   00000264   0x6800             LDR      R0,[R0, #+0]
   \   00000266   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000026A   0x.... 0x....      LDR.W    R1,??DataTable36_84  ;; 0x400ff008
   \   0000026E   0x6008             STR      R0,[R1, #+0]
   1633              GPIOC_PCOR |= (1<<5);
   \   00000270   0x.... 0x....      LDR.W    R0,??DataTable36_85  ;; 0x400ff088
   \   00000274   0x6800             LDR      R0,[R0, #+0]
   \   00000276   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000027A   0x.... 0x....      LDR.W    R1,??DataTable36_85  ;; 0x400ff088
   \   0000027E   0x6008             STR      R0,[R1, #+0]
   1634              GPIOC_PCOR |= (1<<6);
   \   00000280   0x.... 0x....      LDR.W    R0,??DataTable36_85  ;; 0x400ff088
   \   00000284   0x6800             LDR      R0,[R0, #+0]
   \   00000286   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000028A   0x.... 0x....      LDR.W    R1,??DataTable36_85  ;; 0x400ff088
   \   0000028E   0x6008             STR      R0,[R1, #+0]
   1635              GPIOC_PCOR |= (1<<7);
   \   00000290   0x.... 0x....      LDR.W    R0,??DataTable36_85  ;; 0x400ff088
   \   00000294   0x6800             LDR      R0,[R0, #+0]
   \   00000296   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000029A   0x.... 0x....      LDR.W    R1,??DataTable36_85  ;; 0x400ff088
   \   0000029E   0x6008             STR      R0,[R1, #+0]
   1636          
   1637              /*Disable Low Voltage Detection*/
   1638                 
   1639              PMC_LVDSC1 = 0x00;
   \   000002A0   0x2000             MOVS     R0,#+0
   \   000002A2   0x.... 0x....      LDR.W    R1,??DataTable36_86  ;; 0x4007d000
   \   000002A6   0x7008             STRB     R0,[R1, #+0]
   1640              
   1641              
   1642              /*CLOCKS to default*/
   1643          
   1644              SIM_SCGC4 = 0xF0100030; //Default
   \   000002A8   0x.... 0x....      LDR.W    R0,??DataTable36_87  ;; 0xf0100030
   \   000002AC   0x.... 0x....      LDR.W    R1,??DataTable36_62  ;; 0x40048034
   \   000002B0   0x6008             STR      R0,[R1, #+0]
   1645          #if (gDefaultWakeupSource_c == gWUAppGPIO_c)
   1646              SIM_SCGC5 = 0x00040182 | SIM_SCGC5_PORTC_MASK; //Default + PTC Clock
   1647          #else
   1648              SIM_SCGC5 = 0x00040182; //Default
   \   000002B2   0x.... 0x....      LDR.W    R0,??DataTable36_88  ;; 0x40182
   \   000002B6   0x.... 0x....      LDR.W    R1,??DataTable36_64  ;; 0x40048038
   \   000002BA   0x6008             STR      R0,[R1, #+0]
   1649          #endif
   1650                 
   1651          #if (gDefaultWakeupSource_c == gWUAppRTC_c)
   1652              SIM_SCGC6 = 0x40000001 | SIM_SCGC6_RTC_MASK; //Default + RTC Clock
   1653          #else
   1654              SIM_SCGC6 = 0x40000001; //Default
   \   000002BC   0x.... 0x....      LDR.W    R0,??DataTable36_89  ;; 0x40000001
   \   000002C0   0x.... 0x....      LDR.W    R1,??DataTable36_65  ;; 0x4004803c
   \   000002C4   0x6008             STR      R0,[R1, #+0]
   1655          #endif
   1656              SIM_SCGC7 = 0x00000002; //Default
   \   000002C6   0x2002             MOVS     R0,#+2
   \   000002C8   0x.... 0x....      LDR.W    R1,??DataTable36_66  ;; 0x40048040
   \   000002CC   0x6008             STR      R0,[R1, #+0]
   1657              
   1658          #if (gDefaultWakeupSource_c == gWUAppGPIO_c)
   1659              bGPIOWakeupFlag = TRUE;
   1660              SIM_SCGC5 |= SIM_SCGC5_PORTC_MASK;
   1661          #elif (gDefaultWakeupSource_c == gWUAppLPTMR_c)
   1662              /*PWRLib_LPTMR_ClockStart(cPWR_LPTMRTickTime, SLEEP_AFTER_ACK);*/
   1663              PWRLib_LPTMR_ClockStart(cPWR_LPTMRTickTime, gOptions.u16SleepAfterAck);
   \   000002CE   0x.... 0x....      LDR.W    R0,??DataTable36_2
   \   000002D2   0x8AC1             LDRH     R1,[R0, #+22]
   \   000002D4   0x2048             MOVS     R0,#+72
   \   000002D6   0x.... 0x....      BL       PWRLib_LPTMR_ClockStart
   1664              bLPTMRWakeupFlag = TRUE;
   \   000002DA   0x2001             MOVS     R0,#+1
   \   000002DC   0x.... 0x....      LDR.W    R1,??DataTable36_90
   \   000002E0   0x7008             STRB     R0,[R1, #+0]
   1665          #elif (gDefaultWakeupSource_c == gWUAppRTC_c)
   1666              /* start RTC */
   1667              PWRLib_RTC_ClockStart(RTC_Duration);
   1668              bRTCWakeupFlag = TRUE;
   1669          #endif
   1670             return;
   \   000002E2   0xBD01             POP      {R0,PC}          ;; return
   1671          }
   1672           
   1673          //thisds will restore the presets from the low power mode

   \                                 In section .text, align 2, keep-with-next
   1674          void WUApp_LPRestoreSettings(void)
   1675          {
   \                     WUApp_LPRestoreSettings: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1676          
   1677          #if (gDefaultWakeupSource_c == gWUAppGPIO_c)
   1678            bGPIOWakeupFlag = FALSE;	
   1679          #elif (gDefaultWakeupSource_c == gWUAppLPTMR_c)
   1680            PWRLib_LPTMR_ClockStop();
   \   00000002   0x.... 0x....      BL       PWRLib_LPTMR_ClockStop
   1681            bLPTMRWakeupFlag = FALSE;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable36_90
   \   0000000C   0x7008             STRB     R0,[R1, #+0]
   1682          #elif (gDefaultWakeupSource_c == gWUAppRTC_c)
   1683            PWRLib_RTC_ClockStop();
   1684            bRTCWakeupFlag = FALSE;  
   1685          #endif
   1686            
   1687            
   1688            SIM_SCGC4 = u32SCGCxBackup[0]; //SCGC4
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable36_63
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable36_62  ;; 0x40048034
   \   00000018   0x6008             STR      R0,[R1, #+0]
   1689            SIM_SCGC5 = u32SCGCxBackup[1]; //SCGC5
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable36_63
   \   0000001E   0x6840             LDR      R0,[R0, #+4]
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable36_64  ;; 0x40048038
   \   00000024   0x6008             STR      R0,[R1, #+0]
   1690            SIM_SCGC6 = u32SCGCxBackup[2]; //SCGC6
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable36_63
   \   0000002A   0x6880             LDR      R0,[R0, #+8]
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable36_65  ;; 0x4004803c
   \   00000030   0x6008             STR      R0,[R1, #+0]
   1691            SIM_SCGC7 = u32SCGCxBackup[3]; //SCGC7
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable36_63
   \   00000036   0x68C0             LDR      R0,[R0, #+12]
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable36_66  ;; 0x40048040
   \   0000003C   0x6008             STR      R0,[R1, #+0]
   1692            
   1693            /*Enable Low Voltage Detection*/
   1694            PMC_LVDSC1 = 0x10;
   \   0000003E   0x2010             MOVS     R0,#+16
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable36_86  ;; 0x4007d000
   \   00000044   0x7008             STRB     R0,[R1, #+0]
   1695            
   1696            /*Restore PORTA PCR*/
   1697            PORTA_PCR0 = u32PortAPCRBackup[0]; //PTA0 JTAG CLK
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable36_44
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable36_43  ;; 0x40049000
   \   00000050   0x6008             STR      R0,[R1, #+0]
   1698            PORTA_PCR1 = u32PortAPCRBackup[1]; //PTA1 JTAG TDI
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable36_44
   \   00000056   0x6840             LDR      R0,[R0, #+4]
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable36_45  ;; 0x40049004
   \   0000005C   0x6008             STR      R0,[R1, #+0]
   1699            PORTA_PCR2 = u32PortAPCRBackup[2]; //PTA2 JTAG TDO
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable36_44
   \   00000062   0x6880             LDR      R0,[R0, #+8]
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable36_46  ;; 0x40049008
   \   00000068   0x6008             STR      R0,[R1, #+0]
   1700            PORTA_PCR3 = u32PortAPCRBackup[3]; //PTA3 JTAG TMS
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable36_44
   \   0000006E   0x68C0             LDR      R0,[R0, #+12]
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable36_47  ;; 0x4004900c
   \   00000074   0x6008             STR      R0,[R1, #+0]
   1701            PORTA_PCR3 = u32PortAPCRBackup[4]; //PTA4 JTAG NMI
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable36_44
   \   0000007A   0x6900             LDR      R0,[R0, #+16]
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable36_47  ;; 0x4004900c
   \   00000080   0x6008             STR      R0,[R1, #+0]
   1702            
   1703            /*Restore GPIOs*/
   1704            GPIOA_PDOR = u32GPIOs_PDORBackup[0];
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable36_68
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable36_67  ;; 0x400ff000
   \   0000008C   0x6008             STR      R0,[R1, #+0]
   1705            GPIOB_PDOR = u32GPIOs_PDORBackup[1];
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable36_68
   \   00000092   0x6840             LDR      R0,[R0, #+4]
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable36_69  ;; 0x400ff040
   \   00000098   0x6008             STR      R0,[R1, #+0]
   1706            GPIOC_PDOR = u32GPIOs_PDORBackup[2];
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable36_68
   \   0000009E   0x6880             LDR      R0,[R0, #+8]
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable36_70  ;; 0x400ff080
   \   000000A4   0x6008             STR      R0,[R1, #+0]
   1707            GPIOD_PDOR = u32GPIOs_PDORBackup[3];
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable36_68
   \   000000AA   0x68C0             LDR      R0,[R0, #+12]
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable36_71  ;; 0x400ff0c0
   \   000000B0   0x6008             STR      R0,[R1, #+0]
   1708            GPIOE_PDOR = u32GPIOs_PDORBackup[4];
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable36_68
   \   000000B6   0x6900             LDR      R0,[R0, #+16]
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable36_72  ;; 0x400ff100
   \   000000BC   0x6008             STR      R0,[R1, #+0]
   1709            
   1710            GPIOA_PDDR = u32GPIOs_PDDRBackup[0];
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable36_74
   \   000000C2   0x6800             LDR      R0,[R0, #+0]
   \   000000C4   0x.... 0x....      LDR.W    R1,??DataTable36_73  ;; 0x400ff014
   \   000000C8   0x6008             STR      R0,[R1, #+0]
   1711            GPIOB_PDDR = u32GPIOs_PDDRBackup[1];
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable36_74
   \   000000CE   0x6840             LDR      R0,[R0, #+4]
   \   000000D0   0x.... 0x....      LDR.W    R1,??DataTable36_75  ;; 0x400ff054
   \   000000D4   0x6008             STR      R0,[R1, #+0]
   1712            GPIOC_PDDR = u32GPIOs_PDDRBackup[2];
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable36_74
   \   000000DA   0x6880             LDR      R0,[R0, #+8]
   \   000000DC   0x.... 0x....      LDR.W    R1,??DataTable36_76  ;; 0x400ff094
   \   000000E0   0x6008             STR      R0,[R1, #+0]
   1713            GPIOD_PDDR = u32GPIOs_PDDRBackup[3];
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable36_74
   \   000000E6   0x68C0             LDR      R0,[R0, #+12]
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable36_77  ;; 0x400ff0d4
   \   000000EC   0x6008             STR      R0,[R1, #+0]
   1714            GPIOE_PDDR = u32GPIOs_PDDRBackup[4];
   \   000000EE   0x.... 0x....      LDR.W    R0,??DataTable36_74
   \   000000F2   0x6900             LDR      R0,[R0, #+16]
   \   000000F4   0x.... 0x....      LDR.W    R1,??DataTable36_78  ;; 0x400ff114
   \   000000F8   0x6008             STR      R0,[R1, #+0]
   1715              
   1716            /*Restore PORTB PCR*/ //SPI to Radio
   1717            PORTB_PCR10 = u32PortBPCRBackup[0];
   \   000000FA   0x....             LDR.N    R0,??DataTable36_50
   \   000000FC   0x6800             LDR      R0,[R0, #+0]
   \   000000FE   0x....             LDR.N    R1,??DataTable36_49  ;; 0x4004a028
   \   00000100   0x6008             STR      R0,[R1, #+0]
   1718            PORTB_PCR11 = u32PortBPCRBackup[1];
   \   00000102   0x....             LDR.N    R0,??DataTable36_50
   \   00000104   0x6840             LDR      R0,[R0, #+4]
   \   00000106   0x....             LDR.N    R1,??DataTable36_51  ;; 0x4004a02c
   \   00000108   0x6008             STR      R0,[R1, #+0]
   1719            PORTB_PCR16 = u32PortBPCRBackup[2];
   \   0000010A   0x....             LDR.N    R0,??DataTable36_50
   \   0000010C   0x6880             LDR      R0,[R0, #+8]
   \   0000010E   0x....             LDR.N    R1,??DataTable36_52  ;; 0x4004a040
   \   00000110   0x6008             STR      R0,[R1, #+0]
   1720            PORTB_PCR17 = u32PortBPCRBackup[3];
   \   00000112   0x....             LDR.N    R0,??DataTable36_50
   \   00000114   0x68C0             LDR      R0,[R0, #+12]
   \   00000116   0x....             LDR.N    R1,??DataTable36_53  ;; 0x4004a044
   \   00000118   0x6008             STR      R0,[R1, #+0]
   1721                
   1722            /*Restore PORTC PCR*/ //EEPROM
   1723            PORTC_PCR4 = u32PortCPCRBackup[0];
   \   0000011A   0x....             LDR.N    R0,??DataTable36_55
   \   0000011C   0x6800             LDR      R0,[R0, #+0]
   \   0000011E   0x....             LDR.N    R1,??DataTable36_54  ;; 0x4004b010
   \   00000120   0x6008             STR      R0,[R1, #+0]
   1724            PORTC_PCR5 = u32PortCPCRBackup[1];
   \   00000122   0x....             LDR.N    R0,??DataTable36_55
   \   00000124   0x6840             LDR      R0,[R0, #+4]
   \   00000126   0x....             LDR.N    R1,??DataTable36_56  ;; 0x4004b014
   \   00000128   0x6008             STR      R0,[R1, #+0]
   1725            PORTC_PCR6 = u32PortCPCRBackup[2];
   \   0000012A   0x....             LDR.N    R0,??DataTable36_55
   \   0000012C   0x6880             LDR      R0,[R0, #+8]
   \   0000012E   0x....             LDR.N    R1,??DataTable36_57  ;; 0x4004b018
   \   00000130   0x6008             STR      R0,[R1, #+0]
   1726            PORTC_PCR7 = u32PortCPCRBackup[3];
   \   00000132   0x....             LDR.N    R0,??DataTable36_55
   \   00000134   0x68C0             LDR      R0,[R0, #+12]
   \   00000136   0x....             LDR.N    R1,??DataTable36_58  ;; 0x4004b01c
   \   00000138   0x6008             STR      R0,[R1, #+0]
   1727            
   1728            /*Restore PORTD PCR*/ //LEDs
   1729            /*
   1730            PORTD_PCR4 = u32PortDPCRBackup[0];
   1731            PORTD_PCR5 = u32PortDPCRBackup[1];
   1732            PORTD_PCR6 = u32PortDPCRBackup[2];
   1733            PORTD_PCR7 = u32PortDPCRBackup[3];
   1734          */
   1735            /*Restore PORTE PCR*/ //UART
   1736            PORTE_PCR0 = u32PortEPCRBackup[0];
   \   0000013A   0x....             LDR.N    R0,??DataTable36_60
   \   0000013C   0x6800             LDR      R0,[R0, #+0]
   \   0000013E   0x....             LDR.N    R1,??DataTable36_59  ;; 0x4004d000
   \   00000140   0x6008             STR      R0,[R1, #+0]
   1737            PORTE_PCR1 = u32PortEPCRBackup[1];
   \   00000142   0x....             LDR.N    R0,??DataTable36_60
   \   00000144   0x6840             LDR      R0,[R0, #+4]
   \   00000146   0x....             LDR.N    R1,??DataTable36_61  ;; 0x4004d004
   \   00000148   0x6008             STR      R0,[R1, #+0]
   1738          
   1739            /* configure Radio in autodoze mode */
   1740            PWRLib_Radio_Enter_AutoDoze();
   \   0000014A   0x.... 0x....      BL       PWRLib_Radio_Enter_AutoDoze
   1741          //  PWRLib_Radio_Enter_Idle();
   1742            
   1743            /* Restore Radio's clock for input*/
   1744            MC1324xDrv_Set_CLK_OUT_Freq(gCLK_OUT_FREQ_4_MHz);
   \   0000014E   0x2003             MOVS     R0,#+3
   \   00000150   0x.... 0x....      BL       MC1324xDrv_Set_CLK_OUT_Freq
   1745              
   1746            /* PEE @ 48MHz */
   1747            gMCG_coreClkMHz = MCG_PLLInit();
   \   00000154   0x.... 0x....      BL       MCG_PLLInit
   \   00000158   0x....             LDR.N    R1,??DataTable36_91
   \   0000015A   0x6008             STR      R0,[R1, #+0]
   1748            
   1749            /*Restore Timers*/
   1750            mLEDTimerID_1 = TMR_AllocateTimer();
   \   0000015C   0x.... 0x....      BL       TMR_AllocateTimer
   \   00000160   0x....             LDR.N    R1,??DataTable36_13
   \   00000162   0x7008             STRB     R0,[R1, #+0]
   1751            mBufferTimerID = TMR_AllocateTimer(); 
   \   00000164   0x.... 0x....      BL       TMR_AllocateTimer
   \   00000168   0x....             LDR.N    R1,??DataTable36_14
   \   0000016A   0x7008             STRB     R0,[R1, #+0]
   1752            LowPowerEntered = TRUE;
   \   0000016C   0x2001             MOVS     R0,#+1
   \   0000016E   0x....             LDR.N    R1,??DataTable36_92
   \   00000170   0x7008             STRB     R0,[R1, #+0]
   1753            return;
   \   00000172   0xBD01             POP      {R0,PC}          ;; return
   1754          }
   1755          
   1756          /**************************************************************************************/
   1757          bool_t SerialContinuousTxRxTest(void)
   1758          {
   1759            bool_t bBackFlag = FALSE;
   1760            smacErrors_t smacResult;
   1761            uint8_t u8Index, u8TempEnergyValue;
   1762            
   1763            if(evTestParameters)
   1764            {
   1765              (void)MLMERXDisableRequest();
   1766              (void)MLMETestMode(gTestModeForceIdle_c);
   1767              (void)MLMESetChannelRequest(testChannel);
   1768              (void)MLMEPAOutputAdjust(testPower);
   1769              (void)MLMEXtalAdjust(testTrimmValue);
   1770              
   1771              if(gCTxRxStateSelectTest_c == cTxRxState){
   1772                PrintTestParameters(TRUE);
   1773              }else{
   1774                PrintTestParameters(FALSE);
   1775                CommUtil_Print("\r\n", gAllowToBlock_d);     
   1776              }
   1777              
   1778              if(gTestModePRBS9_c == contTestRunning){
   1779                (void)MLMETestMode(gTestModePRBS9_c);
   1780              }else if(gTestModeContinuousTxModulated_c == contTestRunning){
   1781                (void)MLMETestMode(gTestModeContinuousTxModulated_c);
   1782              }else if(gTestModeContinuousTxUnmodulated_c == contTestRunning){
   1783                (void)MLMETestMode(gTestModeContinuousTxUnmodulated_c);
   1784              }
   1785              
   1786              if(gCTxRxStateRunnigRxTest_c == cTxRxState){
   1787                bRxDone = FALSE;
   1788                gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
   1789                (void)MLMERXEnableRequest(gAppRxPacket, 0);
   1790              }
   1791              evTestParameters = FALSE;
   1792            }
   1793            
   1794            switch(cTxRxState)
   1795            {
   1796              case gCTxRxStateIdle_c:
   1797                   if((evDataFromCOMM) && ('\r' == gu8CommData))
   1798                   {
   1799                     cTxRxState = gCTxRxStateInit_c;
   1800                     evDataFromCOMM = FALSE;  
   1801                   }
   1802              break;
   1803              case gCTxRxStateInit_c:
   1804                   PrintMenu(cu8ShortCutsBar, gDefaultCommPort_c);
   1805                   PrintMenu(cu8ContinuousTestMenu, gDefaultCommPort_c);
   1806                   
   1807                   (void)MLMETestMode(gTestModeForceIdle_c);  
   1808                   
   1809                   while(MLMESetChannelRequest(testChannel)); 
   1810                   
   1811                   (void)MLMETestMode(contTestRunning);
   1812                   CommUtil_Print(cu8ContinuousTestTags[contTestRunning], gAllowToBlock_d);
   1813                   CommUtil_Print("\r\n\r\n", gAllowToBlock_d);       
   1814                   PrintTestParameters(FALSE);
   1815                   shortCutsEnabled = TRUE;           
   1816                   cTxRxState = gCTxRxStateSelectTest_c; 
   1817              break;
   1818              case gCTxRxStateSelectTest_c:
   1819                   if(evDataFromCOMM)
   1820                   {           
   1821                     if('1' == gu8CommData){
   1822                       contTestRunning = gTestModeForceIdle_c;              
   1823                       cTxRxState = gCTxRxStateInit_c;
   1824                     }else if('2' == gu8CommData){
   1825                       contTestRunning = gTestModePRBS9_c;               
   1826                       cTxRxState = gCTxRxStateInit_c;
   1827                     }else if('3' == gu8CommData){
   1828                       contTestRunning = gTestModeContinuousTxModulated_c;               
   1829                       cTxRxState = gCTxRxStateInit_c;
   1830                     }else if('4' == gu8CommData){
   1831                       if(gTestModeContinuousTxUnmodulated_c != contTestRunning) 
   1832                       { 
   1833                        contTestRunning = gTestModeContinuousTxUnmodulated_c;               
   1834                        cTxRxState = gCTxRxStateInit_c;
   1835                       }
   1836                     }else if('5' == gu8CommData)
   1837                     {
   1838                       (void)MLMETestMode(gTestModeForceIdle_c);     
   1839                       contTestRunning = gTestModeForceIdle_c;
   1840                       CommUtil_Print("\f\r\nPress [p] to stop receiving promiscuous packets \r\n", gAllowToBlock_d);
   1841                              
   1842                       MLMESetPromiscuousMode(TRUE);    
   1843                       
   1844                       bRxDone = FALSE;
   1845                       gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
   1846                       (void)MLMERXEnableRequest(gAppRxPacket, 0);
   1847                       cTxRxState = gCTxRxStateRunnigRxTest_c;
   1848                     }else if('6' == gu8CommData){
   1849                       (void)MLMETestMode(gTestModeForceIdle_c);
   1850                       contTestRunning = gTestModeForceIdle_c;
   1851                       CommUtil_Print("\f\r\nPress [p] to stop the Continuous ED test\r\n", gAllowToBlock_d);
   1852                       contTestRunning = gTestModeForceIdle_c;                
   1853                       cTxRxState = gCTxRxStateRunnigEdTest_c;
   1854                     }else if('7' == gu8CommData){
   1855                       (void)MLMETestMode(gTestModeForceIdle_c);
   1856                       contTestRunning = gTestModeForceIdle_c;
   1857                       CommUtil_Print("\f\r\nPress [p] to stop the Continuous SCAN test\r\n", gAllowToBlock_d);
   1858                       bScanDone = FALSE;
   1859                       smacResult = MLMEScanRequest(0xFFFF, gScanModeED_c, au8ScanResults);
   1860                       (void)smacResult;
   1861                       contTestRunning = gTestModeForceIdle_c;                
   1862                       cTxRxState = gCTxRxStateRunnigScanTest_c;
   1863                     }else if('p' == gu8CommData){ 
   1864                       (void)MLMETestMode(gTestModeForceIdle_c);
   1865                       (void)MLMESetChannelRequest(testChannel);
   1866                       bBackFlag = TRUE;
   1867                     }
   1868                     evDataFromCOMM = FALSE;
   1869                   }
   1870              break;
   1871              case gCTxRxStateRunnigRxTest_c:
   1872                   if(bRxDone){
   1873                     if (gAppRxPacket->rxStatus == rxSuccessStatus_c){
   1874                       CommUtil_Print("New Packet: ", gAllowToBlock_d);
   1875                       for(u8Index = 0; u8Index < (gAppRxPacket->u8DataLength); u8Index++){
   1876                         PrintByteOnHexFormatBlocking(gAppRxPacket->smacPdu.u8Data[u8Index], TRUE, gAllowToBlock_d);
   1877                       }
   1878                       CommUtil_Print("\b \r\n", gAllowToBlock_d);
   1879                     }
   1880                     bRxDone = FALSE;
   1881                     gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
   1882                     (void)MLMERXEnableRequest(gAppRxPacket, 0);
   1883                   }
   1884                   if((evDataFromCOMM) && ('p' == gu8CommData)){
   1885                     (void)MLMERXDisableRequest();
   1886                     (void)MLMETestMode(gTestModeForceIdle_c);
   1887                     MLMESetPromiscuousMode(FALSE);
   1888                     CommUtil_Print("\r\n\r\n Press [enter] to go back to the Continuous test menu ", gAllowToBlock_d);
   1889                     cTxRxState = gCTxRxStateIdle_c;
   1890                     evDataFromCOMM = FALSE;
   1891                   }
   1892              break;
   1893              case gCTxRxStateRunnigEdTest_c:
   1894                   delayMs(100);delayMs(100);
   1895                   CommUtil_Print("Energy on the Channel ", gAllowToBlock_d);
   1896                   PrintWordOnDecimalFormatBlocking((uint16_t)testChannel, 0, FALSE, gDefaultCommPort_c);
   1897                   CommUtil_Print(" : ", gAllowToBlock_d);
   1898                   (void)MLMEEnergyDetect(&u8TempEnergyValue);
   1899                   PrintWordOnDecimalFormatBlocking(u8TempEnergyValue,0,TRUE, gDefaultCommPort_c);
   1900                   CommUtil_Print("dBm\r\n", gAllowToBlock_d);
   1901                   if((evDataFromCOMM) && ('p' == gu8CommData)){
   1902                     CommUtil_Print("\r\n\r\n Press [enter] to go back to the Continuous test menu ", gAllowToBlock_d);
   1903                     cTxRxState = gCTxRxStateIdle_c;
   1904                     evDataFromCOMM = FALSE;
   1905                   }
   1906              break;
   1907              case gCTxRxStateRunnigScanTest_c:
   1908                   if(bScanDone){
   1909                     CommUtil_Print("Results : ", gAllowToBlock_d);
   1910                     for(u8Index = 0; u8Index < 16 ; u8Index++){
   1911                       PrintWordOnDecimalFormatBlocking((uint16_t)(au8ScanResults[u8Index]),0,TRUE, gDefaultCommPort_c);
   1912                       CommUtil_Print(",", gAllowToBlock_d);   
   1913                     }
   1914                     CommUtil_Print("\b \r\n", gAllowToBlock_d);
   1915                     if((evDataFromCOMM) && ('p' == gu8CommData)){
   1916                       CommUtil_Print("\r\n\r\n Press [enter] to go back to the Continuous test menu ", gAllowToBlock_d);
   1917                       cTxRxState = gCTxRxStateIdle_c;
   1918                       evDataFromCOMM = FALSE;
   1919                     }else{
   1920                       delayMs(100);delayMs(100);delayMs(50);
   1921                       bScanDone = FALSE;
   1922                       smacResult = MLMEScanRequest(0xFFFF, gScanModeED_c, au8ScanResults);
   1923                     }
   1924                   }
   1925              break;
   1926              default:
   1927              break;
   1928            }
   1929            return bBackFlag;
   1930          }
   1931          
   1932          /**************************************************************************************/
   1933          bool_t PacketErrorRateTx(void)
   1934          {
   1935            const uint16_t u16TotalPacketsOptions[] = {1,25,100,500,1000,2000,5000,10000,65535};
   1936            static uint16_t u16TotalPackets;
   1937            static uint16_t u16SentPackets;
   1938            uint8_t u8Index;
   1939            bool_t bBackFlag = FALSE;
   1940            
   1941            if(evTestParameters)
   1942            {
   1943              (void)MLMERXDisableRequest();
   1944              (void)MLMESetChannelRequest(testChannel);
   1945              (void)MLMEPAOutputAdjust(testPower);
   1946              (void)MLMEXtalAdjust(testTrimmValue);
   1947              PrintTestParameters(TRUE);
   1948              evTestParameters = FALSE;
   1949            }
   1950            
   1951            switch(perTxState)
   1952            {
   1953              case gPerTxStateInit_c:
   1954                     PrintMenu(cu8ShortCutsBar, gDefaultCommPort_c);
   1955                     PrintMenu(cu8PerTxTestMenu, gDefaultCommPort_c);
   1956                     PrintTestParameters(FALSE);
   1957                     shortCutsEnabled = TRUE;           
   1958                     perTxState = gPerTxStateSelectPacketNum_c;        
   1959              break;
   1960              case gPerTxStateSelectPacketNum_c:
   1961                   if(evDataFromCOMM){
   1962                     if((gu8CommData >= '0') && (gu8CommData <= '8')){
   1963                       u16TotalPackets = u16TotalPacketsOptions[gu8CommData - '0'];
   1964                       shortCutsEnabled = FALSE;  
   1965                       perTxState = gPerTxStateStartTest_c;
   1966                  }else if('p' == gu8CommData){ 
   1967                       bBackFlag = TRUE;
   1968                     }
   1969          			 evDataFromCOMM = FALSE;
   1970                   }
   1971              break;
   1972              case gPerTxStateStartTest_c:
   1973                   gAppTxPacket->u8DataLength = testPayloadLen;
   1974                   u16SentPackets = 0;
   1975                   gAppTxPacket->smacPdu.u8Data[0] = (u16TotalPackets >> 8);
   1976                   gAppTxPacket->smacPdu.u8Data[1] = (uint8_t)u16TotalPackets;
   1977                   gAppTxPacket->smacPdu.u8Data[2] = ((u16SentPackets+1) >> 8);
   1978                   gAppTxPacket->smacPdu.u8Data[3] = (uint8_t)(u16SentPackets+1);
   1979                   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[4]), "SMAC PER Demo",13);
   1980                   if(17 < testPayloadLen){
   1981                     for(u8Index=17;u8Index<testPayloadLen;u8Index++){
   1982                       gAppTxPacket->smacPdu.u8Data[u8Index] = (u8Index%10)+'0';            
   1983                     }
   1984                   }
   1985                   bTxDone = FALSE;
   1986          
   1987                   (void)MCPSDataRequest(gAppTxPacket);
   1988                   u16SentPackets++;
   1989                   CommUtil_Print("\f\r\n Running PER Tx, Sending ", gAllowToBlock_d);
   1990                   PrintWordOnDecimalFormatBlocking(u16TotalPackets, 0, FALSE, gDefaultCommPort_c);
   1991                   CommUtil_Print(" Packets", gAllowToBlock_d);
   1992                   perTxState = gPerTxStateRunningTest_c;
   1993              break;
   1994              case gPerTxStateRunningTest_c:
   1995                   if(bTxDone){
   1996                     if(u16SentPackets == u16TotalPackets)
   1997                     {
   1998                       MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[4]), "DONE",4);
   1999                       gAppTxPacket->u8DataLength = 8;
   2000                       u16SentPackets = 0;
   2001                       u16TotalPackets = mTotalFinalFrames_c;
   2002                       gAppTxPacket->u8DataLength = 8;
   2003                       perTxState = gPerTxStateSendingLastFrames_c;
   2004                     }else
   2005                     {
   2006                      gAppTxPacket->smacPdu.u8Data[2] = ((u16SentPackets+1) >> 8);
   2007                      gAppTxPacket->smacPdu.u8Data[3] = (uint8_t)(u16SentPackets+1);
   2008                      gAppTxPacket->u8DataLength = testPayloadLen;
   2009                     }
   2010                      bTxDone = FALSE;
   2011                     delayMs(10);
   2012                      (void)MCPSDataRequest(gAppTxPacket);
   2013                      u16SentPackets++;
   2014                    }
   2015              break;
   2016              case gPerTxStateSendingLastFrames_c:
   2017                   if(bTxDone)
   2018                   {
   2019                     bTxDone = FALSE;
   2020                     if(u16SentPackets == u16TotalPackets)
   2021                     {
   2022                         CommUtil_Print("\r\n PER Tx DONE \r\n", gAllowToBlock_d);
   2023                         CommUtil_Print("\r\n\r\n Press [enter] to go back to the PER Tx test menu ", gAllowToBlock_d);
   2024                         perTxState = gPerTxStateIdle_c;
   2025                     }else
   2026                     {
   2027                       gAppTxPacket->u8DataLength = 8;
   2028                       delayMs(10);
   2029                       (void)MCPSDataRequest(gAppTxPacket);
   2030                       u16SentPackets++;
   2031                        } 
   2032                    }	 
   2033              break;	
   2034              case gPerTxStateIdle_c:
   2035                   if((evDataFromCOMM) && ('\r' == gu8CommData))
   2036                   {
   2037                     perTxState = gPerTxStateInit_c;
   2038                     evDataFromCOMM = FALSE;
   2039                   }
   2040              break;
   2041             default:
   2042              break;
   2043            }
   2044          
   2045            return bBackFlag;
   2046          }
   2047          
   2048          /**************************************************************************************/
   2049          bool_t PacketErrorRateRx(void)
   2050          {
   2051            static uint16_t u16ReceivedPackets;
   2052            static uint16_t u16PacketsIndex;  
   2053            static uint16_t u16TotalPackets;
   2054            static uint16_t u16FinalPacketsCount;
   2055            static uint32_t u32LQISum;
   2056            uint8_t  u8AverageLQI, u8TempLQIvalue;
   2057          
   2058            bool_t bBackFlag = FALSE;
   2059            if(evTestParameters){
   2060              (void)MLMESetChannelRequest(testChannel);
   2061              (void)MLMEPAOutputAdjust(testPower);
   2062              (void)MLMEXtalAdjust(testTrimmValue);
   2063              PrintTestParameters(TRUE);
   2064              evTestParameters = FALSE;
   2065            }
   2066          
   2067            switch(perRxState)
   2068            {
   2069              case gPerRxStateInit_c:
   2070                  u16TotalPackets = 0;
   2071                  u16ReceivedPackets = 0;
   2072                  u16PacketsIndex = 0;
   2073                  u32LQISum = 0;
   2074                  PrintMenu(cu8ShortCutsBar, gDefaultCommPort_c);
   2075                  PrintMenu(cu8PerRxTestMenu, gDefaultCommPort_c);
   2076                  PrintTestParameters(FALSE);
   2077                  shortCutsEnabled = TRUE;           
   2078                  perRxState = gPerRxWaitStartTest_c;
   2079              break;
   2080              case gPerRxWaitStartTest_c:
   2081                   if(evDataFromCOMM){
   2082                     if(' ' == gu8CommData){
   2083                           CommUtil_Print("\f\n\rPER Test Rx Running\r\n\r\n", gAllowToBlock_d);
   2084                           SetRadioRxOnTimeOut15ms();
   2085                           shortCutsEnabled = FALSE;  
   2086                           perRxState = gPerRxStateStartTest_c;
   2087                        }else if('p' == gu8CommData){ 
   2088                        bBackFlag = TRUE;
   2089                     }
   2090                     evDataFromCOMM = FALSE;
   2091                   }
   2092              break;
   2093              case gPerRxStateStartTest_c:
   2094                   if(bRxDone){
   2095                     if (gAppRxPacket->rxStatus == rxSuccessStatus_c){
   2096                       if(stringComp("SMAC PER Demo",&gAppRxPacket->smacPdu.u8Data[4],13)){
   2097                         u16TotalPackets = ((uint16_t)gAppRxPacket->smacPdu.u8Data[0] <<8) + gAppRxPacket->smacPdu.u8Data[1];
   2098                         u16PacketsIndex = ((uint16_t)gAppRxPacket->smacPdu.u8Data[2] <<8) + gAppRxPacket->smacPdu.u8Data[3];
   2099                         u16ReceivedPackets++;
   2100                         (void)MLMELinkQuality(&u8TempLQIvalue);
   2101                         u32LQISum += u8TempLQIvalue;
   2102                         u8AverageLQI = (uint8_t)(u32LQISum/u16ReceivedPackets);
   2103                         (void)u8AverageLQI;
   2104                           CommUtil_Print("Packet ", gAllowToBlock_d);
   2105                         PrintWordOnDecimalFormatBlocking(u16ReceivedPackets, 2, FALSE, gDefaultCommPort_c);
   2106                         CommUtil_Print("\r\n", gAllowToBlock_d);
   2107                         if(u16PacketsIndex == u16TotalPackets){
   2108                           u16FinalPacketsCount = 0; 
   2109                           perRxState = gPerRxStateReceivingLastFrames_c;
   2110                     }
   2111                       }else if(stringComp("DONE",&gAppRxPacket->smacPdu.u8Data[4],4)){
   2112                         u16FinalPacketsCount = 0; 
   2113                         perRxState = gPerRxStateReceivingLastFrames_c;
   2114                       }
   2115                     }else{ 
   2116                       if(u16TotalPackets){
   2117                         u16PacketsIndex++;
   2118                         if(u16PacketsIndex == u16TotalPackets){
   2119                           u16FinalPacketsCount = 0; 
   2120                       perRxState = gPerRxStateReceivingLastFrames_c;
   2121                      }
   2122                       }
   2123                     }
   2124                     SetRadioRxOnTimeOut15ms();
   2125                   }
   2126                   if(evDataFromCOMM){
   2127                     if(' ' == gu8CommData){
   2128                       (void)MLMERXDisableRequest();
   2129                       CommUtil_Print("\n\rPER Test Rx Stopped\r\n\r\n", gAllowToBlock_d);
   2130                       PrintPerRxFinalLine(u16ReceivedPackets,u16TotalPackets);
   2131                       perRxState = gPerRxStateIdle_c;
   2132                     } 
   2133                     evDataFromCOMM = FALSE;
   2134                   }         
   2135              break;
   2136              case gPerRxStateReceivingLastFrames_c:
   2137                   if(bRxDone){
   2138                     u16FinalPacketsCount++; 
   2139                     if(mTotalFinalFrames_c == u16FinalPacketsCount){
   2140                     CommUtil_Print("\n\rPER Test Finished\r\n\r\n", gAllowToBlock_d);
   2141                     PrintPerRxFinalLine(u16ReceivedPackets,u16TotalPackets);              
   2142                     perRxState = gPerRxStateIdle_c;
   2143                     }else{  
   2144                       SetRadioRxOnTimeOut15ms();
   2145                     }
   2146                   }
   2147              break;
   2148              case gPerRxStateIdle_c:
   2149                   if((evDataFromCOMM) && ('\r' == gu8CommData)){
   2150                     perRxState = gPerRxStateInit_c;
   2151                   }
   2152                   evDataFromCOMM = FALSE;
   2153              break;
   2154              default:
   2155              break;
   2156            }
   2157            return bBackFlag;
   2158          }
   2159          
   2160          /**************************************************************************************/
   2161          bool_t RangeTx(void)
   2162          {
   2163            bool_t bBackFlag = FALSE;
   2164            static uint32_t u32LQISum;
   2165            static uint16_t u16ReceivedPackets;
   2166            static uint16_t u16PacketsDropped;
   2167            uint8_t  u8AverageLQI;
   2168            uint8_t  u8CurrentLQI;
   2169            
   2170            if(evTestParameters){
   2171              (void)MLMESetChannelRequest(testChannel);
   2172              (void)MLMEPAOutputAdjust(testPower);
   2173              (void)MLMEXtalAdjust(testTrimmValue);
   2174              PrintTestParameters(TRUE);
   2175              evTestParameters = FALSE;
   2176            }
   2177            
   2178            switch(rangeTxState)
   2179            {
   2180              case gRangeTxStateInit_c:
   2181                   u32LQISum = 0;
   2182                   u16ReceivedPackets = 0;
   2183                   u16PacketsDropped = 0;
   2184                     PrintMenu(cu8ShortCutsBar, gDefaultCommPort_c);
   2185                     PrintMenu(cu8RangeTxTestMenu, gDefaultCommPort_c);
   2186                     PrintTestParameters(FALSE);
   2187                     shortCutsEnabled = TRUE;           
   2188                     rangeTxState = gRangeTxWaitStartTest_c;
   2189              break;
   2190              case gRangeTxWaitStartTest_c:
   2191                   if(evDataFromCOMM){
   2192                     if(' ' == gu8CommData){
   2193                       shortCutsEnabled = FALSE; 
   2194                       CommUtil_Print("\f\r\nRange Test Tx Running\r\n", gAllowToBlock_d);
   2195                       rangeTxState = gRangeTxStateStartTest_c;
   2196                     }else if('p' == gu8CommData){ 
   2197                       bBackFlag = TRUE;
   2198                     }
   2199                     evDataFromCOMM = FALSE;
   2200                   }
   2201              break;
   2202              case gRangeTxStateStartTest_c:
   2203                   delayMs(100);
   2204                   delayMs(100);
   2205                   bTxDone = FALSE;
   2206                   gAppTxPacket->u8DataLength = 16;
   2207                   gAppTxPacket->smacPdu.u8Data[0]  = 0;
   2208                   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[1]), "SMAC Range Demo",15);
   2209                   (void)MCPSDataRequest(gAppTxPacket);
   2210                   rangeTxState = gRangeTxStateRunningTest_c;
   2211              break;
   2212              case gRangeTxStateRunningTest_c:
   2213                   if(bTxDone){
   2214                     SetRadioRxOnTimeOut15ms();
   2215                     rangeTxState = gRangeTxStatePrintTestResults_c;
   2216                   }
   2217              break;
   2218              case gRangeTxStatePrintTestResults_c:
   2219                   if(bRxDone){
   2220                     if(gAppRxPacket->rxStatus == rxSuccessStatus_c){ 
   2221                       if(stringComp("SMAC Range Demo",&gAppRxPacket->smacPdu.u8Data[1],15)){
   2222                         u8CurrentLQI = (gAppRxPacket->smacPdu.u8Data[0]); 
   2223                         u32LQISum += u8CurrentLQI;  
   2224                         u16ReceivedPackets++;
   2225                         u8AverageLQI = (uint8_t)(u32LQISum/u16ReceivedPackets);
   2226                           CommUtil_Print("\r\n LQI = ", gAllowToBlock_d);
   2227                           PrintWordOnDecimalFormatBlocking((uint16_t)u8CurrentLQI,1,FALSE, gDefaultCommPort_c);               
   2228                       }else{
   2229                         SetRadioRxOnTimeOut15ms();
   2230                       }
   2231                     }else{
   2232                         u16PacketsDropped++;
   2233                         CommUtil_Print("\r\nPacket Dropped", gAllowToBlock_d);
   2234                     }
   2235                     if(evDataFromCOMM && (' ' == gu8CommData)){
   2236                       CommUtil_Print("\n\r\n\rRange Test Tx Stopped\r\n\r\n", gAllowToBlock_d);
   2237                       u8AverageLQI = (uint8_t)(u32LQISum/u16ReceivedPackets);
   2238                       CommUtil_Print("Average LQI     ", gAllowToBlock_d);
   2239                       PrintWordOnDecimalFormatBlocking((uint16_t)u8AverageLQI,1,FALSE, gDefaultCommPort_c);  
   2240                       CommUtil_Print("\r\nPackets dropped ", gAllowToBlock_d);
   2241                       PrintWordOnDecimalFormatBlocking(u16PacketsDropped,1,FALSE, gDefaultCommPort_c);  
   2242                       CommUtil_Print("\r\n\r\n Press [enter] to go back to the Range Tx test menu", gAllowToBlock_d);
   2243                       rangeTxState = gRangeTxStateIdle_c;
   2244                     }else{
   2245                       rangeTxState = gRangeTxStateStartTest_c;
   2246                     }
   2247                     evDataFromCOMM = FALSE;
   2248                   }
   2249              break;
   2250              case gRangeTxStateIdle_c:
   2251                   if((evDataFromCOMM) && ('\r' == gu8CommData))
   2252                   {
   2253                     rangeTxState = gRangeTxStateInit_c;
   2254                   }
   2255                   evDataFromCOMM = FALSE;
   2256              break;
   2257              default:
   2258              break;
   2259            }
   2260            return bBackFlag;
   2261          }
   2262          
   2263          /**************************************************************************************/
   2264          bool_t RangeRx(void)
   2265          {
   2266            bool_t bBackFlag = FALSE;
   2267            static uint32_t u32LQISum;
   2268            static uint16_t u16ReceivedPackets;
   2269            uint8_t  u8AverageLQI, u8TempLQIvalue;
   2270            uint8_t  u8CurrentLQI;
   2271          
   2272            if(evTestParameters){
   2273              (void)MLMESetChannelRequest(testChannel);
   2274              (void)MLMEPAOutputAdjust(testPower);
   2275              (void)MLMEXtalAdjust(testTrimmValue);
   2276              PrintTestParameters(TRUE);
   2277              evTestParameters = FALSE;
   2278            }
   2279          
   2280            switch(rangeRxState)
   2281            {
   2282              case gRangeRxStateInit_c:
   2283                   u32LQISum = 0;
   2284                   u16ReceivedPackets = 0;
   2285                     PrintMenu(cu8ShortCutsBar, gDefaultCommPort_c);
   2286                     PrintMenu(cu8RangeRxTestMenu, gDefaultCommPort_c);
   2287                     PrintTestParameters(FALSE);
   2288                     shortCutsEnabled = TRUE;           
   2289                     rangeRxState = gRangeRxWaitStartTest_c;
   2290              break;
   2291              case gRangeRxWaitStartTest_c:
   2292                   if(evDataFromCOMM){
   2293                     if(' ' == gu8CommData){
   2294                       shortCutsEnabled = FALSE; 
   2295                       CommUtil_Print("\f\r\nRange Test Rx Running\r\n", gAllowToBlock_d);
   2296                       rangeRxState = gRangeRxStateStartTest_c;
   2297                     }else if('p' == gu8CommData){ 
   2298                       bBackFlag = TRUE;
   2299                     }
   2300                     evDataFromCOMM = FALSE;
   2301                   }
   2302              break;
   2303              case gRangeRxStateStartTest_c:
   2304                   SetRadioRxOnNoTimeOut();
   2305                   rangeRxState = gRangeRxStateRunningTest_c;
   2306              break;
   2307              case gRangeRxStateRunningTest_c:
   2308                   if(evDataFromCOMM && (' ' == gu8CommData))
   2309                   {             
   2310                     (void)MLMERXDisableRequest();
   2311                     CommUtil_Print("\n\r\n\rRange Test Rx Stopped\r\n\r\n", gAllowToBlock_d);
   2312                     u8AverageLQI = (uint8_t)(u32LQISum/u16ReceivedPackets);
   2313                     CommUtil_Print("Average LQI     ", gAllowToBlock_d);
   2314                     PrintWordOnDecimalFormatBlocking((uint16_t)u8AverageLQI,1,FALSE, gDefaultCommPort_c);  
   2315                     CommUtil_Print("\r\n\r\n Press [enter] to go back to the Range Rx test menu", gAllowToBlock_d);
   2316                     rangeRxState = gRangeRxStateIdle_c;
   2317                   }
   2318                   evDataFromCOMM = FALSE;
   2319                   if(bRxDone){
   2320                     if(gAppRxPacket->rxStatus == rxSuccessStatus_c){ 
   2321                       if(stringComp("SMAC Range Demo",&gAppRxPacket->smacPdu.u8Data[1],15)){
   2322                         bTxDone = FALSE;
   2323          			   delayMs(2);
   2324                         (void)MLMELinkQuality(&u8TempLQIvalue);
   2325                         gAppTxPacket->smacPdu.u8Data[0] = u8TempLQIvalue;
   2326                         MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[1]), "SMAC Range Demo",15);
   2327                         gAppTxPacket->u8DataLength = 16;
   2328                         (void)MCPSDataRequest(gAppTxPacket);
   2329                         rangeRxState = gRangeRxStatePrintTestResults_c;
   2330                       }else{
   2331                         SetRadioRxOnNoTimeOut();
   2332                       }
   2333                     }else{
   2334                       SetRadioRxOnNoTimeOut();
   2335                     }
   2336                   }
   2337              break;
   2338              case gRangeRxStatePrintTestResults_c:
   2339                   if(bTxDone)
   2340                   {
   2341                     (void)MLMELinkQuality(&u8CurrentLQI); 
   2342                     u32LQISum += u8CurrentLQI;
   2343                     u16ReceivedPackets++;
   2344                     u8AverageLQI = (uint8_t)(u32LQISum/u16ReceivedPackets);
   2345                       CommUtil_Print("\r\n LQI = ", gAllowToBlock_d);
   2346                       PrintWordOnDecimalFormatBlocking((uint16_t)u8CurrentLQI,1,FALSE, gDefaultCommPort_c);               
   2347                     rangeRxState = gRangeRxStateStartTest_c;
   2348                   }
   2349              break;
   2350              case gRangeRxStateIdle_c:
   2351                   if((evDataFromCOMM) && ('\r' == gu8CommData))
   2352                   {
   2353                     rangeRxState = gRangeRxStateInit_c;
   2354                   }
   2355                   evDataFromCOMM = FALSE;
   2356              break;
   2357              default:
   2358              break;
   2359            }
   2360            return bBackFlag;
   2361          }
   2362          
   2363          /**************************************************************************************/
   2364          /**************************************************************************************/
   2365          bool_t EditRegisters(void)
   2366          {
   2367            bool_t bBackFlag = FALSE;
   2368            if(evTestParameters){
   2369              (void)MLMESetChannelRequest(testChannel);
   2370              (void)MLMEPAOutputAdjust(testPower);
   2371              (void)MLMEXtalAdjust(testTrimmValue);
   2372              PrintTestParameters(TRUE);
   2373              evTestParameters = FALSE;
   2374            }
   2375          
   2376            switch(eRState)
   2377            {
   2378              case gERStateInit_c:
   2379                   PrintMenu(cu8ShortCutsBar, gDefaultCommPort_c);
   2380                   PrintMenu(cu8RadioRegistersEditMenu, gDefaultCommPort_c);
   2381                   PrintTestParameters(FALSE);
   2382                   shortCutsEnabled = TRUE;           
   2383                   eRState = gERWaitSelection_c;
   2384              break;
   2385              case gERWaitSelection_c:
   2386                   if(evDataFromCOMM){
   2387                     if('1' == gu8CommData){
   2388                       oDRState = gODRStateInit_c;
   2389                       eRState = gERStateOverrideDirectReg_c;
   2390                     }else if('2' == gu8CommData){
   2391                       rDRState = gRDRStateInit_c;
   2392                       eRState = gERStateReadDirectReg_c;
   2393                     }else if('3' == gu8CommData){
   2394                       oIRState = gOIRStateInit_c;
   2395                       eRState = gERStateOverrideIndirectReg_c;
   2396                     }else if('4' == gu8CommData){
   2397                       rIRState = gRIRStateInit_c;
   2398                       eRState = gERStateReadIndirectReg_c;
   2399                     }else if('p' == gu8CommData){ 
   2400                       bBackFlag = TRUE;
   2401                     }
   2402                     evDataFromCOMM = FALSE;
   2403                   }
   2404              break;
   2405              case gERStateOverrideDirectReg_c:
   2406                   if(OverrideDirectRegisters()) {
   2407                       eRState = gERStateInit_c;
   2408                   }    
   2409              break;
   2410              case gERStateOverrideIndirectReg_c:
   2411                   if(OverrideIndirectRegisters()) {
   2412                       eRState = gERStateInit_c;
   2413                   }    
   2414              break;
   2415              case gERStateReadDirectReg_c:
   2416                   if(ReadDirectRegisters()) {
   2417                       eRState = gERStateInit_c;
   2418                   }    
   2419              break;
   2420              case gERStateReadIndirectReg_c:
   2421                   if(ReadIndirectRegisters()) {
   2422                       eRState = gERStateInit_c;
   2423                   }    
   2424              break;
   2425              default:
   2426              break;
   2427            }
   2428            return bBackFlag;
   2429          }
   2430          
   2431          
   2432          /**************************************************************************************/
   2433          bool_t OverrideDirectRegisters(void)
   2434          {
   2435            bool_t bBackFlag = FALSE;
   2436            static uint8_t au8RxString[5];
   2437            static uint8_t u8Index;
   2438            static uint8_t u8RegAddress;
   2439            static uint8_t u8RegValue;
   2440            
   2441            
   2442            switch(oDRState)
   2443            {
   2444              case gODRStateInit_c:
   2445                   CommUtil_Print("\f\r\nOverride Direct Registers\r\n", gAllowToBlock_d);
   2446                   CommUtil_Print("\r\n-Press [p] Previous Menu\r\n", gAllowToBlock_d);
   2447                   shortCutsEnabled = FALSE;   
   2448                   oDRState = gODRStateStart_c;
   2449              break;
   2450              case gODRStateStart_c:
   2451                   CommUtil_Print("\r\n -write the Register address in Hex and [enter]: 0x", gAllowToBlock_d);
   2452                   u8Index = 0;
   2453                   oDRState = gODRWaitForTheAddress_c; 
   2454              break;
   2455              case gODRWaitForTheAddress_c:
   2456                   if(evDataFromCOMM){
   2457                     if((!isAsciiHex(gu8CommData)) && ('\r' != gu8CommData)){
   2458                       if('p' == gu8CommData){ 
   2459                         bBackFlag = TRUE;
   2460                       }else{
   2461                         CommUtil_Print("\r\n -Invalid Character!! ", gAllowToBlock_d);
   2462                         oDRState = gODRStateStart_c;              
   2463                       }
   2464                     }else if((2 == u8Index) && ('\r' != gu8CommData)){ 
   2465                       CommUtil_Print("\r\n -Value out of Range!! ", gAllowToBlock_d);
   2466                       oDRState = gODRStateStart_c;
   2467                     }else if(isAsciiHex(gu8CommData)){
   2468                       au8RxString[u8Index++] = gu8CommData;
   2469                     }else{
   2470                       au8RxString[u8Index] = 0;
   2471                       u8RegAddress = HexString2Dec16(au8RxString);
   2472                       CommUtil_Print("\r\n -write the Register value to override in Hex and [enter]: 0x", gAllowToBlock_d);
   2473                       u8Index = 0;
   2474                       oDRState = gODRWaitForTheValue_c; 
   2475                     }
   2476                     evDataFromCOMM = FALSE;
   2477                   }
   2478              break;
   2479              case gODRWaitForTheValue_c:
   2480                   if(evDataFromCOMM){
   2481                     if((!isAsciiHex(gu8CommData)) && ('\r' != gu8CommData)){
   2482                       if('p' == gu8CommData){ 
   2483                         bBackFlag = TRUE;
   2484                       }else{
   2485                         CommUtil_Print("\r\n -Invalid Character!! ", gAllowToBlock_d);
   2486                         oDRState = gODRStateStart_c;              
   2487                       }
   2488                     }else if((2 == u8Index) && ('\r' != gu8CommData)){ 
   2489                       CommUtil_Print("\r\n -Value out of Range!! ", gAllowToBlock_d);
   2490                       oDRState = gODRStateStart_c;              
   2491                     }else if(isAsciiHex(gu8CommData)){
   2492                       au8RxString[u8Index++] = gu8CommData;
   2493                     }else{
   2494                       au8RxString[u8Index] = 0;
   2495                       u8RegValue = (uint8_t)(HexString2Dec16(au8RxString) & 0x00FF);
   2496                       MC1324xDrv_DirectAccessSPIWrite(u8RegAddress,u8RegValue);
   2497                       
   2498                       CommUtil_Print("\r\n Register overridden \r\n", gAllowToBlock_d);
   2499                       u8Index = 0;
   2500                       oDRState = gODRStateStart_c; 
   2501                     }
   2502                     evDataFromCOMM = FALSE;
   2503                   }
   2504              break;
   2505              default:
   2506              break;
   2507            }
   2508            return bBackFlag;  
   2509          }
   2510          
   2511          /**************************************************************************************/
   2512          bool_t OverrideIndirectRegisters(void)
   2513          {
   2514            bool_t bBackFlag = FALSE;
   2515            static uint8_t au8RxString[3];
   2516            static uint8_t u8Index;
   2517            static uint8_t u8RegAddress;
   2518            static uint8_t u8RegValue;
   2519            
   2520            
   2521            switch(oIRState)
   2522            {
   2523              case gOIRStateInit_c:
   2524                   CommUtil_Print("\f\r\nOverride Indirect Registers\r\n", gAllowToBlock_d);
   2525                   CommUtil_Print("\r\n-Press [p] Previous Menu\r\n", gAllowToBlock_d);
   2526                   shortCutsEnabled = FALSE;   
   2527                   oIRState = gOIRStateStart_c;
   2528              break;
   2529              case gOIRStateStart_c:
   2530                   CommUtil_Print("\r\n -write the Register address in Hex and [enter]: 0x", gAllowToBlock_d);
   2531                   u8Index = 0;
   2532                   oIRState = gOIRWaitForTheAddress_c; 
   2533              break;
   2534              case gOIRWaitForTheAddress_c:
   2535                   if(evDataFromCOMM){
   2536                     if((!isAsciiHex(gu8CommData)) && ('\r' != gu8CommData)){
   2537                       if('p' == gu8CommData){ 
   2538                         bBackFlag = TRUE;
   2539                       }else{
   2540                         CommUtil_Print("\r\n -Invalid Character!! ", gAllowToBlock_d);
   2541                         oIRState = gOIRStateStart_c;              
   2542                       }
   2543                     }else if((2 == u8Index) && ('\r' != gu8CommData)){ 
   2544                       CommUtil_Print("\r\n -Value out of Range!! ", gAllowToBlock_d);
   2545                       oIRState = gOIRStateStart_c;   
   2546                     }else if(isAsciiHex(gu8CommData)){
   2547                       au8RxString[u8Index++] = gu8CommData;
   2548                     }else{
   2549                       au8RxString[u8Index] = 0;
   2550                       u8RegAddress = (uint8_t)(HexString2Dec16(au8RxString) & 0x00FF);
   2551                       CommUtil_Print("\r\n -write the Register value to override in Hex and [enter]: 0x", gAllowToBlock_d);
   2552                       u8Index = 0;
   2553                       oIRState = gOIRWaitForTheValue_c; 
   2554                     }
   2555                     evDataFromCOMM = FALSE;
   2556                   }
   2557              break;
   2558              case gOIRWaitForTheValue_c:
   2559                   if(evDataFromCOMM)
   2560                   {
   2561                     if((!isAsciiHex(gu8CommData)) && ('\r' != gu8CommData)){
   2562                       if('p' == gu8CommData){ 
   2563                         bBackFlag = TRUE;
   2564                       }else{
   2565                         CommUtil_Print("\r\n -Invalid Character!! ", gAllowToBlock_d);
   2566                         oIRState = gOIRStateStart_c;              
   2567                       }
   2568                     }else if((2 == u8Index) && ('\r' != gu8CommData)){ 
   2569                       CommUtil_Print("\r\n -Value out of Range!! ", gAllowToBlock_d);
   2570                       bBackFlag = TRUE;
   2571                     }else if(isAsciiHex(gu8CommData)){
   2572                       au8RxString[u8Index++] = gu8CommData;
   2573                     }else{
   2574                       au8RxString[u8Index] = 0;
   2575                       u8RegValue = (uint8_t)(HexString2Dec16(au8RxString) & 0x00FF);
   2576                       MC1324xDrv_IndirectAccessSPIWrite(u8RegAddress, u8RegValue);
   2577                       CommUtil_Print("\r\n Register overridden \r\n", gAllowToBlock_d);
   2578                       u8Index = 0;
   2579                       oIRState = gOIRStateStart_c; 
   2580                     }
   2581                     evDataFromCOMM = FALSE;
   2582                   }
   2583              break;
   2584              default:
   2585              break;
   2586            }
   2587            return bBackFlag;  
   2588          }
   2589          
   2590          
   2591          /**************************************************************************************/
   2592          bool_t ReadDirectRegisters(void)
   2593          {
   2594            bool_t bBackFlag = FALSE;
   2595            static uint8_t au8RxString[5];
   2596            static uint8_t u8Index;
   2597            static uint8_t u8RegAddress;
   2598            static uint8_t u8RegValue;
   2599            
   2600            switch(rDRState)
   2601            {
   2602              case gRDRStateInit_c:
   2603                   CommUtil_Print("\f\r\rRead Direct Registers\r\n", gAllowToBlock_d);
   2604                   CommUtil_Print("\r\n-Press [p] Previous Menu\r\n", gAllowToBlock_d);
   2605                   shortCutsEnabled = FALSE;   
   2606                   rDRState = gRDRStateStart_c;
   2607              break;
   2608              case gRDRStateStart_c:
   2609                   CommUtil_Print("\r\n -write the Register address in Hex and [enter]: 0x", gAllowToBlock_d);
   2610                   u8Index = 0;
   2611                   rDRState = gRDRWaitForTheAddress_c; 
   2612              break;
   2613              case gRDRWaitForTheAddress_c:
   2614                   if(evDataFromCOMM){
   2615                     if((!isAsciiHex(gu8CommData)) && ('\r' != gu8CommData)){
   2616                       if('p' == gu8CommData){ 
   2617                         bBackFlag = TRUE;
   2618                       }else{
   2619                         CommUtil_Print("\r\n -Invalid Character!! ", gAllowToBlock_d);
   2620                         rDRState = gRDRStateStart_c;              
   2621                       }
   2622                     }else if((2 == u8Index) && ('\r' != gu8CommData)){ 
   2623                       CommUtil_Print("\r\n -Value out of Range!! ", gAllowToBlock_d);
   2624                       rDRState = gRDRStateStart_c;
   2625                     }else if(isAsciiHex(gu8CommData)){
   2626                       au8RxString[u8Index++] = gu8CommData;
   2627                     }else{
   2628                       au8RxString[u8Index] = 0;
   2629                       u8RegAddress = HexString2Dec16(au8RxString);
   2630                       u8RegValue = MC1324xDrv_DirectAccessSPIRead(u8RegAddress);
   2631                       
   2632                       CommUtil_Print("\r\n -Register value : 0x", gAllowToBlock_d);
   2633                       PrintByteOnHexFormatBlocking(u8RegValue,FALSE, gDefaultCommPort_c);
   2634                       CommUtil_Print("\r\n", gAllowToBlock_d);
   2635                       
   2636                       rDRState = gRDRStateStart_c; 
   2637                     }
   2638                     evDataFromCOMM = FALSE;
   2639                   }
   2640              break;
   2641              default:
   2642              break;
   2643            }
   2644            return bBackFlag;  
   2645          }
   2646          
   2647          /**************************************************************************************/
   2648          bool_t ReadIndirectRegisters(void)
   2649          {
   2650            bool_t bBackFlag = FALSE;
   2651            static uint8_t au8RxString[5];
   2652            static uint8_t u8Index;
   2653            static uint8_t u8RegAddress;
   2654            static uint8_t u8RegValue;
   2655            
   2656            switch(rIRState)
   2657            {
   2658              case gRIRStateInit_c:
   2659                   CommUtil_Print("\f\r\rRead Indirect Registers\r\n", gAllowToBlock_d);
   2660                   CommUtil_Print("\r\n-Press [p] Previous Menu\r\n", gAllowToBlock_d);
   2661                   shortCutsEnabled = FALSE;   
   2662                   rIRState = gRIRStateStart_c;
   2663              break;
   2664              case gRIRStateStart_c:
   2665                   CommUtil_Print("\r\n -write the Register address in Hex and [enter]: 0x", gAllowToBlock_d);
   2666                   u8Index = 0;
   2667                   rIRState = gRIRWaitForTheAddress_c; 
   2668              break;
   2669              case gRIRWaitForTheAddress_c:
   2670                   if(evDataFromCOMM){
   2671                     if((!isAsciiHex(gu8CommData)) && ('\r' != gu8CommData))
   2672                     {
   2673                       if('p' == gu8CommData){ 
   2674                         bBackFlag = TRUE;
   2675                       }else{
   2676                         CommUtil_Print("\r\n -Invalid Character!! ", gAllowToBlock_d);
   2677                         rIRState = gRIRStateStart_c;              
   2678                       }
   2679                     }else if((2 == u8Index) && ('\r' != gu8CommData)){ 
   2680                       CommUtil_Print("\r\n -Value out of Range!! ", gAllowToBlock_d);
   2681                       rIRState = gRIRStateStart_c; 
   2682                     }else if(isAsciiHex(gu8CommData)){
   2683                       au8RxString[u8Index++] = gu8CommData;
   2684                     }else{
   2685                       au8RxString[u8Index] = 0;
   2686                       u8RegAddress = (uint8_t)(HexString2Dec16(au8RxString) & 0x00FF);
   2687                       u8RegValue = MC1324xDrv_IndirectAccessSPIRead(u8RegAddress);
   2688                       
   2689                       CommUtil_Print("\r\n -Register value : 0x", gAllowToBlock_d);
   2690                       PrintByteOnHexFormatBlocking(u8RegValue, FALSE, gDefaultCommPort_c);
   2691                       CommUtil_Print("\r\n", gAllowToBlock_d);
   2692                       rIRState = gRIRStateStart_c; 
   2693                     }
   2694                     evDataFromCOMM = FALSE;
   2695                   }
   2696              break;
   2697              default:
   2698              break;
   2699            }
   2700            return bBackFlag;  
   2701          } 
   2702          
   2703          /**************************************************************************************/
   2704          void PrintTestParameters(bool_t bEraseLine)
   2705          {
   2706            uint8_t u8lineLen = 63;
   2707            uint8_t u8Index;
   2708           
   2709            if(bEraseLine)
   2710            {
   2711              for(u8Index = 0;u8Index<u8lineLen;u8Index++)
   2712              {
   2713                CommUtil_Print("\b", gAllowToBlock_d);
   2714              }
   2715            }
   2716            
   2717            CommUtil_Print("Mode ", gAllowToBlock_d);
   2718            if(mTxOperation_c == testOpMode){
   2719              CommUtil_Print("Tx", gAllowToBlock_d);
   2720            }else{
   2721              CommUtil_Print("Rx", gAllowToBlock_d);
   2722            }
   2723            CommUtil_Print(", Channel ", gAllowToBlock_d);
   2724            PrintWordOnDecimalFormatBlocking((uint16_t)testChannel,2, FALSE, gDefaultCommPort_c);
   2725            CommUtil_Print(", Power ", gAllowToBlock_d);
   2726            PrintWordOnDecimalFormatBlocking((uint16_t)testPower,2, FALSE, gDefaultCommPort_c);
   2727            CommUtil_Print(", Crystal Trim ", gAllowToBlock_d);
   2728            PrintWordOnDecimalFormatBlocking((uint16_t)testTrimmValue,3, FALSE, gDefaultCommPort_c);
   2729            CommUtil_Print(", Payload ", gAllowToBlock_d);
   2730            PrintWordOnDecimalFormatBlocking((uint16_t)testPayloadLen,3, FALSE, gDefaultCommPort_c);
   2731            CommUtil_Print(" >", gAllowToBlock_d);
   2732          }
   2733          
   2734          /**************************************************************************************/
   2735          void SetRadioRxOnTimeOut15ms(void)
   2736          {
   2737            bRxDone = FALSE;
   2738            gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
   2739            smacErrors_t status = MLMERXEnableRequest(gAppRxPacket, 45000);
   2740            while(status!=gErrorNoError_c){
   2741              status = MLMERXEnableRequest(gAppRxPacket, 45000);
   2742            }
   2743          }
   2744          
   2745          /**************************************************************************************/
   2746          void SetRadioRxOnNoTimeOut(void)
   2747          {
   2748            bRxDone = FALSE;
   2749            gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
   2750            (void)MLMERXEnableRequest(gAppRxPacket, 0);
   2751          }
   2752          
   2753          /**************************************************************************************/
   2754          void PrintPerRxFinalLine(uint16_t u16Received, uint16_t u16Total)
   2755          {
   2756            CommUtil_Print("Received ", gAllowToBlock_d);
   2757            PrintWordOnDecimalFormatBlocking(u16Received, 2, FALSE, gDefaultCommPort_c);
   2758            CommUtil_Print(" of ", gAllowToBlock_d);
   2759            PrintWordOnDecimalFormatBlocking(u16Total, 2, FALSE, gDefaultCommPort_c);
   2760            CommUtil_Print(" packets transmitted \r\n", gAllowToBlock_d);
   2761            CommUtil_Print("\r\n Press [enter] to go back to the Per Rx test menu", gAllowToBlock_d);
   2762          }
   2763          
   2764          
   2765          /************************************************************************************
   2766          * User's Callbacks
   2767          ************************************************************************************/
   2768          
   2769          /* Place your callbacks here */
   2770          
   2771          
   2772          /************************************************************************************
   2773          * CommTxCallback
   2774          * 
   2775          *
   2776          *
   2777          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2778          void CommTxCallback(void)
   2779          {
   2780              bCommTxDone = TRUE;  
   \                     CommTxCallback: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x....             LDR.N    R1,??DataTable36_93
   \   00000004   0x7008             STRB     R0,[R1, #+0]
   2781          }
   \   00000006   0x4770             BX       LR               ;; return
   2782          
   2783          /************************************************************************************
   2784          * CommRxCallback
   2785          * 
   2786          *
   2787          *
   2788          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2789          void CommRxCallback()
   2790          {
   \                     CommRxCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2791              Comm_GetByteFromRxBuffer(&gu8CommData);
   \   00000002   0x....             LDR.N    R0,??DataTable36_94
   \   00000004   0x.... 0x....      BL       Uart1_GetByteFromRxBuffer
   2792              if(shortCutsEnabled){
   \   00000008   0x....             LDR.N    R0,??DataTable36_30
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD004             BEQ.N    ??CommRxCallback_0
   2793                ShortCutsParser(gu8CommData);  
   \   00000010   0x....             LDR.N    R0,??DataTable36_94
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x.... 0x....      BL       ShortCutsParser
   \   00000018   0xE002             B.N      ??CommRxCallback_1
   2794              }else{
   2795                evDataFromCOMM = TRUE;
   \                     ??CommRxCallback_0: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x....             LDR.N    R1,??DataTable36_1
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
   2796              }
   2797          }
   \                     ??CommRxCallback_1: (+1)
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
   2798          
   2799          
   2800          /************************************************************************************
   2801          * SMAC Callbacks
   2802          ************************************************************************************/
   2803          
   2804          /************************************************************************************
   2805          * MCPSDataConfirm
   2806          * 
   2807          *
   2808          *
   2809          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2810          void MCPSDataConfirm(txStatus_t TransmissionResult)
   2811          {  
   2812              bTxDone = TRUE;
   \                     MCPSDataConfirm: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x....             LDR.N    R2,??DataTable36_95
   \   00000004   0x7011             STRB     R1,[R2, #+0]
   2813          }
   \   00000006   0x4770             BX       LR               ;; return
   2814           
   2815          
   2816          /************************************************************************************
   2817          * MCPSDataIndication
   2818          * 
   2819          *
   2820          *
   2821          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2822          void MCPSDataIndication(rxPacket_t *gsRxPacket)
   2823          {  
   2824            bRxDone = TRUE;
   \                     MCPSDataIndication: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x....             LDR.N    R2,??DataTable36_96
   \   00000004   0x7011             STRB     R1,[R2, #+0]
   2825            appState=RECEIVE_FINISHED;
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x....             LDR.N    R2,??DataTable36
   \   0000000A   0x7011             STRB     R1,[R2, #+0]
   2826          }
   \   0000000C   0x4770             BX       LR               ;; return
   2827          
   2828          
   2829          /************************************************************************************
   2830          * MLMEScanConfirm
   2831          * 
   2832          *
   2833          *
   2834          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2835          void MLMEScanConfirm(channels_t ClearestChann)
   2836          {
   2837            bestChannel = ClearestChann; 
   \                     MLMEScanConfirm: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable36_97
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   2838            bScanDone = TRUE;
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x....             LDR.N    R2,??DataTable36_98
   \   00000008   0x7011             STRB     R1,[R2, #+0]
   2839          }
   \   0000000A   0x4770             BX       LR               ;; return
   2840          
   2841          /************************************************************************************
   2842          * MLMEResetIndication
   2843          * 
   2844          *
   2845          *
   2846          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2847          void MLMEResetIndication(void)
   2848          {
   2849            
   2850          }
   \                     MLMEResetIndication: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2851          
   2852          /************************************************************************************
   2853          * MLMEWakeConfirm
   2854          * 
   2855          *
   2856          *
   2857          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2858          void MLMEWakeConfirm(void)
   2859          {
   2860            
   2861          }
   \                     MLMEWakeConfirm: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2862          
   2863          /**************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2864          void ShortCutsParser(uint8_t u8CommData)
   2865          {
   2866            evTestParameters = TRUE;
   \                     ShortCutsParser: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x....             LDR.N    R2,??DataTable36_99
   \   00000004   0x7011             STRB     R1,[R2, #+0]
   2867            evDataFromCOMM = FALSE;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x....             LDR.N    R2,??DataTable36_1
   \   0000000A   0x7011             STRB     R1,[R2, #+0]
   2868            switch(u8CommData){
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x0001             MOVS     R1,R0
   \   00000010   0x2961             CMP      R1,#+97
   \   00000012   0xD034             BEQ.N    ??ShortCutsParser_0
   \   00000014   0x296D             CMP      R1,#+109
   \   00000016   0xD065             BEQ.N    ??ShortCutsParser_1
   \   00000018   0x296E             CMP      R1,#+110
   \   0000001A   0xD056             BEQ.N    ??ShortCutsParser_2
   \   0000001C   0x2971             CMP      R1,#+113
   \   0000001E   0xD014             BEQ.N    ??ShortCutsParser_3
   \   00000020   0x2972             CMP      R1,#+114
   \   00000022   0xD00E             BEQ.N    ??ShortCutsParser_4
   \   00000024   0x2973             CMP      R1,#+115
   \   00000026   0xD037             BEQ.N    ??ShortCutsParser_5
   \   00000028   0x2974             CMP      R1,#+116
   \   0000002A   0xD006             BEQ.N    ??ShortCutsParser_6
   \   0000002C   0x2977             CMP      R1,#+119
   \   0000002E   0xD019             BEQ.N    ??ShortCutsParser_7
   \   00000030   0x2978             CMP      R1,#+120
   \   00000032   0xD044             BEQ.N    ??ShortCutsParser_8
   \   00000034   0x297A             CMP      R1,#+122
   \   00000036   0xD03C             BEQ.N    ??ShortCutsParser_9
   \   00000038   0xE061             B.N      ??ShortCutsParser_10
   2869              case 't':
   2870                testOpMode = mTxOperation_c;
   \                     ??ShortCutsParser_6: (+1)
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x....             LDR.N    R2,??DataTable36_24
   \   0000003E   0x7011             STRB     R1,[R2, #+0]
   2871              break;
   \   00000040   0xE063             B.N      ??ShortCutsParser_11
   2872              case 'r':
   2873                testOpMode = mRxOperation_c;
   \                     ??ShortCutsParser_4: (+1)
   \   00000042   0x2101             MOVS     R1,#+1
   \   00000044   0x....             LDR.N    R2,??DataTable36_24
   \   00000046   0x7011             STRB     R1,[R2, #+0]
   2874              break;
   \   00000048   0xE05F             B.N      ??ShortCutsParser_11
   2875              case 'q': 
   2876                testChannel++;
   \                     ??ShortCutsParser_3: (+1)
   \   0000004A   0x....             LDR.N    R1,??DataTable36_25
   \   0000004C   0x7809             LDRB     R1,[R1, #+0]
   \   0000004E   0x1C49             ADDS     R1,R1,#+1
   \   00000050   0x....             LDR.N    R2,??DataTable36_25
   \   00000052   0x7011             STRB     R1,[R2, #+0]
   2877                if(gChannel26_c < testChannel){
   \   00000054   0x....             LDR.N    R1,??DataTable36_25
   \   00000056   0x7809             LDRB     R1,[R1, #+0]
   \   00000058   0x291B             CMP      R1,#+27
   \   0000005A   0xDB02             BLT.N    ??ShortCutsParser_12
   2878                  testChannel = gChannel11_c;
   \   0000005C   0x210B             MOVS     R1,#+11
   \   0000005E   0x....             LDR.N    R2,??DataTable36_25
   \   00000060   0x7011             STRB     R1,[R2, #+0]
   2879                }
   2880              break;
   \                     ??ShortCutsParser_12: (+1)
   \   00000062   0xE052             B.N      ??ShortCutsParser_11
   2881              case 'w':
   2882                testChannel--;
   \                     ??ShortCutsParser_7: (+1)
   \   00000064   0x....             LDR.N    R1,??DataTable36_25
   \   00000066   0x7809             LDRB     R1,[R1, #+0]
   \   00000068   0x1E49             SUBS     R1,R1,#+1
   \   0000006A   0x....             LDR.N    R2,??DataTable36_25
   \   0000006C   0x7011             STRB     R1,[R2, #+0]
   2883                if(gChannel11_c > testChannel){
   \   0000006E   0x....             LDR.N    R1,??DataTable36_25
   \   00000070   0x7809             LDRB     R1,[R1, #+0]
   \   00000072   0x290B             CMP      R1,#+11
   \   00000074   0xDA02             BGE.N    ??ShortCutsParser_13
   2884                  testChannel = gChannel26_c;
   \   00000076   0x211A             MOVS     R1,#+26
   \   00000078   0x....             LDR.N    R2,??DataTable36_25
   \   0000007A   0x7011             STRB     R1,[R2, #+0]
   2885                }
   2886              break;
   \                     ??ShortCutsParser_13: (+1)
   \   0000007C   0xE045             B.N      ??ShortCutsParser_11
   2887              case 'a':
   2888                testPower++;
   \                     ??ShortCutsParser_0: (+1)
   \   0000007E   0x....             LDR.N    R1,??DataTable36_26
   \   00000080   0x7809             LDRB     R1,[R1, #+0]
   \   00000082   0x1C49             ADDS     R1,R1,#+1
   \   00000084   0x....             LDR.N    R2,??DataTable36_26
   \   00000086   0x7011             STRB     R1,[R2, #+0]
   2889                if(gMaxOutputPower_c < testPower){
   \   00000088   0x....             LDR.N    R1,??DataTable36_26
   \   0000008A   0x7809             LDRB     R1,[R1, #+0]
   \   0000008C   0x2920             CMP      R1,#+32
   \   0000008E   0xDB02             BLT.N    ??ShortCutsParser_14
   2890                  testPower = gMinOutputPower_c;
   \   00000090   0x2103             MOVS     R1,#+3
   \   00000092   0x....             LDR.N    R2,??DataTable36_26
   \   00000094   0x7011             STRB     R1,[R2, #+0]
   2891                }
   2892              break;
   \                     ??ShortCutsParser_14: (+1)
   \   00000096   0xE038             B.N      ??ShortCutsParser_11
   2893              case 's':
   2894                testPower--;
   \                     ??ShortCutsParser_5: (+1)
   \   00000098   0x....             LDR.N    R1,??DataTable36_26
   \   0000009A   0x7809             LDRB     R1,[R1, #+0]
   \   0000009C   0x1E49             SUBS     R1,R1,#+1
   \   0000009E   0x....             LDR.N    R2,??DataTable36_26
   \   000000A0   0x7011             STRB     R1,[R2, #+0]
   2895                if(gMinOutputPower_c > testPower){
   \   000000A2   0x....             LDR.N    R1,??DataTable36_26
   \   000000A4   0x7809             LDRB     R1,[R1, #+0]
   \   000000A6   0x2903             CMP      R1,#+3
   \   000000A8   0xDA02             BGE.N    ??ShortCutsParser_15
   2896                  testPower = gMaxOutputPower_c;
   \   000000AA   0x211F             MOVS     R1,#+31
   \   000000AC   0x....             LDR.N    R2,??DataTable36_26
   \   000000AE   0x7011             STRB     R1,[R2, #+0]
   2897                }
   2898              break;
   \                     ??ShortCutsParser_15: (+1)
   \   000000B0   0xE02B             B.N      ??ShortCutsParser_11
   2899              case 'z':
   2900                testTrimmValue++;
   \                     ??ShortCutsParser_9: (+1)
   \   000000B2   0x....             LDR.N    R1,??DataTable36_27
   \   000000B4   0x7809             LDRB     R1,[R1, #+0]
   \   000000B6   0x1C49             ADDS     R1,R1,#+1
   \   000000B8   0x....             LDR.N    R2,??DataTable36_27
   \   000000BA   0x7011             STRB     R1,[R2, #+0]
   2901              break;
   \   000000BC   0xE025             B.N      ??ShortCutsParser_11
   2902              case 'x':
   2903                testTrimmValue--;
   \                     ??ShortCutsParser_8: (+1)
   \   000000BE   0x....             LDR.N    R1,??DataTable36_27
   \   000000C0   0x7809             LDRB     R1,[R1, #+0]
   \   000000C2   0x1E49             SUBS     R1,R1,#+1
   \   000000C4   0x....             LDR.N    R2,??DataTable36_27
   \   000000C6   0x7011             STRB     R1,[R2, #+0]
   2904              break;
   \   000000C8   0xE01F             B.N      ??ShortCutsParser_11
   2905              case 'n':
   2906                testPayloadLen++;
   \                     ??ShortCutsParser_2: (+1)
   \   000000CA   0x....             LDR.N    R1,??DataTable36_28
   \   000000CC   0x7809             LDRB     R1,[R1, #+0]
   \   000000CE   0x1C49             ADDS     R1,R1,#+1
   \   000000D0   0x....             LDR.N    R2,??DataTable36_28
   \   000000D2   0x7011             STRB     R1,[R2, #+0]
   2907                if(gMaxSmacSDULength_c < testPayloadLen){
   \   000000D4   0x....             LDR.N    R1,??DataTable36_28
   \   000000D6   0x7809             LDRB     R1,[R1, #+0]
   \   000000D8   0x297C             CMP      R1,#+124
   \   000000DA   0xDB02             BLT.N    ??ShortCutsParser_16
   2908                  testPayloadLen = 1;
   \   000000DC   0x2101             MOVS     R1,#+1
   \   000000DE   0x....             LDR.N    R2,??DataTable36_28
   \   000000E0   0x7011             STRB     R1,[R2, #+0]
   2909                }    
   2910              break;
   \                     ??ShortCutsParser_16: (+1)
   \   000000E2   0xE012             B.N      ??ShortCutsParser_11
   2911              case 'm':
   2912                testPayloadLen--;
   \                     ??ShortCutsParser_1: (+1)
   \   000000E4   0x....             LDR.N    R1,??DataTable36_28
   \   000000E6   0x7809             LDRB     R1,[R1, #+0]
   \   000000E8   0x1E49             SUBS     R1,R1,#+1
   \   000000EA   0x....             LDR.N    R2,??DataTable36_28
   \   000000EC   0x7011             STRB     R1,[R2, #+0]
   2913                if(1 > testPayloadLen){
   \   000000EE   0x....             LDR.N    R1,??DataTable36_28
   \   000000F0   0x7809             LDRB     R1,[R1, #+0]
   \   000000F2   0x2900             CMP      R1,#+0
   \   000000F4   0xD102             BNE.N    ??ShortCutsParser_17
   2914                  testPayloadLen = gMaxSmacSDULength_c;
   \   000000F6   0x217B             MOVS     R1,#+123
   \   000000F8   0x....             LDR.N    R2,??DataTable36_28
   \   000000FA   0x7011             STRB     R1,[R2, #+0]
   2915                }    
   2916              break;
   \                     ??ShortCutsParser_17: (+1)
   \   000000FC   0xE005             B.N      ??ShortCutsParser_11
   2917              default:
   2918                evDataFromCOMM = TRUE;
   \                     ??ShortCutsParser_10: (+1)
   \   000000FE   0x2101             MOVS     R1,#+1
   \   00000100   0x....             LDR.N    R2,??DataTable36_1
   \   00000102   0x7011             STRB     R1,[R2, #+0]
   2919                evTestParameters = FALSE;
   \   00000104   0x2100             MOVS     R1,#+0
   \   00000106   0x....             LDR.N    R2,??DataTable36_99
   \   00000108   0x7011             STRB     R1,[R2, #+0]
   2920              break;
   2921            }
   2922          }
   \                     ??ShortCutsParser_11: (+1)
   \   0000010A   0x4770             BX       LR               ;; return
   2923          
   2924          
   2925          /************************************************************************************
   2926          *
   2927          * AppTimerCallback
   2928          *
   2929          ************************************************************************************/
   2930          

   \                                 In section .text, align 2, keep-with-next
   2931          void AppLedTimerCallback (tmrTimerID_t timerId)
   2932          {
   \                     AppLedTimerCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2933            (void)timerId;  /* prevent compiler warning */
   2934              LED_StopFlashingAllLeds();
   \   00000004   0x.... 0x....      BL       LED_StopFlashingAllLeds
   2935              //LED_TurnOffAllLeds();
   2936          }
   \   00000008   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x400FF0C8         DC32     0x400ff0c8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x........         DC32     connState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     TempSumx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     TempSumy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     TempSumz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     AXIS

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x........         DC32     PIT_ITTERATIONS

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x........         DC32     testTrimmValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x........         DC32     sentPackets

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x400FF0C4         DC32     0x400ff0c4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     sensorID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     appState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x........         DC32     evDataFromCOMM

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     gSnd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x........         DC32     gOptions

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x........         DC32     gIsAck

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x........         DC32     gAppRxPacket

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x........         DC32     LowPowerEntered

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x........         DC32     gOpt+0x8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x........         DC32     gOpt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0x........         DC32     gLPConfigState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   0x........         DC32     bGotoLowPwrFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   0x........         DC32     gLastLPConfigState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   0x........         DC32     pu8GotoLowPowerString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   0x........         DC32     cau8WUContinueAskString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \   00000000   0x........         DC32     pu8NowInLowPowerString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \   00000000   0x........         DC32     pu8WakeupSourceString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x400FF0D4         DC32     0x400ff0d4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x00028488         DC32     0x28488

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x........         DC32     AppLedTimerCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x........         DC32     mLEDInterval1_c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x........         DC32     mLEDTimerID_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0x........         DC32     cau8WUInvalidValueString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   0x........         DC32     cau8WUWait4Option

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   0x40048038         DC32     0x40048038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \   00000000   0x4004C004         DC32     0x4004c004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_9:
   \   00000000   0x4004C014         DC32     0x4004c014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x........         DC32     gRxTimeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     gAppTxPacket

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x00014BAD         DC32     0x14bad

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \   00000000   0x40037000         DC32     0x40037000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_5:
   \   00000000   0x40037100         DC32     0x40037100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_6:
   \   00000000   0x40037108         DC32     0x40037108

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     gSnd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     gConfigState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x400FF0C0         DC32     0x400ff0c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x1FFF9200         DC32     0x1fff9200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x1FFF80F1         DC32     0x1fff80f1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x4003710C         DC32     0x4003710c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x........         DC32     ??b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_2:
   \   00000000   0x........         DC32     gAppTxPacket

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x........         DC32     gIsMyAck

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \   00000000   0x........         DC32     gPng

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_2:
   \   00000000   0x........         DC32     gPng+0x1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_3:
   \   00000000   0x........         DC32     gPng+0x2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_4:
   \   00000000   0x........         DC32     gPng+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_5:
   \   00000000   0x........         DC32     gSnd+0x1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_6:
   \   00000000   0x........         DC32     gSnd+0x2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_7:
   \   00000000   0x........         DC32     gSnd+0x3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_8:
   \   00000000   0x........         DC32     gSnd+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_9:
   \   00000000   0x........         DC32     gSnd+0x6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_10:
   \   00000000   0x........         DC32     gSnd+0x8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_11:
   \   00000000   0x........         DC32     gSnd+0xA

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_12:
   \   00000000   0x........         DC32     gSnd+0xC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_13:
   \   00000000   0x........         DC32     gSnd+0x10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_14:
   \   00000000   0x........         DC32     gSnd+0x14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_15:
   \   00000000   0x........         DC32     gSnd+0x18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_16:
   \   00000000   0x........         DC32     gSnd+0x1A

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_17:
   \   00000000   0x........         DC32     gSnd+0x1C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_18:
   \   00000000   0x........         DC32     gSnd+0x20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_19:
   \   00000000   0x........         DC32     gSnd+0x24

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_20:
   \   00000000   0x........         DC32     gSnd+0x28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_21:
   \   00000000   0x........         DC32     gSnd+0x2A

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_22:
   \   00000000   0x........         DC32     gSnd+0x2C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_23:
   \   00000000   0x........         DC32     gSnd+0x30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_24:
   \   00000000   0x........         DC32     gSnd+0x34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_25:
   \   00000000   0x........         DC32     gSnd+0x38

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_26:
   \   00000000   0x........         DC32     gSnd+0x3A

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_27:
   \   00000000   0x........         DC32     gSnd+0x3C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_28:
   \   00000000   0x........         DC32     gSnd+0x3E

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_29:
   \   00000000   0x........         DC32     gSnd+0x40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_30:
   \   00000000   0x........         DC32     gSnd+0x42

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_31:
   \   00000000   0x........         DC32     gSnd+0x43

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_32:
   \   00000000   0x........         DC32     gSnd+0x44

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_33:
   \   00000000   0x........         DC32     gOpt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   0x........         DC32     gOpt+0x1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_1:
   \   00000000   0x........         DC32     gOpt+0x2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_2:
   \   00000000   0x........         DC32     gOpt+0x3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_3:
   \   00000000   0x........         DC32     gOpt+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_4:
   \   00000000   0x........         DC32     gOpt+0x8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_5:
   \   00000000   0x........         DC32     gOpt+0xA

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_6:
   \   00000000   0x........         DC32     gOpt+0xC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_7:
   \   00000000   0x........         DC32     gOpt+0xE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_8:
   \   00000000   0x........         DC32     gOpt+0xF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_9:
   \   00000000   0x........         DC32     gOpt+0x10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_10:
   \   00000000   0x........         DC32     gOpt+0x14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_11:
   \   00000000   0x........         DC32     gOpt+0x18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_12:
   \   00000000   0x........         DC32     gOpt+0x1C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_13:
   \   00000000   0x........         DC32     gOpt+0x1E

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_14:
   \   00000000   0x........         DC32     sentPackets

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_15:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_16:
   \   00000000   0x........         DC32     gAppTxPacket

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_17:
   \   00000000   0x........         DC32     gSnd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_18:
   \   00000000   0x........         DC32     sensorID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_19:
   \   00000000   0x0010F447         DC32     0x10f447

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_20:
   \   00000000   0x0021E88E         DC32     0x21e88e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_21:
   \   00000000   0x0032DCD5         DC32     0x32dcd5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_22:
   \   00000000   0x069F6BC7         DC32     0x69f6bc7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x0D3ED78E         DC32     0xd3ed78e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \   00000000   0x13DE4355         DC32     0x13de4355

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_1:
   \   00000000   0x........         DC32     g_DEAD_BEEF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_2:
   \   00000000   0x........         DC32     gFlashDeadBeef

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_3:
   \   00000000   0x........         DC32     settingsAddress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_4:
   \   00000000   0x........         DC32     cau8WULPTMRWakeupString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_5:
   \   00000000   0x........         DC32     cau8WUGotoVLLS1String

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_6:
   \   00000000   0x........         DC32     pu8GotoLowPowerString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_7:
   \   00000000   0x........         DC32     cau8WUIsVLLS1ModeString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_8:
   \   00000000   0x........         DC32     pu8NowInLowPowerString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36:
   \   00000000   0x........         DC32     appState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_1:
   \   00000000   0x........         DC32     evDataFromCOMM

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_2:
   \   00000000   0x........         DC32     gOptions

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_3:
   \   00000000   0x00028488         DC32     0x28488

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_4:
   \   00000000   0x........         DC32     pu8WakeupSourceString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_5:
   \   00000000   0x4007E000         DC32     0x4007e000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_6:
   \   00000000   0x........         DC32     gLPConfigState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_7:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_8:
   \   00000000   0x........         DC32     ??sDeadBeef

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_9:
   \   00000000   0x........         DC32     maMmPools

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_10:
   \   00000000   0x........         DC32     poolInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_11:
   \   00000000   0x........         DC32     maMacHeap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_12:
   \   00000000   0x........         DC32     CommRxCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_13:
   \   00000000   0x........         DC32     mLEDTimerID_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_14:
   \   00000000   0x........         DC32     mBufferTimerID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_15:
   \   00000000   0x........         DC32     gConfigState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_16:
   \   00000000   0x........         DC32     u8SequencePointerCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_17:
   \   00000000   0x........         DC32     bReturnToMainMenuFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_18:
   \   00000000   0x........         DC32     cau8WUVLLS1String

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_19:
   \   00000000   0x........         DC32     pu8MainLowPowerString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_20:
   \   00000000   0x........         DC32     cau8WULPTMRString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_21:
   \   00000000   0x........         DC32     pu8MainWakeupSourceString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_22:
   \   00000000   0x........         DC32     bTxOtaBusyFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_23:
   \   00000000   0x........         DC32     bCommGetDataTimerFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_24:
   \   00000000   0x........         DC32     testOpMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_25:
   \   00000000   0x........         DC32     testChannel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_26:
   \   00000000   0x........         DC32     testPower

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_27:
   \   00000000   0x........         DC32     testTrimmValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_28:
   \   00000000   0x........         DC32     testPayloadLen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_29:
   \   00000000   0x........         DC32     contTestRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_30:
   \   00000000   0x........         DC32     shortCutsEnabled

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_31:
   \   00000000   0x........         DC32     connState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_32:
   \   00000000   0x........         DC32     cTxRxState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_33:
   \   00000000   0x........         DC32     perTxState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_34:
   \   00000000   0x........         DC32     perRxState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_35:
   \   00000000   0x........         DC32     rangeTxState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_36:
   \   00000000   0x........         DC32     rangeRxState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_37:
   \   00000000   0x........         DC32     prevOpMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_38:
   \   00000000   0x........         DC32     txTestIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_39:
   \   00000000   0x........         DC32     rxTestIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_40:
   \   00000000   0x........         DC32     gau8TxDataBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_41:
   \   00000000   0x........         DC32     gau8RxDataBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_42:
   \   00000000   0x........         DC32     gAppRxPacket

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_43:
   \   00000000   0x40049000         DC32     0x40049000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_44:
   \   00000000   0x........         DC32     u32PortAPCRBackup

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_45:
   \   00000000   0x40049004         DC32     0x40049004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_46:
   \   00000000   0x40049008         DC32     0x40049008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_47:
   \   00000000   0x4004900C         DC32     0x4004900c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_48:
   \   00000000   0x40049010         DC32     0x40049010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_49:
   \   00000000   0x4004A028         DC32     0x4004a028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_50:
   \   00000000   0x........         DC32     u32PortBPCRBackup

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_51:
   \   00000000   0x4004A02C         DC32     0x4004a02c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_52:
   \   00000000   0x4004A040         DC32     0x4004a040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_53:
   \   00000000   0x4004A044         DC32     0x4004a044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_54:
   \   00000000   0x4004B010         DC32     0x4004b010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_55:
   \   00000000   0x........         DC32     u32PortCPCRBackup

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_56:
   \   00000000   0x4004B014         DC32     0x4004b014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_57:
   \   00000000   0x4004B018         DC32     0x4004b018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_58:
   \   00000000   0x4004B01C         DC32     0x4004b01c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_59:
   \   00000000   0x4004D000         DC32     0x4004d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_60:
   \   00000000   0x........         DC32     u32PortEPCRBackup

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_61:
   \   00000000   0x4004D004         DC32     0x4004d004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_62:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_63:
   \   00000000   0x........         DC32     u32SCGCxBackup

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_64:
   \   00000000   0x40048038         DC32     0x40048038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_65:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_66:
   \   00000000   0x40048040         DC32     0x40048040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_67:
   \   00000000   0x400FF000         DC32     0x400ff000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_68:
   \   00000000   0x........         DC32     u32GPIOs_PDORBackup

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_69:
   \   00000000   0x400FF040         DC32     0x400ff040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_70:
   \   00000000   0x400FF080         DC32     0x400ff080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_71:
   \   00000000   0x400FF0C0         DC32     0x400ff0c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_72:
   \   00000000   0x400FF100         DC32     0x400ff100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_73:
   \   00000000   0x400FF014         DC32     0x400ff014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_74:
   \   00000000   0x........         DC32     u32GPIOs_PDDRBackup

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_75:
   \   00000000   0x400FF054         DC32     0x400ff054

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_76:
   \   00000000   0x400FF094         DC32     0x400ff094

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_77:
   \   00000000   0x400FF0D4         DC32     0x400ff0d4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_78:
   \   00000000   0x400FF114         DC32     0x400ff114

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_79:
   \   00000000   0x4004B000         DC32     0x4004b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_80:
   \   00000000   0x4004B004         DC32     0x4004b004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_81:
   \   00000000   0x4004B00C         DC32     0x4004b00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_82:
   \   00000000   0x4004C00C         DC32     0x4004c00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_83:
   \   00000000   0x4004C010         DC32     0x4004c010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_84:
   \   00000000   0x400FF008         DC32     0x400ff008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_85:
   \   00000000   0x400FF088         DC32     0x400ff088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_86:
   \   00000000   0x4007D000         DC32     0x4007d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_87:
   \   00000000   0xF0100030         DC32     0xf0100030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_88:
   \   00000000   0x00040182         DC32     0x40182

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_89:
   \   00000000   0x40000001         DC32     0x40000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_90:
   \   00000000   0x........         DC32     bLPTMRWakeupFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_91:
   \   00000000   0x........         DC32     gMCG_coreClkMHz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_92:
   \   00000000   0x........         DC32     LowPowerEntered

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_93:
   \   00000000   0x........         DC32     bCommTxDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_94:
   \   00000000   0x........         DC32     gu8CommData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_95:
   \   00000000   0x........         DC32     bTxDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_96:
   \   00000000   0x........         DC32     bRxDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_97:
   \   00000000   0x........         DC32     bestChannel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_98:
   \   00000000   0x........         DC32     bScanDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_99:
   \   00000000   0x........         DC32     evTestParameters

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x0C 0x0D          DC8 "\014\015\012 Running PER Tx, Sending "
   \              0x0A 0x20    
   \              0x52 0x75    
   \              0x6E 0x6E    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x50 0x45    
   \              0x52 0x20    
   \              0x54 0x78    
   \              0x2C 0x20    
   \              0x53 0x65    
   \              0x6E 0x64    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x20 0x50          DC8 " Packets"
   \              0x61 0x63    
   \              0x6B 0x65    
   \              0x74 0x73    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x53 0x4E          DC8 53H, 4EH, 44H, 9, 25H, 75H, 9, 25H
   \              0x44 0x09    
   \              0x25 0x75    
   \              0x09 0x25    
   \   00000008   0x75 0x09          DC8 75H, 9, 25H, 75H, 9, 25H, 75H, 9
   \              0x25 0x75    
   \              0x09 0x25    
   \              0x75 0x09    
   \   00000010   0x25 0x75          DC8 25H, 75H, 9, 25H, 75H, 9, 25H, 75H
   \              0x09 0x25    
   \              0x75 0x09    
   \              0x25 0x75    
   \   00000018   0x09 0x25          DC8 9, 25H, 75H, 9, 25H, 75H, 9, 25H
   \              0x75 0x09    
   \              0x25 0x75    
   \              0x09 0x25    
   \   00000020   0x75 0x09          DC8 75H, 9, 25H, 75H, 9, 25H, 75H, 9
   \              0x25 0x75    
   \              0x09 0x25    
   \              0x75 0x09    
   \   00000028   0x25 0x75          DC8 25H, 75H, 9, 25H, 64H, 9, 25H, 75H
   \              0x09 0x25    
   \              0x64 0x09    
   \              0x25 0x75    
   \   00000030   0x09 0x25          DC8 9, 25H, 64H, 9, 25H, 75H, 9, 25H
   \              0x64 0x09    
   \              0x25 0x75    
   \              0x09 0x25    
   \   00000038   0x75 0x09          DC8 75H, 9, 25H, 75H, 9, 25H, 75H, 9
   \              0x25 0x75    
   \              0x09 0x25    
   \              0x75 0x09    
   \   00000040   0x25 0x75          DC8 25H, 75H, 0DH, 0AH, 0
   \              0x0D 0x0A    
   \              0x00         
   \   00000045   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x40020000         DC32 1073872896, 0, 524288, 0, 0, 0, 0, 0
   \              0x00000000   
   \              0x00080000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x40020000         DC32 1073872896, 0, 524288, 0, 0, 0, 0, 0
   \              0x00000000   
   \              0x00080000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   2937          
   2938          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   AppLedTimerCallback
         8   -> LED_StopFlashingAllLeds
       8   ChangeOptions
         8   -> FlashSaveOptions
         8   -> SendCurrentOptions
         8   -> __aeabi_memcpy4
         8   -> memcmp
      32   ChooseBestChannel
        32   -> CopyPngPacketToSMAC
        32   -> GetLinkQdBm
        32   -> GetRandomNibble
        32   -> MCPSDataRequest
        32   -> MLMESetChannelRequest
        32   -> PngSwapEndianness
        32   -> ReceivePacket
        32   -> SendCurrentOptions
       8   CommRxCallback
         8   -> ShortCutsParser
         8   -> Uart1_GetByteFromRxBuffer
       0   CommTxCallback
       8   CopyBinaryPacketToSMAC
         8   -> MemoryCpy
       8   CopyOptPacketToSMAC
         8   -> MemoryCpy
      16   CopyOptionsFromRecvPacket
        16   -> MemoryCpy
       8   CopyPngPacketToSMAC
         8   -> MemoryCpy
      48   FlashSaveOptions
        48   -> NV_FlashEraseSector
        48   -> NV_FlashProgramLongword
        48   -> NV_FlashProgramUnalignedLongword
        48   -> __aeabi_memcpy4
      16   GetDeviceData
        16   -> ConversionAComplete
        16   -> GetConversionValue
        16   -> INIT_PIT
        16   -> NVIC_DisableIRQ
        16   -> NVIC_EnableIRQ
        16   -> StartBattConversion
        16   -> StartTempConversion
       0   GetFactoryOptions
       8   GetLinkQdBm
         8   -> MLMELinkQuality
       0   GetRandomNibble
       0   GlobalDataInit
       8   INIT_PIT
         8   -> NVIC_DisableIRQ
         8   -> NVIC_EnableIRQ
         8   -> NVIC_SetPriority
       0   InitAccelControlls
       0   InitPacket
      56   InitProject
        56   -> FlashSaveOptions
        56   -> GetFactoryOptions
        56   -> GlobalDataInit
        56   -> InitPacket
        56   -> KeyboardInit
        56   -> LED_Init
        56   -> MC1324xDrv_SPIInit
        56   -> MLMERadioInit
        56   -> MM_Init
        56   -> NV_FlashInit
        56   -> NV_FlashRead
        56   -> TMR_AllocateTimer
        56   -> TMR_Init
        56   -> Uart1_SetBaud
        56   -> Uart1_SetRxCallBack
        56   -> Uart_ModuleInit
        56   -> __aeabi_memcpy4
      16   InitSmac
        16   -> MLMEPAOutputAdjust
        16   -> MLMESetChannelRequest
        16   -> MLMESetPromiscuousMode
        16   -> MLMEXtalAdjust
       0   MCPSDataConfirm
       0   MCPSDataIndication
       0   MLMEResetIndication
       0   MLMEScanConfirm
       0   MLMEWakeConfirm
       0   OptSwapEndianness
      16   PIT_ISR
        16   -> ConversionAComplete
        16   -> GetConversionValue
        16   -> StartXConversion
        16   -> StartYConversion
        16   -> StartZConversion
       0   PngSwapEndianness
       8   PrintPacketID
         8   -> CommUtil_Print
         8   -> PrintWordOnDecimalFormatBlocking
       8   ReceivePacket
         8   -> MLMERXEnableRequest
      88   SendASCIIPacket
        88   -> InitPacket
        88   -> MCPSDataRequest
        88   -> sprintf
       8   SendBinaryPacket
         8   -> CopyBinaryPacketToSMAC
         8   -> GetLinkQdBm
         8   -> MCPSDataRequest
         8   -> SndSwapEndianness
       8   SendCurrentOptions
         8   -> CopyOptPacketToSMAC
         8   -> MCPSDataRequest
         8   -> OptSwapEndianness
         8   -> __aeabi_memcpy4
       0   ShortCutsParser
       0   SndSwapEndianness
       0   ValidateOptions
       0   WUApp_InitLowPowerMode
       8   WUApp_InitWakupSource
         8   -> NVIC_EnableIRQ
         8   -> PWRLib_LLWU_WakeupModuleEnable
       8   WUApp_LPRestoreSettings
         8   -> MC1324xDrv_Set_CLK_OUT_Freq
         8   -> MCG_PLLInit
         8   -> PWRLib_LPTMR_ClockStop
         8   -> PWRLib_Radio_Enter_AutoDoze
         8   -> TMR_AllocateTimer
       8   WUApp_LowPowerWhile
         8   -> PWRLib_MCU_Enter_VLLS1
         8   -> WUApp_LPRestoreSettings
         8   -> WUApp_PrepareToEnterLowPower
       8   WUApp_LowPwrStateMachine
         8   -> LED_StartSerialFlash
         8   -> PrintMenu
         8   -> TMR_StartSingleShotTimer
         8   -> WUApp_InitLowPowerMode
         8   -> WUApp_InitWakupSource
         8   -> WUApp_LowPowerWhile
       8   WUApp_PrepareToEnterLowPower
         8   -> MC1324xDrv_Set_CLK_OUT_Freq
         8   -> MCG_Pee2Fei
         8   -> PWRLib_LPTMR_ClockStart
         8   -> PWRLib_Radio_Enter_Hibernate
         8   -> TMR_FreeTimer
         8   -> TMR_StopTimer
       0   getRandomNumberInRange
      88   main
        88   -> ADCInit
        88   -> ChooseBestChannel
        88   -> CopyOptionsFromRecvPacket
        88   -> GetDeviceData
        88   -> GetFactoryOptions
        88   -> INIT_PIT
        88   -> InitAccelControlls
        88   -> InitPacket
        88   -> InitProject
        88   -> InitSmac
        88   -> MLMEPAOutputAdjust
        88   -> MLMESetChannelRequest
        88   -> MLMEXtalAdjust
        88   -> OptSwapEndianness
        88   -> ReceivePacket
        88   -> SendBinaryPacket
        88   -> ValidateOptions
        88   -> WUApp_LowPwrStateMachine


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable14
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable17_9
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable19
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable24
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_2
       4  ??DataTable26
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_10
       4  ??DataTable28_11
       4  ??DataTable28_12
       4  ??DataTable28_13
       4  ??DataTable28_14
       4  ??DataTable28_15
       4  ??DataTable28_16
       4  ??DataTable28_17
       4  ??DataTable28_18
       4  ??DataTable28_19
       4  ??DataTable28_2
       4  ??DataTable28_20
       4  ??DataTable28_21
       4  ??DataTable28_22
       4  ??DataTable28_23
       4  ??DataTable28_24
       4  ??DataTable28_25
       4  ??DataTable28_26
       4  ??DataTable28_27
       4  ??DataTable28_28
       4  ??DataTable28_29
       4  ??DataTable28_3
       4  ??DataTable28_30
       4  ??DataTable28_31
       4  ??DataTable28_32
       4  ??DataTable28_33
       4  ??DataTable28_4
       4  ??DataTable28_5
       4  ??DataTable28_6
       4  ??DataTable28_7
       4  ??DataTable28_8
       4  ??DataTable28_9
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable29_10
       4  ??DataTable29_11
       4  ??DataTable29_12
       4  ??DataTable29_13
       4  ??DataTable29_14
       4  ??DataTable29_15
       4  ??DataTable29_16
       4  ??DataTable29_17
       4  ??DataTable29_18
       4  ??DataTable29_19
       4  ??DataTable29_2
       4  ??DataTable29_20
       4  ??DataTable29_21
       4  ??DataTable29_22
       4  ??DataTable29_3
       4  ??DataTable29_4
       4  ??DataTable29_5
       4  ??DataTable29_6
       4  ??DataTable29_7
       4  ??DataTable29_8
       4  ??DataTable29_9
       4  ??DataTable30
       4  ??DataTable31
       4  ??DataTable35
       4  ??DataTable35_1
       4  ??DataTable35_2
       4  ??DataTable35_3
       4  ??DataTable35_4
       4  ??DataTable35_5
       4  ??DataTable35_6
       4  ??DataTable35_7
       4  ??DataTable35_8
       4  ??DataTable36
       4  ??DataTable36_1
       4  ??DataTable36_10
       4  ??DataTable36_11
       4  ??DataTable36_12
       4  ??DataTable36_13
       4  ??DataTable36_14
       4  ??DataTable36_15
       4  ??DataTable36_16
       4  ??DataTable36_17
       4  ??DataTable36_18
       4  ??DataTable36_19
       4  ??DataTable36_2
       4  ??DataTable36_20
       4  ??DataTable36_21
       4  ??DataTable36_22
       4  ??DataTable36_23
       4  ??DataTable36_24
       4  ??DataTable36_25
       4  ??DataTable36_26
       4  ??DataTable36_27
       4  ??DataTable36_28
       4  ??DataTable36_29
       4  ??DataTable36_3
       4  ??DataTable36_30
       4  ??DataTable36_31
       4  ??DataTable36_32
       4  ??DataTable36_33
       4  ??DataTable36_34
       4  ??DataTable36_35
       4  ??DataTable36_36
       4  ??DataTable36_37
       4  ??DataTable36_38
       4  ??DataTable36_39
       4  ??DataTable36_4
       4  ??DataTable36_40
       4  ??DataTable36_41
       4  ??DataTable36_42
       4  ??DataTable36_43
       4  ??DataTable36_44
       4  ??DataTable36_45
       4  ??DataTable36_46
       4  ??DataTable36_47
       4  ??DataTable36_48
       4  ??DataTable36_49
       4  ??DataTable36_5
       4  ??DataTable36_50
       4  ??DataTable36_51
       4  ??DataTable36_52
       4  ??DataTable36_53
       4  ??DataTable36_54
       4  ??DataTable36_55
       4  ??DataTable36_56
       4  ??DataTable36_57
       4  ??DataTable36_58
       4  ??DataTable36_59
       4  ??DataTable36_6
       4  ??DataTable36_60
       4  ??DataTable36_61
       4  ??DataTable36_62
       4  ??DataTable36_63
       4  ??DataTable36_64
       4  ??DataTable36_65
       4  ??DataTable36_66
       4  ??DataTable36_67
       4  ??DataTable36_68
       4  ??DataTable36_69
       4  ??DataTable36_7
       4  ??DataTable36_70
       4  ??DataTable36_71
       4  ??DataTable36_72
       4  ??DataTable36_73
       4  ??DataTable36_74
       4  ??DataTable36_75
       4  ??DataTable36_76
       4  ??DataTable36_77
       4  ??DataTable36_78
       4  ??DataTable36_79
       4  ??DataTable36_8
       4  ??DataTable36_80
       4  ??DataTable36_81
       4  ??DataTable36_82
       4  ??DataTable36_83
       4  ??DataTable36_84
       4  ??DataTable36_85
       4  ??DataTable36_86
       4  ??DataTable36_87
       4  ??DataTable36_88
       4  ??DataTable36_89
       4  ??DataTable36_9
       4  ??DataTable36_90
       4  ??DataTable36_91
       4  ??DataTable36_92
       4  ??DataTable36_93
       4  ??DataTable36_94
       4  ??DataTable36_95
       4  ??DataTable36_96
       4  ??DataTable36_97
       4  ??DataTable36_98
       4  ??DataTable36_99
      32  ?_0
      12  ?_1
      72  ?_2
      32  ?_3
      32  ?_4
       4  AXIS
      10  AppLedTimerCallback
      54  ChangeOptions
     228  ChooseBestChannel
      34  CommRxCallback
       8  CommTxCallback
     476  CopyBinaryPacketToSMAC
     252  CopyOptPacketToSMAC
     196  CopyOptionsFromRecvPacket
      68  CopyPngPacketToSMAC
      96  FlashSaveOptions
     230  GetDeviceData
      50  GetFactoryOptions
      16  GetLinkQdBm
      58  GetRandomNibble
     130  GlobalDataInit
      72  INIT_PIT
     114  InitAccelControlls
     278  InitPacket
     400  InitProject
      74  InitSmac
       4  LPTMR_Duration
       1  LowPowerEntered
       8  MCPSDataConfirm
      14  MCPSDataIndication
       2  MLMEResetIndication
      12  MLMEScanConfirm
       2  MLMEWakeConfirm
     104  OptSwapEndianness
     246  PIT_ISR
       4  PIT_ITTERATIONS
      28  PngSwapEndianness
      40  PrintPacketID
       4  RTC_Duration
     210  ReceivePacket
     194  SendASCIIPacket
      54  SendBinaryPacket
      66  SendCurrentOptions
     268  ShortCutsParser
     724  SndSwapEndianness
       4  TempSumx
       4  TempSumy
       4  TempSumz
     146  ValidateOptions
      38  WUApp_InitLowPowerMode
      32  WUApp_InitWakupSource
     372  WUApp_LPRestoreSettings
      16  WUApp_LowPowerWhile
     258  WUApp_LowPwrStateMachine
     740  WUApp_PrepareToEnterLowPower
       1  appState
      16  au8ScanResults
       1  b
       1  bCommGetDataTimerFlag
       1  bCommTxDone
       1  bFirstNibbleFlag
       1  bGPIOWakeupFlag
       1  bGotoLowPwrFlag
       1  bLPTMRWakeupFlag
       1  bRTCWakeupFlag
       1  bReturnToMainMenuFlag
       1  bRxDone
       1  bScanDone
       1  bTxDone
       1  bTxOtaBusyFlag
       1  bestChannel
       1  cTxRxState
       1  connState
       1  contTestRunning
       1  eRState
       1  evDataFromCOMM
       1  evTestParameters
       4  gAppRxPacket
       4  gAppTxPacket
       1  gConfigState
       4  gFlashDeadBeef
      24  gFlashOptions
       1  gIsAck
       1  gIsMyAck
       1  gLPConfigState
       1  gLastConfigState
       1  gLastLPConfigState
      32  gOpt
      24  gOptions
       8  gPng
      96  gRawSnd
       4  gRxTimeout
      72  gSnd
       4  g_DEAD_BEEF
     132  gau8RxDataBuffer
     128  gau8TxDataBuffer
      34  getRandomNumberInRange
       1  gu8CommData
       1  mBufferInterval_c
       1  mBufferTimerID
       2  mLEDInterval1_c
       1  mLEDTimerID_1
     800  main
       1  oDRState
       1  oIRState
       1  perRxState
       1  perTxState
       1  prevOpMode
       4  pu8GotoLowPowerString
       4  pu8MainLowPowerString
       4  pu8MainWakeupSourceString
       4  pu8NowInLowPowerString
       4  pu8WakeupSourceString
       1  rDRState
       1  rIRState
       1  rangeRxState
       1  rangeTxState
       1  rxTestIndex
       4  sDeadBeef
       2  sensorID
       2  sentPackets
       4  settingsAddress
       1  shortCutsEnabled
       1  testChannel
       1  testOpMode
       1  testPayloadLen
       1  testPower
       1  testTrimmValue
       1  txTestIndex
      32  u32GPIOs_PDDRBackup
      32  u32GPIOs_PDORBackup
      32  u32PortAPCRBackup
      32  u32PortBPCRBackup
      32  u32PortCPCRBackup
      32  u32PortDPCRBackup
      32  u32PortEPCRBackup
      20  u32SCGCxBackup
       1  u8ConfigDecValue
       1  u8ConfigHexValue
       1  u8SequencePointerCounter

 
   889 bytes in section .bss
    13 bytes in section .data
   188 bytes in section .rodata
 8 140 bytes in section .text
 
 8 140 bytes of CODE  memory
   188 bytes of CONST memory
   902 bytes of DATA  memory

Errors: none
Warnings: 4
