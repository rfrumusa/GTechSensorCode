###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        23/Mar/2018  14:45:44
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor Code
#        - Copy\Shanit Origional Code\Connectivity
#        Test\Application\Source\main.c
#    Command line =  
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code - Copy\Shanit Origional Code\Connectivity
#        Test\Application\Source\main.c" -D IAR --preprocess
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code - Copy\Shanit Origional Code\Connectivity Test\Debug\List\" -lC
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code - Copy\Shanit Origional Code\Connectivity Test\Debug\List\" -lB
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code - Copy\Shanit Origional Code\Connectivity Test\Debug\List\"
#        --diag_suppress Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code - Copy\Shanit Origional Code\Connectivity Test\Debug\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\rfrum\OneDrive\2018
#        Spring Semester\Senior Design\Sensor Code - Copy\Shanit Origional
#        Code\Connectivity Test\PLM\Configure\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code - Copy\Shanit Origional Code\Connectivity Test\PLM\Environment\"
#        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code - Copy\Shanit Origional Code\Connectivity Test\PLM\Interface\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code - Copy\Shanit Origional Code\Connectivity Test\Generic
#        Services\Interface\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code - Copy\Shanit Origional
#        Code\Connectivity Test\PLM\Source\Uart\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code - Copy\Shanit Origional Code\Connectivity Test\PLM\Source\USB\"
#        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code - Copy\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code - Copy\Shanit Origional
#        Code\Connectivity Test\PLM\Source\USB\APP\CDC\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code - Copy\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\Descriptor\" -I "C:\Users\rfrum\OneDrive\2018
#        Spring Semester\Senior Design\Sensor Code - Copy\Shanit Origional
#        Code\Connectivity Test\PLM\Source\USB\Class\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code - Copy\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\Common\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code - Copy\Shanit Origional
#        Code\Connectivity Test\PLM\Source\USB\Driver\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code - Copy\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\"
#        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code - Copy\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Radio\MC1324x\PHY\" -I "C:\Users\rfrum\OneDrive\2018
#        Spring Semester\Senior Design\Sensor Code - Copy\Shanit Origional
#        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code - Copy\Shanit Origional Code\Connectivity Test\PLM\Source\Sys
#        Common\" -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior
#        Design\Sensor Code - Copy\Shanit Origional Code\Connectivity
#        Test\SMAC\Source\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code - Copy\Shanit Origional
#        Code\Connectivity Test\SMAC\Interface\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code - Copy\Shanit Origional Code\Connectivity Test\SMAC\Configure\"
#        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code - Copy\Shanit Origional Code\Connectivity
#        Test\Application\Source\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code - Copy\Shanit Origional
#        Code\Connectivity Test\Application\Configure\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code - Copy\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\"
#        -I "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -On
#    List file    =  
#        C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor Code
#        - Copy\Shanit Origional Code\Connectivity Test\Debug\List\main.lst
#    Object file  =  
#        C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor Code
#        - Copy\Shanit Origional Code\Connectivity Test\Debug\Obj\main.o
#
###############################################################################

C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor Code - Copy\Shanit Origional Code\Connectivity Test\Application\Source\main.c
      1          /*****************************************************************************
      2          * Connectivity test demo main file.
      3          * 
      4          * Copyright (c) 2012, Freescale, Inc. All rights reserved.
      5          *
      6          * 
      7          * No part of this document must be reproduced in any form - including copied,
      8          * transcribed, printed or by any electronic means - without specific written
      9          * permission from Freescale Semiconductor.
     10          *
     11          *  The Connectivity Test Demo  is  mainly  used  to perform radio performance 
     12          *  test in hardware for wireless implementations. It allows users to exercise 
     13          *  all the radio functionality and to get results for some important wireless 
     14          *  tests as Packet Error Rate and Range test.
     15          *  
     16          *  The main functions provided by Connectivity test are:
     17          *  - Perform Range test.
     18          *  - Perform Packet Error Rate test.
     19          *  - Manage radio parameters as Channel, Power and Crystal Trim.
     20          *  - Perform Radio Tests as Continuous Modulated TX, Continuous PRBS9 packets 
     21          *    Tx, Un-modulated TX, Continuous Rx and Channel energy Detect.
     22          *  - Manage to read and write radio registers by address.
     23          *
     24          *****************************************************************************/
     25          
     26          #include "ApplicationConf.h"             /*Defines the Application default parameters*/
     27          #include "SMAC.h"
     28          #include <stdio.h>
     29          #include <stdlib.h>
     30          #include <string.h>
     31          
     32          /************************************************************************************
     33          *************************************************************************************
     34          * Private prototypes 
     35          *************************************************************************************
     36          ************************************************************************************/
     37          static void InitProject(void);
     38          void InitSmac(void);
     39          static void PrintTestParameters(bool_t bEraseLine);
     40          static void SerialUIStateMachine(void);
     41          static bool_t SerialContinuousTxRxTest(void);
     42          static bool_t PacketErrorRateTx(void);
     43          static bool_t PacketErrorRateRx(void);
     44          static void SetRadioRxOnTimeOut15ms(void);
     45          static void SetRadioRxOnNoTimeOut(void);
     46          static void PrintPerRxFinalLine(uint16_t u16Received, uint16_t u16Total);
     47          static bool_t RangeTx(void);
     48          static bool_t RangeRx(void);
     49          
     50          static bool_t EditRegisters(void);
     51          static bool_t OverrideDirectRegisters(void);
     52          static bool_t OverrideIndirectRegisters(void);
     53          static bool_t ReadDirectRegisters(void);
     54          static bool_t ReadIndirectRegisters(void);
     55          
     56          void MLMEScanConfirm(channels_t ClearestChann);
     57          void MLMEResetIndication(void);
     58          void MLMEWakeConfirm(void);
     59          void CommRxCallback();
     60          void ShortCutsParser(uint8_t u8CommData);
     61          void CommTxCallback(void);
     62          void MCPSDataConfirm(txStatus_t TransmissionResult);
     63          void MCPSDataIndication(rxPacket_t *gsRxPacket);
     64          void GlobalDataInit(void);
     65          /* Place your callbacks prototypes declarations here */
     66          void InitPacket();
     67          smacErrors_t SendASCIIPacket();
     68          smacErrors_t SendBinaryPacket();
     69          void ReceivePacket();
     70          void PrintPacketID(uint16_t packetID);
     71          void CopyBinaryPacketToSMAC();
     72          void SndSwapEndianness();
     73          void PngSwapEndianness();
     74          void OptSwapEndianness(tOptions* opt);
     75          void GetFactoryOptions(tOptions *pOptions);
     76          void FlashSaveOptions();
     77          void ChangeOptions(tOptions* pOptions);
     78          int ValidateOptions(tOptions *pOptions);
     79          smacErrors_t SendCurrentOptions();
     80          void CopyOptPacketToSMAC();
     81          void CopyOptionsFromRecvPacket(tOptions* pOptions);
     82          void CopyPngPacketToSMAC();
     83          uint8_t ChooseBestChannel();
     84          uint8_t GetRandomNibble();
     85          int8_t GetLinkQdBm();
     86          /************************************************************************************
     87          *************************************************************************************
     88          * Module Constants
     89          *************************************************************************************
     90          ************************************************************************************/
     91          /*initilize the functions to turn on and off the power to the Accel Module*/
     92          #define AccellPowerOn()         (gLED_PortDataSetReg_c |= gAccelPower);
     93          #define AccellEnableOn()         (gLED_PortDataSetReg_c |= gAccelEnable);
     94          
     95          /*initilize the functions that will turn on the power to teh accell module */
     96          #define AccellPowerOff()        (gLED_PortDataClearReg_c |= gAccelPower);
     97          #define AccellEnableOff()          (gLED_PortDataClearReg_c |= gAccelEnable);
     98          
     99          /************************************************************************************
    100          *************************************************************************************
    101          * Public memory declarations
    102          *************************************************************************************
    103          ************************************************************************************/
    104          

   \                                 In section .bss, align 4
    105          static uint8_t gau8RxDataBuffer[130]; 
   \                     gau8RxDataBuffer:
   \   00000000                      DS8 132

   \                                 In section .bss, align 4
    106          static uint8_t gau8TxDataBuffer[128]; 
   \                     gau8TxDataBuffer:
   \   00000000                      DS8 128
    107          

   \                                 In section .bss, align 4
    108          static txPacket_t * gAppTxPacket;
   \                     gAppTxPacket:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    109          static rxPacket_t * gAppRxPacket;
   \                     gAppRxPacket:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    110          static tSnd        gSnd;
   \                     gSnd:
   \   00000000                      DS8 72

   \                                 In section .bss, align 4
    111          tOptions    gOptions;
   \                     gOptions:
   \   00000000                      DS8 24

   \                                 In section .bss, align 4
    112          tOpt        gOpt;
   \                     gOpt:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
    113          tPng        gPng;
   \                     gPng:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
    114          tRawSnd     gRawSnd;      
   \                     gRawSnd:
   \   00000000                      DS8 96
    115          

   \                                 In section .bss, align 1
    116          volatile int8_t appState;
   \                     appState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    117          uint8_t       gIsAck;
   \                     gIsAck:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    118          uint8_t       gIsMyAck;
   \                     gIsMyAck:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    119          uint32_t      gRxTimeout;
   \                     gRxTimeout:
   \   00000000                      DS8 4

   \                                 In section .rodata, align 4
    120          const uint32_t g_DEAD_BEEF = 0xDEADBEEF;  // unlikely-to-exist bit pattern
   \                     g_DEAD_BEEF:
   \   00000000   0xDEADBEEF         DC32 3735928559

   \                                 In section .rodata, align 4
    121          const uint32_t settingsAddress = 0x0007F800;
   \                     settingsAddress:
   \   00000000   0x0007F800         DC32 522240
    122          //uint32_t      gFlashDeadBeef  @0x0007F800;

   \                                 In section .bss, align 4
    123          uint32_t      gFlashDeadBeef;
   \                     gFlashDeadBeef:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    124          tOptions    gFlashOptions;    // Note: on same FLASH memory page as "gFlashDeadBeef"
   \                     gFlashOptions:
   \   00000000                      DS8 24

   \                                 In section .bss, align 2
    125          uint16_t sensorID;
   \                     sensorID:
   \   00000000                      DS8 2
    126          

   \                                 In section .bss, align 1
    127          bool_t bTxDone;
   \                     bTxDone:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    128          bool_t bRxDone;
   \                     bRxDone:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    129          bool_t bScanDone;
   \                     bScanDone:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    130          channels_t bestChannel;
   \                     bestChannel:
   \   00000000                      DS8 1
    131          

   \                                 In section .bss, align 1
    132          bool_t  bCommTxDone;  
   \                     bCommTxDone:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    133          uint8_t gu8CommData;
   \                     gu8CommData:
   \   00000000                      DS8 1
    134          

   \                                 In section .bss, align 1
    135          operationModes_t testOpMode;
   \                     testOpMode:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    136          operationModes_t prevOpMode;
   \                     prevOpMode:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    137          channels_t       testChannel;
   \                     testChannel:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    138          uint8_t          testPower;
   \                     testPower:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    139          uint8_t          testTrimmValue;
   \                     testTrimmValue:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    140          uint8_t          testPayloadLen;
   \                     testPayloadLen:
   \   00000000                      DS8 1
    141          

   \                                 In section .bss, align 1
    142          smacTestMode_t contTestRunning;
   \                     contTestRunning:
   \   00000000                      DS8 1
    143          

   \                                 In section .bss, align 1
    144          bool_t evDataFromCOMM;
   \                     evDataFromCOMM:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    145          bool_t evTestParameters;
   \                     evTestParameters:
   \   00000000                      DS8 1
    146          

   \                                 In section .bss, align 1
    147          bool_t shortCutsEnabled;
   \                     shortCutsEnabled:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    148          ConnectivityStates_t       connState;
   \                     connState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    149          ContinuousTxRxTestStates_t cTxRxState;
   \                     cTxRxState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    150          PerTxStates_t              perTxState;
   \                     perTxState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    151          PerRxStates_t              perRxState;
   \                     perRxState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    152          RangeTxStates_t            rangeTxState;
   \                     rangeTxState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    153          RangeRxStates_t            rangeRxState;
   \                     rangeRxState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    154          EditRegsStates_t    eRState; 
   \                     eRState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    155          ODRStates_t         oDRState;
   \                     oDRState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    156          OIRStates_t         oIRState;
   \                     oIRState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    157          RDRStates_t         rDRState;
   \                     rDRState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    158          RIRStates_t         rIRState;
   \                     rIRState:
   \   00000000                      DS8 1
    159          

   \                                 In section .bss, align 4
    160          int     PIT_ITTERATIONS;
   \                     PIT_ITTERATIONS:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    161          int     AXIS ;
   \                     AXIS:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    162          uint32_t  TempSumx ;
   \                     TempSumx:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    163          uint32_t  TempSumy ;
   \                     TempSumy:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    164          uint32_t  TempSumz ;
   \                     TempSumz:
   \   00000000                      DS8 4
    165          
    166          

   \                                 In section .bss, align 4
    167          uint8_t au8ScanResults[16];
   \                     au8ScanResults:
   \   00000000                      DS8 16
    168          

   \                                 In section .bss, align 1
    169          txTests_t txTestIndex;
   \                     txTestIndex:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    170          RxTests_t rxTestIndex;
   \                     rxTestIndex:
   \   00000000                      DS8 1

   \                                 In section .bss, align 2
    171          uint16_t sentPackets;
   \                     sentPackets:
   \   00000000                      DS8 2
    172          #define MMCAU_TEST  FALSE    
    173          
    174          #if TRUE == MMCAU_TEST
    175            #define AES192                    192
    176            unsigned char key_expansion[60*4];
    177            /*24 bytes key: "UltraMegaSecretPassword1"*/
    178            unsigned char   key192[AES192/8] = { 0x55, 0x6c, 0x74, 0x72, 0x61, 0x4d, 0x65, 0x67, 
    179                                                 0x61, 0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x50, 
    180          	                               0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x31 };
    181          #endif
    182          
    183          
    184          /************************************************************************************
    185          *************************************************************************************
    186          * Main application functions
    187          *************************************************************************************
    188          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    189          void main(void)
    190          {
   \                     main: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
    191            int XDiff;
    192            int YDiff;
    193            int ZDiff;
    194            
    195            int threshHold = 120;
   \   00000006   0x2778             MOVS     R7,#+120
    196            sensorID=6543; 
   \   00000008   0xF641 0x108F      MOVW     R0,#+6543
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable15
   \   00000010   0x8008             STRH     R0,[R1, #+0]
    197            TempSumx = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable15_1
   \   00000018   0x6008             STR      R0,[R1, #+0]
    198            TempSumy = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable15_2
   \   00000020   0x6008             STR      R0,[R1, #+0]
    199            TempSumz = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000028   0x6008             STR      R0,[R1, #+0]
    200            AXIS = 0; 
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   00000030   0x6008             STR      R0,[R1, #+0]
    201            PIT_ITTERATIONS =0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable15_5
   \   00000038   0x6008             STR      R0,[R1, #+0]
    202            
    203            InitProject(); 
   \   0000003A   0x.... 0x....      BL       InitProject
    204            /* SMAC Initialization */
    205            InitSmac(); 
   \   0000003E   0x.... 0x....      BL       InitSmac
    206            
    207            //initalize the accelerometter
    208            InitAccelControlls();
   \   00000042   0x.... 0x....      BL       InitAccelControlls
    209            ADCInit();
   \   00000046   0x.... 0x....      BL       ADCInit
    210            
    211           //right now this should be equal to a pit running every .000125 seconds so it will run 8000 itterations in 1 second
    212            INIT_PIT((uint32_t) 5999);        //((50,000,000)/(1/TIME)) -1 = TimeForInitFucntion Here Time is equal to  intot initthis can be changed for different sample times if the number is increased the sample time is increased
   \   0000004A   0xF241 0x706F      MOVW     R0,#+5999
   \   0000004E   0x.... 0x....      BL       INIT_PIT
    213            /*this time is for 8000Hz */
    214            
    215            //blink the leds
    216            RedStatLedOn();
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable15_6  ;; 0x400ff0c8
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable15_6  ;; 0x400ff0c8
   \   00000060   0x6008             STR      R0,[R1, #+0]
    217            GreenStatLedOn();
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable15_6  ;; 0x400ff0c8
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable15_6  ;; 0x400ff0c8
   \   00000070   0x6008             STR      R0,[R1, #+0]
    218            
    219          #if defined(gCDCInterface_d)    //Wait for user to open the VirtualCom
    220            while(!Comm_Open());
    221          #endif
    222            /*Prints the Welcome screens in the COMM*/  
    223            //PrintMenu(cu8FreescaleLogo, gDefaultCommPort_c);
    224            
    225            #if TRUE == MMCAU_TEST
    226             cau_aes_set_key(key192, AES192, key_expansion);
    227            #endif
    228            
    229            /*Waits until de user selects press Enter*/    
    230           // while(!(evDataFromCOMM && ('\r' == gu8CommData))); 
    231            connState = gConnIdleState_c; 
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable15_7
   \   00000078   0x7008             STRB     R0,[R1, #+0]
    232            int32_t cin[30];
    233            int in;
    234            
    235            gSnd.channel=gChannel11_c;
   \   0000007A   0x200B             MOVS     R0,#+11
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000080   0xF881 0x0043      STRB     R0,[R1, #+67]
    236            uint16_t flashCount=0;
   \   00000084   0xF05F 0x0800      MOVS     R8,#+0
    237            (void)MLMESetChannelRequest(gSnd.channel);
                                               ^
Warning[Pe188]: enumerated type mixed with another type
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000008C   0xF890 0x0043      LDRB     R0,[R0, #+67]
   \   00000090   0x.... 0x....      BL       MLMESetChannelRequest
   \   00000094   0x4681             MOV      R9,R0
    238            (void)MLMEPAOutputAdjust(gMaxOutputPower_c);
   \   00000096   0x201F             MOVS     R0,#+31
   \   00000098   0x.... 0x....      BL       MLMEPAOutputAdjust
   \   0000009C   0x4682             MOV      R10,R0
    239            (void)MLMEXtalAdjust(testTrimmValue);
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable15_8
   \   000000A2   0x7800             LDRB     R0,[R0, #+0]
   \   000000A4   0x.... 0x....      BL       MLMEXtalAdjust
   \   000000A8   0x4683             MOV      R11,R0
    240            //MLMESetPromiscuousMode(TRUE);
    241            sentPackets=0;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable15_9
   \   000000B0   0x8008             STRH     R0,[R1, #+0]
    242          
    243            (void)ChooseBestChannel();
   \   000000B2   0x.... 0x....      BL       ChooseBestChannel
    244            appState=TRANSMIT_MODE;
   \   000000B6   0x2100             MOVS     R1,#+0
   \   000000B8   0x.... 0x....      LDR.W    R2,??DataTable15_10
   \   000000BC   0x7011             STRB     R1,[R2, #+0]
    245            
    246              RedStatLedOff();
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable15_11  ;; 0x400ff0c4
   \   000000C2   0x6809             LDR      R1,[R1, #+0]
   \   000000C4   0xF051 0x0110      ORRS     R1,R1,#0x10
   \   000000C8   0x.... 0x....      LDR.W    R2,??DataTable15_11  ;; 0x400ff0c4
   \   000000CC   0x6011             STR      R1,[R2, #+0]
    247            GreenStatLedOff();
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable15_11  ;; 0x400ff0c4
   \   000000D2   0x6809             LDR      R1,[R1, #+0]
   \   000000D4   0xF051 0x0108      ORRS     R1,R1,#0x8
   \   000000D8   0x.... 0x....      LDR.W    R2,??DataTable15_11  ;; 0x400ff0c4
   \   000000DC   0x6011             STR      R1,[R2, #+0]
    248            
    249            PIT_ITTERATIONS =0;
   \   000000DE   0x2100             MOVS     R1,#+0
   \   000000E0   0x.... 0x....      LDR.W    R2,??DataTable15_5
   \   000000E4   0x6011             STR      R1,[R2, #+0]
    250            
    251            AccellEnableOn();
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable15_11  ;; 0x400ff0c4
   \   000000EA   0x6809             LDR      R1,[R1, #+0]
   \   000000EC   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   000000F0   0x.... 0x....      LDR.W    R2,??DataTable15_11  ;; 0x400ff0c4
   \   000000F4   0x6011             STR      R1,[R2, #+0]
    252            AccellPowerOn();
   \   000000F6   0x.... 0x....      LDR.W    R1,??DataTable15_11  ;; 0x400ff0c4
   \   000000FA   0x6809             LDR      R1,[R1, #+0]
   \   000000FC   0xF051 0x0120      ORRS     R1,R1,#0x20
   \   00000100   0x.... 0x....      LDR.W    R2,??DataTable15_11  ;; 0x400ff0c4
   \   00000104   0x6011             STR      R1,[R2, #+0]
    253            
    254            
    255            
    256            for(;;){
    257              
    258             TempSumx = 0;
   \                     ??main_0: (+1)
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0x.... 0x....      LDR.W    R1,??DataTable15_1
   \   0000010C   0x6008             STR      R0,[R1, #+0]
    259             TempSumy = 0;
   \   0000010E   0x2000             MOVS     R0,#+0
   \   00000110   0x.... 0x....      LDR.W    R1,??DataTable15_2
   \   00000114   0x6008             STR      R0,[R1, #+0]
    260             TempSumz = 0;
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   0000011C   0x6008             STR      R0,[R1, #+0]
    261             gSnd.xmax =0;
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000124   0x8148             STRH     R0,[R1, #+10]
    262             gSnd.ymax =0;
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000012C   0x8348             STRH     R0,[R1, #+26]
    263             gSnd.zmax =0;
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000134   0x8548             STRH     R0,[R1, #+42]
    264             gSnd.xmin = 4000;
   \   00000136   0xF44F 0x607A      MOV      R0,#+4000
   \   0000013A   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000013E   0x8108             STRH     R0,[R1, #+8]
    265             gSnd.ymin = 4000;
   \   00000140   0xF44F 0x607A      MOV      R0,#+4000
   \   00000144   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000148   0x8308             STRH     R0,[R1, #+24]
    266             gSnd.zmin = 4000;
   \   0000014A   0xF44F 0x607A      MOV      R0,#+4000
   \   0000014E   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000152   0x8508             STRH     R0,[R1, #+40]
    267              
    268              
    269              uint16_t sleepTime = 1000*gOptions.u16SleepAfterAck;
   \   00000154   0x.... 0x....      LDR.W    R0,??DataTable15_12
   \   00000158   0x8AC0             LDRH     R0,[R0, #+22]
   \   0000015A   0xF44F 0x717A      MOV      R1,#+1000
   \   0000015E   0xFB10 0xF901      SMULBB   R9,R0,R1
    270              
    271               
    272               // Prepare the usual stats SND packet
    273               // get temp and vibration data, put in packet
    274               GetDeviceData();
   \   00000162   0x.... 0x....      BL       GetDeviceData
    275              
    276              
    277              //delayMs(3000);
    278              XDiff = gSnd.xmax - gSnd.xmin;
   \   00000166   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000016A   0x8940             LDRH     R0,[R0, #+10]
   \   0000016C   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000170   0x8909             LDRH     R1,[R1, #+8]
   \   00000172   0x1A40             SUBS     R0,R0,R1
   \   00000174   0x0004             MOVS     R4,R0
    279              YDiff = gSnd.ymax - gSnd.ymin;
   \   00000176   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000017A   0x8B40             LDRH     R0,[R0, #+26]
   \   0000017C   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000180   0x8B09             LDRH     R1,[R1, #+24]
   \   00000182   0x1A40             SUBS     R0,R0,R1
   \   00000184   0x0005             MOVS     R5,R0
    280              ZDiff = gSnd.zmax - gSnd.zmin;
   \   00000186   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000018A   0x8D40             LDRH     R0,[R0, #+42]
   \   0000018C   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000190   0x8D09             LDRH     R1,[R1, #+40]
   \   00000192   0x1A40             SUBS     R0,R0,R1
   \   00000194   0x0006             MOVS     R6,R0
    281              
    282              
    283              if( (XDiff > threshHold || XDiff < -threshHold) || (YDiff > threshHold || YDiff < -threshHold) || (ZDiff > threshHold || ZDiff < -threshHold))
   \   00000196   0x42A7             CMP      R7,R4
   \   00000198   0xDB09             BLT.N    ??main_1
   \   0000019A   0x42FC             CMN      R4,R7
   \   0000019C   0xDB07             BLT.N    ??main_1
   \   0000019E   0x42AF             CMP      R7,R5
   \   000001A0   0xDB05             BLT.N    ??main_1
   \   000001A2   0x42FD             CMN      R5,R7
   \   000001A4   0xDB03             BLT.N    ??main_1
   \   000001A6   0x42B7             CMP      R7,R6
   \   000001A8   0xDB01             BLT.N    ??main_1
   \   000001AA   0x42FE             CMN      R6,R7
   \   000001AC   0xDA43             BGE.N    ??main_2
    284              {
    285                sentPackets++;
   \                     ??main_1: (+1)
   \   000001AE   0x.... 0x....      LDR.W    R0,??DataTable15_9
   \   000001B2   0x8800             LDRH     R0,[R0, #+0]
   \   000001B4   0x1C40             ADDS     R0,R0,#+1
   \   000001B6   0x.... 0x....      LDR.W    R1,??DataTable15_9
   \   000001BA   0x8008             STRH     R0,[R1, #+0]
    286                flashCount=0;
   \   000001BC   0x2000             MOVS     R0,#+0
   \   000001BE   0x4680             MOV      R8,R0
    287                //LED_SetLed(LED2, gLedOn_c);
    288                
    289                smacErrors_t status=SendBinaryPacket();
   \   000001C0   0x.... 0x....      BL       SendBinaryPacket
   \   000001C4   0x4682             MOV      R10,R0
    290                if(status==gErrorNoError_c){
   \   000001C6   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001CA   0xF1BA 0x0F00      CMP      R10,#+0
   \   000001CE   0xD101             BNE.N    ??main_3
    291                  ReceivePacket();
   \   000001D0   0x.... 0x....      BL       ReceivePacket
    292                }
    293                while(--flashCount);
   \                     ??main_3: (+1)
   \   000001D4   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   000001D8   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000001DC   0xF1B8 0x0F00      CMP      R8,#+0
   \   000001E0   0xD1F8             BNE.N    ??main_3
    294                
    295                evDataFromCOMM=FALSE;
   \   000001E2   0x2000             MOVS     R0,#+0
   \   000001E4   0x.... 0x....      LDR.W    R1,??DataTable15_13
   \   000001E8   0x7008             STRB     R0,[R1, #+0]
    296                //PrintPacketID(sentPackets);
    297                tOptions pOptions;
    298                if(appState==RECEIVE_FINISHED && gIsAck) {
   \   000001EA   0x.... 0x....      LDR.W    R0,??DataTable15_10
   \   000001EE   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   000001F2   0x2802             CMP      R0,#+2
   \   000001F4   0xD11F             BNE.N    ??main_2
   \   000001F6   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   000001FA   0x7800             LDRB     R0,[R0, #+0]
   \   000001FC   0x2800             CMP      R0,#+0
   \   000001FE   0xD01A             BEQ.N    ??main_2
    299                  if(gAppRxPacket->u8DataLength>ACK_HEADER_SIZE){
   \   00000200   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000204   0x6800             LDR      R0,[R0, #+0]
   \   00000206   0x7880             LDRB     R0,[R0, #+2]
   \   00000208   0x2806             CMP      R0,#+6
   \   0000020A   0xDB14             BLT.N    ??main_2
    300                    if(gAppRxPacket->u8DataLength==ACK_OPT_SIZE){
   \   0000020C   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000210   0x6800             LDR      R0,[R0, #+0]
   \   00000212   0x7880             LDRB     R0,[R0, #+2]
   \   00000214   0x2818             CMP      R0,#+24
   \   00000216   0xD10B             BNE.N    ??main_4
    301                      CopyOptionsFromRecvPacket(&pOptions);
   \   00000218   0xA800             ADD      R0,SP,#+0
   \   0000021A   0x.... 0x....      BL       CopyOptionsFromRecvPacket
    302                      
    303                      OptSwapEndianness(&pOptions);
   \   0000021E   0xA800             ADD      R0,SP,#+0
   \   00000220   0x.... 0x....      BL       OptSwapEndianness
    304                      if (!ValidateOptions(&pOptions)) continue;
   \   00000224   0xA800             ADD      R0,SP,#+0
   \   00000226   0x.... 0x....      BL       ValidateOptions
   \   0000022A   0x2800             CMP      R0,#+0
   \   0000022C   0xD103             BNE.N    ??main_2
   \   0000022E   0xE76A             B.N      ??main_0
    305                    }
    306                    else {
    307                      GetFactoryOptions(&pOptions);
   \                     ??main_4: (+1)
   \   00000230   0xA800             ADD      R0,SP,#+0
   \   00000232   0x.... 0x....      BL       GetFactoryOptions
    308                    }
    309                    //ChangeOptions(&pOptions);
    310                  }
    311                  
    312                }
    313              }
    314              /*this needs to be here to reset the packet ID every time*/
    315              InitPacket(); 
   \                     ??main_2: (+1)
   \   00000236   0x.... 0x....      BL       InitPacket
   \   0000023A   0xE764             B.N      ??main_0
    316              
    317            }/* For(;;)*/
    318            
    319          }/*Main*/

   \                                 In section .text, align 2, keep-with-next
    320          int ValidateOptions(tOptions *pOptions){
   \                     ValidateOptions: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    321            if((pOptions->u8RawSpinCount!=0) && (pOptions->u8RawSpinCount > 64 || pOptions->u8RawSpinCount < 5)) return 0;   // updated *** 06/08/11 *** (formerly "u8Reserved1")
   \   00000002   0x7808             LDRB     R0,[R1, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD007             BEQ.N    ??ValidateOptions_0
   \   00000008   0x7808             LDRB     R0,[R1, #+0]
   \   0000000A   0x2841             CMP      R0,#+65
   \   0000000C   0xDA02             BGE.N    ??ValidateOptions_1
   \   0000000E   0x7808             LDRB     R0,[R1, #+0]
   \   00000010   0x2805             CMP      R0,#+5
   \   00000012   0xDA01             BGE.N    ??ValidateOptions_0
   \                     ??ValidateOptions_1: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE03B             B.N      ??ValidateOptions_2
    322            if(pOptions->u16TimeoutsToKill > 3600 || pOptions->u16TimeoutsToKill < 1) return 0;
   \                     ??ValidateOptions_0: (+1)
   \   00000018   0x8848             LDRH     R0,[R1, #+2]
   \   0000001A   0xF5B0 0x6F61      CMP      R0,#+3600
   \   0000001E   0xDC02             BGT.N    ??ValidateOptions_3
   \   00000020   0x8848             LDRH     R0,[R1, #+2]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD101             BNE.N    ??ValidateOptions_4
   \                     ??ValidateOptions_3: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE032             B.N      ??ValidateOptions_2
    323            if(pOptions->u16SampleSize != ACCEL_SAMPLE_SIZE) return 0;
   \                     ??ValidateOptions_4: (+1)
   \   0000002A   0x8888             LDRH     R0,[R1, #+4]
   \   0000002C   0xF5B0 0x5FFA      CMP      R0,#+8000
   \   00000030   0xD001             BEQ.N    ??ValidateOptions_5
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xE02C             B.N      ??ValidateOptions_2
    324            if(pOptions->bAsciiMode > 1) return 0;
   \                     ??ValidateOptions_5: (+1)
   \   00000036   0x7988             LDRB     R0,[R1, #+6]
   \   00000038   0x2802             CMP      R0,#+2
   \   0000003A   0xDB01             BLT.N    ??ValidateOptions_6
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE027             B.N      ??ValidateOptions_2
    325            if(pOptions->bBlinkingLEDs > 1) return 0;
   \                     ??ValidateOptions_6: (+1)
   \   00000040   0x79C8             LDRB     R0,[R1, #+7]
   \   00000042   0x2802             CMP      R0,#+2
   \   00000044   0xDB01             BLT.N    ??ValidateOptions_7
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xE022             B.N      ??ValidateOptions_2
    326            if(pOptions->u8OutputPower != OUTPUT_POWER) return 0;
   \                     ??ValidateOptions_7: (+1)
   \   0000004A   0x7A08             LDRB     R0,[R1, #+8]
   \   0000004C   0x2864             CMP      R0,#+100
   \   0000004E   0xD001             BEQ.N    ??ValidateOptions_8
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xE01D             B.N      ??ValidateOptions_2
    327            if(pOptions->u32PngTimeout != PNG_TIMEOUT) return 0;
   \                     ??ValidateOptions_8: (+1)
   \   00000054   0x68C8             LDR      R0,[R1, #+12]
   \   00000056   0xF248 0x02E8      MOVW     R2,#+33000
   \   0000005A   0x4290             CMP      R0,R2
   \   0000005C   0xD001             BEQ.N    ??ValidateOptions_9
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xE016             B.N      ??ValidateOptions_2
    328            if(pOptions->u32SndTimeout != SND_TIMEOUT) return 0;
   \                     ??ValidateOptions_9: (+1)
   \   00000062   0x6908             LDR      R0,[R1, #+16]
   \   00000064   0x.... 0x....      LDR.W    R2,??DataTable18  ;; 0x28488
   \   00000068   0x4290             CMP      R0,R2
   \   0000006A   0xD001             BEQ.N    ??ValidateOptions_10
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xE00F             B.N      ??ValidateOptions_2
    329            if(pOptions->bLNAHighGainMode != 1) return 0; // i.e. Low Noise Amplifier - updated *** 10/26/10 *** (formerly "u8Reserved2")
   \                     ??ValidateOptions_10: (+1)
   \   00000070   0x7D08             LDRB     R0,[R1, #+20]
   \   00000072   0x2801             CMP      R0,#+1
   \   00000074   0xD001             BEQ.N    ??ValidateOptions_11
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xE00A             B.N      ??ValidateOptions_2
    330            if(pOptions->u16SleepAfterAck > 3000|| pOptions->u16SleepAfterAck < 3) return 0;
   \                     ??ValidateOptions_11: (+1)
   \   0000007A   0x8AC8             LDRH     R0,[R1, #+22]
   \   0000007C   0xF640 0x32B9      MOVW     R2,#+3001
   \   00000080   0x4290             CMP      R0,R2
   \   00000082   0xDA02             BGE.N    ??ValidateOptions_12
   \   00000084   0x8AC8             LDRH     R0,[R1, #+22]
   \   00000086   0x2803             CMP      R0,#+3
   \   00000088   0xDA01             BGE.N    ??ValidateOptions_13
   \                     ??ValidateOptions_12: (+1)
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xE000             B.N      ??ValidateOptions_2
    331            return 1;
   \                     ??ValidateOptions_13: (+1)
   \   0000008E   0x2001             MOVS     R0,#+1
   \                     ??ValidateOptions_2: (+1)
   \   00000090   0x4770             BX       LR               ;; return
    332          }/*ValidateOptions*/
    333          

   \                                 In section .text, align 2, keep-with-next
    334          void ChangeOptions(tOptions* pOptions)
    335          {
   \                     ChangeOptions: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    336              
    337            // Are the new options different from the old/current options?
    338            if (memcmp(pOptions, &gOptions, sizeof(tOptions)) != 0)
   \   00000004   0x2218             MOVS     R2,#+24
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable15_12
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       memcmp
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD00D             BEQ.N    ??ChangeOptions_0
    339              {
    340          //        TRACE("\r\nConfiguration OPTIONS will be changed\r\n");
    341                  
    342                  // Save the new options
    343                  gOptions = *pOptions;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable15_12
   \   00000018   0x0021             MOVS     R1,R4
   \   0000001A   0x2218             MOVS     R2,#+24
   \   0000001C   0x.... 0x....      BL       __aeabi_memcpy4
    344                  
    345                  // Save new options to FLASH memory
    346                  FlashSaveOptions();
   \   00000020   0x.... 0x....      BL       FlashSaveOptions
    347                  
    348                  // Make sure all of the options changes will be in effect
    349          //        RadioInitNew(); // added *** 10/27/10 ***
    350          //        (void)MLMEMC13192PAOutputAdjust(gOptions.u8OutputPower);
    351                  gRxTimeout = gOptions.u32SndTimeout;    // usual timeout value, i.e., timeout for SND packets
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable15_12
   \   00000028   0x6900             LDR      R0,[R0, #+16]
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    352                  
    353                  // Updated *** 06/20/11 ***
    354                  // Whenever options change, flush the sending of raw data packets
    355           /*
    356                  gRawSnd.rawSpinCount = gOptions.u8RawSpinCount;
    357                  gRawSnd.axis = 3;     // Note: 1 = X-axis, 2 = Y-axis, 3 = Z-axis
    358                  gRawSnd.blockNo = 16; // Note: raw data is sent in blocks numbered 1 thru 16 (0 means not ready)
    359          */        
    360              }
    361              
    362              // Inform pan coordinator of our new configuration options
    363              SendCurrentOptions();
   \                     ??ChangeOptions_0: (+1)
   \   00000030   0x.... 0x....      BL       SendCurrentOptions
    364          
    365              return;
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    366          }//ChangeOptions
    367          

   \                                 In section .text, align 2, keep-with-next
    368          smacErrors_t SendCurrentOptions(){
   \                     SendCurrentOptions: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    369              
    370              gOpt.options = gOptions;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable15_12
   \   0000000A   0x2218             MOVS     R2,#+24
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy4
    371              OptSwapEndianness(&gOpt.options);
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   00000014   0x.... 0x....      BL       OptSwapEndianness
    372              gOpt.hdr.u16SensorID = gOpt.hdr.u16SensorID << 8 | gOpt.hdr.u16SensorID>>8;
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   0000001C   0x8880             LDRH     R0,[R0, #+4]
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable18_1
   \   00000022   0x8889             LDRH     R1,[R1, #+4]
   \   00000024   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000026   0x0A09             LSRS     R1,R1,#+8
   \   00000028   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable18_1
   \   00000030   0x8088             STRH     R0,[R1, #+4]
    373              
    374              CopyOptPacketToSMAC();
   \   00000032   0x.... 0x....      BL       CopyOptPacketToSMAC
    375              // Get ready to send the configuration options SND packet
    376           //   gAppTxPacket->u8DataLength = sizeof(gOpt);
    377          //    gAppTxPacket->smacPdu.u8Data = (uint8_t*)&gOpt;
    378              return MCPSDataRequest(gAppTxPacket); // transmit data
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x.... 0x....      BL       MCPSDataRequest
   \   00000040   0xBD02             POP      {R1,PC}          ;; return
    379              
    380              // Note: even though the pan coordinator may acknowledge this message,
    381              // we don't need to wait for it, because the sensor data SND messages
    382              // are sent much more frequently, so we'll ignore any ACK here.
    383            
    384              
    385          }//SendCurrentOptions
    386          
    387          
    388          
    389          

   \                                 In section .text, align 2, keep-with-next
    390          void InitAccelControlls(){
    391           /*
    392          Initilizes the GPIO's that controll the  power in the Accelerommeter.
    393          This initilizes PTD1 and PTD 5 as GPIO's with output functionality and active low performance.
    394          */
    395                  //enable the clock gating to the module.
    396                  gLED_ClkGatingReg_c |= gLED_ClkGatingBit_c; 
   \                     InitAccelControlls: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x40048038
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable16_3  ;; 0x40048038
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    397                  //enable the conenctions, and enable the clock to the PTD output
    398                  gAccelEnableControlReg_c &= ~PORT_PCR_MUX_MASK;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x4004c004
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF430 0x60E0      BICS     R0,R0,#0x700
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable16_4  ;; 0x4004c004
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    399                  gAccelEnableControlReg_c |= PORT_PCR_MUX(gLED_PinCtrlAltFunc_c);
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x4004c004
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable16_4  ;; 0x4004c004
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    400                  gAccelPowerControlReg_c &= ~PORT_PCR_MUX_MASK;
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable16_5  ;; 0x4004c014
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0xF430 0x60E0      BICS     R0,R0,#0x700
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable16_5  ;; 0x4004c014
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    401                  gAccelPowerControlReg_c |= PORT_PCR_MUX(gLED_PinCtrlAltFunc_c);
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable16_5  ;; 0x4004c014
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable16_5  ;; 0x4004c014
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    402                  
    403                  
    404                  /*Pins direction -> output */
    405                  gLED_PortDataDirReg_c |= (gAccelPower | gAccelEnable);
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable16_6  ;; 0x400ff0d4
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0xF050 0x0022      ORRS     R0,R0,#0x22
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable16_6  ;; 0x400ff0d4
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    406                  /*turn off all outputs */
    407                  gLED_PortDataOutReg_c |= (gAccelPower | gAccelEnable);
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable19_2  ;; 0x400ff0c0
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0xF050 0x0022      ORRS     R0,R0,#0x22
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable19_2  ;; 0x400ff0c0
   \   0000006E   0x6008             STR      R0,[R1, #+0]
    408            
    409          }/*void InitAccelControlls()*/
   \   00000070   0x4770             BX       LR               ;; return
    410          
    411          

   \                                 In section .text, align 2, keep-with-next
    412          void GetDeviceData()
    413          {
   \                     GetDeviceData: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    414            
    415            int TempTempVal =0;
   \   00000002   0x2400             MOVS     R4,#+0
    416            int TempBat =0;
   \   00000004   0x2500             MOVS     R5,#+0
    417            //filteringCode  =0;
    418            
    419              /*for the regular data smapling we might want to make the change so that it will sample at the rate in gOptions.sampleRate
    420                the filtering code below needs to run at 20Khz at all times though that will not change*/
    421            
    422              AXIS =1 ;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    423             /*first want to get the max average and other values at 8KHz and then teansition into 20KHz*/
    424              INIT_PIT((uint32_t) 5999);        /*this is the 8K Hz*/
   \   0000000E   0xF241 0x706F      MOVW     R0,#+5999
   \   00000012   0x.... 0x....      BL       INIT_PIT
    425              NVIC_EnableIRQ(48);
   \   00000016   0x2030             MOVS     R0,#+48
   \   00000018   0x.... 0x....      BL       NVIC_EnableIRQ
    426              
    427              
    428              AXIS = 1;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   00000022   0x6008             STR      R0,[R1, #+0]
    429              PIT_ITTERATIONS =0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable15_5
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    430              
    431              while(PIT_ITTERATIONS < ACCEL_SAMPLE_SIZE)
   \                     ??GetDeviceData_0: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable15_5
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF5B0 0x5FFA      CMP      R0,#+8000
   \   00000036   0xDBF9             BLT.N    ??GetDeviceData_0
    432              {
    433                // X Y and Z to complete wait for the conversions to finish before continuing
    434              }
    435              AXIS =0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    436              gSnd.xmean = (uint16_t)((TempSumx + (ACCEL_SAMPLE_SIZE >>1))/ ACCEL_SAMPLE_SIZE);
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF510 0x607A      ADDS     R0,R0,#+4000
   \   0000004A   0xF44F 0x51FA      MOV      R1,#+8000
   \   0000004E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000056   0x8188             STRH     R0,[R1, #+12]
    437              
    438              
    439              gSnd.ymean = (uint16_t)((TempSumy + (ACCEL_SAMPLE_SIZE >>1))/ ACCEL_SAMPLE_SIZE);
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0xF510 0x607A      ADDS     R0,R0,#+4000
   \   00000062   0xF44F 0x51FA      MOV      R1,#+8000
   \   00000066   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000006E   0x8388             STRH     R0,[R1, #+28]
    440              
    441              
    442              gSnd.zmean = (uint16_t)((TempSumz + (ACCEL_SAMPLE_SIZE >>1))/ ACCEL_SAMPLE_SIZE);
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0xF510 0x607A      ADDS     R0,R0,#+4000
   \   0000007A   0xF44F 0x51FA      MOV      R1,#+8000
   \   0000007E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000086   0x8588             STRH     R0,[R1, #+44]
    443              
    444             /*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    445              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    446              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    447              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    448              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    449              *
    450              *This is where the filtering code needs to be enetered when we want to implement filtering again.
    451              *
    452              *
    453              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    454              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    455              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    456              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    457              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    458              *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    459              */
    460              
    461              /*stop the timer and finish the temp and battery conversion and then send the data that was packed*/
    462              NVIC_DisableIRQ(48);
   \   00000088   0x2030             MOVS     R0,#+48
   \   0000008A   0x.... 0x....      BL       NVIC_DisableIRQ
    463                
    464                
    465              
    466              StartTempConversion();
   \   0000008E   0x.... 0x....      BL       StartTempConversion
    467              
    468              while(ConversionAComplete()==0){
   \                     ??GetDeviceData_1: (+1)
   \   00000092   0x.... 0x....      BL       ConversionAComplete
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD0FB             BEQ.N    ??GetDeviceData_1
    469              }
    470              TempTempVal = GetConversionValue();
   \   0000009A   0x.... 0x....      BL       GetConversionValue
   \   0000009E   0x0004             MOVS     R4,R0
    471              gSnd.temperature = 373 - (int16_t)((uint32_t)(TempTempVal) * 37800/84909)  ;
   \   000000A0   0xF240 0x1075      MOVW     R0,#+373
   \   000000A4   0xF249 0x31A8      MOVW     R1,#+37800
   \   000000A8   0xFB01 0xF104      MUL      R1,R1,R4
   \   000000AC   0x.... 0x....      LDR.W    R2,??DataTable17_1  ;; 0x14bad
   \   000000B0   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   000000B4   0x1A40             SUBS     R0,R0,R1
   \   000000B6   0x.... 0x....      LDR.W    R1,??DataTable16
   \   000000BA   0x8708             STRH     R0,[R1, #+56]
    472              
    473              /*now that the conversions are finished measure the voltage over the battery using adc 7 */
    474              StartBattConversion();
   \   000000BC   0x.... 0x....      BL       StartBattConversion
    475              while(ConversionAComplete()==0){
   \                     ??GetDeviceData_2: (+1)
   \   000000C0   0x.... 0x....      BL       ConversionAComplete
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD0FB             BEQ.N    ??GetDeviceData_2
    476              }
    477              TempBat = GetConversionValue();
   \   000000C8   0x.... 0x....      BL       GetConversionValue
   \   000000CC   0x0005             MOVS     R5,R0
    478              gSnd.battery_mV = (uint16_t)((uint32_t)(TempBat) * 4200 / 1023);
   \   000000CE   0xF241 0x0068      MOVW     R0,#+4200
   \   000000D2   0xFB00 0xF005      MUL      R0,R0,R5
   \   000000D6   0xF240 0x31FF      MOVW     R1,#+1023
   \   000000DA   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable16
   \   000000E2   0x8748             STRH     R0,[R1, #+58]
    479          
    480              
    481              
    482              
    483          }/*void GetDeviceData()*/
   \   000000E4   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    484          
    485          /*
    486          
    487          inits the pit timmer
    488          */

   \                                 In section .text, align 2, keep-with-next
    489          void INIT_PIT(uint32_t SampleSpeed)
    490          {
   \                     INIT_PIT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    491            NVIC_DisableIRQ(48);
   \   00000004   0x2030             MOVS     R0,#+48
   \   00000006   0x.... 0x....      BL       NVIC_DisableIRQ
    492            
    493            //set bit 24 in scgc6
    494            SIM_SCGC6 |= (uint32_t)(1<<23);
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable17_2  ;; 0x4004803c
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF450 0x0000      ORRS     R0,R0,#0x800000
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable17_2  ;; 0x4004803c
   \   00000018   0x6008             STR      R0,[R1, #+0]
    495            
    496            
    497            PIT_MCR = (uint32_t)0x1;                  //enable the freexe bit and enable the clock for standard pit timer
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable17_3  ;; 0x40037000
   \   00000020   0x6008             STR      R0,[R1, #+0]
    498            PIT_LDVAL0 = SampleSpeed;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable17_4  ;; 0x40037100
   \   00000026   0x6004             STR      R4,[R0, #+0]
    499            PIT_TCTRL0 = (uint32_t)0x3;                   //enable the timer and inable the timer interupt diable the cahin mode
   \   00000028   0x2003             MOVS     R0,#+3
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable18_2  ;; 0x40037108
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    500            
    501            
    502            
    503            PIT_TFLG0  = (uint32_t)0x1;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable22  ;; 0x4003710c
   \   00000036   0x6008             STR      R0,[R1, #+0]
    504            NVIC_SetPriority(48, 0);
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x2030             MOVS     R0,#+48
   \   0000003C   0x.... 0x....      BL       NVIC_SetPriority
    505            NVIC_EnableIRQ(48);
   \   00000040   0x2030             MOVS     R0,#+48
   \   00000042   0x.... 0x....      BL       NVIC_EnableIRQ
    506          }
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
    507          
    508          
    509          
    510          /*This is the Pit ISR, It will take samples of the ADC 8000 times in 1 second these two values will eventually 
    511          be modifiable using vibe.
    512          
    513          There will be a Golbal boolean that needs to be set when the value is at 8000 itterations, it needs to be reset when the program starts up
    514          
    515          */
    516          

   \                                 In section .text, align 2, keep-with-next
    517          void PIT_ISR()
    518          {
   \                     PIT_ISR: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    519            int TempXVal =0;
   \   00000002   0x2400             MOVS     R4,#+0
    520            int TempYVal =0;
   \   00000004   0x2500             MOVS     R5,#+0
    521            int TempZVal =0;  
   \   00000006   0x2600             MOVS     R6,#+0
    522            
    523            
    524            /*GreenStatLedOn();*/
    525          
    526          /*this is just set to do the 8 k samples it will not run the filtering code.
    527            */
    528            
    529                  /*need to take the sampling at 8KHz and find the min and max values here*/
    530                  /*need take 10,000 samples for the x conversion and save the raw values into the q15_t temp value thing */
    531                if(PIT_ITTERATIONS <= ACCEL_SAMPLE_SIZE && AXIS==1)
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable15_5
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF5B0 0x5FFA      CMP      R0,#+8000
   \   00000012   0xDC6B             BGT.N    ??PIT_ISR_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable15_4
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD166             BNE.N    ??PIT_ISR_0
    532                {
    533                //take the converstion values forom the a to d converter an then increment the number of ittereantion
    534                    StartXConversion();
   \   0000001E   0x.... 0x....      BL       StartXConversion
    535                    while(ConversionAComplete()==0){
   \                     ??PIT_ISR_1: (+1)
   \   00000022   0x.... 0x....      BL       ConversionAComplete
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD0FB             BEQ.N    ??PIT_ISR_1
    536                    }
    537                    TempXVal = GetConversionValue();
   \   0000002A   0x.... 0x....      BL       GetConversionValue
   \   0000002E   0x0004             MOVS     R4,R0
    538                     
    539                    
    540                    if(TempXVal > gSnd.xmax)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000034   0x8940             LDRH     R0,[R0, #+10]
   \   00000036   0x42A0             CMP      R0,R4
   \   00000038   0xDA02             BGE.N    ??PIT_ISR_2
    541                    {
    542                      gSnd.xmax = TempXVal;
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000003E   0x8144             STRH     R4,[R0, #+10]
    543                    }
    544                    if(TempXVal < gSnd.xmin)
   \                     ??PIT_ISR_2: (+1)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000044   0x8900             LDRH     R0,[R0, #+8]
   \   00000046   0x4284             CMP      R4,R0
   \   00000048   0xDA02             BGE.N    ??PIT_ISR_3
    545                    {
    546                      gSnd.xmin = TempXVal;
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000004E   0x8104             STRH     R4,[R0, #+8]
    547                    }
    548                    TempSumx += TempXVal;  
   \                     ??PIT_ISR_3: (+1)
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x1820             ADDS     R0,R4,R0
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable15_1
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    549                
    550                
    551                    StartYConversion();
   \   0000005E   0x.... 0x....      BL       StartYConversion
    552                    while(ConversionAComplete()==0){
   \                     ??PIT_ISR_4: (+1)
   \   00000062   0x.... 0x....      BL       ConversionAComplete
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD0FB             BEQ.N    ??PIT_ISR_4
    553                    }   
    554                    TempYVal = GetConversionValue();
   \   0000006A   0x.... 0x....      BL       GetConversionValue
   \   0000006E   0x0005             MOVS     R5,R0
    555                         
    556                    /*check th eY max and the Y Min */
    557                    if(TempYVal > gSnd.ymax)
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000074   0x8B40             LDRH     R0,[R0, #+26]
   \   00000076   0x42A8             CMP      R0,R5
   \   00000078   0xDA02             BGE.N    ??PIT_ISR_5
    558                    {
    559                      gSnd.ymax = TempYVal;
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000007E   0x8345             STRH     R5,[R0, #+26]
    560                    }
    561                    if(TempYVal < gSnd.ymin)
   \                     ??PIT_ISR_5: (+1)
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000084   0x8B00             LDRH     R0,[R0, #+24]
   \   00000086   0x4285             CMP      R5,R0
   \   00000088   0xDA02             BGE.N    ??PIT_ISR_6
    562                    {
    563                      gSnd.ymin = TempYVal;
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000008E   0x8305             STRH     R5,[R0, #+24]
    564                    }
    565                    TempSumy += TempYVal;
   \                     ??PIT_ISR_6: (+1)
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0x1828             ADDS     R0,R5,R0
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable15_2
   \   0000009C   0x6008             STR      R0,[R1, #+0]
    566                
    567                
    568                    StartZConversion();
   \   0000009E   0x.... 0x....      BL       StartZConversion
    569                    while(ConversionAComplete()==0){
   \                     ??PIT_ISR_7: (+1)
   \   000000A2   0x.... 0x....      BL       ConversionAComplete
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD0FB             BEQ.N    ??PIT_ISR_7
    570                    }
    571                    TempZVal = GetConversionValue();
   \   000000AA   0x.... 0x....      BL       GetConversionValue
   \   000000AE   0x0006             MOVS     R6,R0
    572                    /*Check the Z max and the Z min*/
    573                    if(TempZVal > gSnd.zmax)
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000B4   0x8D40             LDRH     R0,[R0, #+42]
   \   000000B6   0x42B0             CMP      R0,R6
   \   000000B8   0xDA02             BGE.N    ??PIT_ISR_8
    574                    {
    575                      gSnd.zmax = TempZVal;
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000BE   0x8546             STRH     R6,[R0, #+42]
    576                    }
    577                    if(TempZVal < gSnd.zmin)
   \                     ??PIT_ISR_8: (+1)
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000C4   0x8D00             LDRH     R0,[R0, #+40]
   \   000000C6   0x4286             CMP      R6,R0
   \   000000C8   0xDA02             BGE.N    ??PIT_ISR_9
    578                    {
    579                      gSnd.zmin = TempZVal;
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000CE   0x8506             STRH     R6,[R0, #+40]
    580                    }
    581                    TempSumz += TempZVal; 
   \                     ??PIT_ISR_9: (+1)
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0x1830             ADDS     R0,R6,R0
   \   000000D8   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   000000DC   0x6008             STR      R0,[R1, #+0]
    582                
    583                
    584                
    585                
    586                PIT_ITTERATIONS ++;
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable15_5
   \   000000E2   0x6800             LDR      R0,[R0, #+0]
   \   000000E4   0x1C40             ADDS     R0,R0,#+1
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable15_5
   \   000000EA   0x6008             STR      R0,[R1, #+0]
    587                }
    588                  
    589             
    590          
    591          
    592            
    593            /* THIS MIGHT BE AN ISSUE
    594                
    595                !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    596                !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    597                !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    598                !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    599                !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    600                !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    601                !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    602                !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    603               */
    604            
    605            
    606            /*the changing of axis will be handled in the main code. this needs to be done there since I need to calculate other tings there using the filter as well. */
    607            PIT_TFLG0  = (uint32_t)0x1;           //clears the interupt flag and will start a new 
   \                     ??PIT_ISR_0: (+1)
   \   000000EC   0x2001             MOVS     R0,#+1
   \   000000EE   0x.... 0x....      LDR.W    R1,??DataTable22  ;; 0x4003710c
   \   000000F2   0x6008             STR      R0,[R1, #+0]
    608            /*GreenStatLedOff();*/
    609          }
   \   000000F4   0xBD70             POP      {R4-R6,PC}       ;; return
    610          
    611          
    612          //return random number 0-15

   \                                 In section .text, align 2, keep-with-next
    613          uint8_t GetRandomNibble()
    614          {
    615              static uint8_t b=0;
    616              uint8_t* p = (uint8_t*) 0x1fff9200;
   \                     GetRandomNibble: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable19_3  ;; 0x1fff9200
    617             
    618              while (p> (uint8_t*) 0x1fff80f0)
   \                     ??GetRandomNibble_0: (+1)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable19_4  ;; 0x1fff80f1
   \   00000008   0x4281             CMP      R1,R0
   \   0000000A   0xD309             BCC.N    ??GetRandomNibble_1
    619              {
    620                --p;
   \   0000000C   0x1E49             SUBS     R1,R1,#+1
    621                
    622                  b ^= *p;    // xor "b" with next byte of memory
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable23
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x780A             LDRB     R2,[R1, #+0]
   \   00000016   0x4050             EORS     R0,R2,R0
   \   00000018   0x.... 0x....      LDR.W    R2,??DataTable23
   \   0000001C   0x7010             STRB     R0,[R2, #+0]
   \   0000001E   0xE7F1             B.N      ??GetRandomNibble_0
    623              }
    624              return (b >> 4) ^ (b & 15); // return left-nibble xor'ed with right-nibble (4 random bits)
   \                     ??GetRandomNibble_1: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable23
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable23
   \   0000002C   0x7812             LDRB     R2,[R2, #+0]
   \   0000002E   0xF012 0x020F      ANDS     R2,R2,#0xF
   \   00000032   0xEA92 0x1010      EORS     R0,R2,R0, LSR #+4
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x4770             BX       LR               ;; return
    625          }

   \                                 In section .bss, align 1
   \                     ??b:
   \   00000000                      DS8 1

   \                                 In section .text, align 2, keep-with-next
    626          int8_t GetLinkQdBm()
    627          {
   \                     GetLinkQdBm: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    628              // Get link quality (dBm) from last successful RX packet
    629            uint8_t quality;
    630           //   return (int8_t)((-(int16_t)MLMELinkQuality()) >> 1); // Note: "floor", not truncation
    631            MLMELinkQuality(&quality);
   \   00000002   0xA800             ADD      R0,SP,#+0
   \   00000004   0x.... 0x....      BL       MLMELinkQuality
    632            return quality;
   \   00000008   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
    633          }

   \                                 In section .text, align 2, keep-with-next
    634          uint8_t getRandomNumberInRange(uint8_t low,uint8_t high){
    635            if(high <= low) return low;
   \                     getRandomNumberInRange: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD301             BCC.N    ??getRandomNumberInRange_0
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0xE009             B.N      ??getRandomNumberInRange_1
    636            uint32_t random;
    637          //  RNG_GetRandomNo(&random);
    638          //  CR[INTM]=1;
    639            return low + (uint8_t)(random % (high - low + 1));    
                                          ^
Warning[Pe549]: variable "random" is used before its value is set
   \                     ??getRandomNumberInRange_0: (+1)
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x1A09             SUBS     R1,R1,R0
   \   00000012   0x1C49             ADDS     R1,R1,#+1
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0xFBB2 0xF2F1      UDIV     R2,R2,R1
   \   0000001A   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??getRandomNumberInRange_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return
    640          }
    641          

   \                                 In section .text, align 2, keep-with-next
    642          uint8_t ChooseBestChannel()
    643          {
   \                     ChooseBestChannel: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
    644            //RNG_Init();  
    645              uint8_t   channelStatus = INITIAL_VALUE;   // something other than SUCCESS
   \   00000004   0x2400             MOVS     R4,#+0
    646              uint8_t   channel = 0;
   \   00000006   0x2500             MOVS     R5,#+0
    647              uint8_t   iter;
    648              channels_t iChannel;
    649              //
    650              // Updated *** 10/26/10 ***
    651              // Note: all calls now go thru "GetLinkQdBm"
    652              //
    653              int8_t    maxLinkQdBm;
    654              
    655              
    656              // Get ready to send the PNG packet
    657              gAppTxPacket->u8DataLength = PNG_SIZE;
   \   00000008   0x2005             MOVS     R0,#+5
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable19_1
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   \   00000010   0x7008             STRB     R0,[R1, #+0]
    658              PngSwapEndianness();
   \   00000012   0x.... 0x....      BL       PngSwapEndianness
    659              CopyPngPacketToSMAC();
   \   00000016   0x.... 0x....      BL       CopyPngPacketToSMAC
    660              
    661              // Note: we don't want to wait very long between testing each channel,
    662              // so temporarily change the timeout to a low value
    663              gRxTimeout = gOptions.u32PngTimeout;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable15_12
   \   0000001E   0x68C0             LDR      R0,[R0, #+12]
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000024   0x6008             STR      R0,[R1, #+0]
    664              
    665              // Find channel with the best link quality
    666              maxLinkQdBm = -128;
   \   00000026   0xF07F 0x007F      MVNS     R0,#+127
   \   0000002A   0x4680             MOV      R8,R0
    667              channel=GetRandomNibble();
   \   0000002C   0x.... 0x....      BL       GetRandomNibble
   \   00000030   0x0005             MOVS     R5,R0
    668              smacErrors_t smacStatus;
    669              for (iter = 0; iter < 64; iter++) {
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x0006             MOVS     R6,R0
   \                     ??ChooseBestChannel_0: (+1)
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x2E40             CMP      R6,#+64
   \   0000003A   0xDA3C             BGE.N    ??ChooseBestChannel_1
    670                  smacStatus=gErrorBusy_c;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x4681             MOV      R9,R0
    671                  channel = (channel + 1) & 15;
   \   00000040   0x1C68             ADDS     R0,R5,#+1
   \   00000042   0xF010 0x050F      ANDS     R5,R0,#0xF
    672           //       channel=0;
    673                  iChannel=channel+gChannel11_c;
                                 ^
Warning[Pe188]: enumerated type mixed with another type
   \   00000046   0xF115 0x000B      ADDS     R0,R5,#+11
   \   0000004A   0x0007             MOVS     R7,R0
    674                  
    675                  while(smacStatus!=gErrorNoError_c){
   \                     ??ChooseBestChannel_2: (+1)
   \   0000004C   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000050   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000054   0xD005             BEQ.N    ??ChooseBestChannel_3
    676                    smacStatus=MLMESetChannelRequest(iChannel);
   \   00000056   0x0038             MOVS     R0,R7
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0x.... 0x....      BL       MLMESetChannelRequest
   \   0000005E   0x4681             MOV      R9,R0
   \   00000060   0xE7F4             B.N      ??ChooseBestChannel_2
    677                  }
    678                  smacStatus=gErrorBusy_c;
   \                     ??ChooseBestChannel_3: (+1)
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0x4681             MOV      R9,R0
    679                  //while(smacStatus!=gErrorNoError_c){
    680                    smacStatus=MCPSDataRequest(gAppTxPacket); // transmit data
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x.... 0x....      BL       MCPSDataRequest
   \   00000070   0x4681             MOV      R9,R0
    681                  //}
    682                  // NOTE: we have to keep looping here, because our PNG packets may be sent back
    683                  // to us by a REPEATER, but we should ignore them (only intereseted in ACK packets)
    684                  if(smacStatus==gErrorNoError_c){
   \   00000072   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000076   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000007A   0xD11A             BNE.N    ??ChooseBestChannel_4
    685                  
    686                  do 
    687                  {
    688                      ReceivePacket();
   \                     ??ChooseBestChannel_5: (+1)
   \   0000007C   0x.... 0x....      BL       ReceivePacket
    689                      if (gIsMyAck) 
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD00D             BEQ.N    ??ChooseBestChannel_6
    690                      {
    691                          int8_t linkQdBm = GetLinkQdBm();
   \   0000008A   0x.... 0x....      BL       GetLinkQdBm
    692                          if (linkQdBm > maxLinkQdBm)
   \   0000008E   0xFA4F 0xF888      SXTB     R8,R8            ;; SignExt  R8,R8,#+24,#+24
   \   00000092   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000094   0x4580             CMP      R8,R0
   \   00000096   0xDA06             BGE.N    ??ChooseBestChannel_6
    693                          {
    694                              maxLinkQdBm = linkQdBm;
   \   00000098   0x4680             MOV      R8,R0
    695                              gSnd.channel = iChannel;
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000009E   0xF881 0x7043      STRB     R7,[R1, #+67]
    696                              channelStatus = SUCCESS;
   \   000000A2   0x2177             MOVS     R1,#+119
   \   000000A4   0x000C             MOVS     R4,R1
    697                          }
    698                          //printf("Channel %d Link Quality %d",iChannel,linkQdBm);
    699                      }
    700                  }
    701                  while (gAppRxPacket->rxStatus != rxTimeOutStatus_c);
   \                     ??ChooseBestChannel_6: (+1)
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable17
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0x7840             LDRB     R0,[R0, #+1]
   \   000000AE   0x2803             CMP      R0,#+3
   \   000000B0   0xD1E4             BNE.N    ??ChooseBestChannel_5
    702                  }
    703              }
   \                     ??ChooseBestChannel_4: (+1)
   \   000000B2   0x1C76             ADDS     R6,R6,#+1
   \   000000B4   0xE7BF             B.N      ??ChooseBestChannel_0
    704              
    705              // Remember to restore the usual timeout value, i.e., the timeout for SND packets
    706              gRxTimeout = gOptions.u32SndTimeout;
   \                     ??ChooseBestChannel_1: (+1)
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable15_12
   \   000000BA   0x6900             LDR      R0,[R0, #+16]
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000000C0   0x6008             STR      R0,[R1, #+0]
    707              
    708              // Reset channel (even if none were successful, since then it's original gChannelNumber)
    709              if (MLMESetChannelRequest(gSnd.channel) != SUCCESS) // select channel here (0-15)
                                               ^
Warning[Pe188]: enumerated type mixed with another type
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000C6   0xF890 0x0043      LDRB     R0,[R0, #+67]
   \   000000CA   0x.... 0x....      BL       MLMESetChannelRequest
   \   000000CE   0x4682             MOV      R10,R0
    710              { 
    711                  //printf("can't set channel %d",gSnd.channel);
    712              }
    713              
    714            	// Added *** 10/27/10 ***
    715              // NOTE: the most meaningful "linkQdBm" value in the first SND packet after
    716              // channel scan is "maxLinkQdBm" - see also "ReceivePacket".
    717              gSnd.linkQdBm = maxLinkQdBm;
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000D4   0xF880 0x803C      STRB     R8,[R0, #+60]
    718          
    719              // Finally, send our current options to the pan coordinator
    720              SendCurrentOptions();
   \   000000D8   0x.... 0x....      BL       SendCurrentOptions
    721              
    722              return channelStatus;  // return SUCCESS if selected channel is good
   \   000000DC   0x0020             MOVS     R0,R4
   \   000000DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E0   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    723          }
    724          

   \                                 In section .text, align 2, keep-with-next
    725          void ReceivePacket(){
   \                     ReceivePacket: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    726            appState = WAIT_FOR_ACK;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable15_10
   \   00000008   0x7008             STRB     R0,[R1, #+0]
    727            gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
   \   0000000A   0x207B             MOVS     R0,#+123
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x7008             STRB     R0,[R1, #+0]
    728            smacErrors_t status = MLMERXEnableRequest(gAppRxPacket, gRxTimeout);
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x.... 0x....      BL       MLMERXEnableRequest
   \   00000024   0x0004             MOVS     R4,R0
    729            while(status!=gErrorNoError_c){
   \                     ??ReceivePacket_0: (+1)
   \   00000026   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000028   0x2C00             CMP      R4,#+0
   \   0000002A   0xD009             BEQ.N    ??ReceivePacket_1
    730              status = MLMERXEnableRequest(gAppRxPacket, gRxTimeout);
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000030   0x6801             LDR      R1,[R0, #+0]
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x.... 0x....      BL       MLMERXEnableRequest
   \   0000003C   0x0004             MOVS     R4,R0
   \   0000003E   0xE7F2             B.N      ??ReceivePacket_0
    731            }
    732            
    733            while(appState == WAIT_FOR_ACK);
   \                     ??ReceivePacket_1: (+1)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable15_10
   \   00000044   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD0F9             BEQ.N    ??ReceivePacket_1
    734            if(gAppRxPacket->rxStatus==rxSuccessStatus_c) {
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x7840             LDRB     R0,[R0, #+1]
   \   00000054   0x2802             CMP      R0,#+2
   \   00000056   0xD13B             BNE.N    ??ReceivePacket_2
    735              //LED_SetLed(LED3, gLedOn_c);
    736              if (gAppRxPacket->smacPdu.u8Data[0] == 'A' &&
    737                  gAppRxPacket->smacPdu.u8Data[1] == 'C' && 
    738                  gAppRxPacket->smacPdu.u8Data[2] == 'K' &&
    739                  gAppRxPacket->u8DataLength >= ACK_HEADER_SIZE)
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x7940             LDRB     R0,[R0, #+5]
   \   00000060   0x2841             CMP      R0,#+65
   \   00000062   0xD12D             BNE.N    ??ReceivePacket_3
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x7980             LDRB     R0,[R0, #+6]
   \   0000006C   0x2843             CMP      R0,#+67
   \   0000006E   0xD127             BNE.N    ??ReceivePacket_3
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0x79C0             LDRB     R0,[R0, #+7]
   \   00000078   0x284B             CMP      R0,#+75
   \   0000007A   0xD121             BNE.N    ??ReceivePacket_3
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0x7880             LDRB     R0,[R0, #+2]
   \   00000084   0x2805             CMP      R0,#+5
   \   00000086   0xDB1B             BLT.N    ??ReceivePacket_3
    740              {
    741                  gIsAck = TRUE;
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   0000008E   0x7008             STRB     R0,[R1, #+0]
    742                  uint16_t ackID = (*(uint16_t*)&gAppRxPacket->smacPdu.u8Data[3]);
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0x8900             LDRH     R0,[R0, #+8]
    743                  ackID = (ackID << 8) | (ackID >> 8);
   \   00000098   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000009A   0x0A01             LSRS     R1,R0,#+8
   \   0000009C   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
    744                  gIsMyAck = (ackID == sensorID);
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable15
   \   000000A4   0x8809             LDRH     R1,[R1, #+0]
   \   000000A6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000A8   0x4288             CMP      R0,R1
   \   000000AA   0xD104             BNE.N    ??ReceivePacket_4
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable29
   \   000000B2   0x7008             STRB     R0,[R1, #+0]
   \   000000B4   0xE00C             B.N      ??ReceivePacket_2
   \                     ??ReceivePacket_4: (+1)
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable29
   \   000000BC   0x7008             STRB     R0,[R1, #+0]
   \   000000BE   0xE007             B.N      ??ReceivePacket_2
    745                  //if(gIsMyAck) LED_SetLed(LED1, gLedOn_c);
    746                 
    747              }
    748              else
    749              {
    750                  gIsAck = FALSE;
   \                     ??ReceivePacket_3: (+1)
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   000000C6   0x7008             STRB     R0,[R1, #+0]
    751                  gIsMyAck = FALSE;
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable29
   \   000000CE   0x7008             STRB     R0,[R1, #+0]
    752              }
    753            }
    754            if(gAppRxPacket->rxStatus==rxTimeOutStatus_c) {
    755              //LED_SetLed(LED4, gLedOn_c); 
    756            }
    757            
    758          }
   \                     ??ReceivePacket_2: (+1)
   \   000000D0   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    759          void PrintPacketID(uint16_t packetID){
   \                     PrintPacketID: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    760            CommUtil_Print("\f\r\n Running PER Tx, Sending ", gAllowToBlock_d);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable22_1
   \   0000000A   0x.... 0x....      BL       CommUtil_Print
    761            PrintWordOnDecimalFormatBlocking(packetID, 0, FALSE, gDefaultCommPort_c);
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000018   0x.... 0x....      BL       PrintWordOnDecimalFormatBlocking
    762            CommUtil_Print(" Packets", gAllowToBlock_d);
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable30
   \   00000022   0x.... 0x....      BL       CommUtil_Print
    763              
    764          }
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    765          
    766          

   \                                 In section .text, align 2, keep-with-next
    767          void SndSwapEndianness(){
    768            //uint16
    769            gSnd.hdr.u16SensorID  = (gSnd.hdr.u16SensorID << 8) | (gSnd.hdr.u16SensorID >> 8 );
   \                     SndSwapEndianness: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   00000004   0x8880             LDRH     R0,[R0, #+4]
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   0000000A   0x8889             LDRH     R1,[R1, #+4]
   \   0000000C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   0x0A09             LSRS     R1,R1,#+8
   \   00000010   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000018   0x8088             STRH     R0,[R1, #+4]
    770            gSnd.packetID         = (gSnd.packetID        << 8) | (gSnd.packetID       >> 8 );
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   0000001E   0x88C0             LDRH     R0,[R0, #+6]
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000024   0x88C9             LDRH     R1,[R1, #+6]
   \   00000026   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000028   0x0A09             LSRS     R1,R1,#+8
   \   0000002A   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000032   0x80C8             STRH     R0,[R1, #+6]
    771            gSnd.xmin             = (gSnd.xmin            << 8) | (gSnd.xmin           >> 8 );
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   00000038   0x8900             LDRH     R0,[R0, #+8]
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   0000003E   0x8909             LDRH     R1,[R1, #+8]
   \   00000040   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000042   0x0A09             LSRS     R1,R1,#+8
   \   00000044   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   0000004C   0x8108             STRH     R0,[R1, #+8]
    772            gSnd.xmax             = (gSnd.xmax            << 8) | (gSnd.xmax           >> 8 );
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   00000052   0x8940             LDRH     R0,[R0, #+10]
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000058   0x8949             LDRH     R1,[R1, #+10]
   \   0000005A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000005C   0x0A09             LSRS     R1,R1,#+8
   \   0000005E   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000066   0x8148             STRH     R0,[R1, #+10]
    773            gSnd.xmean            = (gSnd.xmean           << 8) | (gSnd.xmean          >> 8 );
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   0000006C   0x8980             LDRH     R0,[R0, #+12]
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000072   0x8989             LDRH     R1,[R1, #+12]
   \   00000074   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000076   0x0A09             LSRS     R1,R1,#+8
   \   00000078   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000080   0x8188             STRH     R0,[R1, #+12]
    774            gSnd.ymin             = (gSnd.ymin            << 8) | (gSnd.ymin           >> 8 );
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   00000086   0x8B00             LDRH     R0,[R0, #+24]
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   0000008C   0x8B09             LDRH     R1,[R1, #+24]
   \   0000008E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000090   0x0A09             LSRS     R1,R1,#+8
   \   00000092   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   0000009A   0x8308             STRH     R0,[R1, #+24]
    775            gSnd.ymax             = (gSnd.ymax            << 8) | (gSnd.ymax           >> 8 );
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   000000A0   0x8B40             LDRH     R0,[R0, #+26]
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   000000A6   0x8B49             LDRH     R1,[R1, #+26]
   \   000000A8   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000AA   0x0A09             LSRS     R1,R1,#+8
   \   000000AC   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   000000B4   0x8348             STRH     R0,[R1, #+26]
    776            gSnd.ymean            = (gSnd.ymean           << 8) | (gSnd.ymean          >> 8 );
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   000000BA   0x8B80             LDRH     R0,[R0, #+28]
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   000000C0   0x8B89             LDRH     R1,[R1, #+28]
   \   000000C2   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000C4   0x0A09             LSRS     R1,R1,#+8
   \   000000C6   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   000000CE   0x8388             STRH     R0,[R1, #+28]
    777            gSnd.zmin             = (gSnd.zmin            << 8) | (gSnd.zmin           >> 8 );
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   000000D4   0x8D00             LDRH     R0,[R0, #+40]
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   000000DA   0x8D09             LDRH     R1,[R1, #+40]
   \   000000DC   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000DE   0x0A09             LSRS     R1,R1,#+8
   \   000000E0   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   000000E8   0x8508             STRH     R0,[R1, #+40]
    778            gSnd.zmax             = (gSnd.zmax            << 8) | (gSnd.zmax           >> 8 );
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   000000EE   0x8D40             LDRH     R0,[R0, #+42]
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   000000F4   0x8D49             LDRH     R1,[R1, #+42]
   \   000000F6   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000F8   0x0A09             LSRS     R1,R1,#+8
   \   000000FA   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000FE   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000102   0x8548             STRH     R0,[R1, #+42]
    779            gSnd.zmean            = (gSnd.zmean           << 8) | (gSnd.zmean          >> 8 );
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   00000108   0x8D80             LDRH     R0,[R0, #+44]
   \   0000010A   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   0000010E   0x8D89             LDRH     R1,[R1, #+44]
   \   00000110   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000112   0x0A09             LSRS     R1,R1,#+8
   \   00000114   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000118   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   0000011C   0x8588             STRH     R0,[R1, #+44]
    780            gSnd.battery_mV       = (gSnd.battery_mV      << 8) | (gSnd.battery_mV     >> 8 );
   \   0000011E   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   00000122   0x8F40             LDRH     R0,[R0, #+58]
   \   00000124   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000128   0x8F49             LDRH     R1,[R1, #+58]
   \   0000012A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000012C   0x0A09             LSRS     R1,R1,#+8
   \   0000012E   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000132   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000136   0x8748             STRH     R0,[R1, #+58]
    781            gSnd.totalTimeouts    = (gSnd.totalTimeouts   << 8) | (gSnd.totalTimeouts  >> 8 );
   \   00000138   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   0000013C   0x8FC0             LDRH     R0,[R0, #+62]
   \   0000013E   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000142   0x8FC9             LDRH     R1,[R1, #+62]
   \   00000144   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000146   0x0A09             LSRS     R1,R1,#+8
   \   00000148   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000014C   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000150   0x87C8             STRH     R0,[R1, #+62]
    782            gSnd.maxMissedCount   = (gSnd.maxMissedCount  << 8) | (gSnd.maxMissedCount >> 8 );
   \   00000152   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   00000156   0xF8B0 0x0040      LDRH     R0,[R0, #+64]
   \   0000015A   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   0000015E   0xF8B1 0x1040      LDRH     R1,[R1, #+64]
   \   00000162   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000164   0x0A09             LSRS     R1,R1,#+8
   \   00000166   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000016A   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   0000016E   0xF8A1 0x0040      STRH     R0,[R1, #+64]
    783            
    784            //int16
    785            gSnd.temperature      = (gSnd.temperature << 8) | ((gSnd.temperature >> 8) & 0xFF);
   \   00000172   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   00000176   0x8F00             LDRH     R0,[R0, #+56]
   \   00000178   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   0000017C   0xF9B1 0x1038      LDRSH    R1,[R1, #+56]
   \   00000180   0xF3C1 0x2107      UBFX     R1,R1,#+8,#+8
   \   00000184   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000188   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   0000018C   0x8708             STRH     R0,[R1, #+56]
    786            
    787            //uint32
    788            gSnd.xsum0 = ((gSnd.xsum0 << 8) & 0xFF00FF00 ) | ((gSnd.xsum0 >> 8) & 0xFF00FF ); 
   \   0000018E   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   00000192   0x6900             LDR      R0,[R0, #+16]
   \   00000194   0x0200             LSLS     R0,R0,#+8
   \   00000196   0xF030 0x10FF      BICS     R0,R0,#0xFF00FF
   \   0000019A   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   0000019E   0x6909             LDR      R1,[R1, #+16]
   \   000001A0   0x0A09             LSRS     R1,R1,#+8
   \   000001A2   0xF011 0x11FF      ANDS     R1,R1,#0xFF00FF
   \   000001A6   0x4308             ORRS     R0,R1,R0
   \   000001A8   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   000001AC   0x6108             STR      R0,[R1, #+16]
    789            gSnd.xsum0 = (gSnd.xsum0 << 16) | (gSnd.xsum0 >> 16);
   \   000001AE   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   000001B2   0x6900             LDR      R0,[R0, #+16]
   \   000001B4   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   000001B8   0x6909             LDR      R1,[R1, #+16]
   \   000001BA   0xEA5F 0x4031      RORS     R0,R1,#+16
   \   000001BE   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   000001C2   0x6108             STR      R0,[R1, #+16]
    790            gSnd.xsum1 = ((gSnd.xsum1 << 8) & 0xFF00FF00 ) | ((gSnd.xsum1 >> 8) & 0xFF00FF ); 
   \   000001C4   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   000001C8   0x6940             LDR      R0,[R0, #+20]
   \   000001CA   0x0200             LSLS     R0,R0,#+8
   \   000001CC   0xF030 0x10FF      BICS     R0,R0,#0xFF00FF
   \   000001D0   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   000001D4   0x6949             LDR      R1,[R1, #+20]
   \   000001D6   0x0A09             LSRS     R1,R1,#+8
   \   000001D8   0xF011 0x11FF      ANDS     R1,R1,#0xFF00FF
   \   000001DC   0x4308             ORRS     R0,R1,R0
   \   000001DE   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   000001E2   0x6148             STR      R0,[R1, #+20]
    791            gSnd.xsum1 =  (gSnd.xsum1 << 16) | (gSnd.xsum1 >> 16);
   \   000001E4   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   000001E8   0x6940             LDR      R0,[R0, #+20]
   \   000001EA   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   000001EE   0x6949             LDR      R1,[R1, #+20]
   \   000001F0   0xEA5F 0x4031      RORS     R0,R1,#+16
   \   000001F4   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   000001F8   0x6148             STR      R0,[R1, #+20]
    792            gSnd.ysum0 = ((gSnd.ysum0 << 8) & 0xFF00FF00 ) | ((gSnd.ysum0 >> 8) & 0xFF00FF ); 
   \   000001FA   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   000001FE   0x6A00             LDR      R0,[R0, #+32]
   \   00000200   0x0200             LSLS     R0,R0,#+8
   \   00000202   0xF030 0x10FF      BICS     R0,R0,#0xFF00FF
   \   00000206   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   0000020A   0x6A09             LDR      R1,[R1, #+32]
   \   0000020C   0x0A09             LSRS     R1,R1,#+8
   \   0000020E   0xF011 0x11FF      ANDS     R1,R1,#0xFF00FF
   \   00000212   0x4308             ORRS     R0,R1,R0
   \   00000214   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000218   0x6208             STR      R0,[R1, #+32]
    793            gSnd.ysum0 = (gSnd.ysum0 << 16) | (gSnd.ysum0 >> 16);
   \   0000021A   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   0000021E   0x6A00             LDR      R0,[R0, #+32]
   \   00000220   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000224   0x6A09             LDR      R1,[R1, #+32]
   \   00000226   0xEA5F 0x4031      RORS     R0,R1,#+16
   \   0000022A   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   0000022E   0x6208             STR      R0,[R1, #+32]
    794            gSnd.ysum1 = ((gSnd.ysum1 << 8) & 0xFF00FF00 ) | ((gSnd.ysum1 >> 8) & 0xFF00FF ); 
   \   00000230   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   00000234   0x6A40             LDR      R0,[R0, #+36]
   \   00000236   0x0200             LSLS     R0,R0,#+8
   \   00000238   0xF030 0x10FF      BICS     R0,R0,#0xFF00FF
   \   0000023C   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000240   0x6A49             LDR      R1,[R1, #+36]
   \   00000242   0x0A09             LSRS     R1,R1,#+8
   \   00000244   0xF011 0x11FF      ANDS     R1,R1,#0xFF00FF
   \   00000248   0x4308             ORRS     R0,R1,R0
   \   0000024A   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   0000024E   0x6248             STR      R0,[R1, #+36]
    795            gSnd.ysum1 =  (gSnd.ysum1 << 16) | (gSnd.ysum1 >> 16);  
   \   00000250   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   00000254   0x6A40             LDR      R0,[R0, #+36]
   \   00000256   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   0000025A   0x6A49             LDR      R1,[R1, #+36]
   \   0000025C   0xEA5F 0x4031      RORS     R0,R1,#+16
   \   00000260   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000264   0x6248             STR      R0,[R1, #+36]
    796            gSnd.zsum0 = ((gSnd.zsum0 << 8) & 0xFF00FF00 ) | ((gSnd.zsum0 >> 8) & 0xFF00FF ); 
   \   00000266   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   0000026A   0x6B00             LDR      R0,[R0, #+48]
   \   0000026C   0x0200             LSLS     R0,R0,#+8
   \   0000026E   0xF030 0x10FF      BICS     R0,R0,#0xFF00FF
   \   00000272   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000276   0x6B09             LDR      R1,[R1, #+48]
   \   00000278   0x0A09             LSRS     R1,R1,#+8
   \   0000027A   0xF011 0x11FF      ANDS     R1,R1,#0xFF00FF
   \   0000027E   0x4308             ORRS     R0,R1,R0
   \   00000280   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000284   0x6308             STR      R0,[R1, #+48]
    797            gSnd.zsum0 = (gSnd.zsum0 << 16) | (gSnd.zsum0 >> 16);
   \   00000286   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   0000028A   0x6B00             LDR      R0,[R0, #+48]
   \   0000028C   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000290   0x6B09             LDR      R1,[R1, #+48]
   \   00000292   0xEA5F 0x4031      RORS     R0,R1,#+16
   \   00000296   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   0000029A   0x6308             STR      R0,[R1, #+48]
    798            gSnd.zsum1 = ((gSnd.zsum1 << 8) & 0xFF00FF00 ) | ((gSnd.zsum1 >> 8) & 0xFF00FF ); 
   \   0000029C   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   000002A0   0x6B40             LDR      R0,[R0, #+52]
   \   000002A2   0x0200             LSLS     R0,R0,#+8
   \   000002A4   0xF030 0x10FF      BICS     R0,R0,#0xFF00FF
   \   000002A8   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   000002AC   0x6B49             LDR      R1,[R1, #+52]
   \   000002AE   0x0A09             LSRS     R1,R1,#+8
   \   000002B0   0xF011 0x11FF      ANDS     R1,R1,#0xFF00FF
   \   000002B4   0x4308             ORRS     R0,R1,R0
   \   000002B6   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   000002BA   0x6348             STR      R0,[R1, #+52]
    799            gSnd.zsum1 =  (gSnd.zsum1 << 16) | (gSnd.zsum1 >> 16);
   \   000002BC   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   000002C0   0x6B40             LDR      R0,[R0, #+52]
   \   000002C2   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   000002C6   0x6B49             LDR      R1,[R1, #+52]
   \   000002C8   0xEA5F 0x4031      RORS     R0,R1,#+16
   \   000002CC   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   000002D0   0x6348             STR      R0,[R1, #+52]
    800            
    801          }
   \   000002D2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    802          void CopyOptionsFromRecvPacket(tOptions* pOptions){
   \                     CopyOptionsFromRecvPacket: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    803          
    804            uint32_t offset = ACK_HEADER_SIZE;      
   \   00000004   0x2505             MOVS     R5,#+5
    805            MemoryCpy(&pOptions->u8RawSpinCount, &gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->u8RawSpinCount));  
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x1828             ADDS     R0,R5,R0
   \   00000010   0x1D41             ADDS     R1,R0,#+5
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       MemoryCpy
    806            offset += sizeof(uint8_t);
   \   00000018   0x1C6D             ADDS     R5,R5,#+1
    807            MemoryCpy(&pOptions->u16TimeoutsToKill, &gAppRxPacket->smacPdu.u8Data[offset],sizeof(pOptions->u16TimeoutsToKill));
   \   0000001A   0x2202             MOVS     R2,#+2
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x1828             ADDS     R0,R5,R0
   \   00000024   0x1D41             ADDS     R1,R0,#+5
   \   00000026   0x1CA0             ADDS     R0,R4,#+2
   \   00000028   0x.... 0x....      BL       MemoryCpy
    808            offset += sizeof(uint16_t);
   \   0000002C   0x1CAD             ADDS     R5,R5,#+2
    809            MemoryCpy(&pOptions->u16SampleSize, &gAppRxPacket->smacPdu.u8Data[offset],sizeof(pOptions->u16SampleSize));
   \   0000002E   0x2202             MOVS     R2,#+2
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x1828             ADDS     R0,R5,R0
   \   00000038   0x1D41             ADDS     R1,R0,#+5
   \   0000003A   0x1D20             ADDS     R0,R4,#+4
   \   0000003C   0x.... 0x....      BL       MemoryCpy
    810            offset += sizeof(uint16_t);
   \   00000040   0x1CAD             ADDS     R5,R5,#+2
    811            MemoryCpy(&pOptions->bAsciiMode, &gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->bAsciiMode));
   \   00000042   0x2201             MOVS     R2,#+1
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x1828             ADDS     R0,R5,R0
   \   0000004C   0x1D41             ADDS     R1,R0,#+5
   \   0000004E   0x1DA0             ADDS     R0,R4,#+6
   \   00000050   0x.... 0x....      BL       MemoryCpy
    812            offset += sizeof(uint8_t);
   \   00000054   0x1C6D             ADDS     R5,R5,#+1
    813            MemoryCpy(&pOptions->bBlinkingLEDs, &gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->bBlinkingLEDs));
   \   00000056   0x2201             MOVS     R2,#+1
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x1828             ADDS     R0,R5,R0
   \   00000060   0x1D41             ADDS     R1,R0,#+5
   \   00000062   0x1DE0             ADDS     R0,R4,#+7
   \   00000064   0x.... 0x....      BL       MemoryCpy
    814            offset += sizeof(uint8_t);                                           
   \   00000068   0x1C6D             ADDS     R5,R5,#+1
    815            MemoryCpy(&pOptions->u8OutputPower, &gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->u8OutputPower));
   \   0000006A   0x2201             MOVS     R2,#+1
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x1828             ADDS     R0,R5,R0
   \   00000074   0x1D41             ADDS     R1,R0,#+5
   \   00000076   0xF114 0x0008      ADDS     R0,R4,#+8
   \   0000007A   0x.... 0x....      BL       MemoryCpy
    816            offset += sizeof(uint8_t);                                        
   \   0000007E   0x1C6D             ADDS     R5,R5,#+1
    817            MemoryCpy(&pOptions->u32PngTimeout, &gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->u32PngTimeout));
   \   00000080   0x2204             MOVS     R2,#+4
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x1828             ADDS     R0,R5,R0
   \   0000008A   0x1D41             ADDS     R1,R0,#+5
   \   0000008C   0xF114 0x000C      ADDS     R0,R4,#+12
   \   00000090   0x.... 0x....      BL       MemoryCpy
    818            offset += sizeof(uint32_t);                                        
   \   00000094   0x1D2D             ADDS     R5,R5,#+4
    819            MemoryCpy(&pOptions->u32SndTimeout, &gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->u32SndTimeout));
   \   00000096   0x2204             MOVS     R2,#+4
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0x1828             ADDS     R0,R5,R0
   \   000000A0   0x1D41             ADDS     R1,R0,#+5
   \   000000A2   0xF114 0x0010      ADDS     R0,R4,#+16
   \   000000A6   0x.... 0x....      BL       MemoryCpy
    820            offset += sizeof(uint32_t);
   \   000000AA   0x1D2D             ADDS     R5,R5,#+4
    821            MemoryCpy(&pOptions->bLNAHighGainMode,&gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->bLNAHighGainMode)); // i.e. Low Noise Amplifier - updated *** 10/26/10 *** (formerly "u8Reserved2")
   \   000000AC   0x2201             MOVS     R2,#+1
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable17
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0x1828             ADDS     R0,R5,R0
   \   000000B6   0x1D41             ADDS     R1,R0,#+5
   \   000000B8   0xF114 0x0014      ADDS     R0,R4,#+20
   \   000000BC   0x.... 0x....      BL       MemoryCpy
    822            offset += sizeof(uint8_t);
   \   000000C0   0x1C6D             ADDS     R5,R5,#+1
    823            MemoryCpy(&pOptions->u16SleepAfterAck,&gAppRxPacket->smacPdu.u8Data[offset], sizeof(pOptions->u16SleepAfterAck));
   \   000000C2   0x2202             MOVS     R2,#+2
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable17
   \   000000C8   0x6800             LDR      R0,[R0, #+0]
   \   000000CA   0x1828             ADDS     R0,R5,R0
   \   000000CC   0x1D41             ADDS     R1,R0,#+5
   \   000000CE   0xF114 0x0016      ADDS     R0,R4,#+22
   \   000000D2   0x.... 0x....      BL       MemoryCpy
    824            
    825          
    826          }
   \   000000D6   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
    827          void OptSwapEndianness(tOptions* pOptions){
    828            
    829            
    830            
    831            pOptions->u16TimeoutsToKill   = ((pOptions->u16TimeoutsToKill)       << 8) | ((pOptions->u16TimeoutsToKill) >> 8);
   \                     OptSwapEndianness: (+1)
   \   00000000   0x8841             LDRH     R1,[R0, #+2]
   \   00000002   0x8842             LDRH     R2,[R0, #+2]
   \   00000004   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000006   0x0A12             LSRS     R2,R2,#+8
   \   00000008   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   0000000C   0x8041             STRH     R1,[R0, #+2]
    832            pOptions->u16SampleSize       = ((pOptions->u16SampleSize)           << 8) | ((pOptions->u16SampleSize)     >> 8);
   \   0000000E   0x8881             LDRH     R1,[R0, #+4]
   \   00000010   0x8882             LDRH     R2,[R0, #+4]
   \   00000012   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000014   0x0A12             LSRS     R2,R2,#+8
   \   00000016   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   0000001A   0x8081             STRH     R1,[R0, #+4]
    833            pOptions->u16SleepAfterAck    = ((pOptions->u16SleepAfterAck)        << 8) | ((pOptions->u16SleepAfterAck)  >> 8);
   \   0000001C   0x8AC1             LDRH     R1,[R0, #+22]
   \   0000001E   0x8AC2             LDRH     R2,[R0, #+22]
   \   00000020   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000022   0x0A12             LSRS     R2,R2,#+8
   \   00000024   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   00000028   0x82C1             STRH     R1,[R0, #+22]
    834            
    835            pOptions->u32PngTimeout = (((pOptions->u32PngTimeout) << 8) & 0xFF00FF00 ) | (((pOptions->u32PngTimeout) >> 8) & 0xFF00FF );
   \   0000002A   0x68C1             LDR      R1,[R0, #+12]
   \   0000002C   0x0209             LSLS     R1,R1,#+8
   \   0000002E   0xF031 0x11FF      BICS     R1,R1,#0xFF00FF
   \   00000032   0x68C2             LDR      R2,[R0, #+12]
   \   00000034   0x0A12             LSRS     R2,R2,#+8
   \   00000036   0xF012 0x12FF      ANDS     R2,R2,#0xFF00FF
   \   0000003A   0x4311             ORRS     R1,R2,R1
   \   0000003C   0x60C1             STR      R1,[R0, #+12]
    836            pOptions->u32PngTimeout = (pOptions->u32PngTimeout << 16) | (pOptions->u32PngTimeout >> 16);
   \   0000003E   0x68C1             LDR      R1,[R0, #+12]
   \   00000040   0x68C2             LDR      R2,[R0, #+12]
   \   00000042   0xEA5F 0x4132      RORS     R1,R2,#+16
   \   00000046   0x60C1             STR      R1,[R0, #+12]
    837            
    838            pOptions->u32SndTimeout = (((pOptions->u32SndTimeout) << 8) & 0xFF00FF00 ) | (((pOptions->u32SndTimeout) >> 8) & 0xFF00FF );
   \   00000048   0x6901             LDR      R1,[R0, #+16]
   \   0000004A   0x0209             LSLS     R1,R1,#+8
   \   0000004C   0xF031 0x11FF      BICS     R1,R1,#0xFF00FF
   \   00000050   0x6902             LDR      R2,[R0, #+16]
   \   00000052   0x0A12             LSRS     R2,R2,#+8
   \   00000054   0xF012 0x12FF      ANDS     R2,R2,#0xFF00FF
   \   00000058   0x4311             ORRS     R1,R2,R1
   \   0000005A   0x6101             STR      R1,[R0, #+16]
    839            pOptions->u32SndTimeout = (pOptions->u32SndTimeout << 16) | (pOptions->u32SndTimeout >> 16);
   \   0000005C   0x6901             LDR      R1,[R0, #+16]
   \   0000005E   0x6902             LDR      R2,[R0, #+16]
   \   00000060   0xEA5F 0x4132      RORS     R1,R2,#+16
   \   00000064   0x6101             STR      R1,[R0, #+16]
    840            
    841            
    842            
    843          }
   \   00000066   0x4770             BX       LR               ;; return
    844          

   \                                 In section .text, align 2, keep-with-next
    845          void PngSwapEndianness(){
    846            gPng.u16SensorID = (gPng.u16SensorID << 8) | (gPng.u16SensorID >> 8);
   \                     PngSwapEndianness: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable31
   \   00000004   0x8880             LDRH     R0,[R0, #+4]
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable31
   \   0000000A   0x8889             LDRH     R1,[R1, #+4]
   \   0000000C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   0x0A09             LSRS     R1,R1,#+8
   \   00000010   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable31
   \   00000018   0x8088             STRH     R0,[R1, #+4]
    847          }
   \   0000001A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    848          void CopyPngPacketToSMAC(){
   \                     CopyPngPacketToSMAC: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    849            MemoryCpy(&gAppTxPacket->smacPdu.u8Data[0],       (uint8_t*)&gPng.u8Prefix[0],       sizeof(gPng.u8Prefix[0]));
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable31
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x1CC0             ADDS     R0,R0,#+3
   \   00000010   0x.... 0x....      BL       MemoryCpy
    850            MemoryCpy(&gAppTxPacket->smacPdu.u8Data[1],       (uint8_t*)&gPng.u8Prefix[1],       sizeof(gPng.u8Prefix[1]));
   \   00000014   0x2201             MOVS     R2,#+1
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable31_1
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x1D00             ADDS     R0,R0,#+4
   \   00000022   0x.... 0x....      BL       MemoryCpy
    851            MemoryCpy(&gAppTxPacket->smacPdu.u8Data[2],       (uint8_t*)&gPng.u8Prefix[2],       sizeof(gPng.u8Prefix[2]));
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable31_2
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x1D40             ADDS     R0,R0,#+5
   \   00000034   0x.... 0x....      BL       MemoryCpy
    852            MemoryCpy(&gAppTxPacket->smacPdu.u8Data[3],       (uint8_t*)&gPng.u16SensorID,       sizeof(gPng.u16SensorID));
   \   00000038   0x2202             MOVS     R2,#+2
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable31_3
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x1D80             ADDS     R0,R0,#+6
   \   00000046   0x.... 0x....      BL       MemoryCpy
    853                     
    854          }
   \   0000004A   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    855          void CopyBinaryPacketToSMAC(){
   \                     CopyBinaryPacketToSMAC: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    856            
    857            
    858            
    859              
    860            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[0]),  (uint8_t*)&gSnd.hdr.u8Prefix[0]        ,sizeof(gSnd.hdr.u8Prefix[0]));
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x....             LDR.N    R1,??DataTable16
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x1CC0             ADDS     R0,R0,#+3
   \   0000000E   0x.... 0x....      BL       MemoryCpy
    861            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[1]),  (uint8_t*)&gSnd.hdr.u8Prefix[1]        ,sizeof(gSnd.hdr.u8Prefix[1]));
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable31_4
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x1D00             ADDS     R0,R0,#+4
   \   00000020   0x.... 0x....      BL       MemoryCpy
    862            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[2]),  (uint8_t*)&gSnd.hdr.u8Prefix[2]        ,sizeof(gSnd.hdr.u8Prefix[2]));
   \   00000024   0x2201             MOVS     R2,#+1
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable31_5
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x1D40             ADDS     R0,R0,#+5
   \   00000032   0x.... 0x....      BL       MemoryCpy
    863            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[3]),  (uint8_t*)&gSnd.hdr.u8Length           ,sizeof(gSnd.hdr.u8Length   ));
   \   00000036   0x2201             MOVS     R2,#+1
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable31_6
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x1D80             ADDS     R0,R0,#+6
   \   00000044   0x.... 0x....      BL       MemoryCpy
    864            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[4]),  (uint8_t*)&gSnd.hdr.u16SensorID        ,sizeof(gSnd.hdr.u16SensorID));
   \   00000048   0x2202             MOVS     R2,#+2
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable31_7
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x1DC0             ADDS     R0,R0,#+7
   \   00000056   0x.... 0x....      BL       MemoryCpy
    865            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[6]),  (uint8_t*)&gSnd.packetID               ,sizeof(gSnd.packetID       ));
   \   0000005A   0x2202             MOVS     R2,#+2
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable31_8
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0x3009             ADDS     R0,R0,#+9
   \   00000068   0x.... 0x....      BL       MemoryCpy
    866            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[8]),  (uint8_t*)&gSnd.xmin                   ,sizeof(gSnd.xmin           ));
   \   0000006C   0x2202             MOVS     R2,#+2
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable31_9
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x300B             ADDS     R0,R0,#+11
   \   0000007A   0x.... 0x....      BL       MemoryCpy
    867            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[10]), (uint8_t*)&gSnd.xmax                   ,sizeof(gSnd.xmax           ));
   \   0000007E   0x2202             MOVS     R2,#+2
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable31_10
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0x300D             ADDS     R0,R0,#+13
   \   0000008C   0x.... 0x....      BL       MemoryCpy
    868            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[12]), (uint8_t*)&gSnd.xmean                  ,sizeof(gSnd.xmean          ));
   \   00000090   0x2202             MOVS     R2,#+2
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable31_11
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0x300F             ADDS     R0,R0,#+15
   \   0000009E   0x.... 0x....      BL       MemoryCpy
    869            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[14]), (uint8_t*)&gSnd.xsum0                  ,sizeof(gSnd.xsum0          ));
   \   000000A2   0x2204             MOVS     R2,#+4
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable31_12
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   000000AC   0x6800             LDR      R0,[R0, #+0]
   \   000000AE   0x3011             ADDS     R0,R0,#+17
   \   000000B0   0x.... 0x....      BL       MemoryCpy
    870            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[18]), (uint8_t*)&gSnd.xsum1                  ,sizeof(gSnd.xsum1          ));
   \   000000B4   0x2204             MOVS     R2,#+4
   \   000000B6   0x.... 0x....      LDR.W    R1,??DataTable31_13
   \   000000BA   0x....             LDR.N    R0,??DataTable19_1
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0x3015             ADDS     R0,R0,#+21
   \   000000C0   0x.... 0x....      BL       MemoryCpy
    871            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[22]), (uint8_t*)&gSnd.ymin                   ,sizeof(gSnd.ymin           ));
   \   000000C4   0x2202             MOVS     R2,#+2
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable31_14
   \   000000CA   0x....             LDR.N    R0,??DataTable19_1
   \   000000CC   0x6800             LDR      R0,[R0, #+0]
   \   000000CE   0x3019             ADDS     R0,R0,#+25
   \   000000D0   0x.... 0x....      BL       MemoryCpy
    872            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[24]), (uint8_t*)&gSnd.ymax                   ,sizeof(gSnd.ymax           ));
   \   000000D4   0x2202             MOVS     R2,#+2
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable31_15
   \   000000DA   0x....             LDR.N    R0,??DataTable19_1
   \   000000DC   0x6800             LDR      R0,[R0, #+0]
   \   000000DE   0x301B             ADDS     R0,R0,#+27
   \   000000E0   0x.... 0x....      BL       MemoryCpy
    873            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[26]), (uint8_t*)&gSnd.ymean                  ,sizeof(gSnd.ymean          ));
   \   000000E4   0x2202             MOVS     R2,#+2
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable31_16
   \   000000EA   0x....             LDR.N    R0,??DataTable19_1
   \   000000EC   0x6800             LDR      R0,[R0, #+0]
   \   000000EE   0x301D             ADDS     R0,R0,#+29
   \   000000F0   0x.... 0x....      BL       MemoryCpy
    874            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[28]), (uint8_t*)&gSnd.ysum0                  ,sizeof(gSnd.ysum0          ));
   \   000000F4   0x2204             MOVS     R2,#+4
   \   000000F6   0x.... 0x....      LDR.W    R1,??DataTable31_17
   \   000000FA   0x....             LDR.N    R0,??DataTable19_1
   \   000000FC   0x6800             LDR      R0,[R0, #+0]
   \   000000FE   0x301F             ADDS     R0,R0,#+31
   \   00000100   0x.... 0x....      BL       MemoryCpy
    875            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[32]), (uint8_t*)&gSnd.ysum1                  ,sizeof(gSnd.ysum1          ));
   \   00000104   0x2204             MOVS     R2,#+4
   \   00000106   0x.... 0x....      LDR.W    R1,??DataTable31_18
   \   0000010A   0x....             LDR.N    R0,??DataTable19_1
   \   0000010C   0x6800             LDR      R0,[R0, #+0]
   \   0000010E   0x3023             ADDS     R0,R0,#+35
   \   00000110   0x.... 0x....      BL       MemoryCpy
    876            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[36]), (uint8_t*)&gSnd.zmin                   ,sizeof(gSnd.zmin           ));
   \   00000114   0x2202             MOVS     R2,#+2
   \   00000116   0x.... 0x....      LDR.W    R1,??DataTable31_19
   \   0000011A   0x....             LDR.N    R0,??DataTable19_1
   \   0000011C   0x6800             LDR      R0,[R0, #+0]
   \   0000011E   0x3027             ADDS     R0,R0,#+39
   \   00000120   0x.... 0x....      BL       MemoryCpy
    877            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[38]), (uint8_t*)&gSnd.zmax                   ,sizeof(gSnd.zmax           ));
   \   00000124   0x2202             MOVS     R2,#+2
   \   00000126   0x.... 0x....      LDR.W    R1,??DataTable31_20
   \   0000012A   0x....             LDR.N    R0,??DataTable19_1
   \   0000012C   0x6800             LDR      R0,[R0, #+0]
   \   0000012E   0x3029             ADDS     R0,R0,#+41
   \   00000130   0x.... 0x....      BL       MemoryCpy
    878            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[40]), (uint8_t*)&gSnd.zmean                  ,sizeof(gSnd.zmean          ));
   \   00000134   0x2202             MOVS     R2,#+2
   \   00000136   0x.... 0x....      LDR.W    R1,??DataTable31_21
   \   0000013A   0x....             LDR.N    R0,??DataTable19_1
   \   0000013C   0x6800             LDR      R0,[R0, #+0]
   \   0000013E   0x302B             ADDS     R0,R0,#+43
   \   00000140   0x.... 0x....      BL       MemoryCpy
    879            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[42]), (uint8_t*)&gSnd.zsum0                  ,sizeof(gSnd.zsum0          ));
   \   00000144   0x2204             MOVS     R2,#+4
   \   00000146   0x.... 0x....      LDR.W    R1,??DataTable31_22
   \   0000014A   0x....             LDR.N    R0,??DataTable19_1
   \   0000014C   0x6800             LDR      R0,[R0, #+0]
   \   0000014E   0x302D             ADDS     R0,R0,#+45
   \   00000150   0x.... 0x....      BL       MemoryCpy
    880            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[46]), (uint8_t*)&gSnd.zsum1                  ,sizeof(gSnd.zsum1          ));
   \   00000154   0x2204             MOVS     R2,#+4
   \   00000156   0x.... 0x....      LDR.W    R1,??DataTable31_23
   \   0000015A   0x....             LDR.N    R0,??DataTable19_1
   \   0000015C   0x6800             LDR      R0,[R0, #+0]
   \   0000015E   0x3031             ADDS     R0,R0,#+49
   \   00000160   0x.... 0x....      BL       MemoryCpy
    881            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[50]), (uint8_t*)&gSnd.temperature            ,sizeof(gSnd.temperature    ));
   \   00000164   0x2202             MOVS     R2,#+2
   \   00000166   0x.... 0x....      LDR.W    R1,??DataTable31_24
   \   0000016A   0x....             LDR.N    R0,??DataTable19_1
   \   0000016C   0x6800             LDR      R0,[R0, #+0]
   \   0000016E   0x3035             ADDS     R0,R0,#+53
   \   00000170   0x.... 0x....      BL       MemoryCpy
    882            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[52]), (uint8_t*)&gSnd.battery_mV             ,sizeof(gSnd.battery_mV     ));
   \   00000174   0x2202             MOVS     R2,#+2
   \   00000176   0x.... 0x....      LDR.W    R1,??DataTable31_25
   \   0000017A   0x....             LDR.N    R0,??DataTable19_1
   \   0000017C   0x6800             LDR      R0,[R0, #+0]
   \   0000017E   0x3037             ADDS     R0,R0,#+55
   \   00000180   0x.... 0x....      BL       MemoryCpy
    883            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[54]), (uint8_t*)&gSnd.linkQdBm               ,sizeof(gSnd.linkQdBm       ));
   \   00000184   0x2201             MOVS     R2,#+1
   \   00000186   0x.... 0x....      LDR.W    R1,??DataTable31_26
   \   0000018A   0x....             LDR.N    R0,??DataTable19_1
   \   0000018C   0x6800             LDR      R0,[R0, #+0]
   \   0000018E   0x3039             ADDS     R0,R0,#+57
   \   00000190   0x.... 0x....      BL       MemoryCpy
    884            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[55]), (uint8_t*)&gSnd.totalTimeouts          ,sizeof(gSnd.totalTimeouts  ));
   \   00000194   0x2202             MOVS     R2,#+2
   \   00000196   0x.... 0x....      LDR.W    R1,??DataTable31_27
   \   0000019A   0x....             LDR.N    R0,??DataTable19_1
   \   0000019C   0x6800             LDR      R0,[R0, #+0]
   \   0000019E   0x303A             ADDS     R0,R0,#+58
   \   000001A0   0x.... 0x....      BL       MemoryCpy
    885            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[57]), (uint8_t*)&gSnd.maxMissedCount         ,sizeof(gSnd.maxMissedCount ));
   \   000001A4   0x2202             MOVS     R2,#+2
   \   000001A6   0x.... 0x....      LDR.W    R1,??DataTable31_28
   \   000001AA   0x....             LDR.N    R0,??DataTable19_1
   \   000001AC   0x6800             LDR      R0,[R0, #+0]
   \   000001AE   0x303C             ADDS     R0,R0,#+60
   \   000001B0   0x.... 0x....      BL       MemoryCpy
    886            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[59]), (uint8_t*)&gSnd.voltageWarning         ,sizeof(gSnd.voltageWarning ));
   \   000001B4   0x2201             MOVS     R2,#+1
   \   000001B6   0x.... 0x....      LDR.W    R1,??DataTable31_29
   \   000001BA   0x....             LDR.N    R0,??DataTable19_1
   \   000001BC   0x6800             LDR      R0,[R0, #+0]
   \   000001BE   0x303E             ADDS     R0,R0,#+62
   \   000001C0   0x.... 0x....      BL       MemoryCpy
    887            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[60]), (uint8_t*)&gSnd.channel                ,sizeof(gSnd.channel        ));
   \   000001C4   0x2201             MOVS     R2,#+1
   \   000001C6   0x.... 0x....      LDR.W    R1,??DataTable31_30
   \   000001CA   0x....             LDR.N    R0,??DataTable19_1
   \   000001CC   0x6800             LDR      R0,[R0, #+0]
   \   000001CE   0x303F             ADDS     R0,R0,#+63
   \   000001D0   0x.... 0x....      BL       MemoryCpy
    888            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[61]), (uint8_t*)&gSnd.version                ,sizeof(gSnd.version        ));
   \   000001D4   0x2201             MOVS     R2,#+1
   \   000001D6   0x.... 0x....      LDR.W    R1,??DataTable31_31
   \   000001DA   0x....             LDR.N    R0,??DataTable19_1
   \   000001DC   0x6800             LDR      R0,[R0, #+0]
   \   000001DE   0x3040             ADDS     R0,R0,#+64
   \   000001E0   0x.... 0x....      BL       MemoryCpy
    889             
    890            gAppTxPacket->u8DataLength = SND_SIZE;
   \   000001E4   0x203E             MOVS     R0,#+62
   \   000001E6   0x....             LDR.N    R1,??DataTable19_1
   \   000001E8   0x6809             LDR      R1,[R1, #+0]
   \   000001EA   0x7008             STRB     R0,[R1, #+0]
    891          }
   \   000001EC   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    892          void CopyOptPacketToSMAC(){
   \                     CopyOptPacketToSMAC: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    893            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[0]),   (uint8_t*)&gOpt.hdr.u8Prefix[0]        ,sizeof(gOpt.hdr.u8Prefix[0]));
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x....             LDR.N    R1,??DataTable18_1
   \   00000006   0x....             LDR.N    R0,??DataTable19_1
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x1CC0             ADDS     R0,R0,#+3
   \   0000000C   0x.... 0x....      BL       MemoryCpy
    894            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[1]),   (uint8_t*)&gOpt.hdr.u8Prefix[1]        ,sizeof(gOpt.hdr.u8Prefix[1]));
   \   00000010   0x2201             MOVS     R2,#+1
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable31_32
   \   00000016   0x....             LDR.N    R0,??DataTable19_1
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x1D00             ADDS     R0,R0,#+4
   \   0000001C   0x.... 0x....      BL       MemoryCpy
    895            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[2]),   (uint8_t*)&gOpt.hdr.u8Prefix[2]        ,sizeof(gOpt.hdr.u8Prefix[2]));
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable31_33
   \   00000026   0x....             LDR.N    R0,??DataTable19_1
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x1D40             ADDS     R0,R0,#+5
   \   0000002C   0x.... 0x....      BL       MemoryCpy
    896            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[3]),   (uint8_t*)&gOpt.hdr.u8Length           ,sizeof(gOpt.hdr.u8Length   ));
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable31_34
   \   00000036   0x....             LDR.N    R0,??DataTable19_1
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x1D80             ADDS     R0,R0,#+6
   \   0000003C   0x.... 0x....      BL       MemoryCpy
    897            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[4]),   (uint8_t*)&gOpt.hdr.u16SensorID        ,sizeof(gOpt.hdr.u16SensorID));
   \   00000040   0x2202             MOVS     R2,#+2
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable31_35
   \   00000046   0x....             LDR.N    R0,??DataTable19_1
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x1DC0             ADDS     R0,R0,#+7
   \   0000004C   0x.... 0x....      BL       MemoryCpy
    898            
    899            
    900            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[6]),   (uint8_t*)&gOpt.options.u8RawSpinCount        ,sizeof(gOpt.options.u8RawSpinCount    ));   // updated *** 06/08/11 *** (formerly "u8Reserved1")
   \   00000050   0x2201             MOVS     R2,#+1
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable31_36
   \   00000056   0x....             LDR.N    R0,??DataTable19_1
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x3009             ADDS     R0,R0,#+9
   \   0000005C   0x.... 0x....      BL       MemoryCpy
    901            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[7]),   (uint8_t*)&gOpt.options.u16TimeoutsToKill     ,sizeof(gOpt.options.u16TimeoutsToKill ));
   \   00000060   0x2202             MOVS     R2,#+2
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable31_37
   \   00000066   0x....             LDR.N    R0,??DataTable19_1
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x300A             ADDS     R0,R0,#+10
   \   0000006C   0x.... 0x....      BL       MemoryCpy
    902            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[9]),   (uint8_t*)&gOpt.options.u16SampleSize         ,sizeof(gOpt.options.u16SampleSize     ));
   \   00000070   0x2202             MOVS     R2,#+2
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable31_38
   \   00000076   0x....             LDR.N    R0,??DataTable19_1
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x300C             ADDS     R0,R0,#+12
   \   0000007C   0x.... 0x....      BL       MemoryCpy
    903            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[11]),   (uint8_t*)&gOpt.options.bAsciiMode            ,sizeof(gOpt.options.bAsciiMode        ));
   \   00000080   0x2201             MOVS     R2,#+1
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable31_39
   \   00000086   0x....             LDR.N    R0,??DataTable19_1
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0x300E             ADDS     R0,R0,#+14
   \   0000008C   0x.... 0x....      BL       MemoryCpy
    904            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[12]),   (uint8_t*)&gOpt.options.bBlinkingLEDs         ,sizeof(gOpt.options.bBlinkingLEDs     ));
   \   00000090   0x2201             MOVS     R2,#+1
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable31_40
   \   00000096   0x....             LDR.N    R0,??DataTable19_1
   \   00000098   0x6800             LDR      R0,[R0, #+0]
   \   0000009A   0x300F             ADDS     R0,R0,#+15
   \   0000009C   0x.... 0x....      BL       MemoryCpy
    905            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[13]),  (uint8_t*)&gOpt.options.u8OutputPower         ,sizeof(gOpt.options.u8OutputPower     ));
   \   000000A0   0x2201             MOVS     R2,#+1
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable31_41
   \   000000A6   0x....             LDR.N    R0,??DataTable19_1
   \   000000A8   0x6800             LDR      R0,[R0, #+0]
   \   000000AA   0x3010             ADDS     R0,R0,#+16
   \   000000AC   0x.... 0x....      BL       MemoryCpy
    906            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[14]),  (uint8_t*)&gOpt.options.u32PngTimeout         ,sizeof(gOpt.options.u32PngTimeout     ));
   \   000000B0   0x2204             MOVS     R2,#+4
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable31_42
   \   000000B6   0x....             LDR.N    R0,??DataTable19_1
   \   000000B8   0x6800             LDR      R0,[R0, #+0]
   \   000000BA   0x3011             ADDS     R0,R0,#+17
   \   000000BC   0x.... 0x....      BL       MemoryCpy
    907            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[18]),  (uint8_t*)&gOpt.options.u32SndTimeout         ,sizeof(gOpt.options.u32SndTimeout     ));
   \   000000C0   0x2204             MOVS     R2,#+4
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable31_43
   \   000000C6   0x....             LDR.N    R0,??DataTable19_1
   \   000000C8   0x6800             LDR      R0,[R0, #+0]
   \   000000CA   0x3015             ADDS     R0,R0,#+21
   \   000000CC   0x.... 0x....      BL       MemoryCpy
    908            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[22]),  (uint8_t*)&gOpt.options.bLNAHighGainMode      ,sizeof(gOpt.options.bLNAHighGainMode  )); // i.e. Low Noise Amplifier - updated *** 10/26/10 *** (formerly "u8Reserved2")
   \   000000D0   0x2201             MOVS     R2,#+1
   \   000000D2   0x.... 0x....      LDR.W    R1,??DataTable31_44
   \   000000D6   0x....             LDR.N    R0,??DataTable19_1
   \   000000D8   0x6800             LDR      R0,[R0, #+0]
   \   000000DA   0x3019             ADDS     R0,R0,#+25
   \   000000DC   0x.... 0x....      BL       MemoryCpy
    909            MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[23]),  (uint8_t*)&gOpt.options.u16SleepAfterAck      ,sizeof(gOpt.options.u16SleepAfterAck  ));
   \   000000E0   0x2202             MOVS     R2,#+2
   \   000000E2   0x.... 0x....      LDR.W    R1,??DataTable31_45
   \   000000E6   0x....             LDR.N    R0,??DataTable19_1
   \   000000E8   0x6800             LDR      R0,[R0, #+0]
   \   000000EA   0x301A             ADDS     R0,R0,#+26
   \   000000EC   0x.... 0x....      BL       MemoryCpy
    910            gAppTxPacket->u8DataLength = OPT_SIZE;
   \   000000F0   0x2019             MOVS     R0,#+25
   \   000000F2   0x....             LDR.N    R1,??DataTable19_1
   \   000000F4   0x6809             LDR      R1,[R1, #+0]
   \   000000F6   0x7008             STRB     R0,[R1, #+0]
    911            
    912          }
   \   000000F8   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    913          smacErrors_t SendASCIIPacket(){
   \                     SendASCIIPacket: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB094             SUB      SP,SP,#+80
    914            InitPacket();
   \   00000004   0x.... 0x....      BL       InitPacket
    915            gSnd.packetID=sentPackets;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable31_46
   \   0000000C   0x8800             LDRH     R0,[R0, #+0]
   \   0000000E   0x....             LDR.N    R1,??DataTable19_5
   \   00000010   0x80C8             STRH     R0,[R1, #+6]
    916            int len = sprintf(&gAppTxPacket->smacPdu.u8Data[0],
    917                      "SND\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%d\t%u\t%d\t%u\t%u\t%u\t%u\t%u\r\n",
    918                      gSnd.hdr.u16SensorID, gSnd.packetID,
    919                      gSnd.xmin, gSnd.xmax, gSnd.xmean,
    920                      gSnd.ymin, gSnd.ymax, gSnd.ymean, 
    921                      gSnd.ysum0, gSnd.ysum1,
    922                      gSnd.zmin, gSnd.zmax, gSnd.zmean,
    923                      gSnd.temperature, gSnd.battery_mV, gSnd.linkQdBm,
    924                      gSnd.totalTimeouts, gSnd.maxMissedCount,
    925                      gSnd.voltageWarning, gSnd.channel, gSnd.version);
   \   00000012   0x....             LDR.N    R0,??DataTable19_5
   \   00000014   0xF890 0x0044      LDRB     R0,[R0, #+68]
   \   00000018   0x9012             STR      R0,[SP, #+72]
   \   0000001A   0x....             LDR.N    R0,??DataTable19_5
   \   0000001C   0xF890 0x0043      LDRB     R0,[R0, #+67]
   \   00000020   0x9011             STR      R0,[SP, #+68]
   \   00000022   0x....             LDR.N    R0,??DataTable19_5
   \   00000024   0xF890 0x0042      LDRB     R0,[R0, #+66]
   \   00000028   0x9010             STR      R0,[SP, #+64]
   \   0000002A   0x....             LDR.N    R0,??DataTable19_5
   \   0000002C   0xF8B0 0x0040      LDRH     R0,[R0, #+64]
   \   00000030   0x900F             STR      R0,[SP, #+60]
   \   00000032   0x....             LDR.N    R0,??DataTable19_5
   \   00000034   0x8FC0             LDRH     R0,[R0, #+62]
   \   00000036   0x900E             STR      R0,[SP, #+56]
   \   00000038   0x....             LDR.N    R0,??DataTable19_5
   \   0000003A   0xF990 0x003C      LDRSB    R0,[R0, #+60]
   \   0000003E   0x900D             STR      R0,[SP, #+52]
   \   00000040   0x....             LDR.N    R0,??DataTable19_5
   \   00000042   0x8F40             LDRH     R0,[R0, #+58]
   \   00000044   0x900C             STR      R0,[SP, #+48]
   \   00000046   0x....             LDR.N    R0,??DataTable19_5
   \   00000048   0xF9B0 0x0038      LDRSH    R0,[R0, #+56]
   \   0000004C   0x900B             STR      R0,[SP, #+44]
   \   0000004E   0x....             LDR.N    R0,??DataTable19_5
   \   00000050   0x8D80             LDRH     R0,[R0, #+44]
   \   00000052   0x900A             STR      R0,[SP, #+40]
   \   00000054   0x....             LDR.N    R0,??DataTable19_5
   \   00000056   0x8D40             LDRH     R0,[R0, #+42]
   \   00000058   0x9009             STR      R0,[SP, #+36]
   \   0000005A   0x....             LDR.N    R0,??DataTable19_5
   \   0000005C   0x8D00             LDRH     R0,[R0, #+40]
   \   0000005E   0x9008             STR      R0,[SP, #+32]
   \   00000060   0x....             LDR.N    R0,??DataTable19_5
   \   00000062   0x6A40             LDR      R0,[R0, #+36]
   \   00000064   0x9007             STR      R0,[SP, #+28]
   \   00000066   0x....             LDR.N    R0,??DataTable19_5
   \   00000068   0x6A00             LDR      R0,[R0, #+32]
   \   0000006A   0x9006             STR      R0,[SP, #+24]
   \   0000006C   0x....             LDR.N    R0,??DataTable19_5
   \   0000006E   0x8B80             LDRH     R0,[R0, #+28]
   \   00000070   0x9005             STR      R0,[SP, #+20]
   \   00000072   0x....             LDR.N    R0,??DataTable19_5
   \   00000074   0x8B40             LDRH     R0,[R0, #+26]
   \   00000076   0x9004             STR      R0,[SP, #+16]
   \   00000078   0x....             LDR.N    R0,??DataTable19_5
   \   0000007A   0x8B00             LDRH     R0,[R0, #+24]
   \   0000007C   0x9003             STR      R0,[SP, #+12]
   \   0000007E   0x....             LDR.N    R0,??DataTable19_5
   \   00000080   0x8980             LDRH     R0,[R0, #+12]
   \   00000082   0x9002             STR      R0,[SP, #+8]
   \   00000084   0x....             LDR.N    R0,??DataTable19_5
   \   00000086   0x8940             LDRH     R0,[R0, #+10]
   \   00000088   0x9001             STR      R0,[SP, #+4]
   \   0000008A   0x....             LDR.N    R0,??DataTable19_5
   \   0000008C   0x8900             LDRH     R0,[R0, #+8]
   \   0000008E   0x9000             STR      R0,[SP, #+0]
   \   00000090   0x....             LDR.N    R0,??DataTable19_5
   \   00000092   0x88C3             LDRH     R3,[R0, #+6]
   \   00000094   0x....             LDR.N    R0,??DataTable19_5
   \   00000096   0x8882             LDRH     R2,[R0, #+4]
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable31_47
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable31_48
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x1CC0             ADDS     R0,R0,#+3
   \   000000A4   0x.... 0x....      BL       sprintf
   \   000000A8   0x0004             MOVS     R4,R0
    926            gAppTxPacket->u8DataLength = len;
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable31_48
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0x7004             STRB     R4,[R0, #+0]
    927            smacErrors_t status=MCPSDataRequest(gAppTxPacket);    
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable31_48
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0x.... 0x....      BL       MCPSDataRequest
    928            return status;
   \   000000BC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BE   0xB014             ADD      SP,SP,#+80
   \   000000C0   0xBD10             POP      {R4,PC}          ;; return
    929              
    930          }

   \                                 In section .text, align 2, keep-with-next
    931          smacErrors_t SendBinaryPacket(){
   \                     SendBinaryPacket: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    932            //InitPacket();
    933            gSnd.packetID=sentPackets;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable31_46
   \   00000006   0x8800             LDRH     R0,[R0, #+0]
   \   00000008   0x....             LDR.N    R1,??DataTable19_5
   \   0000000A   0x80C8             STRH     R0,[R1, #+6]
    934            gSnd.linkQdBm=GetLinkQdBm();
   \   0000000C   0x.... 0x....      BL       GetLinkQdBm
   \   00000010   0x....             LDR.N    R1,??DataTable19_5
   \   00000012   0xF881 0x003C      STRB     R0,[R1, #+60]
    935            SndSwapEndianness();
   \   00000016   0x.... 0x....      BL       SndSwapEndianness
    936            CopyBinaryPacketToSMAC();  
   \   0000001A   0x.... 0x....      BL       CopyBinaryPacketToSMAC
    937            smacErrors_t status=MCPSDataRequest(gAppTxPacket);    
   \   0000001E   0x....             LDR.N    R0,??DataTable19_1
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x.... 0x....      BL       MCPSDataRequest
    938            appState = WAIT_FOR_ACK;
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable31_49
   \   0000002C   0x7011             STRB     R1,[R2, #+0]
    939            return status;
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0xBD02             POP      {R1,PC}          ;; return
    940          }
    941          

   \                                 In section .text, align 2, keep-with-next
    942          void InitPacket(){
    943            gSnd.hdr.u8Prefix[0] = 'S';
   \                     InitPacket: (+1)
   \   00000000   0x2053             MOVS     R0,#+83
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    944            gSnd.hdr.u8Prefix[1] = 'N';
   \   00000008   0x204E             MOVS     R0,#+78
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   0000000E   0x7048             STRB     R0,[R1, #+1]
    945            gSnd.hdr.u8Prefix[2] = 'D';       
   \   00000010   0x2044             MOVS     R0,#+68
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   00000016   0x7088             STRB     R0,[R1, #+2]
    946            gSnd.hdr.u8Length = SND_SIZE;
   \   00000018   0x203E             MOVS     R0,#+62
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   0000001E   0x70C8             STRB     R0,[R1, #+3]
    947            gSnd.hdr.u16SensorID = sensorID;  
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable31_51
   \   00000024   0x8800             LDRH     R0,[R0, #+0]
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   0000002A   0x8088             STRH     R0,[R1, #+4]
    948            
    949            gSnd.xsum0 = 1111111;
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable31_52  ;; 0x10f447
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   00000034   0x6108             STR      R0,[R1, #+16]
    950            gSnd.ysum0 = 2222222;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable31_53  ;; 0x21e88e
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   0000003E   0x6208             STR      R0,[R1, #+32]
    951            gSnd.zsum0 = 3333333;
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable31_54  ;; 0x32dcd5
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   00000048   0x6308             STR      R0,[R1, #+48]
    952            gSnd.xsum1 = 111111111;
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable31_55  ;; 0x69f6bc7
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   00000052   0x6148             STR      R0,[R1, #+20]
    953            gSnd.ysum1 = 222222222;
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable31_56  ;; 0xd3ed78e
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   0000005C   0x6248             STR      R0,[R1, #+36]
    954            gSnd.zsum1 = 333333333;
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable31_57  ;; 0x13de4355
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   00000066   0x6348             STR      R0,[R1, #+52]
    955            gSnd.xmin = 1000;
   \   00000068   0xF44F 0x707A      MOV      R0,#+1000
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   00000070   0x8108             STRH     R0,[R1, #+8]
    956            gSnd.ymin = 2000;
   \   00000072   0xF44F 0x60FA      MOV      R0,#+2000
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   0000007A   0x8308             STRH     R0,[R1, #+24]
    957            gSnd.zmin = 3000;
   \   0000007C   0xF640 0x30B8      MOVW     R0,#+3000
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   00000084   0x8508             STRH     R0,[R1, #+40]
    958            gSnd.xmax = 9991;
   \   00000086   0xF242 0x7007      MOVW     R0,#+9991
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   0000008E   0x8148             STRH     R0,[R1, #+10]
    959            gSnd.ymax = 9992;
   \   00000090   0xF242 0x7008      MOVW     R0,#+9992
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   00000098   0x8348             STRH     R0,[R1, #+26]
    960            gSnd.zmax = 9993;
   \   0000009A   0xF242 0x7009      MOVW     R0,#+9993
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   000000A2   0x8548             STRH     R0,[R1, #+42]
    961            gSnd.xmean = 111;
   \   000000A4   0x206F             MOVS     R0,#+111
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   000000AA   0x8188             STRH     R0,[R1, #+12]
    962            gSnd.ymean = 222;
   \   000000AC   0x20DE             MOVS     R0,#+222
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   000000B2   0x8388             STRH     R0,[R1, #+28]
    963            gSnd.zmean = 333;
   \   000000B4   0xF240 0x104D      MOVW     R0,#+333
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   000000BC   0x8588             STRH     R0,[R1, #+44]
    964            gSnd.packetID=666;
   \   000000BE   0xF240 0x209A      MOVW     R0,#+666
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   000000C6   0x80C8             STRH     R0,[R1, #+6]
    965            gSnd.temperature=375;
   \   000000C8   0xF240 0x1077      MOVW     R0,#+375
   \   000000CC   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   000000D0   0x8708             STRH     R0,[R1, #+56]
    966            gSnd.battery_mV=3000;
   \   000000D2   0xF640 0x30B8      MOVW     R0,#+3000
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   000000DA   0x8748             STRH     R0,[R1, #+58]
    967           // gSnd.linkQdBm=-75;
    968            gSnd.totalTimeouts=3;
   \   000000DC   0x2003             MOVS     R0,#+3
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   000000E2   0x87C8             STRH     R0,[R1, #+62]
    969            gSnd.maxMissedCount=3;
   \   000000E4   0x2003             MOVS     R0,#+3
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   000000EA   0xF8A1 0x0040      STRH     R0,[R1, #+64]
    970            gSnd.voltageWarning=2;
   \   000000EE   0x2002             MOVS     R0,#+2
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   000000F4   0xF881 0x0042      STRB     R0,[R1, #+66]
    971            gSnd.channel=gChannel11_c - 11;
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   000000FE   0xF881 0x0043      STRB     R0,[R1, #+67]
    972            gSnd.version=9;
   \   00000102   0x2009             MOVS     R0,#+9
   \   00000104   0x.... 0x....      LDR.W    R1,??DataTable31_50
   \   00000108   0xF881 0x0044      STRB     R0,[R1, #+68]
    973            
    974            evDataFromCOMM = FALSE;
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable31_58
   \   00000112   0x7008             STRB     R0,[R1, #+0]
    975          }
   \   00000114   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    976          void FlashSaveOptions(){
   \                     FlashSaveOptions: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
    977            
    978            uint32_t statErase, statRead, statWrite;
    979            NvConfig_t mNvConfig = {
    980             gNV_FTFX_REG_BASE_c,
    981             gNV_PFLASH_BLOCK_BASE_c,
    982             gNV_PFLASH_BLOCK_SIZE_c,
    983             gNV_DFLASH_BLOCK_BASE_c,
    984             gNV_DFLASH_BLOCK_SIZE_c,
    985             gNV_EERAM_BLOCK_BASE_c,
    986             gNV_EERAM_BLOCK_SIZE_c,
    987             gNV_EEE_BLOCK_SIZE_c
    988            };
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable31_59
   \   0000000A   0x2220             MOVS     R2,#+32
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy4
    989            gFlashDeadBeef=g_DEAD_BEEF;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable31_60
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable31_61
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    990            statErase = NV_FlashEraseSector(&mNvConfig, settingsAddress,0x800);
   \   0000001C   0xF44F 0x6200      MOV      R2,#+2048
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable31_62
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0xA800             ADD      R0,SP,#+0
   \   00000028   0x.... 0x....      BL       NV_FlashEraseSector
   \   0000002C   0x0004             MOVS     R4,R0
    991            uint32_t address = settingsAddress;
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable31_62
   \   00000032   0x6806             LDR      R6,[R0, #+0]
    992            statWrite = NV_FlashProgramLongword(&mNvConfig,settingsAddress,sizeof(gFlashDeadBeef),(uint32_t)&gFlashDeadBeef);
   \   00000034   0x.... 0x....      LDR.W    R3,??DataTable31_61
   \   00000038   0x2204             MOVS     R2,#+4
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable31_62
   \   0000003E   0x6801             LDR      R1,[R0, #+0]
   \   00000040   0xA800             ADD      R0,SP,#+0
   \   00000042   0x.... 0x....      BL       NV_FlashProgramLongword
   \   00000046   0x0005             MOVS     R5,R0
    993            address = address + sizeof(gFlashDeadBeef);
   \   00000048   0x1D36             ADDS     R6,R6,#+4
    994            if(statWrite ==gNV_OK_c) NV_FlashProgramUnalignedLongword(&mNvConfig,address,sizeof(gOptions),(uint32_t)&gOptions);
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD106             BNE.N    ??FlashSaveOptions_0
   \   0000004E   0x.... 0x....      LDR.W    R3,??DataTable31_63
   \   00000052   0x2218             MOVS     R2,#+24
   \   00000054   0x0031             MOVS     R1,R6
   \   00000056   0xA800             ADD      R0,SP,#+0
   \   00000058   0x.... 0x....      BL       NV_FlashProgramUnalignedLongword
    995          //  NV_FlashRead(address, (uint8_t*)&gFlashOptions,sizeof(gFlashOptions));
    996            
    997          }
   \                     ??FlashSaveOptions_0: (+1)
   \   0000005C   0xB008             ADD      SP,SP,#+32
   \   0000005E   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
    998          void GetFactoryOptions(tOptions* pOptions)
    999          {
   1000              // Load the factory default configuration options
   1001              pOptions->u8RawSpinCount = 0; // i.e., don't send raw accelerometer data - updated *** 06/08/11 ***
   \                     GetFactoryOptions: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7001             STRB     R1,[R0, #+0]
   1002              pOptions->u16TimeoutsToKill = TIMEOUTS_TO_KILL;
   \   00000004   0xF44F 0x71B4      MOV      R1,#+360
   \   00000008   0x8041             STRH     R1,[R0, #+2]
   1003              pOptions->u16SampleSize = ACCEL_SAMPLE_SIZE;
   \   0000000A   0xF44F 0x51FA      MOV      R1,#+8000
   \   0000000E   0x8081             STRH     R1,[R0, #+4]
   1004              pOptions->bAsciiMode = TRUE;
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x7181             STRB     R1,[R0, #+6]
   1005              pOptions->bBlinkingLEDs = TRUE;
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x71C1             STRB     R1,[R0, #+7]
   1006              pOptions->u8OutputPower = OUTPUT_POWER;
   \   00000018   0x2164             MOVS     R1,#+100
   \   0000001A   0x7201             STRB     R1,[R0, #+8]
   1007              pOptions->u32PngTimeout = PNG_TIMEOUT;
   \   0000001C   0xF248 0x01E8      MOVW     R1,#+33000
   \   00000020   0x60C1             STR      R1,[R0, #+12]
   1008              pOptions->u32SndTimeout = SND_TIMEOUT;
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable31_64  ;; 0x28488
   \   00000026   0x6101             STR      R1,[R0, #+16]
   1009          
   1010          // Updated *** 10/26/10 ***    
   1011          #if defined (PANASONIC_REVB)
   1012              pOptions->bLNAHighGainMode = TRUE;
   1013          #elif defined (PANASONIC_YES)
   1014              pOptions->bLNAHighGainMode = TRUE;
   1015          #else
   1016              pOptions->bLNAHighGainMode = FALSE; // Note: LNA isn't even available for PANASONIC_NO
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x7501             STRB     R1,[R0, #+20]
   1017          #endif
   1018          
   1019              pOptions->u16SleepAfterAck = SLEEP_AFTER_ACK;
   \   0000002C   0x2103             MOVS     R1,#+3
   \   0000002E   0x82C1             STRH     R1,[R0, #+22]
   1020              
   1021              return;
   \   00000030   0x4770             BX       LR               ;; return
   1022          }
   1023          
   1024          
   1025          
   1026          /************************************************************************************
   1027          * InitProject
   1028          * 
   1029          * Hardware and Global data initialization
   1030          *
   1031          ************************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1032          void InitProject(void)
   1033          {
   \                     InitProject: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
   1034              DisableInterrupts();
   \   00000006   0xB672             CPSID i
   1035             
   1036             gOpt.hdr.u8Prefix[0] = 'O';
   \   00000008   0x204F             MOVS     R0,#+79
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable31_65
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
   1037             gOpt.hdr.u8Prefix[1] = 'P';
   \   00000010   0x2050             MOVS     R0,#+80
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable31_65
   \   00000016   0x7048             STRB     R0,[R1, #+1]
   1038             gOpt.hdr.u8Prefix[2] = 'T';
   \   00000018   0x2054             MOVS     R0,#+84
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable31_65
   \   0000001E   0x7088             STRB     R0,[R1, #+2]
   1039             gOpt.hdr.u16SensorID = sensorID;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable31_51
   \   00000024   0x8800             LDRH     R0,[R0, #+0]
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable31_65
   \   0000002A   0x8088             STRH     R0,[R1, #+4]
   1040             gOpt.hdr.u8Length = OPT_SIZE;
   \   0000002C   0x2019             MOVS     R0,#+25
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable31_65
   \   00000032   0x70C8             STRB     R0,[R1, #+3]
   1041             
   1042             gPng.u8Prefix[0] = 'P';
   \   00000034   0x2050             MOVS     R0,#+80
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable31
   \   0000003A   0x7008             STRB     R0,[R1, #+0]
   1043             gPng.u8Prefix[1] = 'N';
   \   0000003C   0x204E             MOVS     R0,#+78
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable31
   \   00000042   0x7048             STRB     R0,[R1, #+1]
   1044             gPng.u8Prefix[2] = 'G';
   \   00000044   0x2047             MOVS     R0,#+71
   \   00000046   0x....             LDR.N    R1,??DataTable31
   \   00000048   0x7088             STRB     R0,[R1, #+2]
   1045             gPng.u16SensorID = sensorID;        // initialized via compiler settings (1 - 65534)
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable31_51
   \   0000004E   0x8800             LDRH     R0,[R0, #+0]
   \   00000050   0x....             LDR.N    R1,??DataTable31
   \   00000052   0x8088             STRH     R0,[R1, #+4]
   1046              
   1047              
   1048            // Bob's code
   1049             uint8_t u8Status;
   1050             uint8_t u8BlinkOnFirstAck = 1;
   \   00000054   0x2401             MOVS     R4,#+1
   1051             uint16_t sleepCount;
   1052             uint16_t missedCount = 0;
   \   00000056   0x2500             MOVS     R5,#+0
   1053            // Detect if we need a factory reset
   1054             uint32_t statErase, statWrite;
   1055             NvConfig_t mNvConfig = {
   1056             gNV_FTFX_REG_BASE_c,
   1057             gNV_PFLASH_BLOCK_BASE_c,
   1058             gNV_PFLASH_BLOCK_SIZE_c,
   1059             gNV_DFLASH_BLOCK_BASE_c,
   1060             gNV_DFLASH_BLOCK_SIZE_c,
   1061             gNV_EERAM_BLOCK_BASE_c,
   1062             gNV_EERAM_BLOCK_SIZE_c,
   1063             gNV_EEE_BLOCK_SIZE_c
   1064            };
   \   00000058   0xA800             ADD      R0,SP,#+0
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable31_66
   \   0000005E   0x2220             MOVS     R2,#+32
   \   00000060   0x.... 0x....      BL       __aeabi_memcpy4
   1065            NV_FlashInit(&mNvConfig);
   \   00000064   0xA800             ADD      R0,SP,#+0
   \   00000066   0x.... 0x....      BL       NV_FlashInit
   1066            static uint32_t sDeadBeef;
   1067          //   
   1068          //   statErase = NV_FlashEraseSector(&mNvConfig, settingsAddress,0x800);
   1069          //   statWrite = NV_FlashProgramLongword(&mNvConfig,settingsAddress,sizeof(sDeadBeef),(uint32_t)&sDeadBeef);
   1070             NV_FlashRead(settingsAddress,(uint8_t*)&gFlashDeadBeef,sizeof(gFlashDeadBeef));
   \   0000006A   0x2204             MOVS     R2,#+4
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable31_61
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable31_62
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0x.... 0x....      BL       NV_FlashRead
   1071             uint8_t bFactoryReset = (sDeadBeef == g_DEAD_BEEF) || (gFlashDeadBeef != g_DEAD_BEEF);
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable31_67
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable31_60
   \   00000084   0x6809             LDR      R1,[R1, #+0]
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xD007             BEQ.N    ??InitProject_0
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable31_61
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0x.... 0x....      LDR.W    R1,??DataTable31_60
   \   00000094   0x6809             LDR      R1,[R1, #+0]
   \   00000096   0x4288             CMP      R0,R1
   \   00000098   0xD001             BEQ.N    ??InitProject_1
   \                     ??InitProject_0: (+1)
   \   0000009A   0x2601             MOVS     R6,#+1
   \   0000009C   0xE000             B.N      ??InitProject_2
   \                     ??InitProject_1: (+1)
   \   0000009E   0x2600             MOVS     R6,#+0
   1072             sDeadBeef = g_DEAD_BEEF;
   \                     ??InitProject_2: (+1)
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable31_60
   \   000000A4   0x6800             LDR      R0,[R0, #+0]
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable31_67
   \   000000AA   0x6008             STR      R0,[R1, #+0]
   1073             if (bFactoryReset)
   \   000000AC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000AE   0x2E00             CMP      R6,#+0
   \   000000B0   0xD004             BEQ.N    ??InitProject_3
   1074             {
   1075                 GetFactoryOptions(&gOptions);
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable31_63
   \   000000B6   0x.... 0x....      BL       GetFactoryOptions
   \   000000BA   0xE008             B.N      ??InitProject_4
   1076             }
   1077             else
   1078             {
   1079           //      gOptions = gFlashOptions;      
   1080                NV_FlashRead(settingsAddress+sizeof(gFlashDeadBeef),(uint8_t*)&gOptions,sizeof(gOptions));
   \                     ??InitProject_3: (+1)
   \   000000BC   0x2218             MOVS     R2,#+24
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable31_63
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable31_62
   \   000000C6   0x6800             LDR      R0,[R0, #+0]
   \   000000C8   0x1D00             ADDS     R0,R0,#+4
   \   000000CA   0x.... 0x....      BL       NV_FlashRead
   1081             }
   1082            InitPacket(); 
   \                     ??InitProject_4: (+1)
   \   000000CE   0x.... 0x....      BL       InitPacket
   1083           
   1084            /* SPI Initialization */ 
   1085            MC1324xDrv_SPIInit(); 
   \   000000D2   0x.... 0x....      BL       MC1324xDrv_SPIInit
   1086            (void)MLMERadioInit();
   \   000000D6   0x.... 0x....      BL       MLMERadioInit
   \   000000DA   0x4680             MOV      R8,R0
   1087            /* TMR Initialization */
   1088            TMR_Init(); 
   \   000000DC   0x.... 0x....      BL       TMR_Init
   1089            MM_Init((uint8_t*)maMacHeap, poolInfo, maMmPools);
   \   000000E0   0x.... 0x....      LDR.W    R2,??DataTable31_68
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable31_69
   \   000000E8   0x.... 0x....      LDR.W    R0,??DataTable31_70
   \   000000EC   0x.... 0x....      BL       MM_Init
   1090            /*LED configuration*/
   1091            LED_Init();
   \   000000F0   0x.... 0x....      BL       LED_Init
   1092          #if defined(gCDCInterface_d)
   1093            USB_Init();
   1094            (void)CDC_ModuleInit();
   1095          #elif defined (gUARTInterface_d)
   1096            /* UART Initialization */
   1097            Uart_ModuleInit();
   \   000000F4   0x.... 0x....      BL       Uart_ModuleInit
   1098          #endif
   1099            Comm_SetBaud(Comm_DefaultBaud);
   \   000000F8   0xF45F 0x30E1      MOVS     R0,#+115200
   \   000000FC   0x.... 0x....      BL       Uart1_SetBaud
   1100            Comm_SetRxCallBack(CommRxCallback);
   \   00000100   0x.... 0x....      ADR.W    R0,CommRxCallback
   \   00000104   0x.... 0x....      BL       Uart1_SetRxCallBack
   1101          
   1102            /* Keyboard Initialization */
   1103            KeyboardInit();
   \   00000108   0x.... 0x....      BL       KeyboardInit
   1104            GlobalDataInit();  
   \   0000010C   0x.... 0x....      BL       GlobalDataInit
   1105            
   1106          
   1107          //  evDataFromCOMM = FALSE;
   1108            
   1109            EnableInterrupts();
   \   00000110   0xB662             CPSIE i
   1110            int count = 10;
   \   00000112   0x270A             MOVS     R7,#+10
   1111            while (count--)
   \                     ??InitProject_5: (+1)
   \   00000114   0x0038             MOVS     R0,R7
   \   00000116   0x1E47             SUBS     R7,R0,#+1
   \   00000118   0x2800             CMP      R0,#+0
   \   0000011A   0xD005             BEQ.N    ??InitProject_6
   1112            {
   1113                uint16_t innerCount = 0;        
   \   0000011C   0x2000             MOVS     R0,#+0
   1114                while (--innerCount);
   \                     ??InitProject_7: (+1)
   \   0000011E   0x1E40             SUBS     R0,R0,#+1
   \   00000120   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000122   0x2800             CMP      R0,#+0
   \   00000124   0xD1FB             BNE.N    ??InitProject_7
   \   00000126   0xE7F5             B.N      ??InitProject_5
   1115            }
   1116            FlashSaveOptions();
   \                     ??InitProject_6: (+1)
   \   00000128   0x.... 0x....      BL       FlashSaveOptions
   1117            sDeadBeef = 0;
   \   0000012C   0x2000             MOVS     R0,#+0
   \   0000012E   0x.... 0x....      LDR.W    R1,??DataTable31_67
   \   00000132   0x6008             STR      R0,[R1, #+0]
   1118           //  
   1119           //  // Initialize options.
   1120           //  // NOTE: we can't write to FLASH memory yet ("AppInit" not called yet, clock, etc),
   1121           //  // so we don't call "FlashSaveOptions" yet.
   1122             
   1123             
   1124             
   1125             
   1126          }
   \   00000134   0xB008             ADD      SP,SP,#+32
   \   00000136   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .bss, align 4
   \                     ??sDeadBeef:
   \   00000000                      DS8 4

   \                                 In section .text, align 2, keep-with-next
   1127          void GlobalDataInit(void)
   1128          {
   1129            /*Global Data init*/
   1130            testOpMode     = gDefaultMode_c;
   \                     GlobalDataInit: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable31_71
   \   00000006   0x7008             STRB     R0,[R1, #+0]
   1131            testChannel    = gDefaultChannelNumber_c;
   \   00000008   0x200F             MOVS     R0,#+15
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable31_72
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
   1132            testPower      = gDefaultOutputPower_c;
   \   00000010   0x2017             MOVS     R0,#+23
   \   00000012   0x....             LDR.N    R1,??DataTable31_73
   \   00000014   0x7008             STRB     R0,[R1, #+0]
   1133            testTrimmValue = gDefaultCrysTrim_c;
   \   00000016   0x2073             MOVS     R0,#+115
   \   00000018   0x....             LDR.N    R1,??DataTable31_74
   \   0000001A   0x7008             STRB     R0,[R1, #+0]
   1134            testPayloadLen = gDefaultPayload_c;
   \   0000001C   0x2014             MOVS     R0,#+20
   \   0000001E   0x....             LDR.N    R1,??DataTable31_75
   \   00000020   0x7008             STRB     R0,[R1, #+0]
   1135            contTestRunning = gTestModeForceIdle_c;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x....             LDR.N    R1,??DataTable31_76
   \   00000026   0x7008             STRB     R0,[R1, #+0]
   1136            shortCutsEnabled = FALSE; 
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x....             LDR.N    R1,??DataTable31_77
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
   1137            connState      = gConnInitState_c;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x....             LDR.N    R1,??DataTable31_78
   \   00000032   0x7008             STRB     R0,[R1, #+0]
   1138            cTxRxState     = gCTxRxStateInit_c;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x....             LDR.N    R1,??DataTable31_79
   \   00000038   0x7008             STRB     R0,[R1, #+0]
   1139            perTxState     = gPerTxStateInit_c;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x....             LDR.N    R1,??DataTable31_80
   \   0000003E   0x7008             STRB     R0,[R1, #+0]
   1140            perRxState     = gPerRxStateInit_c;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x....             LDR.N    R1,??DataTable31_81
   \   00000044   0x7008             STRB     R0,[R1, #+0]
   1141            rangeTxState   = gRangeTxStateInit_c;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x....             LDR.N    R1,??DataTable31_82
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
   1142            rangeRxState   = gRangeRxStateInit_c;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x....             LDR.N    R1,??DataTable31_83
   \   00000050   0x7008             STRB     R0,[R1, #+0]
   1143            prevOpMode      = gDefaultMode_c;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x....             LDR.N    R1,??DataTable31_84
   \   00000056   0x7008             STRB     R0,[R1, #+0]
   1144            txTestIndex    = gPacketErrorRateTx_c;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x....             LDR.N    R1,??DataTable31_85
   \   0000005C   0x7008             STRB     R0,[R1, #+0]
   1145            rxTestIndex    = gPacketErrorRateRx_c;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x....             LDR.N    R1,??DataTable31_86
   \   00000062   0x7008             STRB     R0,[R1, #+0]
   1146          }
   \   00000064   0x4770             BX       LR               ;; return
   1147          /**************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1148          void InitSmac(void)
   1149          {
   \                     InitSmac: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1150            gAppTxPacket = (txPacket_t*)gau8TxDataBuffer;
   \   00000002   0x....             LDR.N    R0,??DataTable31_87
   \   00000004   0x....             LDR.N    R1,??DataTable25
   \   00000006   0x6008             STR      R0,[R1, #+0]
   1151            gAppRxPacket = (rxPacket_t*)gau8RxDataBuffer; 
   \   00000008   0x....             LDR.N    R0,??DataTable31_88
   \   0000000A   0x....             LDR.N    R1,??DataTable31_89
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   1152            gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
   \   0000000E   0x207B             MOVS     R0,#+123
   \   00000010   0x....             LDR.N    R1,??DataTable31_89
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x7008             STRB     R0,[R1, #+0]
   1153            
   1154            MLMESetPromiscuousMode(gPromiscuousMode_d); 
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      BL       MLMESetPromiscuousMode
   1155            (void)MLMESetChannelRequest(testChannel);
   \   0000001C   0x....             LDR.N    R0,??DataTable31_72
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x.... 0x....      BL       MLMESetChannelRequest
   \   00000024   0x0004             MOVS     R4,R0
   1156            (void)MLMEPAOutputAdjust(testPower);
   \   00000026   0x....             LDR.N    R0,??DataTable31_73
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x.... 0x....      BL       MLMEPAOutputAdjust
   \   0000002E   0x0005             MOVS     R5,R0
   1157            (void)MLMEXtalAdjust(testTrimmValue); 
   \   00000030   0x....             LDR.N    R0,??DataTable31_74
   \   00000032   0x7800             LDRB     R0,[R0, #+0]
   \   00000034   0x.... 0x....      BL       MLMEXtalAdjust
   1158          }
   \   00000038   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1159          
   1160          /**************************************************************************************/
   1161          void SerialUIStateMachine(void)
   1162          {
   1163            if((gConnSelectTest_c == connState) && evTestParameters)
   1164            {
   1165              (void)MLMESetChannelRequest(testChannel);
   1166              (void)MLMEPAOutputAdjust(testPower);
   1167              (void)MLMEXtalAdjust(testTrimmValue);
   1168              PrintTestParameters(TRUE);
   1169              evTestParameters = FALSE;
   1170            }
   1171            switch(connState){
   1172              case gConnIdleState_c:
   1173                 PrintMenu(cu8MainMenu, gDefaultCommPort_c);
   1174                 PrintTestParameters(FALSE);
   1175                 shortCutsEnabled = TRUE;           
   1176                 connState = gConnSelectTest_c;
   1177              break;
   1178              case gConnSelectTest_c:
   1179               if(evDataFromCOMM){
   1180                 if('1' == gu8CommData){
   1181                   cTxRxState = gCTxRxStateInit_c;
   1182                   connState = gConnContinuousTxRxState_c;
   1183                 }else if('2' == gu8CommData){
   1184                   perTxState = gPerTxStateInit_c;
   1185                   perRxState = gPerRxStateInit_c;
   1186                   connState = gConnPerState_c;
   1187                 }else if('3' == gu8CommData){
   1188                   rangeTxState = gRangeTxStateInit_c;
   1189                   rangeRxState = gRangeRxStateInit_c;
   1190                   connState = gConnRangeState_c;
   1191                 }else if('4' == gu8CommData){
   1192                   eRState = gERStateInit_c;
   1193                   connState = gConnRegEditState_c;
   1194                 }
   1195                 evDataFromCOMM = FALSE;
   1196               }
   1197              break;
   1198              case gConnContinuousTxRxState_c:
   1199                 if(SerialContinuousTxRxTest()) {
   1200                     connState = gConnIdleState_c;
   1201                 }
   1202              break;
   1203              case gConnPerState_c:
   1204                 if(mTxOperation_c == testOpMode){
   1205                   if(PacketErrorRateTx()){
   1206                     connState = gConnIdleState_c;
   1207                   }
   1208                 }else{
   1209                   if(PacketErrorRateRx()){
   1210                     connState = gConnIdleState_c;
   1211                   }
   1212                 }
   1213              break;
   1214              case gConnRangeState_c:
   1215                 if(mTxOperation_c == testOpMode){
   1216                   if(RangeTx()){
   1217                     connState = gConnIdleState_c;
   1218                   }
   1219                 }else{
   1220                   if(RangeRx()){
   1221                     connState = gConnIdleState_c;
   1222                   }
   1223                 }
   1224              break;
   1225              case gConnRegEditState_c:
   1226                 if(EditRegisters()) {
   1227                     connState = gConnIdleState_c;
   1228                 }
   1229              break;
   1230              default:
   1231              break;
   1232              
   1233            }
   1234            if(prevOpMode != testOpMode){
   1235              perTxState = gPerTxStateInit_c;
   1236              perRxState = gPerRxStateInit_c;
   1237              rangeTxState = gRangeTxStateInit_c;
   1238              rangeRxState = gRangeRxStateInit_c;
   1239              prevOpMode = testOpMode;
   1240            }
   1241          }
   1242          
   1243          
   1244          /**************************************************************************************/
   1245          bool_t SerialContinuousTxRxTest(void)
   1246          {
   1247            bool_t bBackFlag = FALSE;
   1248            smacErrors_t smacResult;
   1249            uint8_t u8Index, u8TempEnergyValue;
   1250            
   1251            if(evTestParameters)
   1252            {
   1253              (void)MLMERXDisableRequest();
   1254              (void)MLMETestMode(gTestModeForceIdle_c);
   1255              (void)MLMESetChannelRequest(testChannel);
   1256              (void)MLMEPAOutputAdjust(testPower);
   1257              (void)MLMEXtalAdjust(testTrimmValue);
   1258              
   1259              if(gCTxRxStateSelectTest_c == cTxRxState){
   1260                PrintTestParameters(TRUE);
   1261              }else{
   1262                PrintTestParameters(FALSE);
   1263                CommUtil_Print("\r\n", gAllowToBlock_d);     
   1264              }
   1265              
   1266              if(gTestModePRBS9_c == contTestRunning){
   1267                (void)MLMETestMode(gTestModePRBS9_c);
   1268              }else if(gTestModeContinuousTxModulated_c == contTestRunning){
   1269                (void)MLMETestMode(gTestModeContinuousTxModulated_c);
   1270              }else if(gTestModeContinuousTxUnmodulated_c == contTestRunning){
   1271                (void)MLMETestMode(gTestModeContinuousTxUnmodulated_c);
   1272              }
   1273              
   1274              if(gCTxRxStateRunnigRxTest_c == cTxRxState){
   1275                bRxDone = FALSE;
   1276                gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
   1277                (void)MLMERXEnableRequest(gAppRxPacket, 0);
   1278              }
   1279              evTestParameters = FALSE;
   1280            }
   1281            
   1282            switch(cTxRxState)
   1283            {
   1284              case gCTxRxStateIdle_c:
   1285                   if((evDataFromCOMM) && ('\r' == gu8CommData))
   1286                   {
   1287                     cTxRxState = gCTxRxStateInit_c;
   1288                     evDataFromCOMM = FALSE;  
   1289                   }
   1290              break;
   1291              case gCTxRxStateInit_c:
   1292                   PrintMenu(cu8ShortCutsBar, gDefaultCommPort_c);
   1293                   PrintMenu(cu8ContinuousTestMenu, gDefaultCommPort_c);
   1294                   
   1295                   (void)MLMETestMode(gTestModeForceIdle_c);  
   1296                   
   1297                   while(MLMESetChannelRequest(testChannel)); 
   1298                   
   1299                   (void)MLMETestMode(contTestRunning);
   1300                   CommUtil_Print(cu8ContinuousTestTags[contTestRunning], gAllowToBlock_d);
   1301                   CommUtil_Print("\r\n\r\n", gAllowToBlock_d);       
   1302                   PrintTestParameters(FALSE);
   1303                   shortCutsEnabled = TRUE;           
   1304                   cTxRxState = gCTxRxStateSelectTest_c; 
   1305              break;
   1306              case gCTxRxStateSelectTest_c:
   1307                   if(evDataFromCOMM)
   1308                   {           
   1309                     if('1' == gu8CommData){
   1310                       contTestRunning = gTestModeForceIdle_c;              
   1311                       cTxRxState = gCTxRxStateInit_c;
   1312                     }else if('2' == gu8CommData){
   1313                       contTestRunning = gTestModePRBS9_c;               
   1314                       cTxRxState = gCTxRxStateInit_c;
   1315                     }else if('3' == gu8CommData){
   1316                       contTestRunning = gTestModeContinuousTxModulated_c;               
   1317                       cTxRxState = gCTxRxStateInit_c;
   1318                     }else if('4' == gu8CommData){
   1319                       if(gTestModeContinuousTxUnmodulated_c != contTestRunning) 
   1320                       { 
   1321                        contTestRunning = gTestModeContinuousTxUnmodulated_c;               
   1322                        cTxRxState = gCTxRxStateInit_c;
   1323                       }
   1324                     }else if('5' == gu8CommData)
   1325                     {
   1326                       (void)MLMETestMode(gTestModeForceIdle_c);     
   1327                       contTestRunning = gTestModeForceIdle_c;
   1328                       CommUtil_Print("\f\r\nPress [p] to stop receiving promiscuous packets \r\n", gAllowToBlock_d);
   1329                              
   1330                       MLMESetPromiscuousMode(TRUE);    
   1331                       
   1332                       bRxDone = FALSE;
   1333                       gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
   1334                       (void)MLMERXEnableRequest(gAppRxPacket, 0);
   1335                       cTxRxState = gCTxRxStateRunnigRxTest_c;
   1336                     }else if('6' == gu8CommData){
   1337                       (void)MLMETestMode(gTestModeForceIdle_c);
   1338                       contTestRunning = gTestModeForceIdle_c;
   1339                       CommUtil_Print("\f\r\nPress [p] to stop the Continuous ED test\r\n", gAllowToBlock_d);
   1340                       contTestRunning = gTestModeForceIdle_c;                
   1341                       cTxRxState = gCTxRxStateRunnigEdTest_c;
   1342                     }else if('7' == gu8CommData){
   1343                       (void)MLMETestMode(gTestModeForceIdle_c);
   1344                       contTestRunning = gTestModeForceIdle_c;
   1345                       CommUtil_Print("\f\r\nPress [p] to stop the Continuous SCAN test\r\n", gAllowToBlock_d);
   1346                       bScanDone = FALSE;
   1347                       smacResult = MLMEScanRequest(0xFFFF, gScanModeED_c, au8ScanResults);
   1348                       (void)smacResult;
   1349                       contTestRunning = gTestModeForceIdle_c;                
   1350                       cTxRxState = gCTxRxStateRunnigScanTest_c;
   1351                     }else if('p' == gu8CommData){ 
   1352                       (void)MLMETestMode(gTestModeForceIdle_c);
   1353                       (void)MLMESetChannelRequest(testChannel);
   1354                       bBackFlag = TRUE;
   1355                     }
   1356                     evDataFromCOMM = FALSE;
   1357                   }
   1358              break;
   1359              case gCTxRxStateRunnigRxTest_c:
   1360                   if(bRxDone){
   1361                     if (gAppRxPacket->rxStatus == rxSuccessStatus_c){
   1362                       CommUtil_Print("New Packet: ", gAllowToBlock_d);
   1363                       for(u8Index = 0; u8Index < (gAppRxPacket->u8DataLength); u8Index++){
   1364                         PrintByteOnHexFormatBlocking(gAppRxPacket->smacPdu.u8Data[u8Index], TRUE, gAllowToBlock_d);
   1365                       }
   1366                       CommUtil_Print("\b \r\n", gAllowToBlock_d);
   1367                     }
   1368                     bRxDone = FALSE;
   1369                     gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
   1370                     (void)MLMERXEnableRequest(gAppRxPacket, 0);
   1371                   }
   1372                   if((evDataFromCOMM) && ('p' == gu8CommData)){
   1373                     (void)MLMERXDisableRequest();
   1374                     (void)MLMETestMode(gTestModeForceIdle_c);
   1375                     MLMESetPromiscuousMode(FALSE);
   1376                     CommUtil_Print("\r\n\r\n Press [enter] to go back to the Continuous test menu ", gAllowToBlock_d);
   1377                     cTxRxState = gCTxRxStateIdle_c;
   1378                     evDataFromCOMM = FALSE;
   1379                   }
   1380              break;
   1381              case gCTxRxStateRunnigEdTest_c:
   1382                   delayMs(100);delayMs(100);
   1383                   CommUtil_Print("Energy on the Channel ", gAllowToBlock_d);
   1384                   PrintWordOnDecimalFormatBlocking((uint16_t)testChannel, 0, FALSE, gDefaultCommPort_c);
   1385                   CommUtil_Print(" : ", gAllowToBlock_d);
   1386                   (void)MLMEEnergyDetect(&u8TempEnergyValue);
   1387                   PrintWordOnDecimalFormatBlocking(u8TempEnergyValue,0,TRUE, gDefaultCommPort_c);
   1388                   CommUtil_Print("dBm\r\n", gAllowToBlock_d);
   1389                   if((evDataFromCOMM) && ('p' == gu8CommData)){
   1390                     CommUtil_Print("\r\n\r\n Press [enter] to go back to the Continuous test menu ", gAllowToBlock_d);
   1391                     cTxRxState = gCTxRxStateIdle_c;
   1392                     evDataFromCOMM = FALSE;
   1393                   }
   1394              break;
   1395              case gCTxRxStateRunnigScanTest_c:
   1396                   if(bScanDone){
   1397                     CommUtil_Print("Results : ", gAllowToBlock_d);
   1398                     for(u8Index = 0; u8Index < 16 ; u8Index++){
   1399                       PrintWordOnDecimalFormatBlocking((uint16_t)(au8ScanResults[u8Index]),0,TRUE, gDefaultCommPort_c);
   1400                       CommUtil_Print(",", gAllowToBlock_d);   
   1401                     }
   1402                     CommUtil_Print("\b \r\n", gAllowToBlock_d);
   1403                     if((evDataFromCOMM) && ('p' == gu8CommData)){
   1404                       CommUtil_Print("\r\n\r\n Press [enter] to go back to the Continuous test menu ", gAllowToBlock_d);
   1405                       cTxRxState = gCTxRxStateIdle_c;
   1406                       evDataFromCOMM = FALSE;
   1407                     }else{
   1408                       delayMs(100);delayMs(100);delayMs(50);
   1409                       bScanDone = FALSE;
   1410                       smacResult = MLMEScanRequest(0xFFFF, gScanModeED_c, au8ScanResults);
   1411                     }
   1412                   }
   1413              break;
   1414              default:
   1415              break;
   1416            }
   1417            return bBackFlag;
   1418          }
   1419          
   1420          /**************************************************************************************/
   1421          bool_t PacketErrorRateTx(void)
   1422          {
   1423            const uint16_t u16TotalPacketsOptions[] = {1,25,100,500,1000,2000,5000,10000,65535};
   1424            static uint16_t u16TotalPackets;
   1425            static uint16_t u16SentPackets;
   1426            uint8_t u8Index;
   1427            bool_t bBackFlag = FALSE;
   1428            
   1429            if(evTestParameters)
   1430            {
   1431              (void)MLMERXDisableRequest();
   1432              (void)MLMESetChannelRequest(testChannel);
   1433              (void)MLMEPAOutputAdjust(testPower);
   1434              (void)MLMEXtalAdjust(testTrimmValue);
   1435              PrintTestParameters(TRUE);
   1436              evTestParameters = FALSE;
   1437            }
   1438            
   1439            switch(perTxState)
   1440            {
   1441              case gPerTxStateInit_c:
   1442                     PrintMenu(cu8ShortCutsBar, gDefaultCommPort_c);
   1443                     PrintMenu(cu8PerTxTestMenu, gDefaultCommPort_c);
   1444                     PrintTestParameters(FALSE);
   1445                     shortCutsEnabled = TRUE;           
   1446                     perTxState = gPerTxStateSelectPacketNum_c;        
   1447              break;
   1448              case gPerTxStateSelectPacketNum_c:
   1449                   if(evDataFromCOMM){
   1450                     if((gu8CommData >= '0') && (gu8CommData <= '8')){
   1451                       u16TotalPackets = u16TotalPacketsOptions[gu8CommData - '0'];
   1452                       shortCutsEnabled = FALSE;  
   1453                       perTxState = gPerTxStateStartTest_c;
   1454                  }else if('p' == gu8CommData){ 
   1455                       bBackFlag = TRUE;
   1456                     }
   1457          			 evDataFromCOMM = FALSE;
   1458                   }
   1459              break;
   1460              case gPerTxStateStartTest_c:
   1461                   gAppTxPacket->u8DataLength = testPayloadLen;
   1462                   u16SentPackets = 0;
   1463                   gAppTxPacket->smacPdu.u8Data[0] = (u16TotalPackets >> 8);
   1464                   gAppTxPacket->smacPdu.u8Data[1] = (uint8_t)u16TotalPackets;
   1465                   gAppTxPacket->smacPdu.u8Data[2] = ((u16SentPackets+1) >> 8);
   1466                   gAppTxPacket->smacPdu.u8Data[3] = (uint8_t)(u16SentPackets+1);
   1467                   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[4]), "SMAC PER Demo",13);
   1468                   if(17 < testPayloadLen){
   1469                     for(u8Index=17;u8Index<testPayloadLen;u8Index++){
   1470                       gAppTxPacket->smacPdu.u8Data[u8Index] = (u8Index%10)+'0';            
   1471                     }
   1472                   }
   1473                   bTxDone = FALSE;
   1474          
   1475                   (void)MCPSDataRequest(gAppTxPacket);
   1476                   u16SentPackets++;
   1477                   CommUtil_Print("\f\r\n Running PER Tx, Sending ", gAllowToBlock_d);
   1478                   PrintWordOnDecimalFormatBlocking(u16TotalPackets, 0, FALSE, gDefaultCommPort_c);
   1479                   CommUtil_Print(" Packets", gAllowToBlock_d);
   1480                   perTxState = gPerTxStateRunningTest_c;
   1481              break;
   1482              case gPerTxStateRunningTest_c:
   1483                   if(bTxDone){
   1484                     if(u16SentPackets == u16TotalPackets)
   1485                     {
   1486                       MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[4]), "DONE",4);
   1487                       gAppTxPacket->u8DataLength = 8;
   1488                       u16SentPackets = 0;
   1489                       u16TotalPackets = mTotalFinalFrames_c;
   1490                       gAppTxPacket->u8DataLength = 8;
   1491                       perTxState = gPerTxStateSendingLastFrames_c;
   1492                     }else
   1493                     {
   1494                      gAppTxPacket->smacPdu.u8Data[2] = ((u16SentPackets+1) >> 8);
   1495                      gAppTxPacket->smacPdu.u8Data[3] = (uint8_t)(u16SentPackets+1);
   1496                      gAppTxPacket->u8DataLength = testPayloadLen;
   1497                     }
   1498                      bTxDone = FALSE;
   1499                     delayMs(10);
   1500                      (void)MCPSDataRequest(gAppTxPacket);
   1501                      u16SentPackets++;
   1502                    }
   1503              break;
   1504              case gPerTxStateSendingLastFrames_c:
   1505                   if(bTxDone)
   1506                   {
   1507                     bTxDone = FALSE;
   1508                     if(u16SentPackets == u16TotalPackets)
   1509                     {
   1510                         CommUtil_Print("\r\n PER Tx DONE \r\n", gAllowToBlock_d);
   1511                         CommUtil_Print("\r\n\r\n Press [enter] to go back to the PER Tx test menu ", gAllowToBlock_d);
   1512                         perTxState = gPerTxStateIdle_c;
   1513                     }else
   1514                     {
   1515                       gAppTxPacket->u8DataLength = 8;
   1516                       delayMs(10);
   1517                       (void)MCPSDataRequest(gAppTxPacket);
   1518                       u16SentPackets++;
   1519                        } 
   1520                    }	 
   1521              break;	
   1522              case gPerTxStateIdle_c:
   1523                   if((evDataFromCOMM) && ('\r' == gu8CommData))
   1524                   {
   1525                     perTxState = gPerTxStateInit_c;
   1526                     evDataFromCOMM = FALSE;
   1527                   }
   1528              break;
   1529             default:
   1530              break;
   1531            }
   1532          
   1533            return bBackFlag;
   1534          }
   1535          
   1536          /**************************************************************************************/
   1537          bool_t PacketErrorRateRx(void)
   1538          {
   1539            static uint16_t u16ReceivedPackets;
   1540            static uint16_t u16PacketsIndex;  
   1541            static uint16_t u16TotalPackets;
   1542            static uint16_t u16FinalPacketsCount;
   1543            static uint32_t u32LQISum;
   1544            uint8_t  u8AverageLQI, u8TempLQIvalue;
   1545          
   1546            bool_t bBackFlag = FALSE;
   1547            if(evTestParameters){
   1548              (void)MLMESetChannelRequest(testChannel);
   1549              (void)MLMEPAOutputAdjust(testPower);
   1550              (void)MLMEXtalAdjust(testTrimmValue);
   1551              PrintTestParameters(TRUE);
   1552              evTestParameters = FALSE;
   1553            }
   1554          
   1555            switch(perRxState)
   1556            {
   1557              case gPerRxStateInit_c:
   1558                  u16TotalPackets = 0;
   1559                  u16ReceivedPackets = 0;
   1560                  u16PacketsIndex = 0;
   1561                  u32LQISum = 0;
   1562                  PrintMenu(cu8ShortCutsBar, gDefaultCommPort_c);
   1563                  PrintMenu(cu8PerRxTestMenu, gDefaultCommPort_c);
   1564                  PrintTestParameters(FALSE);
   1565                  shortCutsEnabled = TRUE;           
   1566                  perRxState = gPerRxWaitStartTest_c;
   1567              break;
   1568              case gPerRxWaitStartTest_c:
   1569                   if(evDataFromCOMM){
   1570                     if(' ' == gu8CommData){
   1571                           CommUtil_Print("\f\n\rPER Test Rx Running\r\n\r\n", gAllowToBlock_d);
   1572                           SetRadioRxOnTimeOut15ms();
   1573                           shortCutsEnabled = FALSE;  
   1574                           perRxState = gPerRxStateStartTest_c;
   1575                        }else if('p' == gu8CommData){ 
   1576                        bBackFlag = TRUE;
   1577                     }
   1578                     evDataFromCOMM = FALSE;
   1579                   }
   1580              break;
   1581              case gPerRxStateStartTest_c:
   1582                   if(bRxDone){
   1583                     if (gAppRxPacket->rxStatus == rxSuccessStatus_c){
   1584                       if(stringComp("SMAC PER Demo",&gAppRxPacket->smacPdu.u8Data[4],13)){
   1585                         u16TotalPackets = ((uint16_t)gAppRxPacket->smacPdu.u8Data[0] <<8) + gAppRxPacket->smacPdu.u8Data[1];
   1586                         u16PacketsIndex = ((uint16_t)gAppRxPacket->smacPdu.u8Data[2] <<8) + gAppRxPacket->smacPdu.u8Data[3];
   1587                         u16ReceivedPackets++;
   1588                         (void)MLMELinkQuality(&u8TempLQIvalue);
   1589                         u32LQISum += u8TempLQIvalue;
   1590                         u8AverageLQI = (uint8_t)(u32LQISum/u16ReceivedPackets);
   1591                         (void)u8AverageLQI;
   1592                           CommUtil_Print("Packet ", gAllowToBlock_d);
   1593                         PrintWordOnDecimalFormatBlocking(u16ReceivedPackets, 2, FALSE, gDefaultCommPort_c);
   1594                         CommUtil_Print("\r\n", gAllowToBlock_d);
   1595                         if(u16PacketsIndex == u16TotalPackets){
   1596                           u16FinalPacketsCount = 0; 
   1597                           perRxState = gPerRxStateReceivingLastFrames_c;
   1598                     }
   1599                       }else if(stringComp("DONE",&gAppRxPacket->smacPdu.u8Data[4],4)){
   1600                         u16FinalPacketsCount = 0; 
   1601                         perRxState = gPerRxStateReceivingLastFrames_c;
   1602                       }
   1603                     }else{ 
   1604                       if(u16TotalPackets){
   1605                         u16PacketsIndex++;
   1606                         if(u16PacketsIndex == u16TotalPackets){
   1607                           u16FinalPacketsCount = 0; 
   1608                       perRxState = gPerRxStateReceivingLastFrames_c;
   1609                      }
   1610                       }
   1611                     }
   1612                     SetRadioRxOnTimeOut15ms();
   1613                   }
   1614                   if(evDataFromCOMM){
   1615                     if(' ' == gu8CommData){
   1616                       (void)MLMERXDisableRequest();
   1617                       CommUtil_Print("\n\rPER Test Rx Stopped\r\n\r\n", gAllowToBlock_d);
   1618                       PrintPerRxFinalLine(u16ReceivedPackets,u16TotalPackets);
   1619                       perRxState = gPerRxStateIdle_c;
   1620                     } 
   1621                     evDataFromCOMM = FALSE;
   1622                   }         
   1623              break;
   1624              case gPerRxStateReceivingLastFrames_c:
   1625                   if(bRxDone){
   1626                     u16FinalPacketsCount++; 
   1627                     if(mTotalFinalFrames_c == u16FinalPacketsCount){
   1628                     CommUtil_Print("\n\rPER Test Finished\r\n\r\n", gAllowToBlock_d);
   1629                     PrintPerRxFinalLine(u16ReceivedPackets,u16TotalPackets);              
   1630                     perRxState = gPerRxStateIdle_c;
   1631                     }else{  
   1632                       SetRadioRxOnTimeOut15ms();
   1633                     }
   1634                   }
   1635              break;
   1636              case gPerRxStateIdle_c:
   1637                   if((evDataFromCOMM) && ('\r' == gu8CommData)){
   1638                     perRxState = gPerRxStateInit_c;
   1639                   }
   1640                   evDataFromCOMM = FALSE;
   1641              break;
   1642              default:
   1643              break;
   1644            }
   1645            return bBackFlag;
   1646          }
   1647          
   1648          /**************************************************************************************/
   1649          bool_t RangeTx(void)
   1650          {
   1651            bool_t bBackFlag = FALSE;
   1652            static uint32_t u32LQISum;
   1653            static uint16_t u16ReceivedPackets;
   1654            static uint16_t u16PacketsDropped;
   1655            uint8_t  u8AverageLQI;
   1656            uint8_t  u8CurrentLQI;
   1657            
   1658            if(evTestParameters){
   1659              (void)MLMESetChannelRequest(testChannel);
   1660              (void)MLMEPAOutputAdjust(testPower);
   1661              (void)MLMEXtalAdjust(testTrimmValue);
   1662              PrintTestParameters(TRUE);
   1663              evTestParameters = FALSE;
   1664            }
   1665            
   1666            switch(rangeTxState)
   1667            {
   1668              case gRangeTxStateInit_c:
   1669                   u32LQISum = 0;
   1670                   u16ReceivedPackets = 0;
   1671                   u16PacketsDropped = 0;
   1672                     PrintMenu(cu8ShortCutsBar, gDefaultCommPort_c);
   1673                     PrintMenu(cu8RangeTxTestMenu, gDefaultCommPort_c);
   1674                     PrintTestParameters(FALSE);
   1675                     shortCutsEnabled = TRUE;           
   1676                     rangeTxState = gRangeTxWaitStartTest_c;
   1677              break;
   1678              case gRangeTxWaitStartTest_c:
   1679                   if(evDataFromCOMM){
   1680                     if(' ' == gu8CommData){
   1681                       shortCutsEnabled = FALSE; 
   1682                       CommUtil_Print("\f\r\nRange Test Tx Running\r\n", gAllowToBlock_d);
   1683                       rangeTxState = gRangeTxStateStartTest_c;
   1684                     }else if('p' == gu8CommData){ 
   1685                       bBackFlag = TRUE;
   1686                     }
   1687                     evDataFromCOMM = FALSE;
   1688                   }
   1689              break;
   1690              case gRangeTxStateStartTest_c:
   1691                   delayMs(100);
   1692                   delayMs(100);
   1693                   bTxDone = FALSE;
   1694                   gAppTxPacket->u8DataLength = 16;
   1695                   gAppTxPacket->smacPdu.u8Data[0]  = 0;
   1696                   MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[1]), "SMAC Range Demo",15);
   1697                   (void)MCPSDataRequest(gAppTxPacket);
   1698                   rangeTxState = gRangeTxStateRunningTest_c;
   1699              break;
   1700              case gRangeTxStateRunningTest_c:
   1701                   if(bTxDone){
   1702                     SetRadioRxOnTimeOut15ms();
   1703                     rangeTxState = gRangeTxStatePrintTestResults_c;
   1704                   }
   1705              break;
   1706              case gRangeTxStatePrintTestResults_c:
   1707                   if(bRxDone){
   1708                     if(gAppRxPacket->rxStatus == rxSuccessStatus_c){ 
   1709                       if(stringComp("SMAC Range Demo",&gAppRxPacket->smacPdu.u8Data[1],15)){
   1710                         u8CurrentLQI = (gAppRxPacket->smacPdu.u8Data[0]); 
   1711                         u32LQISum += u8CurrentLQI;  
   1712                         u16ReceivedPackets++;
   1713                         u8AverageLQI = (uint8_t)(u32LQISum/u16ReceivedPackets);
   1714                           CommUtil_Print("\r\n LQI = ", gAllowToBlock_d);
   1715                           PrintWordOnDecimalFormatBlocking((uint16_t)u8CurrentLQI,1,FALSE, gDefaultCommPort_c);               
   1716                       }else{
   1717                         SetRadioRxOnTimeOut15ms();
   1718                       }
   1719                     }else{
   1720                         u16PacketsDropped++;
   1721                         CommUtil_Print("\r\nPacket Dropped", gAllowToBlock_d);
   1722                     }
   1723                     if(evDataFromCOMM && (' ' == gu8CommData)){
   1724                       CommUtil_Print("\n\r\n\rRange Test Tx Stopped\r\n\r\n", gAllowToBlock_d);
   1725                       u8AverageLQI = (uint8_t)(u32LQISum/u16ReceivedPackets);
   1726                       CommUtil_Print("Average LQI     ", gAllowToBlock_d);
   1727                       PrintWordOnDecimalFormatBlocking((uint16_t)u8AverageLQI,1,FALSE, gDefaultCommPort_c);  
   1728                       CommUtil_Print("\r\nPackets dropped ", gAllowToBlock_d);
   1729                       PrintWordOnDecimalFormatBlocking(u16PacketsDropped,1,FALSE, gDefaultCommPort_c);  
   1730                       CommUtil_Print("\r\n\r\n Press [enter] to go back to the Range Tx test menu", gAllowToBlock_d);
   1731                       rangeTxState = gRangeTxStateIdle_c;
   1732                     }else{
   1733                       rangeTxState = gRangeTxStateStartTest_c;
   1734                     }
   1735                     evDataFromCOMM = FALSE;
   1736                   }
   1737              break;
   1738              case gRangeTxStateIdle_c:
   1739                   if((evDataFromCOMM) && ('\r' == gu8CommData))
   1740                   {
   1741                     rangeTxState = gRangeTxStateInit_c;
   1742                   }
   1743                   evDataFromCOMM = FALSE;
   1744              break;
   1745              default:
   1746              break;
   1747            }
   1748            return bBackFlag;
   1749          }
   1750          
   1751          /**************************************************************************************/
   1752          bool_t RangeRx(void)
   1753          {
   1754            bool_t bBackFlag = FALSE;
   1755            static uint32_t u32LQISum;
   1756            static uint16_t u16ReceivedPackets;
   1757            uint8_t  u8AverageLQI, u8TempLQIvalue;
   1758            uint8_t  u8CurrentLQI;
   1759          
   1760            if(evTestParameters){
   1761              (void)MLMESetChannelRequest(testChannel);
   1762              (void)MLMEPAOutputAdjust(testPower);
   1763              (void)MLMEXtalAdjust(testTrimmValue);
   1764              PrintTestParameters(TRUE);
   1765              evTestParameters = FALSE;
   1766            }
   1767          
   1768            switch(rangeRxState)
   1769            {
   1770              case gRangeRxStateInit_c:
   1771                   u32LQISum = 0;
   1772                   u16ReceivedPackets = 0;
   1773                     PrintMenu(cu8ShortCutsBar, gDefaultCommPort_c);
   1774                     PrintMenu(cu8RangeRxTestMenu, gDefaultCommPort_c);
   1775                     PrintTestParameters(FALSE);
   1776                     shortCutsEnabled = TRUE;           
   1777                     rangeRxState = gRangeRxWaitStartTest_c;
   1778              break;
   1779              case gRangeRxWaitStartTest_c:
   1780                   if(evDataFromCOMM){
   1781                     if(' ' == gu8CommData){
   1782                       shortCutsEnabled = FALSE; 
   1783                       CommUtil_Print("\f\r\nRange Test Rx Running\r\n", gAllowToBlock_d);
   1784                       rangeRxState = gRangeRxStateStartTest_c;
   1785                     }else if('p' == gu8CommData){ 
   1786                       bBackFlag = TRUE;
   1787                     }
   1788                     evDataFromCOMM = FALSE;
   1789                   }
   1790              break;
   1791              case gRangeRxStateStartTest_c:
   1792                   SetRadioRxOnNoTimeOut();
   1793                   rangeRxState = gRangeRxStateRunningTest_c;
   1794              break;
   1795              case gRangeRxStateRunningTest_c:
   1796                   if(evDataFromCOMM && (' ' == gu8CommData))
   1797                   {             
   1798                     (void)MLMERXDisableRequest();
   1799                     CommUtil_Print("\n\r\n\rRange Test Rx Stopped\r\n\r\n", gAllowToBlock_d);
   1800                     u8AverageLQI = (uint8_t)(u32LQISum/u16ReceivedPackets);
   1801                     CommUtil_Print("Average LQI     ", gAllowToBlock_d);
   1802                     PrintWordOnDecimalFormatBlocking((uint16_t)u8AverageLQI,1,FALSE, gDefaultCommPort_c);  
   1803                     CommUtil_Print("\r\n\r\n Press [enter] to go back to the Range Rx test menu", gAllowToBlock_d);
   1804                     rangeRxState = gRangeRxStateIdle_c;
   1805                   }
   1806                   evDataFromCOMM = FALSE;
   1807                   if(bRxDone){
   1808                     if(gAppRxPacket->rxStatus == rxSuccessStatus_c){ 
   1809                       if(stringComp("SMAC Range Demo",&gAppRxPacket->smacPdu.u8Data[1],15)){
   1810                         bTxDone = FALSE;
   1811          			   delayMs(2);
   1812                         (void)MLMELinkQuality(&u8TempLQIvalue);
   1813                         gAppTxPacket->smacPdu.u8Data[0] = u8TempLQIvalue;
   1814                         MemoryCpy(&(gAppTxPacket->smacPdu.u8Data[1]), "SMAC Range Demo",15);
   1815                         gAppTxPacket->u8DataLength = 16;
   1816                         (void)MCPSDataRequest(gAppTxPacket);
   1817                         rangeRxState = gRangeRxStatePrintTestResults_c;
   1818                       }else{
   1819                         SetRadioRxOnNoTimeOut();
   1820                       }
   1821                     }else{
   1822                       SetRadioRxOnNoTimeOut();
   1823                     }
   1824                   }
   1825              break;
   1826              case gRangeRxStatePrintTestResults_c:
   1827                   if(bTxDone)
   1828                   {
   1829                     (void)MLMELinkQuality(&u8CurrentLQI); 
   1830                     u32LQISum += u8CurrentLQI;
   1831                     u16ReceivedPackets++;
   1832                     u8AverageLQI = (uint8_t)(u32LQISum/u16ReceivedPackets);
   1833                       CommUtil_Print("\r\n LQI = ", gAllowToBlock_d);
   1834                       PrintWordOnDecimalFormatBlocking((uint16_t)u8CurrentLQI,1,FALSE, gDefaultCommPort_c);               
   1835                     rangeRxState = gRangeRxStateStartTest_c;
   1836                   }
   1837              break;
   1838              case gRangeRxStateIdle_c:
   1839                   if((evDataFromCOMM) && ('\r' == gu8CommData))
   1840                   {
   1841                     rangeRxState = gRangeRxStateInit_c;
   1842                   }
   1843                   evDataFromCOMM = FALSE;
   1844              break;
   1845              default:
   1846              break;
   1847            }
   1848            return bBackFlag;
   1849          }
   1850          
   1851          /**************************************************************************************/
   1852          /**************************************************************************************/
   1853          bool_t EditRegisters(void)
   1854          {
   1855            bool_t bBackFlag = FALSE;
   1856            if(evTestParameters){
   1857              (void)MLMESetChannelRequest(testChannel);
   1858              (void)MLMEPAOutputAdjust(testPower);
   1859              (void)MLMEXtalAdjust(testTrimmValue);
   1860              PrintTestParameters(TRUE);
   1861              evTestParameters = FALSE;
   1862            }
   1863          
   1864            switch(eRState)
   1865            {
   1866              case gERStateInit_c:
   1867                   PrintMenu(cu8ShortCutsBar, gDefaultCommPort_c);
   1868                   PrintMenu(cu8RadioRegistersEditMenu, gDefaultCommPort_c);
   1869                   PrintTestParameters(FALSE);
   1870                   shortCutsEnabled = TRUE;           
   1871                   eRState = gERWaitSelection_c;
   1872              break;
   1873              case gERWaitSelection_c:
   1874                   if(evDataFromCOMM){
   1875                     if('1' == gu8CommData){
   1876                       oDRState = gODRStateInit_c;
   1877                       eRState = gERStateOverrideDirectReg_c;
   1878                     }else if('2' == gu8CommData){
   1879                       rDRState = gRDRStateInit_c;
   1880                       eRState = gERStateReadDirectReg_c;
   1881                     }else if('3' == gu8CommData){
   1882                       oIRState = gOIRStateInit_c;
   1883                       eRState = gERStateOverrideIndirectReg_c;
   1884                     }else if('4' == gu8CommData){
   1885                       rIRState = gRIRStateInit_c;
   1886                       eRState = gERStateReadIndirectReg_c;
   1887                     }else if('p' == gu8CommData){ 
   1888                       bBackFlag = TRUE;
   1889                     }
   1890                     evDataFromCOMM = FALSE;
   1891                   }
   1892              break;
   1893              case gERStateOverrideDirectReg_c:
   1894                   if(OverrideDirectRegisters()) {
   1895                       eRState = gERStateInit_c;
   1896                   }    
   1897              break;
   1898              case gERStateOverrideIndirectReg_c:
   1899                   if(OverrideIndirectRegisters()) {
   1900                       eRState = gERStateInit_c;
   1901                   }    
   1902              break;
   1903              case gERStateReadDirectReg_c:
   1904                   if(ReadDirectRegisters()) {
   1905                       eRState = gERStateInit_c;
   1906                   }    
   1907              break;
   1908              case gERStateReadIndirectReg_c:
   1909                   if(ReadIndirectRegisters()) {
   1910                       eRState = gERStateInit_c;
   1911                   }    
   1912              break;
   1913              default:
   1914              break;
   1915            }
   1916            return bBackFlag;
   1917          }
   1918          
   1919          
   1920          /**************************************************************************************/
   1921          bool_t OverrideDirectRegisters(void)
   1922          {
   1923            bool_t bBackFlag = FALSE;
   1924            static uint8_t au8RxString[5];
   1925            static uint8_t u8Index;
   1926            static uint8_t u8RegAddress;
   1927            static uint8_t u8RegValue;
   1928            
   1929            
   1930            switch(oDRState)
   1931            {
   1932              case gODRStateInit_c:
   1933                   CommUtil_Print("\f\r\nOverride Direct Registers\r\n", gAllowToBlock_d);
   1934                   CommUtil_Print("\r\n-Press [p] Previous Menu\r\n", gAllowToBlock_d);
   1935                   shortCutsEnabled = FALSE;   
   1936                   oDRState = gODRStateStart_c;
   1937              break;
   1938              case gODRStateStart_c:
   1939                   CommUtil_Print("\r\n -write the Register address in Hex and [enter]: 0x", gAllowToBlock_d);
   1940                   u8Index = 0;
   1941                   oDRState = gODRWaitForTheAddress_c; 
   1942              break;
   1943              case gODRWaitForTheAddress_c:
   1944                   if(evDataFromCOMM){
   1945                     if((!isAsciiHex(gu8CommData)) && ('\r' != gu8CommData)){
   1946                       if('p' == gu8CommData){ 
   1947                         bBackFlag = TRUE;
   1948                       }else{
   1949                         CommUtil_Print("\r\n -Invalid Character!! ", gAllowToBlock_d);
   1950                         oDRState = gODRStateStart_c;              
   1951                       }
   1952                     }else if((2 == u8Index) && ('\r' != gu8CommData)){ 
   1953                       CommUtil_Print("\r\n -Value out of Range!! ", gAllowToBlock_d);
   1954                       oDRState = gODRStateStart_c;
   1955                     }else if(isAsciiHex(gu8CommData)){
   1956                       au8RxString[u8Index++] = gu8CommData;
   1957                     }else{
   1958                       au8RxString[u8Index] = 0;
   1959                       u8RegAddress = HexString2Dec16(au8RxString);
   1960                       CommUtil_Print("\r\n -write the Register value to override in Hex and [enter]: 0x", gAllowToBlock_d);
   1961                       u8Index = 0;
   1962                       oDRState = gODRWaitForTheValue_c; 
   1963                     }
   1964                     evDataFromCOMM = FALSE;
   1965                   }
   1966              break;
   1967              case gODRWaitForTheValue_c:
   1968                   if(evDataFromCOMM){
   1969                     if((!isAsciiHex(gu8CommData)) && ('\r' != gu8CommData)){
   1970                       if('p' == gu8CommData){ 
   1971                         bBackFlag = TRUE;
   1972                       }else{
   1973                         CommUtil_Print("\r\n -Invalid Character!! ", gAllowToBlock_d);
   1974                         oDRState = gODRStateStart_c;              
   1975                       }
   1976                     }else if((2 == u8Index) && ('\r' != gu8CommData)){ 
   1977                       CommUtil_Print("\r\n -Value out of Range!! ", gAllowToBlock_d);
   1978                       oDRState = gODRStateStart_c;              
   1979                     }else if(isAsciiHex(gu8CommData)){
   1980                       au8RxString[u8Index++] = gu8CommData;
   1981                     }else{
   1982                       au8RxString[u8Index] = 0;
   1983                       u8RegValue = (uint8_t)(HexString2Dec16(au8RxString) & 0x00FF);
   1984                       MC1324xDrv_DirectAccessSPIWrite(u8RegAddress,u8RegValue);
   1985                       
   1986                       CommUtil_Print("\r\n Register overridden \r\n", gAllowToBlock_d);
   1987                       u8Index = 0;
   1988                       oDRState = gODRStateStart_c; 
   1989                     }
   1990                     evDataFromCOMM = FALSE;
   1991                   }
   1992              break;
   1993              default:
   1994              break;
   1995            }
   1996            return bBackFlag;  
   1997          }
   1998          
   1999          /**************************************************************************************/
   2000          bool_t OverrideIndirectRegisters(void)
   2001          {
   2002            bool_t bBackFlag = FALSE;
   2003            static uint8_t au8RxString[3];
   2004            static uint8_t u8Index;
   2005            static uint8_t u8RegAddress;
   2006            static uint8_t u8RegValue;
   2007            
   2008            
   2009            switch(oIRState)
   2010            {
   2011              case gOIRStateInit_c:
   2012                   CommUtil_Print("\f\r\nOverride Indirect Registers\r\n", gAllowToBlock_d);
   2013                   CommUtil_Print("\r\n-Press [p] Previous Menu\r\n", gAllowToBlock_d);
   2014                   shortCutsEnabled = FALSE;   
   2015                   oIRState = gOIRStateStart_c;
   2016              break;
   2017              case gOIRStateStart_c:
   2018                   CommUtil_Print("\r\n -write the Register address in Hex and [enter]: 0x", gAllowToBlock_d);
   2019                   u8Index = 0;
   2020                   oIRState = gOIRWaitForTheAddress_c; 
   2021              break;
   2022              case gOIRWaitForTheAddress_c:
   2023                   if(evDataFromCOMM){
   2024                     if((!isAsciiHex(gu8CommData)) && ('\r' != gu8CommData)){
   2025                       if('p' == gu8CommData){ 
   2026                         bBackFlag = TRUE;
   2027                       }else{
   2028                         CommUtil_Print("\r\n -Invalid Character!! ", gAllowToBlock_d);
   2029                         oIRState = gOIRStateStart_c;              
   2030                       }
   2031                     }else if((2 == u8Index) && ('\r' != gu8CommData)){ 
   2032                       CommUtil_Print("\r\n -Value out of Range!! ", gAllowToBlock_d);
   2033                       oIRState = gOIRStateStart_c;   
   2034                     }else if(isAsciiHex(gu8CommData)){
   2035                       au8RxString[u8Index++] = gu8CommData;
   2036                     }else{
   2037                       au8RxString[u8Index] = 0;
   2038                       u8RegAddress = (uint8_t)(HexString2Dec16(au8RxString) & 0x00FF);
   2039                       CommUtil_Print("\r\n -write the Register value to override in Hex and [enter]: 0x", gAllowToBlock_d);
   2040                       u8Index = 0;
   2041                       oIRState = gOIRWaitForTheValue_c; 
   2042                     }
   2043                     evDataFromCOMM = FALSE;
   2044                   }
   2045              break;
   2046              case gOIRWaitForTheValue_c:
   2047                   if(evDataFromCOMM)
   2048                   {
   2049                     if((!isAsciiHex(gu8CommData)) && ('\r' != gu8CommData)){
   2050                       if('p' == gu8CommData){ 
   2051                         bBackFlag = TRUE;
   2052                       }else{
   2053                         CommUtil_Print("\r\n -Invalid Character!! ", gAllowToBlock_d);
   2054                         oIRState = gOIRStateStart_c;              
   2055                       }
   2056                     }else if((2 == u8Index) && ('\r' != gu8CommData)){ 
   2057                       CommUtil_Print("\r\n -Value out of Range!! ", gAllowToBlock_d);
   2058                       bBackFlag = TRUE;
   2059                     }else if(isAsciiHex(gu8CommData)){
   2060                       au8RxString[u8Index++] = gu8CommData;
   2061                     }else{
   2062                       au8RxString[u8Index] = 0;
   2063                       u8RegValue = (uint8_t)(HexString2Dec16(au8RxString) & 0x00FF);
   2064                       MC1324xDrv_IndirectAccessSPIWrite(u8RegAddress, u8RegValue);
   2065                       CommUtil_Print("\r\n Register overridden \r\n", gAllowToBlock_d);
   2066                       u8Index = 0;
   2067                       oIRState = gOIRStateStart_c; 
   2068                     }
   2069                     evDataFromCOMM = FALSE;
   2070                   }
   2071              break;
   2072              default:
   2073              break;
   2074            }
   2075            return bBackFlag;  
   2076          }
   2077          
   2078          
   2079          /**************************************************************************************/
   2080          bool_t ReadDirectRegisters(void)
   2081          {
   2082            bool_t bBackFlag = FALSE;
   2083            static uint8_t au8RxString[5];
   2084            static uint8_t u8Index;
   2085            static uint8_t u8RegAddress;
   2086            static uint8_t u8RegValue;
   2087            
   2088            switch(rDRState)
   2089            {
   2090              case gRDRStateInit_c:
   2091                   CommUtil_Print("\f\r\rRead Direct Registers\r\n", gAllowToBlock_d);
   2092                   CommUtil_Print("\r\n-Press [p] Previous Menu\r\n", gAllowToBlock_d);
   2093                   shortCutsEnabled = FALSE;   
   2094                   rDRState = gRDRStateStart_c;
   2095              break;
   2096              case gRDRStateStart_c:
   2097                   CommUtil_Print("\r\n -write the Register address in Hex and [enter]: 0x", gAllowToBlock_d);
   2098                   u8Index = 0;
   2099                   rDRState = gRDRWaitForTheAddress_c; 
   2100              break;
   2101              case gRDRWaitForTheAddress_c:
   2102                   if(evDataFromCOMM){
   2103                     if((!isAsciiHex(gu8CommData)) && ('\r' != gu8CommData)){
   2104                       if('p' == gu8CommData){ 
   2105                         bBackFlag = TRUE;
   2106                       }else{
   2107                         CommUtil_Print("\r\n -Invalid Character!! ", gAllowToBlock_d);
   2108                         rDRState = gRDRStateStart_c;              
   2109                       }
   2110                     }else if((2 == u8Index) && ('\r' != gu8CommData)){ 
   2111                       CommUtil_Print("\r\n -Value out of Range!! ", gAllowToBlock_d);
   2112                       rDRState = gRDRStateStart_c;
   2113                     }else if(isAsciiHex(gu8CommData)){
   2114                       au8RxString[u8Index++] = gu8CommData;
   2115                     }else{
   2116                       au8RxString[u8Index] = 0;
   2117                       u8RegAddress = HexString2Dec16(au8RxString);
   2118                       u8RegValue = MC1324xDrv_DirectAccessSPIRead(u8RegAddress);
   2119                       
   2120                       CommUtil_Print("\r\n -Register value : 0x", gAllowToBlock_d);
   2121                       PrintByteOnHexFormatBlocking(u8RegValue,FALSE, gDefaultCommPort_c);
   2122                       CommUtil_Print("\r\n", gAllowToBlock_d);
   2123                       
   2124                       rDRState = gRDRStateStart_c; 
   2125                     }
   2126                     evDataFromCOMM = FALSE;
   2127                   }
   2128              break;
   2129              default:
   2130              break;
   2131            }
   2132            return bBackFlag;  
   2133          }
   2134          
   2135          /**************************************************************************************/
   2136          bool_t ReadIndirectRegisters(void)
   2137          {
   2138            bool_t bBackFlag = FALSE;
   2139            static uint8_t au8RxString[5];
   2140            static uint8_t u8Index;
   2141            static uint8_t u8RegAddress;
   2142            static uint8_t u8RegValue;
   2143            
   2144            switch(rIRState)
   2145            {
   2146              case gRIRStateInit_c:
   2147                   CommUtil_Print("\f\r\rRead Indirect Registers\r\n", gAllowToBlock_d);
   2148                   CommUtil_Print("\r\n-Press [p] Previous Menu\r\n", gAllowToBlock_d);
   2149                   shortCutsEnabled = FALSE;   
   2150                   rIRState = gRIRStateStart_c;
   2151              break;
   2152              case gRIRStateStart_c:
   2153                   CommUtil_Print("\r\n -write the Register address in Hex and [enter]: 0x", gAllowToBlock_d);
   2154                   u8Index = 0;
   2155                   rIRState = gRIRWaitForTheAddress_c; 
   2156              break;
   2157              case gRIRWaitForTheAddress_c:
   2158                   if(evDataFromCOMM){
   2159                     if((!isAsciiHex(gu8CommData)) && ('\r' != gu8CommData))
   2160                     {
   2161                       if('p' == gu8CommData){ 
   2162                         bBackFlag = TRUE;
   2163                       }else{
   2164                         CommUtil_Print("\r\n -Invalid Character!! ", gAllowToBlock_d);
   2165                         rIRState = gRIRStateStart_c;              
   2166                       }
   2167                     }else if((2 == u8Index) && ('\r' != gu8CommData)){ 
   2168                       CommUtil_Print("\r\n -Value out of Range!! ", gAllowToBlock_d);
   2169                       rIRState = gRIRStateStart_c; 
   2170                     }else if(isAsciiHex(gu8CommData)){
   2171                       au8RxString[u8Index++] = gu8CommData;
   2172                     }else{
   2173                       au8RxString[u8Index] = 0;
   2174                       u8RegAddress = (uint8_t)(HexString2Dec16(au8RxString) & 0x00FF);
   2175                       u8RegValue = MC1324xDrv_IndirectAccessSPIRead(u8RegAddress);
   2176                       
   2177                       CommUtil_Print("\r\n -Register value : 0x", gAllowToBlock_d);
   2178                       PrintByteOnHexFormatBlocking(u8RegValue, FALSE, gDefaultCommPort_c);
   2179                       CommUtil_Print("\r\n", gAllowToBlock_d);
   2180                       rIRState = gRIRStateStart_c; 
   2181                     }
   2182                     evDataFromCOMM = FALSE;
   2183                   }
   2184              break;
   2185              default:
   2186              break;
   2187            }
   2188            return bBackFlag;  
   2189          } 
   2190          
   2191          /**************************************************************************************/
   2192          void PrintTestParameters(bool_t bEraseLine)
   2193          {
   2194            uint8_t u8lineLen = 63;
   2195            uint8_t u8Index;
   2196           
   2197            if(bEraseLine)
   2198            {
   2199              for(u8Index = 0;u8Index<u8lineLen;u8Index++)
   2200              {
   2201                CommUtil_Print("\b", gAllowToBlock_d);
   2202              }
   2203            }
   2204            
   2205            CommUtil_Print("Mode ", gAllowToBlock_d);
   2206            if(mTxOperation_c == testOpMode){
   2207              CommUtil_Print("Tx", gAllowToBlock_d);
   2208            }else{
   2209              CommUtil_Print("Rx", gAllowToBlock_d);
   2210            }
   2211            CommUtil_Print(", Channel ", gAllowToBlock_d);
   2212            PrintWordOnDecimalFormatBlocking((uint16_t)testChannel,2, FALSE, gDefaultCommPort_c);
   2213            CommUtil_Print(", Power ", gAllowToBlock_d);
   2214            PrintWordOnDecimalFormatBlocking((uint16_t)testPower,2, FALSE, gDefaultCommPort_c);
   2215            CommUtil_Print(", Crystal Trim ", gAllowToBlock_d);
   2216            PrintWordOnDecimalFormatBlocking((uint16_t)testTrimmValue,3, FALSE, gDefaultCommPort_c);
   2217            CommUtil_Print(", Payload ", gAllowToBlock_d);
   2218            PrintWordOnDecimalFormatBlocking((uint16_t)testPayloadLen,3, FALSE, gDefaultCommPort_c);
   2219            CommUtil_Print(" >", gAllowToBlock_d);
   2220          }
   2221          
   2222          /**************************************************************************************/
   2223          void SetRadioRxOnTimeOut15ms(void)
   2224          {
   2225            bRxDone = FALSE;
   2226            gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
   2227            smacErrors_t status = MLMERXEnableRequest(gAppRxPacket, 45000);
   2228            while(status!=gErrorNoError_c){
   2229              status = MLMERXEnableRequest(gAppRxPacket, 45000);
   2230            }
   2231          }
   2232          
   2233          /**************************************************************************************/
   2234          void SetRadioRxOnNoTimeOut(void)
   2235          {
   2236            bRxDone = FALSE;
   2237            gAppRxPacket->u8MaxDataLength = gMaxSmacSDULength_c;
   2238            (void)MLMERXEnableRequest(gAppRxPacket, 0);
   2239          }
   2240          
   2241          /**************************************************************************************/
   2242          void PrintPerRxFinalLine(uint16_t u16Received, uint16_t u16Total)
   2243          {
   2244            CommUtil_Print("Received ", gAllowToBlock_d);
   2245            PrintWordOnDecimalFormatBlocking(u16Received, 2, FALSE, gDefaultCommPort_c);
   2246            CommUtil_Print(" of ", gAllowToBlock_d);
   2247            PrintWordOnDecimalFormatBlocking(u16Total, 2, FALSE, gDefaultCommPort_c);
   2248            CommUtil_Print(" packets transmitted \r\n", gAllowToBlock_d);
   2249            CommUtil_Print("\r\n Press [enter] to go back to the Per Rx test menu", gAllowToBlock_d);
   2250          }
   2251          
   2252          
   2253          /************************************************************************************
   2254          * User's Callbacks
   2255          ************************************************************************************/
   2256          
   2257          /* Place your callbacks here */
   2258          
   2259          
   2260          /************************************************************************************
   2261          * CommTxCallback
   2262          * 
   2263          *
   2264          *
   2265          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2266          void CommTxCallback(void)
   2267          {
   2268              bCommTxDone = TRUE;  
   \                     CommTxCallback: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x....             LDR.N    R1,??DataTable31_90
   \   00000004   0x7008             STRB     R0,[R1, #+0]
   2269          }
   \   00000006   0x4770             BX       LR               ;; return
   2270          
   2271          /************************************************************************************
   2272          * CommRxCallback
   2273          * 
   2274          *
   2275          *
   2276          ************************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   2277          void CommRxCallback()
   2278          {
   \                     CommRxCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2279              Comm_GetByteFromRxBuffer(&gu8CommData);
   \   00000002   0x....             LDR.N    R0,??DataTable31_91
   \   00000004   0x.... 0x....      BL       Uart1_GetByteFromRxBuffer
   2280              if(shortCutsEnabled){
   \   00000008   0x....             LDR.N    R0,??DataTable31_77
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD004             BEQ.N    ??CommRxCallback_0
   2281                ShortCutsParser(gu8CommData);  
   \   00000010   0x....             LDR.N    R0,??DataTable31_91
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x.... 0x....      BL       ShortCutsParser
   \   00000018   0xE002             B.N      ??CommRxCallback_1
   2282              }else{
   2283                evDataFromCOMM = TRUE;
   \                     ??CommRxCallback_0: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x....             LDR.N    R1,??DataTable31_58
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
   2284              }
   2285          }
   \                     ??CommRxCallback_1: (+1)
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
   2286          
   2287          
   2288          /************************************************************************************
   2289          * SMAC Callbacks
   2290          ************************************************************************************/
   2291          
   2292          /************************************************************************************
   2293          * MCPSDataConfirm
   2294          * 
   2295          *
   2296          *
   2297          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2298          void MCPSDataConfirm(txStatus_t TransmissionResult)
   2299          {  
   2300              bTxDone = TRUE;
   \                     MCPSDataConfirm: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x....             LDR.N    R2,??DataTable31_92
   \   00000004   0x7011             STRB     R1,[R2, #+0]
   2301          }
   \   00000006   0x4770             BX       LR               ;; return
   2302           
   2303          
   2304          /************************************************************************************
   2305          * MCPSDataIndication
   2306          * 
   2307          *
   2308          *
   2309          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2310          void MCPSDataIndication(rxPacket_t *gsRxPacket)
   2311          {  
   2312            bRxDone = TRUE;
   \                     MCPSDataIndication: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x....             LDR.N    R2,??DataTable31_93
   \   00000004   0x7011             STRB     R1,[R2, #+0]
   2313            appState=RECEIVE_FINISHED;
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x....             LDR.N    R2,??DataTable31_49
   \   0000000A   0x7011             STRB     R1,[R2, #+0]
   2314          }
   \   0000000C   0x4770             BX       LR               ;; return
   2315          
   2316          
   2317          /************************************************************************************
   2318          * MLMEScanConfirm
   2319          * 
   2320          *
   2321          *
   2322          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2323          void MLMEScanConfirm(channels_t ClearestChann)
   2324          {
   2325            bestChannel = ClearestChann; 
   \                     MLMEScanConfirm: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable31_94
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   2326            bScanDone = TRUE;
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x....             LDR.N    R2,??DataTable31_95
   \   00000008   0x7011             STRB     R1,[R2, #+0]
   2327          }
   \   0000000A   0x4770             BX       LR               ;; return
   2328          
   2329          /************************************************************************************
   2330          * MLMEResetIndication
   2331          * 
   2332          *
   2333          *
   2334          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2335          void MLMEResetIndication(void)
   2336          {
   2337            
   2338          }
   \                     MLMEResetIndication: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2339          
   2340          /************************************************************************************
   2341          * MLMEWakeConfirm
   2342          * 
   2343          *
   2344          *
   2345          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2346          void MLMEWakeConfirm(void)
   2347          {
   2348            
   2349          }
   \                     MLMEWakeConfirm: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2350          
   2351          /**************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2352          void ShortCutsParser(uint8_t u8CommData)
   2353          {
   2354            evTestParameters = TRUE;
   \                     ShortCutsParser: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x....             LDR.N    R2,??DataTable31_96
   \   00000004   0x7011             STRB     R1,[R2, #+0]
   2355            evDataFromCOMM = FALSE;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x....             LDR.N    R2,??DataTable31_58
   \   0000000A   0x7011             STRB     R1,[R2, #+0]
   2356            switch(u8CommData){
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x0001             MOVS     R1,R0
   \   00000010   0x2961             CMP      R1,#+97
   \   00000012   0xD034             BEQ.N    ??ShortCutsParser_0
   \   00000014   0x296D             CMP      R1,#+109
   \   00000016   0xD065             BEQ.N    ??ShortCutsParser_1
   \   00000018   0x296E             CMP      R1,#+110
   \   0000001A   0xD056             BEQ.N    ??ShortCutsParser_2
   \   0000001C   0x2971             CMP      R1,#+113
   \   0000001E   0xD014             BEQ.N    ??ShortCutsParser_3
   \   00000020   0x2972             CMP      R1,#+114
   \   00000022   0xD00E             BEQ.N    ??ShortCutsParser_4
   \   00000024   0x2973             CMP      R1,#+115
   \   00000026   0xD037             BEQ.N    ??ShortCutsParser_5
   \   00000028   0x2974             CMP      R1,#+116
   \   0000002A   0xD006             BEQ.N    ??ShortCutsParser_6
   \   0000002C   0x2977             CMP      R1,#+119
   \   0000002E   0xD019             BEQ.N    ??ShortCutsParser_7
   \   00000030   0x2978             CMP      R1,#+120
   \   00000032   0xD044             BEQ.N    ??ShortCutsParser_8
   \   00000034   0x297A             CMP      R1,#+122
   \   00000036   0xD03C             BEQ.N    ??ShortCutsParser_9
   \   00000038   0xE061             B.N      ??ShortCutsParser_10
   2357              case 't':
   2358                testOpMode = mTxOperation_c;
   \                     ??ShortCutsParser_6: (+1)
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x....             LDR.N    R2,??DataTable31_71
   \   0000003E   0x7011             STRB     R1,[R2, #+0]
   2359              break;
   \   00000040   0xE063             B.N      ??ShortCutsParser_11
   2360              case 'r':
   2361                testOpMode = mRxOperation_c;
   \                     ??ShortCutsParser_4: (+1)
   \   00000042   0x2101             MOVS     R1,#+1
   \   00000044   0x....             LDR.N    R2,??DataTable31_71
   \   00000046   0x7011             STRB     R1,[R2, #+0]
   2362              break;
   \   00000048   0xE05F             B.N      ??ShortCutsParser_11
   2363              case 'q': 
   2364                testChannel++;
   \                     ??ShortCutsParser_3: (+1)
   \   0000004A   0x....             LDR.N    R1,??DataTable31_72
   \   0000004C   0x7809             LDRB     R1,[R1, #+0]
   \   0000004E   0x1C49             ADDS     R1,R1,#+1
   \   00000050   0x....             LDR.N    R2,??DataTable31_72
   \   00000052   0x7011             STRB     R1,[R2, #+0]
   2365                if(gChannel26_c < testChannel){
   \   00000054   0x....             LDR.N    R1,??DataTable31_72
   \   00000056   0x7809             LDRB     R1,[R1, #+0]
   \   00000058   0x291B             CMP      R1,#+27
   \   0000005A   0xDB02             BLT.N    ??ShortCutsParser_12
   2366                  testChannel = gChannel11_c;
   \   0000005C   0x210B             MOVS     R1,#+11
   \   0000005E   0x....             LDR.N    R2,??DataTable31_72
   \   00000060   0x7011             STRB     R1,[R2, #+0]
   2367                }
   2368              break;
   \                     ??ShortCutsParser_12: (+1)
   \   00000062   0xE052             B.N      ??ShortCutsParser_11
   2369              case 'w':
   2370                testChannel--;
   \                     ??ShortCutsParser_7: (+1)
   \   00000064   0x....             LDR.N    R1,??DataTable31_72
   \   00000066   0x7809             LDRB     R1,[R1, #+0]
   \   00000068   0x1E49             SUBS     R1,R1,#+1
   \   0000006A   0x....             LDR.N    R2,??DataTable31_72
   \   0000006C   0x7011             STRB     R1,[R2, #+0]
   2371                if(gChannel11_c > testChannel){
   \   0000006E   0x....             LDR.N    R1,??DataTable31_72
   \   00000070   0x7809             LDRB     R1,[R1, #+0]
   \   00000072   0x290B             CMP      R1,#+11
   \   00000074   0xDA02             BGE.N    ??ShortCutsParser_13
   2372                  testChannel = gChannel26_c;
   \   00000076   0x211A             MOVS     R1,#+26
   \   00000078   0x....             LDR.N    R2,??DataTable31_72
   \   0000007A   0x7011             STRB     R1,[R2, #+0]
   2373                }
   2374              break;
   \                     ??ShortCutsParser_13: (+1)
   \   0000007C   0xE045             B.N      ??ShortCutsParser_11
   2375              case 'a':
   2376                testPower++;
   \                     ??ShortCutsParser_0: (+1)
   \   0000007E   0x....             LDR.N    R1,??DataTable31_73
   \   00000080   0x7809             LDRB     R1,[R1, #+0]
   \   00000082   0x1C49             ADDS     R1,R1,#+1
   \   00000084   0x....             LDR.N    R2,??DataTable31_73
   \   00000086   0x7011             STRB     R1,[R2, #+0]
   2377                if(gMaxOutputPower_c < testPower){
   \   00000088   0x....             LDR.N    R1,??DataTable31_73
   \   0000008A   0x7809             LDRB     R1,[R1, #+0]
   \   0000008C   0x2920             CMP      R1,#+32
   \   0000008E   0xDB02             BLT.N    ??ShortCutsParser_14
   2378                  testPower = gMinOutputPower_c;
   \   00000090   0x2103             MOVS     R1,#+3
   \   00000092   0x....             LDR.N    R2,??DataTable31_73
   \   00000094   0x7011             STRB     R1,[R2, #+0]
   2379                }
   2380              break;
   \                     ??ShortCutsParser_14: (+1)
   \   00000096   0xE038             B.N      ??ShortCutsParser_11
   2381              case 's':
   2382                testPower--;
   \                     ??ShortCutsParser_5: (+1)
   \   00000098   0x....             LDR.N    R1,??DataTable31_73
   \   0000009A   0x7809             LDRB     R1,[R1, #+0]
   \   0000009C   0x1E49             SUBS     R1,R1,#+1
   \   0000009E   0x....             LDR.N    R2,??DataTable31_73
   \   000000A0   0x7011             STRB     R1,[R2, #+0]
   2383                if(gMinOutputPower_c > testPower){
   \   000000A2   0x....             LDR.N    R1,??DataTable31_73
   \   000000A4   0x7809             LDRB     R1,[R1, #+0]
   \   000000A6   0x2903             CMP      R1,#+3
   \   000000A8   0xDA02             BGE.N    ??ShortCutsParser_15
   2384                  testPower = gMaxOutputPower_c;
   \   000000AA   0x211F             MOVS     R1,#+31
   \   000000AC   0x....             LDR.N    R2,??DataTable31_73
   \   000000AE   0x7011             STRB     R1,[R2, #+0]
   2385                }
   2386              break;
   \                     ??ShortCutsParser_15: (+1)
   \   000000B0   0xE02B             B.N      ??ShortCutsParser_11
   2387              case 'z':
   2388                testTrimmValue++;
   \                     ??ShortCutsParser_9: (+1)
   \   000000B2   0x....             LDR.N    R1,??DataTable31_74
   \   000000B4   0x7809             LDRB     R1,[R1, #+0]
   \   000000B6   0x1C49             ADDS     R1,R1,#+1
   \   000000B8   0x....             LDR.N    R2,??DataTable31_74
   \   000000BA   0x7011             STRB     R1,[R2, #+0]
   2389              break;
   \   000000BC   0xE025             B.N      ??ShortCutsParser_11
   2390              case 'x':
   2391                testTrimmValue--;
   \                     ??ShortCutsParser_8: (+1)
   \   000000BE   0x....             LDR.N    R1,??DataTable31_74
   \   000000C0   0x7809             LDRB     R1,[R1, #+0]
   \   000000C2   0x1E49             SUBS     R1,R1,#+1
   \   000000C4   0x....             LDR.N    R2,??DataTable31_74
   \   000000C6   0x7011             STRB     R1,[R2, #+0]
   2392              break;
   \   000000C8   0xE01F             B.N      ??ShortCutsParser_11
   2393              case 'n':
   2394                testPayloadLen++;
   \                     ??ShortCutsParser_2: (+1)
   \   000000CA   0x....             LDR.N    R1,??DataTable31_75
   \   000000CC   0x7809             LDRB     R1,[R1, #+0]
   \   000000CE   0x1C49             ADDS     R1,R1,#+1
   \   000000D0   0x....             LDR.N    R2,??DataTable31_75
   \   000000D2   0x7011             STRB     R1,[R2, #+0]
   2395                if(gMaxSmacSDULength_c < testPayloadLen){
   \   000000D4   0x....             LDR.N    R1,??DataTable31_75
   \   000000D6   0x7809             LDRB     R1,[R1, #+0]
   \   000000D8   0x297C             CMP      R1,#+124
   \   000000DA   0xDB02             BLT.N    ??ShortCutsParser_16
   2396                  testPayloadLen = 1;
   \   000000DC   0x2101             MOVS     R1,#+1
   \   000000DE   0x....             LDR.N    R2,??DataTable31_75
   \   000000E0   0x7011             STRB     R1,[R2, #+0]
   2397                }    
   2398              break;
   \                     ??ShortCutsParser_16: (+1)
   \   000000E2   0xE012             B.N      ??ShortCutsParser_11
   2399              case 'm':
   2400                testPayloadLen--;
   \                     ??ShortCutsParser_1: (+1)
   \   000000E4   0x....             LDR.N    R1,??DataTable31_75
   \   000000E6   0x7809             LDRB     R1,[R1, #+0]
   \   000000E8   0x1E49             SUBS     R1,R1,#+1
   \   000000EA   0x....             LDR.N    R2,??DataTable31_75
   \   000000EC   0x7011             STRB     R1,[R2, #+0]
   2401                if(1 > testPayloadLen){
   \   000000EE   0x....             LDR.N    R1,??DataTable31_75
   \   000000F0   0x7809             LDRB     R1,[R1, #+0]
   \   000000F2   0x2900             CMP      R1,#+0
   \   000000F4   0xD102             BNE.N    ??ShortCutsParser_17
   2402                  testPayloadLen = gMaxSmacSDULength_c;
   \   000000F6   0x217B             MOVS     R1,#+123
   \   000000F8   0x....             LDR.N    R2,??DataTable31_75
   \   000000FA   0x7011             STRB     R1,[R2, #+0]
   2403                }    
   2404              break;
   \                     ??ShortCutsParser_17: (+1)
   \   000000FC   0xE005             B.N      ??ShortCutsParser_11
   2405              default:
   2406                evDataFromCOMM = TRUE;
   \                     ??ShortCutsParser_10: (+1)
   \   000000FE   0x2101             MOVS     R1,#+1
   \   00000100   0x....             LDR.N    R2,??DataTable31_58
   \   00000102   0x7011             STRB     R1,[R2, #+0]
   2407                evTestParameters = FALSE;
   \   00000104   0x2100             MOVS     R1,#+0
   \   00000106   0x....             LDR.N    R2,??DataTable31_96
   \   00000108   0x7011             STRB     R1,[R2, #+0]
   2408              break;
   2409            }
   2410          }
   \                     ??ShortCutsParser_11: (+1)
   \   0000010A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     sensorID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x........         DC32     TempSumx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x........         DC32     TempSumy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x........         DC32     TempSumz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x........         DC32     AXIS

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0x........         DC32     PIT_ITTERATIONS

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0x400FF0C8         DC32     0x400ff0c8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   0x........         DC32     connState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \   00000000   0x........         DC32     testTrimmValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \   00000000   0x........         DC32     sentPackets

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_10:
   \   00000000   0x........         DC32     appState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_11:
   \   00000000   0x400FF0C4         DC32     0x400ff0c4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_12:
   \   00000000   0x........         DC32     gOptions

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_13:
   \   00000000   0x........         DC32     evDataFromCOMM

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     gSnd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x........         DC32     gIsAck

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x........         DC32     gOpt+0x8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x40048038         DC32     0x40048038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x4004C004         DC32     0x4004c004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x4004C014         DC32     0x4004c014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x400FF0D4         DC32     0x400ff0d4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     gAppRxPacket

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x00014BAD         DC32     0x14bad

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x40037000         DC32     0x40037000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x40037100         DC32     0x40037100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x00028488         DC32     0x28488

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     gOpt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x40037108         DC32     0x40037108

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     gRxTimeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x........         DC32     gAppTxPacket

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x400FF0C0         DC32     0x400ff0c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0x1FFF9200         DC32     0x1fff9200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \   00000000   0x1FFF80F1         DC32     0x1fff80f1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_5:
   \   00000000   0x........         DC32     gSnd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0x4003710C         DC32     0x4003710c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x........         DC32     ??b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x........         DC32     gAppTxPacket

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   0x........         DC32     gIsMyAck

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \   00000000   0x........         DC32     gPng

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_1:
   \   00000000   0x........         DC32     gPng+0x1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_2:
   \   00000000   0x........         DC32     gPng+0x2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_3:
   \   00000000   0x........         DC32     gPng+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_4:
   \   00000000   0x........         DC32     gSnd+0x1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_5:
   \   00000000   0x........         DC32     gSnd+0x2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_6:
   \   00000000   0x........         DC32     gSnd+0x3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_7:
   \   00000000   0x........         DC32     gSnd+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_8:
   \   00000000   0x........         DC32     gSnd+0x6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_9:
   \   00000000   0x........         DC32     gSnd+0x8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_10:
   \   00000000   0x........         DC32     gSnd+0xA

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_11:
   \   00000000   0x........         DC32     gSnd+0xC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_12:
   \   00000000   0x........         DC32     gSnd+0x10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_13:
   \   00000000   0x........         DC32     gSnd+0x14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_14:
   \   00000000   0x........         DC32     gSnd+0x18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_15:
   \   00000000   0x........         DC32     gSnd+0x1A

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_16:
   \   00000000   0x........         DC32     gSnd+0x1C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_17:
   \   00000000   0x........         DC32     gSnd+0x20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_18:
   \   00000000   0x........         DC32     gSnd+0x24

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_19:
   \   00000000   0x........         DC32     gSnd+0x28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_20:
   \   00000000   0x........         DC32     gSnd+0x2A

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_21:
   \   00000000   0x........         DC32     gSnd+0x2C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_22:
   \   00000000   0x........         DC32     gSnd+0x30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_23:
   \   00000000   0x........         DC32     gSnd+0x34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_24:
   \   00000000   0x........         DC32     gSnd+0x38

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_25:
   \   00000000   0x........         DC32     gSnd+0x3A

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_26:
   \   00000000   0x........         DC32     gSnd+0x3C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_27:
   \   00000000   0x........         DC32     gSnd+0x3E

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_28:
   \   00000000   0x........         DC32     gSnd+0x40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_29:
   \   00000000   0x........         DC32     gSnd+0x42

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_30:
   \   00000000   0x........         DC32     gSnd+0x43

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_31:
   \   00000000   0x........         DC32     gSnd+0x44

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_32:
   \   00000000   0x........         DC32     gOpt+0x1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_33:
   \   00000000   0x........         DC32     gOpt+0x2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_34:
   \   00000000   0x........         DC32     gOpt+0x3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_35:
   \   00000000   0x........         DC32     gOpt+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_36:
   \   00000000   0x........         DC32     gOpt+0x8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_37:
   \   00000000   0x........         DC32     gOpt+0xA

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_38:
   \   00000000   0x........         DC32     gOpt+0xC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_39:
   \   00000000   0x........         DC32     gOpt+0xE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_40:
   \   00000000   0x........         DC32     gOpt+0xF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_41:
   \   00000000   0x........         DC32     gOpt+0x10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_42:
   \   00000000   0x........         DC32     gOpt+0x14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_43:
   \   00000000   0x........         DC32     gOpt+0x18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_44:
   \   00000000   0x........         DC32     gOpt+0x1C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_45:
   \   00000000   0x........         DC32     gOpt+0x1E

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_46:
   \   00000000   0x........         DC32     sentPackets

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_47:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_48:
   \   00000000   0x........         DC32     gAppTxPacket

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_49:
   \   00000000   0x........         DC32     appState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_50:
   \   00000000   0x........         DC32     gSnd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_51:
   \   00000000   0x........         DC32     sensorID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_52:
   \   00000000   0x0010F447         DC32     0x10f447

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_53:
   \   00000000   0x0021E88E         DC32     0x21e88e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_54:
   \   00000000   0x0032DCD5         DC32     0x32dcd5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_55:
   \   00000000   0x069F6BC7         DC32     0x69f6bc7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_56:
   \   00000000   0x0D3ED78E         DC32     0xd3ed78e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_57:
   \   00000000   0x13DE4355         DC32     0x13de4355

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_58:
   \   00000000   0x........         DC32     evDataFromCOMM

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_59:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_60:
   \   00000000   0x........         DC32     g_DEAD_BEEF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_61:
   \   00000000   0x........         DC32     gFlashDeadBeef

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_62:
   \   00000000   0x........         DC32     settingsAddress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_63:
   \   00000000   0x........         DC32     gOptions

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_64:
   \   00000000   0x00028488         DC32     0x28488

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_65:
   \   00000000   0x........         DC32     gOpt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_66:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_67:
   \   00000000   0x........         DC32     ??sDeadBeef

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_68:
   \   00000000   0x........         DC32     maMmPools

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_69:
   \   00000000   0x........         DC32     poolInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_70:
   \   00000000   0x........         DC32     maMacHeap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_71:
   \   00000000   0x........         DC32     testOpMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_72:
   \   00000000   0x........         DC32     testChannel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_73:
   \   00000000   0x........         DC32     testPower

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_74:
   \   00000000   0x........         DC32     testTrimmValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_75:
   \   00000000   0x........         DC32     testPayloadLen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_76:
   \   00000000   0x........         DC32     contTestRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_77:
   \   00000000   0x........         DC32     shortCutsEnabled

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_78:
   \   00000000   0x........         DC32     connState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_79:
   \   00000000   0x........         DC32     cTxRxState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_80:
   \   00000000   0x........         DC32     perTxState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_81:
   \   00000000   0x........         DC32     perRxState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_82:
   \   00000000   0x........         DC32     rangeTxState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_83:
   \   00000000   0x........         DC32     rangeRxState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_84:
   \   00000000   0x........         DC32     prevOpMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_85:
   \   00000000   0x........         DC32     txTestIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_86:
   \   00000000   0x........         DC32     rxTestIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_87:
   \   00000000   0x........         DC32     gau8TxDataBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_88:
   \   00000000   0x........         DC32     gau8RxDataBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_89:
   \   00000000   0x........         DC32     gAppRxPacket

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_90:
   \   00000000   0x........         DC32     bCommTxDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_91:
   \   00000000   0x........         DC32     gu8CommData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_92:
   \   00000000   0x........         DC32     bTxDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_93:
   \   00000000   0x........         DC32     bRxDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_94:
   \   00000000   0x........         DC32     bestChannel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_95:
   \   00000000   0x........         DC32     bScanDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_96:
   \   00000000   0x........         DC32     evTestParameters

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x0C 0x0D          DC8 "\014\015\012 Running PER Tx, Sending "
   \              0x0A 0x20    
   \              0x52 0x75    
   \              0x6E 0x6E    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x50 0x45    
   \              0x52 0x20    
   \              0x54 0x78    
   \              0x2C 0x20    
   \              0x53 0x65    
   \              0x6E 0x64    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x20 0x50          DC8 " Packets"
   \              0x61 0x63    
   \              0x6B 0x65    
   \              0x74 0x73    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x53 0x4E          DC8 53H, 4EH, 44H, 9, 25H, 75H, 9, 25H
   \              0x44 0x09    
   \              0x25 0x75    
   \              0x09 0x25    
   \   00000008   0x75 0x09          DC8 75H, 9, 25H, 75H, 9, 25H, 75H, 9
   \              0x25 0x75    
   \              0x09 0x25    
   \              0x75 0x09    
   \   00000010   0x25 0x75          DC8 25H, 75H, 9, 25H, 75H, 9, 25H, 75H
   \              0x09 0x25    
   \              0x75 0x09    
   \              0x25 0x75    
   \   00000018   0x09 0x25          DC8 9, 25H, 75H, 9, 25H, 75H, 9, 25H
   \              0x75 0x09    
   \              0x25 0x75    
   \              0x09 0x25    
   \   00000020   0x75 0x09          DC8 75H, 9, 25H, 75H, 9, 25H, 75H, 9
   \              0x25 0x75    
   \              0x09 0x25    
   \              0x75 0x09    
   \   00000028   0x25 0x75          DC8 25H, 75H, 9, 25H, 64H, 9, 25H, 75H
   \              0x09 0x25    
   \              0x64 0x09    
   \              0x25 0x75    
   \   00000030   0x09 0x25          DC8 9, 25H, 64H, 9, 25H, 75H, 9, 25H
   \              0x64 0x09    
   \              0x25 0x75    
   \              0x09 0x25    
   \   00000038   0x75 0x09          DC8 75H, 9, 25H, 75H, 9, 25H, 75H, 9
   \              0x25 0x75    
   \              0x09 0x25    
   \              0x75 0x09    
   \   00000040   0x25 0x75          DC8 25H, 75H, 0DH, 0AH, 0
   \              0x0D 0x0A    
   \              0x00         
   \   00000045   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x40020000         DC32 1073872896, 0, 524288, 0, 0, 0, 0, 0
   \              0x00000000   
   \              0x00080000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x40020000         DC32 1073872896, 0, 524288, 0, 0, 0, 0, 0
   \              0x00000000   
   \              0x00080000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   2411          
   2412          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   ChangeOptions
         8   -> FlashSaveOptions
         8   -> SendCurrentOptions
         8   -> __aeabi_memcpy4
         8   -> memcmp
      32   ChooseBestChannel
        32   -> CopyPngPacketToSMAC
        32   -> GetLinkQdBm
        32   -> GetRandomNibble
        32   -> MCPSDataRequest
        32   -> MLMESetChannelRequest
        32   -> PngSwapEndianness
        32   -> ReceivePacket
        32   -> SendCurrentOptions
       8   CommRxCallback
         8   -> ShortCutsParser
         8   -> Uart1_GetByteFromRxBuffer
       0   CommTxCallback
       8   CopyBinaryPacketToSMAC
         8   -> MemoryCpy
       8   CopyOptPacketToSMAC
         8   -> MemoryCpy
      16   CopyOptionsFromRecvPacket
        16   -> MemoryCpy
       8   CopyPngPacketToSMAC
         8   -> MemoryCpy
      48   FlashSaveOptions
        48   -> NV_FlashEraseSector
        48   -> NV_FlashProgramLongword
        48   -> NV_FlashProgramUnalignedLongword
        48   -> __aeabi_memcpy4
      16   GetDeviceData
        16   -> ConversionAComplete
        16   -> GetConversionValue
        16   -> INIT_PIT
        16   -> NVIC_DisableIRQ
        16   -> NVIC_EnableIRQ
        16   -> StartBattConversion
        16   -> StartTempConversion
       0   GetFactoryOptions
       8   GetLinkQdBm
         8   -> MLMELinkQuality
       0   GetRandomNibble
       0   GlobalDataInit
       8   INIT_PIT
         8   -> NVIC_DisableIRQ
         8   -> NVIC_EnableIRQ
         8   -> NVIC_SetPriority
       0   InitAccelControlls
       0   InitPacket
      56   InitProject
        56   -> FlashSaveOptions
        56   -> GetFactoryOptions
        56   -> GlobalDataInit
        56   -> InitPacket
        56   -> KeyboardInit
        56   -> LED_Init
        56   -> MC1324xDrv_SPIInit
        56   -> MLMERadioInit
        56   -> MM_Init
        56   -> NV_FlashInit
        56   -> NV_FlashRead
        56   -> TMR_Init
        56   -> Uart1_SetBaud
        56   -> Uart1_SetRxCallBack
        56   -> Uart_ModuleInit
        56   -> __aeabi_memcpy4
      16   InitSmac
        16   -> MLMEPAOutputAdjust
        16   -> MLMESetChannelRequest
        16   -> MLMESetPromiscuousMode
        16   -> MLMEXtalAdjust
       0   MCPSDataConfirm
       0   MCPSDataIndication
       0   MLMEResetIndication
       0   MLMEScanConfirm
       0   MLMEWakeConfirm
       0   OptSwapEndianness
      16   PIT_ISR
        16   -> ConversionAComplete
        16   -> GetConversionValue
        16   -> StartXConversion
        16   -> StartYConversion
        16   -> StartZConversion
       0   PngSwapEndianness
       8   PrintPacketID
         8   -> CommUtil_Print
         8   -> PrintWordOnDecimalFormatBlocking
       8   ReceivePacket
         8   -> MLMERXEnableRequest
      88   SendASCIIPacket
        88   -> InitPacket
        88   -> MCPSDataRequest
        88   -> sprintf
       8   SendBinaryPacket
         8   -> CopyBinaryPacketToSMAC
         8   -> GetLinkQdBm
         8   -> MCPSDataRequest
         8   -> SndSwapEndianness
       8   SendCurrentOptions
         8   -> CopyOptPacketToSMAC
         8   -> MCPSDataRequest
         8   -> OptSwapEndianness
         8   -> __aeabi_memcpy4
       0   ShortCutsParser
       0   SndSwapEndianness
       0   ValidateOptions
       0   getRandomNumberInRange
      64   main
        64   -> ADCInit
        64   -> ChooseBestChannel
        64   -> CopyOptionsFromRecvPacket
        64   -> GetDeviceData
        64   -> GetFactoryOptions
        64   -> INIT_PIT
        64   -> InitAccelControlls
        64   -> InitPacket
        64   -> InitProject
        64   -> InitSmac
        64   -> MLMEPAOutputAdjust
        64   -> MLMESetChannelRequest
        64   -> MLMEXtalAdjust
        64   -> OptSwapEndianness
        64   -> ReceivePacket
        64   -> SendBinaryPacket
        64   -> ValidateOptions


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable23
       4  ??DataTable25
       4  ??DataTable29
       4  ??DataTable30
       4  ??DataTable31
       4  ??DataTable31_1
       4  ??DataTable31_10
       4  ??DataTable31_11
       4  ??DataTable31_12
       4  ??DataTable31_13
       4  ??DataTable31_14
       4  ??DataTable31_15
       4  ??DataTable31_16
       4  ??DataTable31_17
       4  ??DataTable31_18
       4  ??DataTable31_19
       4  ??DataTable31_2
       4  ??DataTable31_20
       4  ??DataTable31_21
       4  ??DataTable31_22
       4  ??DataTable31_23
       4  ??DataTable31_24
       4  ??DataTable31_25
       4  ??DataTable31_26
       4  ??DataTable31_27
       4  ??DataTable31_28
       4  ??DataTable31_29
       4  ??DataTable31_3
       4  ??DataTable31_30
       4  ??DataTable31_31
       4  ??DataTable31_32
       4  ??DataTable31_33
       4  ??DataTable31_34
       4  ??DataTable31_35
       4  ??DataTable31_36
       4  ??DataTable31_37
       4  ??DataTable31_38
       4  ??DataTable31_39
       4  ??DataTable31_4
       4  ??DataTable31_40
       4  ??DataTable31_41
       4  ??DataTable31_42
       4  ??DataTable31_43
       4  ??DataTable31_44
       4  ??DataTable31_45
       4  ??DataTable31_46
       4  ??DataTable31_47
       4  ??DataTable31_48
       4  ??DataTable31_49
       4  ??DataTable31_5
       4  ??DataTable31_50
       4  ??DataTable31_51
       4  ??DataTable31_52
       4  ??DataTable31_53
       4  ??DataTable31_54
       4  ??DataTable31_55
       4  ??DataTable31_56
       4  ??DataTable31_57
       4  ??DataTable31_58
       4  ??DataTable31_59
       4  ??DataTable31_6
       4  ??DataTable31_60
       4  ??DataTable31_61
       4  ??DataTable31_62
       4  ??DataTable31_63
       4  ??DataTable31_64
       4  ??DataTable31_65
       4  ??DataTable31_66
       4  ??DataTable31_67
       4  ??DataTable31_68
       4  ??DataTable31_69
       4  ??DataTable31_7
       4  ??DataTable31_70
       4  ??DataTable31_71
       4  ??DataTable31_72
       4  ??DataTable31_73
       4  ??DataTable31_74
       4  ??DataTable31_75
       4  ??DataTable31_76
       4  ??DataTable31_77
       4  ??DataTable31_78
       4  ??DataTable31_79
       4  ??DataTable31_8
       4  ??DataTable31_80
       4  ??DataTable31_81
       4  ??DataTable31_82
       4  ??DataTable31_83
       4  ??DataTable31_84
       4  ??DataTable31_85
       4  ??DataTable31_86
       4  ??DataTable31_87
       4  ??DataTable31_88
       4  ??DataTable31_89
       4  ??DataTable31_9
       4  ??DataTable31_90
       4  ??DataTable31_91
       4  ??DataTable31_92
       4  ??DataTable31_93
       4  ??DataTable31_94
       4  ??DataTable31_95
       4  ??DataTable31_96
      32  ?_0
      12  ?_1
      72  ?_2
      32  ?_3
      32  ?_4
       4  AXIS
      54  ChangeOptions
     228  ChooseBestChannel
      34  CommRxCallback
       8  CommTxCallback
     494  CopyBinaryPacketToSMAC
     250  CopyOptPacketToSMAC
     216  CopyOptionsFromRecvPacket
      76  CopyPngPacketToSMAC
      96  FlashSaveOptions
     230  GetDeviceData
      50  GetFactoryOptions
      16  GetLinkQdBm
      58  GetRandomNibble
     102  GlobalDataInit
      72  INIT_PIT
     114  InitAccelControlls
     278  InitPacket
     314  InitProject
      58  InitSmac
       8  MCPSDataConfirm
      14  MCPSDataIndication
       2  MLMEResetIndication
      12  MLMEScanConfirm
       2  MLMEWakeConfirm
     104  OptSwapEndianness
     246  PIT_ISR
       4  PIT_ITTERATIONS
      28  PngSwapEndianness
      40  PrintPacketID
     210  ReceivePacket
     194  SendASCIIPacket
      50  SendBinaryPacket
      66  SendCurrentOptions
     268  ShortCutsParser
     724  SndSwapEndianness
       4  TempSumx
       4  TempSumy
       4  TempSumz
     146  ValidateOptions
       1  appState
      16  au8ScanResults
       1  b
       1  bCommTxDone
       1  bRxDone
       1  bScanDone
       1  bTxDone
       1  bestChannel
       1  cTxRxState
       1  connState
       1  contTestRunning
       1  eRState
       1  evDataFromCOMM
       1  evTestParameters
       4  gAppRxPacket
       4  gAppTxPacket
       4  gFlashDeadBeef
      24  gFlashOptions
       1  gIsAck
       1  gIsMyAck
      32  gOpt
      24  gOptions
       8  gPng
      96  gRawSnd
       4  gRxTimeout
      72  gSnd
       4  g_DEAD_BEEF
     132  gau8RxDataBuffer
     128  gau8TxDataBuffer
      34  getRandomNumberInRange
       1  gu8CommData
     572  main
       1  oDRState
       1  oIRState
       1  perRxState
       1  perTxState
       1  prevOpMode
       1  rDRState
       1  rIRState
       1  rangeRxState
       1  rangeTxState
       1  rxTestIndex
       4  sDeadBeef
       2  sensorID
       2  sentPackets
       4  settingsAddress
       1  shortCutsEnabled
       1  testChannel
       1  testOpMode
       1  testPayloadLen
       1  testPower
       1  testTrimmValue
       1  txTestIndex

 
   609 bytes in section .bss
   188 bytes in section .rodata
 6 020 bytes in section .text
 
 6 020 bytes of CODE  memory
   188 bytes of CONST memory
   609 bytes of DATA  memory

Errors: none
Warnings: 4
