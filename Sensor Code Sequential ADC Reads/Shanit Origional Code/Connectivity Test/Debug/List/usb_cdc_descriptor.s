///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM       02/Sep/2018  14:19:42
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\APP\CDC\usb_cdc_descriptor.c
//    Command line =  
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\APP\CDC\usb_cdc_descriptor.c" -D IAR --preprocess
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\" -lC
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\" -lB
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\"
//        --diag_suppress Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\Obj\" --no_cse
//        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
//        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\APP\CDC\" -I "F:\Guardrail Work\Sensor Code\Git
//        Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\USB\APP\Descriptor\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Class\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Sys Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
//    List file    =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\Debug\List\usb_cdc_descriptor.s
//
///////////////////////////////////////////////////////////////////////////////

        #define SHT_PROGBITS 0x1

        PUBLIC USB_CDC_Desc_GetAbstractState
        PUBLIC USB_CDC_Desc_GetCountrySetting
        PUBLIC USB_CDC_Desc_GetDescriptor
        PUBLIC USB_CDC_Desc_GetInterface
        PUBLIC USB_CDC_Desc_GetLineCoding
        PUBLIC USB_CDC_Desc_RemoteWakeup
        PUBLIC USB_CDC_Desc_SetAbstractState
        PUBLIC USB_CDC_Desc_SetCountrySetting
        PUBLIC USB_CDC_Desc_SetInterface
        PUBLIC USB_CDC_Desc_SetLineCoding
        PUBLIC USB_CDC_Desc_ValidConfiguration
        PUBLIC USB_CDC_Desc_ValidInterface
        PUBLIC gCDCConfigDescriptor
        PUBLIC gCDCDeviceDescriptor
        PUBLIC gCDC_Languages
        PUBLIC gCDC_StdDescSize
        PUBLIC gCDC_StdDescriptors
        PUBLIC gCDC_Str0
        PUBLIC gCDC_Str1
        PUBLIC gCDC_Str2
        PUBLIC gCDC_StringDescSize
        PUBLIC gCDC_StringDescriptors
        PUBLIC gCDC_Strn
        PUBLIC gCDC_ValidConfigValues
        PUBLIC usbCdcDescEp

// F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\APP\CDC\usb_cdc_descriptor.c
//    1 /******************************************************************************
//    2  *
//    3  * Virtual Com Application descriptor file
//    4  * Freescale Semiconductor Inc.
//    5  * (c) Copyright 2012 Freescale Semiconductor, Inc.
//    6  * ALL RIGHTS RESERVED.
//    7  *
//    8  **************************************************************************/
//    9  
//   10 
//   11 /******************************************************************************
//   12  * Includes
//   13  *****************************************************************************/
//   14 #include "EmbeddedTypes.h"
//   15 #include "usb_class.h"
//   16 #include "USB.h"
//   17 #include "usb_descriptor.h"
//   18 #include "usb_cdc_descriptor.h"
//   19 #include "usb_dciapi.h"
//   20 #include "usb_cdc_pstn.h"
//   21 #include "CDC_Interface.h" 
//   22 
//   23 #if gVirtualCOMPort_d
//   24 /*****************************************************************************
//   25  * Constant and Macro's
//   26  *****************************************************************************/
//   27 /* structure containing details of all the endpoints used by this device */

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
//   28  const usbEpStruct_t  usbCdcDescEp[gNumUsbCdcNonControlEp_d]=
usbCdcDescEp:
        DATA
        DC8 1, 2, 1, 0
        DC16 16
        DC8 2, 2, 0, 0
        DC16 16
        DC8 3, 3, 1, 0
        DC16 16
        DC8 0, 0
//   29 {
//   30   {
//   31     gCDC_DIC_BulkInEndpoint_d,
//   32     gUsbEpType_Bulk_c,
//   33     gUsbEpDirection_In_c,
//   34     gUsbCdcBulkInEpSize_d,
//   35   },
//   36   {
//   37     gCDC_DIC_BulkOutEndpoint_d,
//   38     gUsbEpType_Bulk_c,
//   39     gUsbEpDirection_Out_c,
//   40     gUsbCdcBulkOutEpSize_d,
//   41   },
//   42   {
//   43     gCDC_CIC_NotifyEndpoint_d,
//   44     gUsbEpType_Interrupt_c,
//   45     gUsbEpDirection_In_c,
//   46     gUsbCdcInterruptInEpSize_d,
//   47   }
//   48 };
//   49 

        SECTION `.data`:DATA:REORDER:NOROOT(2)
//   50 uint8_t   gCDCDeviceDescriptor[gUSB_DescSize_DeviceDescriptorSize_d] =
gCDCDeviceDescriptor:
        DATA
        DC8 18, 1, 0, 2, 2, 0, 0, 16, 4, 37, 0, 3, 2, 0, 1, 2, 0, 1, 0, 0
//   51 
//   52 {
//   53   gUSB_DescSize_DeviceDescriptorSize_d,               /*  Device Dexcriptor Size         */
//   54   gUSB_DescType_DeviceDescriptor_d,                /*  Device Type of descriptor      */
//   55   0x00, 0x02,                           /*  BCD USB version                */
//   56   0x02,                                 /*  Communications device class    */
//   57   0x00,                                 /*  Device Subclass is indicated
//   58                                             in the interface descriptors   */
//   59   0x00,                                 /*  Device Protocol                */
//   60   gUsbCdcControlEpSize_d,              /*  Max Packet size                */
//   61   0x04,0x25,                            /*  Vendor ID                      */
//   62   0x00,0x03,                            /*  0300 is our Product ID for CDC */
//   63   0x02,0x00,                            /*  BCD Device version             */
//   64   0x01,                                 /*  Manufacturer string index      */
//   65   0x02,                                 /*  Product string index           */
//   66   #if gVirtualCOMPortSerialNoEnable_d
//   67   0x03,
//   68   #else
//   69   0x00,
//   70   #endif                                 /*  Serial number string index     */
//   71   0x01                                  /*  Number of configurations       */
//   72 };
//   73 

        SECTION `.data`:DATA:REORDER:NOROOT(2)
//   74 uint8_t    gCDCConfigDescriptor[gCDC_ConfigDescSize_d] =
gCDCConfigDescriptor:
        DATA
        DC8 9, 2, 67, 0, 2, 1, 0, 224, 50, 9, 4, 0, 0, 1, 2, 2, 0, 0, 5, 36, 0
        DC8 16, 1, 5, 36, 1, 1, 1, 4, 36, 2, 6, 5, 36, 6, 0, 1, 7, 5, 131, 3
        DC8 16, 0, 10, 9, 4, 1, 0, 2, 10, 0, 0, 0, 7, 5, 129, 2, 16, 0, 0, 7, 5
        DC8 2, 2, 16, 0, 0, 0
//   75 {
//   76   gUSB_DescSize_ConfigOnlyDescriptorSize_d,  /*  Configuration Descriptor Size */
//   77   gUSB_DescType_ConfigDescriptor_d,  /* "Configuration" type of descriptor */
//   78   gCDC_ConfigDescSize_d, 0x00, /*  Total length of the Configuration descriptor */
//   79   (uint8_t)(2),/*NumInterfaces*/
//   80   0x01,                      /*  Configuration Value */
//   81   0x00,                      /*  Configuration Description String Index*/
//   82   gbmUsbAttributes_BusPowered_d|gbmUsbAttributes_SelfPowered_d|(gCDCRemoteWakeupSupport_d<<gCDC_RemoteWakeupShift_d),
//   83               /*  Attributes.support RemoteWakeup and self power*/
//   84   0x32,                   /*  Current draw from bus -- 100mA*/
//   85   /* CIC INTERFACE DESCRIPTOR */
//   86   gUSB_DescSize_InterfaceOnlyDescriptorSize_d,
//   87   gUSB_DescType_InterfaceDescriptor_d,
//   88   0x00, /* bInterfaceNumber */
//   89   0x00, /* bAlternateSetting */
//   90   gCDC_CIC_EndpCount_d, /* management and notification(optional)element present */
//   91   0x02, /* Communication Interface Class */
//   92   gCDC_CIC_SubclassCode_d,
//   93   gCDC_CIC_ProtocolCode_d,
//   94   0x00, /* Interface Description String Index*/
//   95 
//   96   /* CDC Class-Specific descriptor */
//   97   0x05,             /* size of Functional Desc in bytes */
//   98   gCDC_DescType_CS_Interface_d,  /* descriptor type*/
//   99   gUSB_CDC_DescType_HeaderFuncDesc_d,
//  100   0x10, 0x01,  /* USB Class Definitions for CDC spec release number in BCD */
//  101   0x05,             /* Size of this descriptor */
//  102   gCDC_DescType_CS_Interface_d, /* descriptor type*/
//  103   gUSB_CDC_DescType_CallManagementFuncDesc_d,
//  104   0x01,/*may use 0x03 */  /* device handales call management itself(D0 set)
//  105               and will process commands multiplexed over the data interface */
//  106   0x01,      /* Indicates multiplexed commands are
//  107                 handled via data interface */
//  108 
//  109   0x04,             /* Size of this descriptor */
//  110   gCDC_DescType_CS_Interface_d, /* descriptor type*/
//  111   gUSB_CDC_DescType_AbstractControlFuncDesc_d,
//  112   0x06, /*may use 0x0F */ /* Device Supports all commands for ACM - CDC
//  113                               PSTN SubClass bmCapabilities */
//  114 
//  115   0x05,             /* size of Functional Desc in bytes */
//  116   gCDC_DescType_CS_Interface_d,  /* descriptor type*/
//  117   gUSB_CDC_DescType_UnionFuncDesc_d,
//  118   0x00,           /* Interface Number of Control */
//  119   0x01,           /* Interface Number of Subordinate (Data Class) Interface */
//  120   gUSB_DescSize_EndpOnlyDescriptorSize_d,
//  121   gUSB_DescType_EndpointDescriptor_d,
//  122   gCDC_CIC_NotifyEndpoint_d|(gUsbEpDirection_In_c << 7),
//  123   gUsbEpType_Interrupt_c,
//  124   gUsbCdcInterruptInEpSize_d, 0x00,
//  125   0x0A,
//  126   gUSB_DescSize_InterfaceOnlyDescriptorSize_d,
//  127   gUSB_DescType_InterfaceDescriptor_d,
//  128   (uint8_t)(1), /* bInterfaceNumber */
//  129   0x00, /* bAlternateSetting */
//  130   gCDC_DIC_EndpCount_d, /* notification element included */
//  131   0x0A, /* DATA Interface Class */
//  132   0x00, /* Data Interface SubClass Code */
//  133   gCDC_DIC_ProtocolCode_d,
//  134   0x00, /* Interface Description String Index*/
//  135   /*Endpoint descriptor */
//  136   gUSB_DescSize_EndpOnlyDescriptorSize_d,
//  137   gUSB_DescType_EndpointDescriptor_d,
//  138   gCDC_DIC_BulkInEndpoint_d|(gUsbEpDirection_In_c << 7),
//  139   gUsbEpType_Bulk_c,
//  140   gUsbCdcBulkInEpSize_d, 0x00,
//  141   0x00,/* This value is ignored for Bulk ENDPOINT */
//  142    /*Endpoint descriptor */
//  143   gUSB_DescSize_EndpOnlyDescriptorSize_d,
//  144   gUSB_DescType_EndpointDescriptor_d,
//  145   gCDC_DIC_BulkOutEndpoint_d|(gUsbEpDirection_Out_c << 7),
//  146   gUsbEpType_Bulk_c,
//  147   gUsbCdcBulkOutEpSize_d, 0x00,
//  148   0x00 /* This value is ignored for Bulk ENDPOINT */
//  149 };
//  150 

        SECTION `.data`:DATA:REORDER:NOROOT(2)
//  151 uint8_t   gCDC_Str0[gCDC_Str0DescSize_d+gUSB_DescSize_StringDescriptorSize_d] =
gCDC_Str0:
        DATA
        DC8 4, 3, 9, 4
//  152 {
//  153   sizeof(gCDC_Str0),
//  154   gUSB_DescType_StringDescriptor_d,
//  155   0x09,
//  156   0x04/*equiavlent to 0x0409(English - United States)*/
//  157 };
//  158 

        SECTION `.data`:DATA:REORDER:NOROOT(2)
//  159 uint8_t   gCDC_Str1[gCDC_Str1DescSize_d+gUSB_DescSize_StringDescriptorSize_d] = 
gCDC_Str1:
        DATA
        DC8 58, 3, 70, 0, 82, 0, 69, 0, 69, 0, 83, 0, 67, 0, 65, 0, 76, 0, 69
        DC8 0, 32, 0, 83, 0, 69, 0, 77, 0, 73, 0, 67, 0, 79, 0, 78, 0, 68, 0
        DC8 85, 0, 67, 0, 84, 0, 79, 0, 82, 0, 32, 0, 73, 0, 78, 0, 67, 0, 46
        DC8 0, 0, 0
//  160 {
//  161   sizeof(gCDC_Str1),
//  162   gUSB_DescType_StringDescriptor_d,
//  163   'F',0,
//  164   'R',0,
//  165   'E',0,
//  166   'E',0,
//  167   'S',0,
//  168   'C',0,
//  169   'A',0,
//  170   'L',0,
//  171   'E',0,
//  172   ' ',0,
//  173   'S',0,
//  174   'E',0,
//  175   'M',0,
//  176   'I',0,
//  177   'C',0,
//  178   'O',0,
//  179   'N',0,
//  180   'D',0,
//  181   'U',0,
//  182   'C',0,
//  183   'T',0,
//  184   'O',0,
//  185   'R',0,
//  186   ' ',0,
//  187   'I',0,
//  188   'N',0,
//  189   'C',0,
//  190   '.',0
//  191 };
//  192 
//  193 

        SECTION `.data`:DATA:REORDER:NOROOT(2)
//  194 uint8_t   gCDC_Str2[gCDC_Str2DescSize_d+gUSB_DescSize_StringDescriptorSize_d] = 
gCDC_Str2:
        DATA
        DC8 46, 3, 70, 0, 82, 0, 69, 0, 69, 0, 83, 0, 67, 0, 65, 0, 76, 0, 69
        DC8 0, 32, 0, 86, 0, 73, 0, 82, 0, 84, 0, 85, 0, 65, 0, 76, 0, 32, 0
        DC8 67, 0, 79, 0, 77, 0, 32, 0, 0, 0
//  195 {
//  196   sizeof(gCDC_Str2),
//  197   gUSB_DescType_StringDescriptor_d,
//  198   'F',0,
//  199   'R',0,
//  200   'E',0,
//  201   'E',0,
//  202   'S',0,
//  203   'C',0,
//  204   'A',0,
//  205   'L',0,
//  206   'E',0,
//  207   ' ',0,
//  208   'V',0,
//  209   'I',0,
//  210   'R',0,
//  211   'T',0,
//  212   'U',0,
//  213   'A',0,
//  214   'L',0,
//  215   ' ',0,
//  216   'C',0,
//  217   'O',0,
//  218   'M',0,
//  219   ' ',0
//  220 };
//  221      
//  222 #if gVirtualCOMPortSerialNoEnable_d                          
//  223 uint8_t   gCDC_Str3[gCDC_Str3DescSize_d+gUSB_DescSize_StringDescriptorSize_d] = 
//  224 {
//  225   sizeof(gCDC_Str3),
//  226   gUSB_DescType_StringDescriptor_d,
//  227   gDefaultValueOfVirtualCOMPortSerialNo_c
//  228 };
//  229 #endif
//  230 

        SECTION `.data`:DATA:REORDER:NOROOT(2)
//  231 uint8_t   gCDC_Strn[gCDC_StrNDescSize_d+gUSB_DescSize_StringDescriptorSize_d] =
gCDC_Strn:
        DATA
        DC8 34, 3, 66, 0, 65, 0, 68, 0, 32, 0, 83, 0, 84, 0, 82, 0, 73, 0, 78
        DC8 0, 71, 0, 32, 0, 73, 0, 78, 0, 68, 0, 69, 0, 88, 0, 0, 0
//  232 {
//  233   sizeof(gCDC_Strn),
//  234   gUSB_DescType_StringDescriptor_d,
//  235   'B',0,
//  236   'A',0,
//  237   'D',0,
//  238   ' ',0,
//  239   'S',0,
//  240   'T',0,
//  241   'R',0,
//  242   'I',0,
//  243   'N',0,
//  244   'G',0,
//  245   ' ',0,
//  246   'I',0,
//  247   'N',0,
//  248   'D',0,
//  249   'E',0,
//  250   'X',0
//  251 };
//  252 
//  253 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
//  254 usbPacketSize_t const gCDC_StdDescSize[gCDC_Num_StdDescriptorsNum_d+1] =
gCDC_StdDescSize:
        DATA
        DC16 0, 18, 67, 0, 0, 0, 0, 0
//  255 {
//  256   0,
//  257   gUSB_DescSize_DeviceDescriptorSize_d,
//  258   gCDC_ConfigDescSize_d,
//  259   0, /* string */
//  260   0, /* Interface */
//  261   0, /* Endpoint */
//  262   0, /* Device Qualifier */
//  263   0 /* other speed config */
//  264 };
//  265 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
//  266 uint8_t* const gCDC_StdDescriptors[gCDC_Num_StdDescriptorsNum_d+1] =
gCDC_StdDescriptors:
        DATA
        DC32 0H, gCDCDeviceDescriptor, gCDCConfigDescriptor, 0H, 0H, 0H, 0H, 0H
//  267 {
//  268   NULL,
//  269   (uint8_t*)gCDCDeviceDescriptor,
//  270   (uint8_t*)gCDCConfigDescriptor,
//  271   NULL, /* string */
//  272   NULL, /* Interface */
//  273   NULL, /* Endpoint */
//  274   NULL, /* Device Qualifier */
//  275   NULL  /* other speed config*/
//  276 };
//  277 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
//  278 uint8_t const gCDC_StringDescSize[gCDC_Num_StringDescriptorsNum_d+1] =
gCDC_StringDescSize:
        DATA
        DC8 4, 58, 46, 34
//  279 {
//  280   sizeof(gCDC_Str0),
//  281   sizeof(gCDC_Str1),
//  282   sizeof(gCDC_Str2),
//  283 #if gVirtualCOMPortSerialNoEnable_d  
//  284   sizeof(gCDC_Str3),
//  285 #endif  
//  286   sizeof(gCDC_Strn)
//  287 };
//  288 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
//  289 uint8_t* const gCDC_StringDescriptors[gCDC_Num_StringDescriptorsNum_d+1] =
gCDC_StringDescriptors:
        DATA
        DC32 gCDC_Str0, gCDC_Str1, gCDC_Str2, gCDC_Strn
//  290 {
//  291   (uint8_t*)gCDC_Str0,
//  292   (uint8_t*)gCDC_Str1,
//  293   (uint8_t*)gCDC_Str2,
//  294 #if gVirtualCOMPortSerialNoEnable_d  
//  295   (uint8_t*)gCDC_Str3,
//  296 #endif  
//  297   (uint8_t*)gCDC_Strn
//  298 };
//  299 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
//  300 usbCDCAllLanguages_t gCDC_Languages = 
gCDC_Languages:
        DATA
        DC32 gCDC_Str0
        DC8 4, 0, 0, 0
        DC16 1033
        DC8 0, 0
        DC32 gCDC_StringDescriptors, gCDC_StringDescSize
//  301 { 
//  302 gCDC_Str0, sizeof(gCDC_Str0),
//  303   { 
//  304     {
//  305       (uint16_t )0x0409,
//  306       (const uint8_t **)gCDC_StringDescriptors,
//  307       gCDC_StringDescSize
//  308     }
//  309   }
//  310 };
//  311 

        SECTION `.rodata`:CONST:REORDER:NOROOT(1)
//  312 uint8_t const gCDC_ValidConfigValues[gCDC_Num_SupportedConfigNum_d+1]={0,1};
gCDC_ValidConfigValues:
        DATA
        DC8 0, 1
//  313 
//  314 /****************************************************************************
//  315  * Global Variables
//  316  ****************************************************************************/
//  317 
//  318 

        SECTION `.data`:DATA:REORDER:NOROOT(2)
//  319 static uint8_t gLineCoding[gCDC_Num_MaxSupportedDataInterfaces_d][gCDC_LineCodingSize_d] =
gLineCoding:
        DATA
        DC8 0, 194, 1, 0, 0, 0, 8, 0
//  320 {
//  321   {
//  322     (gCDC_LineCodeDTERateIface0_d>> 0) & 0x000000FF,
//  323     (gCDC_LineCodeDTERateIface0_d>> 8) & 0x000000FF,
//  324     (gCDC_LineCodeDTERateIface0_d>>16) & 0x000000FF,
//  325     (gCDC_LineCodeDTERateIface0_d>>24) & 0x000000FF,
//  326     /*e.g. 0x00,0xC2,0x01,0x00 : 0x0001C200 is 115200 bits per second */
//  327     gCDC_LineCodeCharFormatIface0_d,
//  328     gCDC_LineCodeParityTypeIface0_d,
//  329     gCDC_LineCodeDataBitsIface0_d
//  330   }
//  331 };
//  332 

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
//  333 static uint8_t gAbstractState[gCDC_Num_MaxSupportedDataInterfaces_d][gUSB_CDC_CommFeatureDataSize_d] =
gAbstractState:
        DS8 2
//  334 {
//  335   { 
//  336     (gCDC_StatusAbstractStateIface0_d>>0) & 0x00FF,
//  337     (gCDC_StatusAbstractStateIface0_d>>8) & 0x00FF
//  338   }
//  339 };
//  340 

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
//  341 static uint8_t gCountryCode[gCDC_Num_MaxSupportedDataInterfaces_d][gUSB_CDC_CommFeatureDataSize_d] =
gCountryCode:
        DS8 2
//  342 {
//  343   { 
//  344     (gCDC_CountrySettingIface0_d>>0) & 0x00FF,
//  345     (gCDC_CountrySettingIface0_d>>8) & 0x00FF
//  346   }
//  347 };
//  348 

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
//  349 static uint8_t gAlternateInterface[gCDC_Num_MaxSupportedDataInterfaces_d + 1];
gAlternateInterface:
        DS8 2
//  350 
//  351 /*****************************************************************************
//  352  * Local Types - None
//  353  *****************************************************************************/
//  354 
//  355 /*****************************************************************************
//  356  * Local Functions Prototypes
//  357  *****************************************************************************/
//  358 
//  359 /*****************************************************************************
//  360  * Local Variables - None
//  361  *****************************************************************************/
//  362 
//  363 
//  364  /*****************************************************************************
//  365  * Local Functions - None
//  366  *****************************************************************************/
//  367 
//  368 /*****************************************************************************
//  369  * Global Functions
//  370  *****************************************************************************/
//  371 
//  372 /*****************************************************************************/
//  373 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  374 uint8_t USB_CDC_Desc_GetDescriptor 
//  375 (
//  376   uint8_t controllerId,   /* [IN] Controller ID */
//  377   uint8_t type,            /* [IN] type of descriptor requested */
//  378   uint8_t strNum,         /* [IN] string index for string descriptor */
//  379   uint16_t index,          /* [IN] string descriptor language Id */
//  380   uint8_t* *pDescriptor, /* [OUT] output descriptor pointer */
//  381   usbPacketSize_t *pSize   /* [OUT] size of descriptor returned */
//  382 )
//  383 {
USB_CDC_Desc_GetDescriptor:
        PUSH     {R4-R7,LR}
        MOVS     R4,R0
        LDR      R5,[SP, #+20]
        LDR      R6,[SP, #+24]
//  384   (void) (controllerId);
//  385    /* string descriptors are handled saperately */
//  386   if (type == gUSB_DescType_StringDescriptor_d)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+3
        BNE.N    ??USB_CDC_Desc_GetDescriptor_0
//  387   {
//  388     if(index == 0)
        UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
        CMP      R3,#+0
        BNE.N    ??USB_CDC_Desc_GetDescriptor_1
//  389     {
//  390       /* return the string and size of all languages */
//  391       *pDescriptor = (uint8_t*)gCDC_Languages.pLanguagesSupportedString;
        LDR.N    R0,??DataTable10
        LDR      R0,[R0, #+0]
        STR      R0,[R5, #+0]
//  392       *pSize = gCDC_Languages.languagesSupportedSize;
        LDR.N    R0,??DataTable10
        LDRB     R0,[R0, #+4]
        STRH     R0,[R6, #+0]
        B.N      ??USB_CDC_Desc_GetDescriptor_2
//  393     }
//  394     else
//  395     {
//  396       uint8_t langId ;
//  397       uint8_t langIndex = gCDC_Num_SupportedLanguagesNum_d;
??USB_CDC_Desc_GetDescriptor_1:
        MOVS     R0,#+1
//  398       for(langId = 0;langId< gCDC_Num_SupportedLanguagesNum_d;langId++)
        MOVS     R12,#+0
        MOV      R7,R12
??USB_CDC_Desc_GetDescriptor_3:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+0
        BNE.N    ??USB_CDC_Desc_GetDescriptor_4
//  399         {
//  400           /* check whether we have a string for this language */
//  401           if(index == gCDC_Languages.usbLanguage[langId].languageId)
        LDR.W    R12,??DataTable10
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     LR,#+12
        MLA      R12,LR,R7,R12
        LDRH     R12,[R12, #+8]
        UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
        CMP      R3,R12
        BNE.N    ??USB_CDC_Desc_GetDescriptor_5
//  402             {   /* check for max descriptors */
//  403               if(strNum < gCDC_Num_StringDescriptorsNum_d)
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+3
        BGE.N    ??USB_CDC_Desc_GetDescriptor_6
//  404               {   /* setup index for the string to be returned */
//  405                 langIndex=strNum;
        MOVS     R0,R2
//  406               }
//  407 
//  408               break;
??USB_CDC_Desc_GetDescriptor_6:
        B.N      ??USB_CDC_Desc_GetDescriptor_4
//  409             }
//  410 
//  411         }
??USB_CDC_Desc_GetDescriptor_5:
        ADDS     R7,R7,#+1
        B.N      ??USB_CDC_Desc_GetDescriptor_3
//  412 
//  413         /* set return val for descriptor and size */
//  414         *pDescriptor = (uint8_t*)gCDC_Languages.usbLanguage[langId].pLangDesc[langIndex];
??USB_CDC_Desc_GetDescriptor_4:
        LDR.W    R12,??DataTable10
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     LR,#+12
        MLA      R12,LR,R7,R12
        LDR      R12,[R12, #+12]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDR      R12,[R12, R0, LSL #+2]
        STR      R12,[R5, #+0]
//  415         *pSize = gCDC_Languages.usbLanguage[langId].pLangDescSize[langIndex];
        LDR.W    R12,??DataTable10
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     LR,#+12
        MLA      R7,LR,R7,R12
        LDR      R7,[R7, #+16]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDRB     R0,[R0, R7]
        STRH     R0,[R6, #+0]
        B.N      ??USB_CDC_Desc_GetDescriptor_2
//  416     }
//  417 
//  418   }
//  419   else if (type < gCDC_Num_StdDescriptorsNum_d+1)
??USB_CDC_Desc_GetDescriptor_0:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+8
        BGE.N    ??USB_CDC_Desc_GetDescriptor_7
//  420   {
//  421     /* set return val for descriptor and size*/
//  422     *pDescriptor = (uint8_t*)gCDC_StdDescriptors [type];
        LDR.N    R0,??DataTable10_1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR      R0,[R0, R1, LSL #+2]
        STR      R0,[R5, #+0]
//  423     /* if there is no descriptor then return error */
//  424     if(*pDescriptor == NULL)
        LDR      R0,[R5, #+0]
        CMP      R0,#+0
        BNE.N    ??USB_CDC_Desc_GetDescriptor_8
//  425     {
//  426       return gUsbErr_InvalidReqType_c;
        MOVS     R0,#+205
        B.N      ??USB_CDC_Desc_GetDescriptor_9
//  427     }
//  428 
//  429     *pSize = gCDC_StdDescSize[type];
??USB_CDC_Desc_GetDescriptor_8:
        LDR.N    R0,??DataTable10_2
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRH     R0,[R0, R1, LSL #+1]
        STRH     R0,[R6, #+0]
        B.N      ??USB_CDC_Desc_GetDescriptor_2
//  430   }
//  431   else /* invalid descriptor */
//  432   {
//  433     return gUsbErr_InvalidReqType_c;
??USB_CDC_Desc_GetDescriptor_7:
        MOVS     R0,#+205
        B.N      ??USB_CDC_Desc_GetDescriptor_9
//  434   }
//  435 
//  436   return gUsbErr_NoError_c;
??USB_CDC_Desc_GetDescriptor_2:
        MOVS     R0,#+0
??USB_CDC_Desc_GetDescriptor_9:
        POP      {R4-R7,PC}       ;; return
//  437 }
//  438 
//  439 /*****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  440 uint8_t USB_CDC_Desc_GetInterface 
//  441 (
//  442   uint8_t controllerId,     /* [IN] Controller ID */
//  443   uint8_t interface,         /* [IN] interface number */
//  444   uint8_t* pAltInterface  /* [OUT] output alternate interface */
//  445 )
//  446 {
USB_CDC_Desc_GetInterface:
        MOVS     R3,R0
//  447   (void) (controllerId);
//  448   /* if interface valid */
//  449   if(interface < gCDC_Num_MaxSupportedDataInterfaces_d + 1)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+2
        BGE.N    ??USB_CDC_Desc_GetInterface_0
//  450   {
//  451     /* get alternate interface*/
//  452     *pAltInterface = gAlternateInterface[interface];
        LDR.N    R0,??DataTable10_3
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R0,[R1, R0]
        STRB     R0,[R2, #+0]
//  453     return gUsbErr_NoError_c;
        MOVS     R0,#+0
        B.N      ??USB_CDC_Desc_GetInterface_1
//  454   }
//  455   return gUsbErr_InvalidReqType_c;
??USB_CDC_Desc_GetInterface_0:
        MOVS     R0,#+205
??USB_CDC_Desc_GetInterface_1:
        BX       LR               ;; return
//  456 }
//  457 
//  458 /*****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  459 uint8_t USB_CDC_Desc_SetInterface
//  460 (
//  461   uint8_t controllerId, /* [IN] Controller ID */
//  462   uint8_t interface,     /* [IN] interface number */
//  463   uint8_t altInterface  /* [IN] input alternate interface */
//  464 )
//  465 {
USB_CDC_Desc_SetInterface:
        MOVS     R3,R0
//  466   (void) (controllerId);
//  467   /* if interface valid */
//  468   if(interface < gCDC_Num_MaxSupportedDataInterfaces_d + 1)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+2
        BGE.N    ??USB_CDC_Desc_SetInterface_0
//  469   {
//  470     /* set alternate interface*/
//  471     gAlternateInterface[interface]=altInterface;
        LDR.N    R0,??DataTable10_3
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R2,[R1, R0]
//  472     return gUsbErr_NoError_c;
        MOVS     R0,#+0
        B.N      ??USB_CDC_Desc_SetInterface_1
//  473   }
//  474     return gUsbErr_InvalidReqType_c;
??USB_CDC_Desc_SetInterface_0:
        MOVS     R0,#+205
??USB_CDC_Desc_SetInterface_1:
        BX       LR               ;; return
//  475 }
//  476 
//  477 /*****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  478 bool_t USB_CDC_Desc_ValidConfiguration 
//  479 (
//  480   uint8_t controllerId,/*[IN] Controller ID */
//  481   uint16_t configVal   /*[IN] configuration value */
//  482 )
//  483 {
USB_CDC_Desc_ValidConfiguration:
        MOVS     R2,R0
//  484   uint8_t loopIndex=0;
        MOVS     R3,#+0
//  485   (void) (controllerId);
//  486   /* check with only supported val right now */
//  487   while(loopIndex < (gCDC_Num_SupportedConfigNum_d+1))
??USB_CDC_Desc_ValidConfiguration_0:
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+2
        BGE.N    ??USB_CDC_Desc_ValidConfiguration_1
//  488   {
//  489     if(configVal == gCDC_ValidConfigValues[loopIndex])
        LDR.N    R0,??DataTable10_4
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        LDRB     R0,[R3, R0]
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        CMP      R1,R0
        BNE.N    ??USB_CDC_Desc_ValidConfiguration_2
//  490     {
//  491       return TRUE;
        MOVS     R0,#+1
        B.N      ??USB_CDC_Desc_ValidConfiguration_3
//  492     }
//  493     loopIndex++;
??USB_CDC_Desc_ValidConfiguration_2:
        ADDS     R3,R3,#+1
        B.N      ??USB_CDC_Desc_ValidConfiguration_0
//  494   }
//  495   return FALSE;
??USB_CDC_Desc_ValidConfiguration_1:
        MOVS     R0,#+0
??USB_CDC_Desc_ValidConfiguration_3:
        BX       LR               ;; return
//  496 }
//  497 
//  498 /*****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  499 bool_t USB_CDC_Desc_ValidInterface 
//  500 (
//  501   uint8_t controllerId, /*[IN] Controller ID */
//  502   uint8_t interface      /*[IN] target interface */
//  503 )
//  504 {
USB_CDC_Desc_ValidInterface:
        MOVS     R2,R0
//  505   uint8_t loopIndex=0;
        MOVS     R3,#+0
//  506   (void) (controllerId);
//  507   /* check with only supported val right now */
//  508   while(loopIndex < gCDC_Num_MaxSupportedDataInterfaces_d)
??USB_CDC_Desc_ValidInterface_0:
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+0
        BNE.N    ??USB_CDC_Desc_ValidInterface_1
//  509   {
//  510     if(interface == gAlternateInterface[loopIndex])
        LDR.N    R0,??DataTable10_3
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        LDRB     R0,[R3, R0]
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,R0
        BNE.N    ??USB_CDC_Desc_ValidInterface_2
//  511     {
//  512       return TRUE;
        MOVS     R0,#+1
        B.N      ??USB_CDC_Desc_ValidInterface_3
//  513     }
//  514     loopIndex++;
??USB_CDC_Desc_ValidInterface_2:
        ADDS     R3,R3,#+1
        B.N      ??USB_CDC_Desc_ValidInterface_0
//  515   }
//  516 
//  517   return FALSE;
??USB_CDC_Desc_ValidInterface_1:
        MOVS     R0,#+0
??USB_CDC_Desc_ValidInterface_3:
        BX       LR               ;; return
//  518 }
//  519 
//  520 /*****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  521 bool_t USB_CDC_Desc_RemoteWakeup 
//  522 (
//  523   uint8_t controllerId  /* [IN] Controller ID */
//  524 )
//  525 {
USB_CDC_Desc_RemoteWakeup:
        MOVS     R1,R0
//  526   (void) (controllerId);
//  527   return gCDCRemoteWakeupSupport_d;
        MOVS     R0,#+1
        BX       LR               ;; return
//  528 }
//  529 
//  530 
//  531 /*****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  532 uint8_t USB_CDC_Desc_GetLineCoding 
//  533 (
//  534   uint8_t controllerId,       /* [IN] Controller ID */
//  535   uint8_t interface,           /* [IN] Interface Number */
//  536   uint8_t* *pCodingData     /* [OUT] Line Coding Data */
//  537 )
//  538 {
USB_CDC_Desc_GetLineCoding:
        PUSH     {R4}
        MOVS     R3,R0
//  539   (void) (controllerId);
//  540   /* if interface valid */
//  541   if(interface < gCDC_Num_MaxSupportedDataInterfaces_d)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.N    ??USB_CDC_Desc_GetLineCoding_0
//  542   {
//  543     /* get line coding data*/
//  544     *pCodingData = gLineCoding[interface];
        LDR.N    R0,??DataTable10_5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R4,#+7
        MLA      R0,R4,R1,R0
        STR      R0,[R2, #+0]
//  545     return gUsbErr_NoError_c;
        MOVS     R0,#+0
        B.N      ??USB_CDC_Desc_GetLineCoding_1
//  546   }
//  547   return gUsbErr_InvalidReqType_c;
??USB_CDC_Desc_GetLineCoding_0:
        MOVS     R0,#+205
??USB_CDC_Desc_GetLineCoding_1:
        POP      {R4}
        BX       LR               ;; return
//  548 }
//  549 
//  550 /*****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  551 uint8_t USB_CDC_Desc_SetLineCoding
//  552 (
//  553   uint8_t controllerId,       /* [IN] Controller ID */
//  554   uint8_t interface,           /* [IN] Interface Number */
//  555   uint8_t* *pCodingData     /* [IN] Line Coding Data */
//  556 )
//  557 {
USB_CDC_Desc_SetLineCoding:
        PUSH     {R4,R5}
        MOVS     R3,R0
//  558   uint8_t count;
//  559   (void)(controllerId);
//  560    /* if interface valid */
//  561   if(interface < gCDC_Num_MaxSupportedDataInterfaces_d)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.N    ??USB_CDC_Desc_SetLineCoding_0
//  562   {
//  563   /* set line coding data*/
//  564     for (count = 0; count < gCDC_LineCodingSize_d; count++)
        MOVS     R0,#+0
        MOVS     R4,R0
??USB_CDC_Desc_SetLineCoding_1:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+7
        BGE.N    ??USB_CDC_Desc_SetLineCoding_2
//  565     {
//  566       gLineCoding[interface][count] = *(*pCodingData + count);
        LDR.N    R0,??DataTable10_5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R5,#+7
        MLA      R0,R5,R1,R0
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDR      R5,[R2, #+0]
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R5,[R4, R5]
        STRB     R5,[R4, R0]
//  567     }
        ADDS     R4,R4,#+1
        B.N      ??USB_CDC_Desc_SetLineCoding_1
//  568     return gUsbErr_NoError_c;
??USB_CDC_Desc_SetLineCoding_2:
        MOVS     R0,#+0
        B.N      ??USB_CDC_Desc_SetLineCoding_3
//  569   }
//  570   return gUsbErr_InvalidReqType_c;
??USB_CDC_Desc_SetLineCoding_0:
        MOVS     R0,#+205
??USB_CDC_Desc_SetLineCoding_3:
        POP      {R4,R5}
        BX       LR               ;; return
//  571 }
//  572 
//  573 /*****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  574 uint8_t USB_CDC_Desc_GetAbstractState 
//  575 (
//  576   uint8_t controllerId,       /* [IN] Controller ID */
//  577   uint8_t interface,           /* [IN] Interface Number */
//  578   uint8_t* *pFeatureData    /* [OUT] Output Comm Feature Data */
//  579 )
//  580 {
USB_CDC_Desc_GetAbstractState:
        MOVS     R3,R0
//  581   (void)(controllerId);
//  582   /* if interface valid */
//  583   if(interface < gCDC_Num_MaxSupportedDataInterfaces_d)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.N    ??USB_CDC_Desc_GetAbstractState_0
//  584   {
//  585     /* get line coding data*/
//  586     *pFeatureData = gAbstractState[interface];
        LDR.N    R0,??DataTable10_6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        ADDS     R0,R0,R1, LSL #+1
        STR      R0,[R2, #+0]
//  587     return gUsbErr_NoError_c;
        MOVS     R0,#+0
        B.N      ??USB_CDC_Desc_GetAbstractState_1
//  588   }
//  589   return gUsbErr_InvalidReqType_c;
??USB_CDC_Desc_GetAbstractState_0:
        MOVS     R0,#+205
??USB_CDC_Desc_GetAbstractState_1:
        BX       LR               ;; return
//  590 }
//  591 
//  592 
//  593 /*****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  594 uint8_t USB_CDC_Desc_GetCountrySetting
//  595 (
//  596   uint8_t controllerId,       /* [IN] Controller ID */
//  597   uint8_t interface,           /* [IN] Interface Number */
//  598   uint8_t* *pFeatureData    /* [OUT] Output Comm Feature Data */
//  599 )
//  600 {
USB_CDC_Desc_GetCountrySetting:
        MOVS     R3,R0
//  601   (void)(controllerId);
//  602   /* if interface valid */
//  603   if(interface < gCDC_Num_MaxSupportedDataInterfaces_d)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.N    ??USB_CDC_Desc_GetCountrySetting_0
//  604   {
//  605     /* get line coding data*/
//  606     *pFeatureData = gCountryCode[interface];
        LDR.N    R0,??DataTable10_7
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        ADDS     R0,R0,R1, LSL #+1
        STR      R0,[R2, #+0]
//  607     return gUsbErr_NoError_c;
        MOVS     R0,#+0
        B.N      ??USB_CDC_Desc_GetCountrySetting_1
//  608   }
//  609   return gUsbErr_InvalidReqType_c;
??USB_CDC_Desc_GetCountrySetting_0:
        MOVS     R0,#+205
??USB_CDC_Desc_GetCountrySetting_1:
        BX       LR               ;; return
//  610 }
//  611 
//  612 /*****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  613 uint8_t USB_CDC_Desc_SetAbstractState
//  614 (
//  615   uint8_t controllerId,       /* [IN] Controller ID */
//  616   uint8_t interface,           /* [IN] Interface Number */
//  617   uint8_t* *pFeatureData    /* [OUT] Output Comm Feature Data */
//  618 )
//  619 {
USB_CDC_Desc_SetAbstractState:
        PUSH     {R4,R5}
        MOVS     R3,R0
//  620   uint8_t count;
//  621   (void)(controllerId);
//  622   /* if interface valid */
//  623   if(interface < gCDC_Num_MaxSupportedDataInterfaces_d)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.N    ??USB_CDC_Desc_SetAbstractState_0
//  624   {
//  625     /* set Abstract State Feature*/
//  626     for (count = 0; count < gUSB_CDC_CommFeatureDataSize_d; count++)
        MOVS     R0,#+0
        MOVS     R4,R0
??USB_CDC_Desc_SetAbstractState_1:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+2
        BGE.N    ??USB_CDC_Desc_SetAbstractState_2
//  627     {
//  628       gAbstractState[interface][count] = *(*pFeatureData + count);
        LDR.N    R0,??DataTable10_6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        ADDS     R0,R0,R1, LSL #+1
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDR      R5,[R2, #+0]
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R5,[R4, R5]
        STRB     R5,[R4, R0]
//  629     }
        ADDS     R4,R4,#+1
        B.N      ??USB_CDC_Desc_SetAbstractState_1
//  630     return gUsbErr_NoError_c;
??USB_CDC_Desc_SetAbstractState_2:
        MOVS     R0,#+0
        B.N      ??USB_CDC_Desc_SetAbstractState_3
//  631   }
//  632   return gUsbErr_InvalidReqType_c;
??USB_CDC_Desc_SetAbstractState_0:
        MOVS     R0,#+205
??USB_CDC_Desc_SetAbstractState_3:
        POP      {R4,R5}
        BX       LR               ;; return
//  633 }
//  634 
//  635 /*****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  636 uint8_t USB_CDC_Desc_SetCountrySetting
//  637 (
//  638   uint8_t controllerId,       /* [IN] Controller ID */
//  639   uint8_t interface,           /* [IN] Interface Number */
//  640   uint8_t* *pFeatureData    /* [OUT] Output Comm Feature Data */
//  641 )
//  642 {
USB_CDC_Desc_SetCountrySetting:
        PUSH     {R4,R5}
        MOVS     R3,R0
//  643   uint8_t count;
//  644   (void)(controllerId);
//  645   /* if interface valid */
//  646   if(interface < gCDC_Num_MaxSupportedDataInterfaces_d)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.N    ??USB_CDC_Desc_SetCountrySetting_0
//  647   {
//  648     for (count = 0; count < gUSB_CDC_CommFeatureDataSize_d; count++)
        MOVS     R0,#+0
        MOVS     R4,R0
??USB_CDC_Desc_SetCountrySetting_1:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+2
        BGE.N    ??USB_CDC_Desc_SetCountrySetting_2
//  649     {
//  650       gCountryCode[interface][count] = *(*pFeatureData + count);
        LDR.N    R0,??DataTable10_7
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        ADDS     R0,R0,R1, LSL #+1
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDR      R5,[R2, #+0]
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R5,[R4, R5]
        STRB     R5,[R4, R0]
//  651     }
        ADDS     R4,R4,#+1
        B.N      ??USB_CDC_Desc_SetCountrySetting_1
//  652     return gUsbErr_NoError_c;
??USB_CDC_Desc_SetCountrySetting_2:
        MOVS     R0,#+0
        B.N      ??USB_CDC_Desc_SetCountrySetting_3
//  653   }
//  654   return gUsbErr_InvalidReqType_c;
??USB_CDC_Desc_SetCountrySetting_0:
        MOVS     R0,#+205
??USB_CDC_Desc_SetCountrySetting_3:
        POP      {R4,R5}
        BX       LR               ;; return
//  655 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable10:
        DC32     gCDC_Languages

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable10_1:
        DC32     gCDC_StdDescriptors

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable10_2:
        DC32     gCDC_StdDescSize

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable10_3:
        DC32     gAlternateInterface

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable10_4:
        DC32     gCDC_ValidConfigValues

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable10_5:
        DC32     gLineCoding

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable10_6:
        DC32     gAbstractState

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable10_7:
        DC32     gCountryCode

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        END
//  656 
//  657 
//  658 
//  659   
//  660 #endif//gVirtualCOMPort_d
// 
//   6 bytes in section .bss
// 244 bytes in section .data
// 110 bytes in section .rodata
// 580 bytes in section .text
// 
// 580 bytes of CODE  memory
// 110 bytes of CONST memory
// 250 bytes of DATA  memory
//
//Errors: none
//Warnings: none
