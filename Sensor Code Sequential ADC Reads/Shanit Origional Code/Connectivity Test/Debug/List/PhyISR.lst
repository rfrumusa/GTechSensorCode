###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        02/Sep/2018  13:33:18
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Radio\MC1324x\PHY\PhyISR.c
#    Command line =  
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Radio\MC1324x\PHY\PhyISR.c" -D IAR --preprocess
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\List\" -lC
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\List\" -lB
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\List\"
#        --diag_suppress Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\CDC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\Descriptor\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\USB\Class\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Sys Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
#    List file    =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\List\PhyISR.lst
#    Object file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\Obj\PhyISR.o
#
###############################################################################

F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Radio\MC1324x\PHY\PhyISR.c
      1          /*****************************************************************************
      2           *                               INCLUDED HEADERS                            *
      3           *---------------------------------------------------------------------------*
      4           * Add to this section all the headers that this module needs to include.    *
      5           *---------------------------------------------------------------------------*
      6           *****************************************************************************/
      7          #include "EmbeddedTypes.h"
      8          #include "PortConfig.h"
      9          #include "TransceiverDrv.h"
     10          #include "TransceiverReg.h"
     11          #include "Phy.h"
     12          #include "Interrupt.h"
     13          
     14          /*****************************************************************************
     15           *                               PRIVATE VARIABLES                           *
     16           *---------------------------------------------------------------------------*
     17           * Add to this section all the variables and constants that have local       *
     18           * (file) scope.                                                             *
     19           * Each of this declarations shall be preceded by the 'static' keyword.      *
     20           * These variables / constants cannot be accessed outside this module.       *
     21           *---------------------------------------------------------------------------*
     22           *****************************************************************************/
     23          #define PHY_IRQSTS1_INDEX_c     0x00
     24          #define PHY_IRQSTS2_INDEX_c     0x01
     25          #define PHY_IRQSTS3_INDEX_c     0x02
     26          #define PHY_CTRL1_INDEX_c       0x03
     27          #define PHY_CTRL2_INDEX_c       0x04
     28          #define PHY_CTRL3_INDEX_c       0x05
     29          #define PHY_RX_FRM_LEN_INDEX_c  0x06
     30          #define PHY_CTRL4_INDEX_c       0x07
     31          

   \                                 In section .bss, align 4
     32          static phyRxParams_t * mpRxParams = NULL;
   \                     mpRxParams:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     33          static phyPacket_t * mpRxData = NULL;
   \                     mpRxData:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     34          uint8_t mStatusAndControlRegs[10];
   \                     mStatusAndControlRegs:
   \   00000000                      DS8 12
     35          
     36          /*****************************************************************************
     37           *                               PUBLIC VARIABLES                            *
     38           *---------------------------------------------------------------------------*
     39           * Add to this section all the variables and constants that have global      *
     40           * (project) scope.                                                          *
     41           * These variables / constants can be accessed outside this module.          *
     42           * These variables / constants shall be preceded by the 'extern' keyword in  *
     43           * the interface header.                                                     *
     44           *---------------------------------------------------------------------------*
     45           *****************************************************************************/
     46          
     47          /*****************************************************************************
     48           *                           PRIVATE FUNCTIONS PROTOTYPES                    *
     49           *---------------------------------------------------------------------------*
     50           * Add to this section all the functions prototypes that have local (file)   *
     51           * scope.                                                                    *
     52           * These functions cannot be accessed outside this module.                   *
     53           * These declarations shall be preceded by the 'static' keyword.             *
     54           *---------------------------------------------------------------------------*
     55           *****************************************************************************/
     56          
     57          /*****************************************************************************
     58           *                                PRIVATE FUNCTIONS                          *
     59           *---------------------------------------------------------------------------*
     60           * Add to this section all the functions that have local (file) scope.       *
     61           * These functions cannot be accessed outside this module.                   *
     62           * These definitions shall be preceded by the 'static' keyword.              *
     63           *---------------------------------------------------------------------------*
     64           *****************************************************************************/
     65          
     66          /*****************************************************************************
     67           *                             PUBLIC FUNCTIONS                              *
     68           *---------------------------------------------------------------------------*
     69           * Add to this section all the functions that have global (project) scope.   *
     70           * These functions can be accessed outside this module.                      *
     71           * These functions shall have their declarations (prototypes) within the     *
     72           * interface header file and shall be preceded by the 'extern' keyword.      *
     73           *---------------------------------------------------------------------------*
     74           *****************************************************************************/
     75          
     76          /*---------------------------------------------------------------------------
     77           * Name: PhyPassRxParams()
     78           * Description: -
     79           * Parameters: -
     80           * Return: -
     81           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     82          void PhyPassRxParams
     83          (
     84            phyRxParams_t * pRxParam
     85          )
     86          {
     87            mpRxParams = pRxParam;
   \                     PhyPassRxParams: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable4
   \   00000004   0x6008             STR      R0,[R1, #+0]
     88          }
   \   00000006   0x4770             BX       LR               ;; return
     89          
     90          /*---------------------------------------------------------------------------
     91           * Name: PhyPassRxDataPtr()
     92           * Description: -
     93           * Parameters: -
     94           * Return: -
     95           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     96          void PhyPassRxDataPtr
     97          (
     98            phyPacket_t * pRxData
     99          )
    100          {
    101            mpRxData = pRxData;
   \                     PhyPassRxDataPtr: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable4_1
   \   00000004   0x6008             STR      R0,[R1, #+0]
    102          }
   \   00000006   0x4770             BX       LR               ;; return
    103          
    104          /*---------------------------------------------------------------------------
    105           * Name: PhyIsrSeqCleanup
    106           * Description: -
    107           * Parameters: -
    108           * Return: -
    109           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    110          void PhyIsrSeqCleanup
    111          (
    112            void
    113          )
    114          {
   \                     PhyIsrSeqCleanup: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    115            mStatusAndControlRegs[PHY_IRQSTS3_INDEX_c] &= 0xF0;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \   00000006   0x7880             LDRB     R0,[R0, #+2]
   \   00000008   0xF010 0x00F0      ANDS     R0,R0,#0xF0
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable4_2
   \   00000010   0x7088             STRB     R0,[R1, #+2]
    116            mStatusAndControlRegs[PHY_IRQSTS3_INDEX_c] &= (uint8_t) ~( cIRQSTS3_TMR3MSK ); // unmask TMR3 interrupt
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \   00000016   0x7880             LDRB     R0,[R0, #+2]
   \   00000018   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable4_2
   \   00000020   0x7088             STRB     R0,[R1, #+2]
    117            mStatusAndControlRegs[PHY_CTRL2_INDEX_c]   |= (uint8_t)  ( cPHY_CTRL2_CCAMSK | \
    118                                                                       cPHY_CTRL2_RXMSK | \
    119                                                                       cPHY_CTRL2_TXMSK | \
    120                                                                       cPHY_CTRL2_SEQMSK);
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \   00000026   0x7900             LDRB     R0,[R0, #+4]
   \   00000028   0xF050 0x000F      ORRS     R0,R0,#0xF
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable4_2
   \   00000030   0x7108             STRB     R0,[R1, #+4]
    121            mStatusAndControlRegs[PHY_CTRL1_INDEX_c]   &= (uint8_t) ~( cPHY_CTRL1_XCVSEQ);
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \   00000036   0x78C0             LDRB     R0,[R0, #+3]
   \   00000038   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable4_2
   \   00000040   0x70C8             STRB     R0,[R1, #+3]
    122            
    123            // clear transceiver interrupts, mask SEQ, RX, TX and CCA interrupts and set the PHY sequencer back to IDLE
    124            MC1324xDrv_DirectAccessSPIMultiByteWrite(IRQSTS1, mStatusAndControlRegs, 5);
   \   00000042   0x2205             MOVS     R2,#+5
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable4_2
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIMultiByteWrite
    125            
    126          }
   \   0000004E   0xBD01             POP      {R0,PC}          ;; return
    127          
    128          /*---------------------------------------------------------------------------
    129           * Name: PhyIsrTimeoutCleanup
    130           * Description: -
    131           * Parameters: -
    132           * Return: -
    133           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    134          void PhyIsrTimeoutCleanup
    135          (
    136            void
    137          )
    138          {
   \                     PhyIsrTimeoutCleanup: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    139            mStatusAndControlRegs[PHY_IRQSTS3_INDEX_c] &= 0xF0;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \   00000006   0x7880             LDRB     R0,[R0, #+2]
   \   00000008   0xF010 0x00F0      ANDS     R0,R0,#0xF0
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable4_2
   \   00000010   0x7088             STRB     R0,[R1, #+2]
    140            mStatusAndControlRegs[PHY_IRQSTS3_INDEX_c] |= (uint8_t)  ( cIRQSTS3_TMR3MSK | \
    141                                                                       cIRQSTS3_TMR3IRQ); // mask and clear TMR3 interrupt
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \   00000016   0x7880             LDRB     R0,[R0, #+2]
   \   00000018   0xF050 0x0044      ORRS     R0,R0,#0x44
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable4_2
   \   00000020   0x7088             STRB     R0,[R1, #+2]
    142            mStatusAndControlRegs[PHY_CTRL2_INDEX_c]   |= (uint8_t)  ( cPHY_CTRL2_CCAMSK | \
    143                                                                       cPHY_CTRL2_RXMSK | \
    144                                                                       cPHY_CTRL2_TXMSK | \
    145                                                                       cPHY_CTRL2_SEQMSK);
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \   00000026   0x7900             LDRB     R0,[R0, #+4]
   \   00000028   0xF050 0x000F      ORRS     R0,R0,#0xF
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable4_2
   \   00000030   0x7108             STRB     R0,[R1, #+4]
    146            mStatusAndControlRegs[PHY_CTRL1_INDEX_c]   &= (uint8_t) ~( cPHY_CTRL1_XCVSEQ);
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \   00000036   0x78C0             LDRB     R0,[R0, #+3]
   \   00000038   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable4_2
   \   00000040   0x70C8             STRB     R0,[R1, #+3]
    147            
    148            // disable TMR3 comparator and timeout
    149            mStatusAndControlRegs[PHY_CTRL3_INDEX_c]   &= (uint8_t) ~( cPHY_CTRL3_TMR3CMP_EN);
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \   00000046   0x7940             LDRB     R0,[R0, #+5]
   \   00000048   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable4_2
   \   00000050   0x7148             STRB     R0,[R1, #+5]
    150            mStatusAndControlRegs[PHY_CTRL4_INDEX_c]   &= (uint8_t) ~( cPHY_CTRL4_TC3TMOUT);
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \   00000056   0x79C0             LDRB     R0,[R0, #+7]
   \   00000058   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   0000005C   0x....             LDR.N    R1,??DataTable4_2
   \   0000005E   0x71C8             STRB     R0,[R1, #+7]
    151            
    152            MC1324xDrv_DirectAccessSPIWrite(PHY_CTRL3, mStatusAndControlRegs[PHY_CTRL3_INDEX_c]);
   \   00000060   0x....             LDR.N    R0,??DataTable4_2
   \   00000062   0x7941             LDRB     R1,[R0, #+5]
   \   00000064   0x2005             MOVS     R0,#+5
   \   00000066   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    153            MC1324xDrv_DirectAccessSPIWrite(PHY_CTRL4, mStatusAndControlRegs[PHY_CTRL4_INDEX_c]);
   \   0000006A   0x....             LDR.N    R0,??DataTable4_2
   \   0000006C   0x79C1             LDRB     R1,[R0, #+7]
   \   0000006E   0x2007             MOVS     R0,#+7
   \   00000070   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    154            
    155            // clear transceiver interrupts, mask mask SEQ, RX, TX, TMR3 and CCA interrupts interrupts and set the PHY sequencer back to IDLE
    156            MC1324xDrv_DirectAccessSPIMultiByteWrite(IRQSTS1, mStatusAndControlRegs, 5);
   \   00000074   0x2205             MOVS     R2,#+5
   \   00000076   0x....             LDR.N    R1,??DataTable4_2
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIMultiByteWrite
    157          }
   \   0000007E   0xBD01             POP      {R0,PC}          ;; return
    158          
    159          /*---------------------------------------------------------------------------
    160           * Name: Phy_GetEnergyLevel
    161           * Description: -
    162           * Parameters: -
    163           * Return: -
    164           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    165          uint8_t Phy_GetEnergyLevel
    166          (
    167            void
    168          )
    169          {
   \                     Phy_GetEnergyLevel: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    170            uint8_t energyLevel;
    171            energyLevel = MC1324xDrv_DirectAccessSPIRead((uint8_t) CCA1_ED_FNL);
   \   00000002   0x200B             MOVS     R0,#+11
   \   00000004   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   00000008   0x0004             MOVS     R4,R0
    172            // TODO to convert energy level based on spec.
    173            return energyLevel;
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    174          }
    175          
    176          /*---------------------------------------------------------------------------
    177           * Name: PHY_InterruptHandler
    178           * Description: -
    179           * Parameters: -
    180           * Return: -
    181           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    182          void PHY_InterruptHandler
    183          (
    184            void
    185          )
    186          {
   \                     PHY_InterruptHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    187            uint8_t xcvseqCopy;
    188            
    189            // disable and clear transceiver(IRQ_B) interrupt
    190            MC1324xDrv_IRQ_Disable();
   \   00000002   0x.... 0x....      BL       MC1324xDrv_IRQ_Disable
    191            MC1324xDrv_IRQ_Clear();
   \   00000006   0x.... 0x....      BL       MC1324xDrv_IRQ_Clear
    192            
    193            // read transceiver interrupt status and control registers
    194            MC1324xDrv_DirectAccessSPIMultiByteRead(IRQSTS1, mStatusAndControlRegs, 8);
   \   0000000A   0x2208             MOVS     R2,#+8
   \   0000000C   0x....             LDR.N    R1,??DataTable4_2
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIMultiByteRead
    195            
    196            xcvseqCopy = mStatusAndControlRegs[PHY_CTRL1] & cPHY_CTRL1_XCVSEQ;
   \   00000014   0x....             LDR.N    R0,??DataTable4_2
   \   00000016   0x78C0             LDRB     R0,[R0, #+3]
   \   00000018   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   0000001C   0x0004             MOVS     R4,R0
    197            
    198            /* debugg */
    199            if(   ((mStatusAndControlRegs[PHY_IRQSTS2_INDEX_c] & cIRQSTS2_WAKE_IRQ) == cIRQSTS2_WAKE_IRQ)
    200                &&((mStatusAndControlRegs[PHY_CTRL3_INDEX_c] & cPHY_CTRL3_WAKE_MSK) != cPHY_CTRL3_WAKE_MSK) )
   \   0000001E   0x....             LDR.N    R0,??DataTable4_2
   \   00000020   0x7840             LDRB     R0,[R0, #+1]
   \   00000022   0x07C0             LSLS     R0,R0,#+31
   \   00000024   0xD50B             BPL.N    ??PHY_InterruptHandler_0
   \   00000026   0x....             LDR.N    R0,??DataTable4_2
   \   00000028   0x7940             LDRB     R0,[R0, #+5]
   \   0000002A   0x07C0             LSLS     R0,R0,#+31
   \   0000002C   0xD407             BMI.N    ??PHY_InterruptHandler_0
    201            {
    202              // clear transceiver interrupts
    203              MC1324xDrv_DirectAccessSPIMultiByteWrite(IRQSTS1, mStatusAndControlRegs, 3);
   \   0000002E   0x2203             MOVS     R2,#+3
   \   00000030   0x....             LDR.N    R1,??DataTable4_2
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIMultiByteWrite
    204              //PhyUnexpectedTransceiverReset();
    205              MC1324xDrv_IRQ_Enable();
   \   00000038   0x.... 0x....      BL       MC1324xDrv_IRQ_Enable
    206              return;
   \   0000003C   0xE144             B.N      ??PHY_InterruptHandler_1
    207            }
    208            /* ----- */
    209           
    210            // sequencer interrupt, the autosequence has completed
    211            if( (mStatusAndControlRegs[PHY_IRQSTS1_INDEX_c] & cIRQSTS1_SEQIRQ) == cIRQSTS1_SEQIRQ )
   \                     ??PHY_InterruptHandler_0: (+1)
   \   0000003E   0x....             LDR.N    R0,??DataTable4_2
   \   00000040   0x7800             LDRB     R0,[R0, #+0]
   \   00000042   0x07C0             LSLS     R0,R0,#+31
   \   00000044   0xF140 0x809B      BPL.W    ??PHY_InterruptHandler_2
    212            {
    213              // PLL unlock, the autosequence has been aborted due to PLL unlock
    214              if( (mStatusAndControlRegs[PHY_IRQSTS1_INDEX_c] & cIRQSTS1_PLL_UNLOCK_IRQ) == cIRQSTS1_PLL_UNLOCK_IRQ )
   \   00000048   0x....             LDR.N    R0,??DataTable4_2
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x0640             LSLS     R0,R0,#+25
   \   0000004E   0xD506             BPL.N    ??PHY_InterruptHandler_3
    215              {
    216                PhyIsrSeqCleanup();
   \   00000050   0x.... 0x....      BL       PhyIsrSeqCleanup
    217                PhyPlmeSyncLossIndication();
   \   00000054   0x.... 0x....      BL       PhyPlmeSyncLossIndication
    218                MC1324xDrv_IRQ_Enable();
   \   00000058   0x.... 0x....      BL       MC1324xDrv_IRQ_Enable
    219                return;
   \   0000005C   0xE134             B.N      ??PHY_InterruptHandler_1
    220              }
    221              // TMR3 timeout, the autosequence has been aborted due to TMR3 timeout
    222              if(  ((mStatusAndControlRegs[PHY_IRQSTS3_INDEX_c] & cIRQSTS3_TMR3IRQ) == cIRQSTS3_TMR3IRQ)
    223                 &&((mStatusAndControlRegs[PHY_IRQSTS1_INDEX_c] & cIRQSTS1_RXIRQ)   != cIRQSTS1_RXIRQ) )
   \                     ??PHY_InterruptHandler_3: (+1)
   \   0000005E   0x....             LDR.N    R0,??DataTable4_2
   \   00000060   0x7880             LDRB     R0,[R0, #+2]
   \   00000062   0x0740             LSLS     R0,R0,#+29
   \   00000064   0xD50A             BPL.N    ??PHY_InterruptHandler_4
   \   00000066   0x....             LDR.N    R0,??DataTable4_2
   \   00000068   0x7800             LDRB     R0,[R0, #+0]
   \   0000006A   0x0740             LSLS     R0,R0,#+29
   \   0000006C   0xD406             BMI.N    ??PHY_InterruptHandler_4
    224              {
    225                PhyIsrTimeoutCleanup();
   \   0000006E   0x.... 0x....      BL       PhyIsrTimeoutCleanup
    226                PhyTimeRxTimeoutIndication();
   \   00000072   0x.... 0x....      BL       PhyTimeRxTimeoutIndication
    227                MC1324xDrv_IRQ_Enable();
   \   00000076   0x.... 0x....      BL       MC1324xDrv_IRQ_Enable
    228                return;
   \   0000007A   0xE125             B.N      ??PHY_InterruptHandler_1
    229              }
    230              
    231              PhyIsrSeqCleanup();
   \                     ??PHY_InterruptHandler_4: (+1)
   \   0000007C   0x.... 0x....      BL       PhyIsrSeqCleanup
    232              
    233              switch(xcvseqCopy)
   \   00000080   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000082   0x2C01             CMP      R4,#+1
   \   00000084   0xD036             BEQ.N    ??PHY_InterruptHandler_5
   \   00000086   0xD377             BCC.N    ??PHY_InterruptHandler_6
   \   00000088   0x2C03             CMP      R4,#+3
   \   0000008A   0xD05A             BEQ.N    ??PHY_InterruptHandler_7
   \   0000008C   0xD303             BCC.N    ??PHY_InterruptHandler_8
   \   0000008E   0x2C05             CMP      R4,#+5
   \   00000090   0xD06E             BEQ.N    ??PHY_InterruptHandler_9
   \   00000092   0xD30F             BCC.N    ??PHY_InterruptHandler_10
   \   00000094   0xE070             B.N      ??PHY_InterruptHandler_6
    234              {
    235                case gTX_c:
    236                {
    237                  if(  ((mStatusAndControlRegs[PHY_IRQSTS2_INDEX_c] & cIRQSTS2_CCA)        == cIRQSTS2_CCA)
    238                     &&((mStatusAndControlRegs[PHY_CTRL1_INDEX_c]   & cPHY_CTRL1_CCABFRTX) == cPHY_CTRL1_CCABFRTX) )
   \                     ??PHY_InterruptHandler_8: (+1)
   \   00000096   0x....             LDR.N    R0,??DataTable4_2
   \   00000098   0x7840             LDRB     R0,[R0, #+1]
   \   0000009A   0x0640             LSLS     R0,R0,#+25
   \   0000009C   0xD507             BPL.N    ??PHY_InterruptHandler_11
   \   0000009E   0x....             LDR.N    R0,??DataTable4_2
   \   000000A0   0x78C0             LDRB     R0,[R0, #+3]
   \   000000A2   0x0680             LSLS     R0,R0,#+26
   \   000000A4   0xD503             BPL.N    ??PHY_InterruptHandler_11
    239                  {
    240                    PhyPlmeCcaConfirm(gChannelBusy_c);
   \   000000A6   0x2001             MOVS     R0,#+1
   \   000000A8   0x.... 0x....      BL       PhyPlmeCcaConfirm
   \   000000AC   0xE001             B.N      ??PHY_InterruptHandler_12
    241                  }
    242                  else
    243                  {
    244                    PhyPdDataConfirm();
   \                     ??PHY_InterruptHandler_11: (+1)
   \   000000AE   0x.... 0x....      BL       PhyPdDataConfirm
    245                  }
    246                }
    247                break;
   \                     ??PHY_InterruptHandler_12: (+1)
   \   000000B2   0xE107             B.N      ??PHY_InterruptHandler_13
    248                case gTR_c:
    249                {
    250                  if(  ((mStatusAndControlRegs[PHY_IRQSTS2_INDEX_c] & cIRQSTS2_CCA)        == cIRQSTS2_CCA)
    251                     &&((mStatusAndControlRegs[PHY_CTRL1_INDEX_c]   & cPHY_CTRL1_CCABFRTX) == cPHY_CTRL1_CCABFRTX) )
   \                     ??PHY_InterruptHandler_10: (+1)
   \   000000B4   0x....             LDR.N    R0,??DataTable4_2
   \   000000B6   0x7840             LDRB     R0,[R0, #+1]
   \   000000B8   0x0640             LSLS     R0,R0,#+25
   \   000000BA   0xD507             BPL.N    ??PHY_InterruptHandler_14
   \   000000BC   0x....             LDR.N    R0,??DataTable4_2
   \   000000BE   0x78C0             LDRB     R0,[R0, #+3]
   \   000000C0   0x0680             LSLS     R0,R0,#+26
   \   000000C2   0xD503             BPL.N    ??PHY_InterruptHandler_14
    252                  {
    253                    PhyPlmeCcaConfirm(gChannelBusy_c);
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0x.... 0x....      BL       PhyPlmeCcaConfirm
   \   000000CA   0xE012             B.N      ??PHY_InterruptHandler_15
    254                  }
    255                  else
    256                  {
    257                    if(NULL != mpRxParams)
   \                     ??PHY_InterruptHandler_14: (+1)
   \   000000CC   0x....             LDR.N    R0,??DataTable4
   \   000000CE   0x6800             LDR      R0,[R0, #+0]
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD00C             BEQ.N    ??PHY_InterruptHandler_16
    258                    {
    259                      // TODO to convert LQI based on spec.
    260                      mpRxParams->linkQuality = MC1324xDrv_DirectAccessSPIRead((uint8_t) LQI_VALUE);
   \   000000D4   0x2025             MOVS     R0,#+37
   \   000000D6   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   000000DA   0x....             LDR.N    R1,??DataTable4
   \   000000DC   0x6809             LDR      R1,[R1, #+0]
   \   000000DE   0x7108             STRB     R0,[R1, #+4]
    261                      MC1324xDrv_DirectAccessSPIMultiByteRead( (uint8_t) TIMESTAMP_LSB, (uint8_t *) mpRxParams->timeStamp, 3);
   \   000000E0   0x2203             MOVS     R2,#+3
   \   000000E2   0x....             LDR.N    R0,??DataTable4
   \   000000E4   0x6800             LDR      R0,[R0, #+0]
   \   000000E6   0x6801             LDR      R1,[R0, #+0]
   \   000000E8   0x200F             MOVS     R0,#+15
   \   000000EA   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIMultiByteRead
    262                    }
    263                    PhyPdDataConfirm();
   \                     ??PHY_InterruptHandler_16: (+1)
   \   000000EE   0x.... 0x....      BL       PhyPdDataConfirm
    264                  }
    265                }
    266                break;
   \                     ??PHY_InterruptHandler_15: (+1)
   \   000000F2   0xE0E7             B.N      ??PHY_InterruptHandler_13
    267                case gRX_c:
    268                {
    269                  if(NULL != mpRxParams)
   \                     ??PHY_InterruptHandler_5: (+1)
   \   000000F4   0x....             LDR.N    R0,??DataTable4
   \   000000F6   0x6800             LDR      R0,[R0, #+0]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD00C             BEQ.N    ??PHY_InterruptHandler_17
    270                  {
    271                    // TODO to convert LQI based on spec.
    272                    mpRxParams->linkQuality = MC1324xDrv_DirectAccessSPIRead((uint8_t) LQI_VALUE);
   \   000000FC   0x2025             MOVS     R0,#+37
   \   000000FE   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   00000102   0x....             LDR.N    R1,??DataTable4
   \   00000104   0x6809             LDR      R1,[R1, #+0]
   \   00000106   0x7108             STRB     R0,[R1, #+4]
    273                    MC1324xDrv_DirectAccessSPIMultiByteRead( (uint8_t) TIMESTAMP_LSB, (uint8_t *) mpRxParams->timeStamp, 3);
   \   00000108   0x2203             MOVS     R2,#+3
   \   0000010A   0x....             LDR.N    R0,??DataTable4
   \   0000010C   0x6800             LDR      R0,[R0, #+0]
   \   0000010E   0x6801             LDR      R1,[R0, #+0]
   \   00000110   0x200F             MOVS     R0,#+15
   \   00000112   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIMultiByteRead
    274                  }
    275                  if(NULL != mpRxData)
   \                     ??PHY_InterruptHandler_17: (+1)
   \   00000116   0x....             LDR.N    R0,??DataTable4_1
   \   00000118   0x6800             LDR      R0,[R0, #+0]
   \   0000011A   0x2800             CMP      R0,#+0
   \   0000011C   0xD00E             BEQ.N    ??PHY_InterruptHandler_18
    276                  {
    277                    MC1324xDrv_PB_SPIBurstRead((uint8_t *) (&mpRxData->data[0]), (uint8_t)(mStatusAndControlRegs[PHY_RX_FRM_LEN_INDEX_c] - 2));
   \   0000011E   0x....             LDR.N    R0,??DataTable4_2
   \   00000120   0x7980             LDRB     R0,[R0, #+6]
   \   00000122   0x1E81             SUBS     R1,R0,#+2
   \   00000124   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000126   0x....             LDR.N    R0,??DataTable4_1
   \   00000128   0x6800             LDR      R0,[R0, #+0]
   \   0000012A   0x1C40             ADDS     R0,R0,#+1
   \   0000012C   0x.... 0x....      BL       MC1324xDrv_PB_SPIBurstRead
    278                    mpRxData->frameLength = (uint8_t)(mStatusAndControlRegs[PHY_RX_FRM_LEN_INDEX_c] - 2);
   \   00000130   0x....             LDR.N    R0,??DataTable4_2
   \   00000132   0x7980             LDRB     R0,[R0, #+6]
   \   00000134   0x1E80             SUBS     R0,R0,#+2
   \   00000136   0x....             LDR.N    R1,??DataTable4_1
   \   00000138   0x6809             LDR      R1,[R1, #+0]
   \   0000013A   0x7008             STRB     R0,[R1, #+0]
    279                  }
    280                  
    281                  PhyPdDataIndication();
   \                     ??PHY_InterruptHandler_18: (+1)
   \   0000013C   0x.... 0x....      BL       PhyPdDataIndication
    282                }
    283                break;
   \   00000140   0xE0C0             B.N      ??PHY_InterruptHandler_13
    284                case gCCA_c:
    285                {
    286                  if( (mStatusAndControlRegs[PHY_CTRL4_INDEX_c] & (cPHY_CTRL4_CCATYPE << cPHY_CTRL4_CCATYPE_Shift_c)) == (gCcaED_c << cPHY_CTRL4_CCATYPE_Shift_c) )
   \                     ??PHY_InterruptHandler_7: (+1)
   \   00000142   0x....             LDR.N    R0,??DataTable4_2
   \   00000144   0x79C0             LDRB     R0,[R0, #+7]
   \   00000146   0x2118             MOVS     R1,#+24
   \   00000148   0x4208             TST      R0,R1
   \   0000014A   0xD105             BNE.N    ??PHY_InterruptHandler_19
    287                  {
    288                    // Ed
    289                    PhyPlmeEdConfirm(Phy_GetEnergyLevel());
   \   0000014C   0x.... 0x....      BL       Phy_GetEnergyLevel
   \   00000150   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000152   0x.... 0x....      BL       PhyPlmeEdConfirm
   \   00000156   0xE00A             B.N      ??PHY_InterruptHandler_20
    290                  } 
    291                  else
    292                  {
    293                    // CCA
    294                    if( ((mStatusAndControlRegs[PHY_IRQSTS2_INDEX_c] & cIRQSTS2_CCA) == cIRQSTS2_CCA) )
   \                     ??PHY_InterruptHandler_19: (+1)
   \   00000158   0x....             LDR.N    R0,??DataTable4_2
   \   0000015A   0x7840             LDRB     R0,[R0, #+1]
   \   0000015C   0x0640             LSLS     R0,R0,#+25
   \   0000015E   0xD503             BPL.N    ??PHY_InterruptHandler_21
    295                    {                      
    296                      PhyPlmeCcaConfirm(gChannelBusy_c);
   \   00000160   0x2001             MOVS     R0,#+1
   \   00000162   0x.... 0x....      BL       PhyPlmeCcaConfirm
   \   00000166   0xE002             B.N      ??PHY_InterruptHandler_20
    297                    }
    298                    else
    299                    {
    300                      PhyPlmeCcaConfirm(gChannelIdle_c);
   \                     ??PHY_InterruptHandler_21: (+1)
   \   00000168   0x2000             MOVS     R0,#+0
   \   0000016A   0x.... 0x....      BL       PhyPlmeCcaConfirm
    301                    }
    302                  } 
    303                }
    304                break;
   \                     ??PHY_InterruptHandler_20: (+1)
   \   0000016E   0xE0A9             B.N      ??PHY_InterruptHandler_13
    305                case gCCCA_c:
    306                {
    307                  PhyPlmeCcaConfirm(gChannelIdle_c);
   \                     ??PHY_InterruptHandler_9: (+1)
   \   00000170   0x2000             MOVS     R0,#+0
   \   00000172   0x.... 0x....      BL       PhyPlmeCcaConfirm
    308                }
    309                break;
   \   00000176   0xE0A5             B.N      ??PHY_InterruptHandler_13
    310                default:
    311                {
    312                  PhyPlmeSyncLossIndication();
   \                     ??PHY_InterruptHandler_6: (+1)
   \   00000178   0x.... 0x....      BL       PhyPlmeSyncLossIndication
    313                }
    314                break;
   \   0000017C   0xE0A2             B.N      ??PHY_InterruptHandler_13
    315              }
    316            }
    317            // timers interrupt
    318            else
    319            {
    320              if((mStatusAndControlRegs[PHY_IRQSTS3_INDEX_c] & cIRQSTS3_TMR2IRQ) == cIRQSTS3_TMR2IRQ)
   \                     ??PHY_InterruptHandler_2: (+1)
   \   0000017E   0x....             LDR.N    R0,??DataTable4_2
   \   00000180   0x7880             LDRB     R0,[R0, #+2]
   \   00000182   0x0780             LSLS     R0,R0,#+30
   \   00000184   0xD52D             BPL.N    ??PHY_InterruptHandler_22
    321              {
    322                // mask and clear TMR2 interrupt
    323                mStatusAndControlRegs[PHY_IRQSTS3_INDEX_c] &= 0xF0;
   \   00000186   0x....             LDR.N    R0,??DataTable4_2
   \   00000188   0x7880             LDRB     R0,[R0, #+2]
   \   0000018A   0xF010 0x00F0      ANDS     R0,R0,#0xF0
   \   0000018E   0x....             LDR.N    R1,??DataTable4_2
   \   00000190   0x7088             STRB     R0,[R1, #+2]
    324                mStatusAndControlRegs[PHY_IRQSTS3_INDEX_c] |= (uint8_t)  ( cIRQSTS3_TMR2MSK | \
    325                                                                           cIRQSTS3_TMR2IRQ);
   \   00000192   0x....             LDR.N    R0,??DataTable4_2
   \   00000194   0x7880             LDRB     R0,[R0, #+2]
   \   00000196   0xF050 0x0022      ORRS     R0,R0,#0x22
   \   0000019A   0x....             LDR.N    R1,??DataTable4_2
   \   0000019C   0x7088             STRB     R0,[R1, #+2]
    326                
    327                MC1324xDrv_DirectAccessSPIWrite(IRQSTS3, mStatusAndControlRegs[PHY_IRQSTS3_INDEX_c]);
   \   0000019E   0x....             LDR.N    R0,??DataTable4_2
   \   000001A0   0x7881             LDRB     R1,[R0, #+2]
   \   000001A2   0x2002             MOVS     R0,#+2
   \   000001A4   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    328                
    329                // disable TMR2 comparator and time triggered action
    330                mStatusAndControlRegs[PHY_CTRL3_INDEX_c]   &= (uint8_t) ~( cPHY_CTRL3_TMR2CMP_EN);
   \   000001A8   0x....             LDR.N    R0,??DataTable4_2
   \   000001AA   0x7940             LDRB     R0,[R0, #+5]
   \   000001AC   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   000001B0   0x....             LDR.N    R1,??DataTable4_2
   \   000001B2   0x7148             STRB     R0,[R1, #+5]
    331                mStatusAndControlRegs[PHY_CTRL1_INDEX_c]   &= (uint8_t) ~( cPHY_CTRL1_TMRTRIGEN);
   \   000001B4   0x....             LDR.N    R0,??DataTable4_2
   \   000001B6   0x78C0             LDRB     R0,[R0, #+3]
   \   000001B8   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   000001BC   0x....             LDR.N    R1,??DataTable4_2
   \   000001BE   0x70C8             STRB     R0,[R1, #+3]
    332                
    333          
    334                
    335                MC1324xDrv_DirectAccessSPIWrite(PHY_CTRL3, mStatusAndControlRegs[PHY_CTRL3_INDEX_c]);
   \   000001C0   0x....             LDR.N    R0,??DataTable4_2
   \   000001C2   0x7941             LDRB     R1,[R0, #+5]
   \   000001C4   0x2005             MOVS     R0,#+5
   \   000001C6   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    336                MC1324xDrv_DirectAccessSPIWrite(PHY_CTRL4, mStatusAndControlRegs[PHY_CTRL4_INDEX_c]);
   \   000001CA   0x....             LDR.N    R0,??DataTable4_2
   \   000001CC   0x79C1             LDRB     R1,[R0, #+7]
   \   000001CE   0x2007             MOVS     R0,#+7
   \   000001D0   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    337                MC1324xDrv_DirectAccessSPIWrite(PHY_CTRL1, mStatusAndControlRegs[PHY_CTRL1_INDEX_c]);
   \   000001D4   0x....             LDR.N    R0,??DataTable4_2
   \   000001D6   0x78C1             LDRB     R1,[R0, #+3]
   \   000001D8   0x2003             MOVS     R0,#+3
   \   000001DA   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    338                
    339                PhyTimeStartEventIndication();
   \   000001DE   0x.... 0x....      BL       PhyTimeStartEventIndication
    340                
    341              }
    342              if((mStatusAndControlRegs[PHY_IRQSTS3_INDEX_c] & cIRQSTS3_TMR3IRQ) == cIRQSTS3_TMR3IRQ)
   \                     ??PHY_InterruptHandler_22: (+1)
   \   000001E2   0x....             LDR.N    R0,??DataTable4_2
   \   000001E4   0x7880             LDRB     R0,[R0, #+2]
   \   000001E6   0x0740             LSLS     R0,R0,#+29
   \   000001E8   0xD52C             BPL.N    ??PHY_InterruptHandler_23
    343              {
    344                // mask and clear TMR3 interrupt
    345                mStatusAndControlRegs[PHY_IRQSTS3_INDEX_c] &= 0xF0;
   \   000001EA   0x....             LDR.N    R0,??DataTable4_2
   \   000001EC   0x7880             LDRB     R0,[R0, #+2]
   \   000001EE   0xF010 0x00F0      ANDS     R0,R0,#0xF0
   \   000001F2   0x....             LDR.N    R1,??DataTable4_2
   \   000001F4   0x7088             STRB     R0,[R1, #+2]
    346                mStatusAndControlRegs[PHY_IRQSTS3_INDEX_c] |= (uint8_t)  ( cIRQSTS3_TMR3MSK | \
    347                                                                           cIRQSTS3_TMR3IRQ);
   \   000001F6   0x....             LDR.N    R0,??DataTable4_2
   \   000001F8   0x7880             LDRB     R0,[R0, #+2]
   \   000001FA   0xF050 0x0044      ORRS     R0,R0,#0x44
   \   000001FE   0x....             LDR.N    R1,??DataTable4_2
   \   00000200   0x7088             STRB     R0,[R1, #+2]
    348                
    349                MC1324xDrv_DirectAccessSPIWrite(IRQSTS3, mStatusAndControlRegs[PHY_IRQSTS3_INDEX_c]);
   \   00000202   0x....             LDR.N    R0,??DataTable4_2
   \   00000204   0x7881             LDRB     R1,[R0, #+2]
   \   00000206   0x2002             MOVS     R0,#+2
   \   00000208   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    350                
    351                // disable TMR3 comparator and timeout
    352                mStatusAndControlRegs[PHY_CTRL3_INDEX_c]   &= (uint8_t) ~( cPHY_CTRL3_TMR3CMP_EN);
   \   0000020C   0x....             LDR.N    R0,??DataTable4_2
   \   0000020E   0x7940             LDRB     R0,[R0, #+5]
   \   00000210   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   00000214   0x....             LDR.N    R1,??DataTable4_2
   \   00000216   0x7148             STRB     R0,[R1, #+5]
    353                mStatusAndControlRegs[PHY_CTRL4_INDEX_c]   &= (uint8_t) ~( cPHY_CTRL4_TC3TMOUT);
   \   00000218   0x....             LDR.N    R0,??DataTable4_2
   \   0000021A   0x79C0             LDRB     R0,[R0, #+7]
   \   0000021C   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   00000220   0x....             LDR.N    R1,??DataTable4_2
   \   00000222   0x71C8             STRB     R0,[R1, #+7]
    354                
    355                MC1324xDrv_DirectAccessSPIWrite(PHY_CTRL3, mStatusAndControlRegs[PHY_CTRL3_INDEX_c]);
   \   00000224   0x....             LDR.N    R0,??DataTable4_2
   \   00000226   0x7941             LDRB     R1,[R0, #+5]
   \   00000228   0x2005             MOVS     R0,#+5
   \   0000022A   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    356                MC1324xDrv_DirectAccessSPIWrite(PHY_CTRL4, mStatusAndControlRegs[PHY_CTRL4_INDEX_c]);
   \   0000022E   0x....             LDR.N    R0,??DataTable4_2
   \   00000230   0x79C1             LDRB     R1,[R0, #+7]
   \   00000232   0x2007             MOVS     R0,#+7
   \   00000234   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    357                
    358                /* Ensure that we're not issuing TimeoutIndication while the Automated sequence is still in progress */
    359                /* TMR3 can expire during R-T turnaround for example, case in which the sequence is not interrupted */
    360                if(gIdle_c == PhyGetSeqState())
   \   00000238   0x.... 0x....      BL       PhyPpGetState
   \   0000023C   0x2800             CMP      R0,#+0
   \   0000023E   0xD101             BNE.N    ??PHY_InterruptHandler_23
    361                {      
    362                  PhyTimeRxTimeoutIndication();
   \   00000240   0x.... 0x....      BL       PhyTimeRxTimeoutIndication
    363                }
    364              }
    365              if((mStatusAndControlRegs[PHY_IRQSTS3_INDEX_c] & cIRQSTS3_TMR1IRQ) == cIRQSTS3_TMR1IRQ)
   \                     ??PHY_InterruptHandler_23: (+1)
   \   00000244   0x....             LDR.N    R0,??DataTable4_2
   \   00000246   0x7880             LDRB     R0,[R0, #+2]
   \   00000248   0x07C0             LSLS     R0,R0,#+31
   \   0000024A   0xD51B             BPL.N    ??PHY_InterruptHandler_24
    366              {
    367                // mask and clear TMR1 interrupt
    368                mStatusAndControlRegs[PHY_IRQSTS3_INDEX_c] &= 0xF0;
   \   0000024C   0x....             LDR.N    R0,??DataTable4_2
   \   0000024E   0x7880             LDRB     R0,[R0, #+2]
   \   00000250   0xF010 0x00F0      ANDS     R0,R0,#0xF0
   \   00000254   0x....             LDR.N    R1,??DataTable4_2
   \   00000256   0x7088             STRB     R0,[R1, #+2]
    369                mStatusAndControlRegs[PHY_IRQSTS3_INDEX_c] |= (uint8_t)  ( cIRQSTS3_TMR1MSK | \
    370                                                                           cIRQSTS3_TMR1IRQ);
   \   00000258   0x....             LDR.N    R0,??DataTable4_2
   \   0000025A   0x7880             LDRB     R0,[R0, #+2]
   \   0000025C   0xF050 0x0011      ORRS     R0,R0,#0x11
   \   00000260   0x....             LDR.N    R1,??DataTable4_2
   \   00000262   0x7088             STRB     R0,[R1, #+2]
    371                
    372                MC1324xDrv_DirectAccessSPIWrite(IRQSTS3, mStatusAndControlRegs[PHY_IRQSTS3_INDEX_c]);
   \   00000264   0x....             LDR.N    R0,??DataTable4_2
   \   00000266   0x7881             LDRB     R1,[R0, #+2]
   \   00000268   0x2002             MOVS     R0,#+2
   \   0000026A   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    373                
    374                // disable TMR1 comparator
    375                mStatusAndControlRegs[PHY_CTRL3_INDEX_c]   &= (uint8_t) ~( cPHY_CTRL3_TMR1CMP_EN);
   \   0000026E   0x....             LDR.N    R0,??DataTable4_2
   \   00000270   0x7940             LDRB     R0,[R0, #+5]
   \   00000272   0xF010 0x00EF      ANDS     R0,R0,#0xEF
   \   00000276   0x....             LDR.N    R1,??DataTable4_2
   \   00000278   0x7148             STRB     R0,[R1, #+5]
    376                
    377                MC1324xDrv_DirectAccessSPIWrite(PHY_CTRL3, mStatusAndControlRegs[PHY_CTRL3_INDEX_c]);
   \   0000027A   0x....             LDR.N    R0,??DataTable4_2
   \   0000027C   0x7941             LDRB     R1,[R0, #+5]
   \   0000027E   0x2005             MOVS     R0,#+5
   \   00000280   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    378          
    379              }
    380              if((mStatusAndControlRegs[PHY_IRQSTS3_INDEX_c] & cIRQSTS3_TMR4IRQ) == cIRQSTS3_TMR4IRQ)
   \                     ??PHY_InterruptHandler_24: (+1)
   \   00000284   0x....             LDR.N    R0,??DataTable4_2
   \   00000286   0x7880             LDRB     R0,[R0, #+2]
   \   00000288   0x0700             LSLS     R0,R0,#+28
   \   0000028A   0xD51B             BPL.N    ??PHY_InterruptHandler_13
    381              {
    382                // mask and clear TMR4 interrupt
    383                mStatusAndControlRegs[PHY_IRQSTS3_INDEX_c] &= 0xF0;
   \   0000028C   0x....             LDR.N    R0,??DataTable4_2
   \   0000028E   0x7880             LDRB     R0,[R0, #+2]
   \   00000290   0xF010 0x00F0      ANDS     R0,R0,#0xF0
   \   00000294   0x....             LDR.N    R1,??DataTable4_2
   \   00000296   0x7088             STRB     R0,[R1, #+2]
    384                mStatusAndControlRegs[PHY_IRQSTS3_INDEX_c] |= (uint8_t)  ( cIRQSTS3_TMR4MSK | \
    385                                                                           cIRQSTS3_TMR4IRQ);
   \   00000298   0x....             LDR.N    R0,??DataTable4_2
   \   0000029A   0x7880             LDRB     R0,[R0, #+2]
   \   0000029C   0xF050 0x0088      ORRS     R0,R0,#0x88
   \   000002A0   0x....             LDR.N    R1,??DataTable4_2
   \   000002A2   0x7088             STRB     R0,[R1, #+2]
    386                
    387                MC1324xDrv_DirectAccessSPIWrite(IRQSTS3, mStatusAndControlRegs[PHY_IRQSTS3_INDEX_c]);
   \   000002A4   0x....             LDR.N    R0,??DataTable4_2
   \   000002A6   0x7881             LDRB     R1,[R0, #+2]
   \   000002A8   0x2002             MOVS     R0,#+2
   \   000002AA   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    388                
    389                // disable TMR4 comparator
    390                mStatusAndControlRegs[PHY_CTRL3_INDEX_c]   &= (uint8_t) ~( cPHY_CTRL3_TMR4CMP_EN);
   \   000002AE   0x....             LDR.N    R0,??DataTable4_2
   \   000002B0   0x7940             LDRB     R0,[R0, #+5]
   \   000002B2   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   000002B6   0x....             LDR.N    R1,??DataTable4_2
   \   000002B8   0x7148             STRB     R0,[R1, #+5]
    391                
    392                MC1324xDrv_DirectAccessSPIWrite(PHY_CTRL3, mStatusAndControlRegs[PHY_CTRL3_INDEX_c]);
   \   000002BA   0x....             LDR.N    R0,??DataTable4_2
   \   000002BC   0x7941             LDRB     R1,[R0, #+5]
   \   000002BE   0x2005             MOVS     R0,#+5
   \   000002C0   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    393              }
    394            }
    395            MC1324xDrv_IRQ_Enable();
   \                     ??PHY_InterruptHandler_13: (+1)
   \   000002C4   0x.... 0x....      BL       MC1324xDrv_IRQ_Enable
    396          }
   \                     ??PHY_InterruptHandler_1: (+1)
   \   000002C8   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     mpRxParams

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     mpRxData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     mStatusAndControlRegs

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   PHY_InterruptHandler
         8   -> MC1324xDrv_DirectAccessSPIMultiByteRead
         8   -> MC1324xDrv_DirectAccessSPIMultiByteWrite
         8   -> MC1324xDrv_DirectAccessSPIRead
         8   -> MC1324xDrv_DirectAccessSPIWrite
         8   -> MC1324xDrv_IRQ_Clear
         8   -> MC1324xDrv_IRQ_Disable
         8   -> MC1324xDrv_IRQ_Enable
         8   -> MC1324xDrv_PB_SPIBurstRead
         8   -> PhyIsrSeqCleanup
         8   -> PhyIsrTimeoutCleanup
         8   -> PhyPdDataConfirm
         8   -> PhyPdDataIndication
         8   -> PhyPlmeCcaConfirm
         8   -> PhyPlmeEdConfirm
         8   -> PhyPlmeSyncLossIndication
         8   -> PhyPpGetState
         8   -> PhyTimeRxTimeoutIndication
         8   -> PhyTimeStartEventIndication
         8   -> Phy_GetEnergyLevel
       8   PhyIsrSeqCleanup
         8   -> MC1324xDrv_DirectAccessSPIMultiByteWrite
       8   PhyIsrTimeoutCleanup
         8   -> MC1324xDrv_DirectAccessSPIMultiByteWrite
         8   -> MC1324xDrv_DirectAccessSPIWrite
       0   PhyPassRxDataPtr
       0   PhyPassRxParams
       8   Phy_GetEnergyLevel
         8   -> MC1324xDrv_DirectAccessSPIRead


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
     714  PHY_InterruptHandler
      80  PhyIsrSeqCleanup
     128  PhyIsrTimeoutCleanup
       8  PhyPassRxDataPtr
       8  PhyPassRxParams
      16  Phy_GetEnergyLevel
      12  mStatusAndControlRegs
       4  mpRxData
       4  mpRxParams

 
  20 bytes in section .bss
 966 bytes in section .text
 
 966 bytes of CODE memory
  20 bytes of DATA memory

Errors: none
Warnings: none
