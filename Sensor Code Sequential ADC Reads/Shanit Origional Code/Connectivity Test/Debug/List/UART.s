///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM       02/Sep/2018  13:33:20
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Uart\UART.c
//    Command line =  
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Uart\UART.c"
//        -D IAR --preprocess "F:\Guardrail Work\Sensor Code\Git Repo\Sensor
//        Code Sequential ADC Reads\Shanit Origional Code\Connectivity
//        Test\Debug\List\" -lC "F:\Guardrail Work\Sensor Code\Git Repo\Sensor
//        Code Sequential ADC Reads\Shanit Origional Code\Connectivity
//        Test\Debug\List\" -lB "F:\Guardrail Work\Sensor Code\Git Repo\Sensor
//        Code Sequential ADC Reads\Shanit Origional Code\Connectivity
//        Test\Debug\List\" --diag_suppress
//        Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\Obj\" --no_cse --no_unroll
//        --no_inline --no_code_motion --no_tbaa --no_clustering
//        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\APP\CDC\" -I "F:\Guardrail Work\Sensor Code\Git
//        Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\USB\APP\Descriptor\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Class\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Sys Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
//    List file    =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\UART.s
//
///////////////////////////////////////////////////////////////////////////////

        #define SHT_PROGBITS 0x1

        EXTERN IntDisableAll
        EXTERN IntRestoreAll
        EXTERN NVIC_EnableIRQ
        EXTERN NVIC_SetPriority

        PUBLIC Uart1ErrorIsr
        PUBLIC Uart1Isr
        PUBLIC Uart1_GetByteFromRxBuffer
        PUBLIC Uart1_IsTxActive
        PUBLIC Uart1_RxBufferByteCount
        PUBLIC Uart1_SetBaud
        PUBLIC Uart1_SetRxCallBack
        PUBLIC Uart1_Transmit
        PUBLIC Uart1_UngetByte
        PUBLIC Uart2ErrorIsr
        PUBLIC Uart2Isr
        PUBLIC Uart2_GetByteFromRxBuffer
        PUBLIC Uart2_IsTxActive
        PUBLIC Uart2_RxBufferByteCount
        PUBLIC Uart2_SetBaud
        PUBLIC Uart2_SetRxCallBack
        PUBLIC Uart2_Transmit
        PUBLIC Uart2_UngetByte
        PUBLIC UartBaseAddress_c
        PUBLIC Uart_ClearErrors
        PUBLIC Uart_IsWakeUpSource
        PUBLIC Uart_ModuleDisableLowPowerWakeup
        PUBLIC Uart_ModuleEnableLowPowerWakeup
        PUBLIC Uart_ModuleInit
        PUBLIC Uart_ModuleUninit

// F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Uart\UART.c
//    1 /******************************************************************************
//    2  * Source file for UART/SCI driver.
//    3  * 
//    4  * Freescale Semiconductor Inc.
//    5  * (c) Copyright 2004-2011 Freescale Semiconductor, Inc.
//    6  * ALL RIGHTS RESERVED.
//    7  *
//    8 *******************************************************************************
//    9  *
//   10  * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR 
//   11  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
//   12  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
//   13  * IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
//   14  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
//   15  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
//   16  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
//   17  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
//   18  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
//   19  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
//   20  * THE POSSIBILITY OF SUCH DAMAGE.
//   21  *
//   22 ***************************************************************************//*!
//   23 ******************************************************************************/
//   24 
//   25 /******************************************************************************
//   26 *******************************************************************************
//   27 * Includes
//   28 *******************************************************************************
//   29 ******************************************************************************/
//   30 #include "Uart_Interface.h"
//   31 #include "Uart.h"
//   32 #include "PortConfig.h"
//   33 #include "Interrupt.h"
//   34 //#include "Platform.h"
//   35 
//   36 /* if neither UART enabled, then no code or data */
//   37 #if gUart1_Enabled_d || gUart2_Enabled_d
//   38 
//   39 /******************************************************************************
//   40 *******************************************************************************
//   41 * Private memory declarations
//   42 *******************************************************************************
//   43 ******************************************************************************/
//   44  
//   45 /******************************************************************************
//   46  * Name: UartBaseAddress_c
//   47  * Description: UART memory map base addresses 
//   48  * Valid ranges: see MCU reference manual
//   49  *****************************************************************************/

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
//   50 const UART_MemMapPtr UartBaseAddress_c[] = {
UartBaseAddress_c:
        DATA
        DC32 4006A000H, 4006B000H, 4006C000H, 4006D000H
//   51 
//   52 #if gUART_HW_MODULES_AVAILABLE_c > 0
//   53         gUART0_BASE_PTR_c,
//   54 #endif
//   55 
//   56 #if gUART_HW_MODULES_AVAILABLE_c > 1        
//   57         gUART1_BASE_PTR_c,
//   58 #endif
//   59 
//   60 #if gUART_HW_MODULES_AVAILABLE_c > 2
//   61         gUART2_BASE_PTR_c,
//   62 #endif
//   63 
//   64 #if gUART_HW_MODULES_AVAILABLE_c > 3
//   65         gUART3_BASE_PTR_c,
//   66 #endif
//   67 
//   68 #if gUART_HW_MODULES_AVAILABLE_c > 4
//   69         gUART4_BASE_PTR_c,
//   70 #endif
//   71 
//   72 #if gUART_HW_MODULES_AVAILABLE_c > 5
//   73         gUART5_BASE_PTR_c
//   74 #endif
//   75 };
//   76 
//   77 /******************************************************************************
//   78  * Name: mUartModule
//   79  * Description: UART module internal status & configuration variable 
//   80  * Valid ranges: see definition of UartModule_t
//   81  *****************************************************************************/
//   82 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   83 static UartModule_t mUartModule[gUART_HW_MODULES_AVAILABLE_c];
mUartModule:
        DS8 208
//   84 
//   85 /************************************
//   86  * UART_1
//   87  ************************************/
//   88 #if gUart1_Enabled_d
//   89 
//   90 /******************************************************************************
//   91  * Name: bUart1FlowConflict
//   92  * Description: UART_1 flow conflict
//   93  * Valid ranges: TRUE/FALSE
//   94  *****************************************************************************/  
//   95 #if gUart1_Hw_Sw_FlowControl_d
//   96   static bool_t bUart1FlowConflict = FALSE;
//   97 #endif
//   98 
//   99 /******************************************************************************
//  100  * Name: uart1_ungetFlag
//  101  * Description: UART_1 unget byte flag
//  102  * Valid ranges: TRUE/FALSE
//  103  *****************************************************************************/

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  104 static bool_t uart1_ungetFlag = FALSE;
uart1_ungetFlag:
        DS8 1
//  105 
//  106 /******************************************************************************
//  107  * Name: uart1_ungetByte
//  108  * Description: UART_1 unget byte
//  109  *              Each port can store one unget byte
//  110  * Valid ranges: 0..0xFF
//  111  *****************************************************************************/

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  112 static unsigned char uart1_ungetByte;
uart1_ungetByte:
        DS8 1
//  113 
//  114 /******************************************************************************
//  115  * Name: maSci1TxBufRefTable
//  116  * Description: UART_1 TX buffer reference table
//  117  * Valid ranges: see definition of SciTxBufRef_t
//  118  *****************************************************************************/

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  119 static SciTxBufRef_t maSci1TxBufRefTable[gUart_TransmitBuffers_c];
maSci1TxBufRefTable:
        DS8 24
//  120 
//  121 /******************************************************************************
//  122  * Name: maSci1TxBufLenTable
//  123  * Description: UART_1 table for TX buffer lengths
//  124  * Valid ranges: range of index_t
//  125  *****************************************************************************/
//  126 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  127 static index_t maSci1TxBufLenTable[gUart_TransmitBuffers_c] = { 0, 0, 0 };
maSci1TxBufLenTable:
        DS8 4
//  128 
//  129 /******************************************************************************
//  130  * Name: mSci1TxCurIndex
//  131  * Description: UART_1 current index in TX buffers array
//  132  * Valid ranges: range of index_t
//  133  *****************************************************************************/
//  134 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  135 static index_t mSci1TxCurIndex = 0;
mSci1TxCurIndex:
        DS8 1
//  136 
//  137 /******************************************************************************
//  138  * Name: mSci1TxBufRefLeadingIndex
//  139  * Description: The leading index is the next position to store 
//  140  *              a buffer reference
//  141  * Valid ranges: range of index_t
//  142  *****************************************************************************/
//  143 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  144 static index_t mSci1TxBufRefLeadingIndex = 0;   /* Post-increment. */
mSci1TxBufRefLeadingIndex:
        DS8 1
//  145 
//  146 /******************************************************************************
//  147  * Name: mSci1TxBufRefTrailingIndex
//  148  * Description: The trailing index is the buffer currently being transmitted
//  149  * Valid ranges: range of index_t
//  150  *****************************************************************************/
//  151 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  152 static index_t mSci1TxBufRefTrailingIndex = 0;  /* Post-increment. */
mSci1TxBufRefTrailingIndex:
        DS8 1
//  153 
//  154 /******************************************************************************
//  155  * Name: maSci1RxBuf
//  156  * Description: UART_1 RX buffer
//  157  *              Each port has a small local circular Rx buffer to store data until the
//  158  *              application can retrieve it. In addition to the leading and trailing
//  159  *              indexes, the Rx code keeps a count of the number of bytes in the buffer.
//  160  * Valid ranges: 0..0xFF
//  161  *****************************************************************************/
//  162 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  163 static unsigned char maSci1RxBuf[gUart1_ReceiveBufferSize_c];
maSci1RxBuf:
        DS8 252
//  164 
//  165 /******************************************************************************
//  166  * Name: pfSci1RxCallBack
//  167  * Description: callback function for UART_1 RX
//  168  * Valid ranges: -
//  169  *****************************************************************************/

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  170 static void (*pfSci1RxCallBack)(void);
pfSci1RxCallBack:
        DS8 4
//  171 
//  172 #endif // gUart1_Enabled_d
//  173 
//  174 /************************************
//  175  * UART_2
//  176  ************************************/
//  177 
//  178 #if gUart2_Enabled_d
//  179 
//  180 /******************************************************************************
//  181  * Name: bUart2FlowConflict
//  182  * Description: UART_2 flow conflict
//  183  * Valid ranges: TRUE/FALSE
//  184  *****************************************************************************/
//  185 
//  186 #if gUart2_Hw_Sw_FlowControl_d
//  187   static bool_t bUart2FlowConflict = FALSE; 
//  188 #endif
//  189 
//  190 /******************************************************************************
//  191  * Name: uart2_ungetFlag
//  192  * Description: UART_2 unget byte flag
//  193  * Valid ranges: TRUE/FALSE
//  194  *****************************************************************************/
//  195 static bool_t uart2_ungetFlag = FALSE;
//  196 
//  197 /******************************************************************************
//  198  * Name: uart2_ungetByte
//  199  * Description: UART_2 unget byte
//  200  *              Each port can store one unget byte
//  201  * Valid ranges: 0..0xFF
//  202  *****************************************************************************/
//  203 static unsigned char uart2_ungetByte;
//  204 
//  205 /******************************************************************************
//  206  * Name: maSci2TxBufRefTable
//  207  * Description: UART_2 TX buffer reference table
//  208  * Valid ranges: see definition of SciTxBufRef_t
//  209  *****************************************************************************/
//  210 static SciTxBufRef_t maSci2TxBufRefTable[gUart_TransmitBuffers_c];
//  211 
//  212 /******************************************************************************
//  213  * Name: maSci2TxBufLenTable
//  214  * Description: UART_2 table for TX buffer lengths
//  215  * Valid ranges: range of index_t
//  216  *****************************************************************************/
//  217 
//  218 static index_t maSci2TxBufLenTable[gUart_TransmitBuffers_c];
//  219 
//  220 /******************************************************************************
//  221  * Name: mSci2TxCurIndex
//  222  * Description: UART_2 current index in TX buffers array
//  223  * Valid ranges: range of index_t
//  224  *****************************************************************************/
//  225 
//  226 static index_t mSci2TxCurIndex=0;
//  227 
//  228 /******************************************************************************
//  229  * Name: mSci2TxBufRefLeadingIndex
//  230  * Description: The leading index is the next position to store 
//  231  *              a buffer reference
//  232  * Valid ranges: range of index_t
//  233  *****************************************************************************/
//  234 
//  235 static index_t mSci2TxBufRefLeadingIndex=0;   /* Post-increment. */
//  236 
//  237 /******************************************************************************
//  238  * Name: mSci2TxBufRefTrailingIndex
//  239  * Description: The trailing index is the buffer currently being transmitted
//  240  * Valid ranges: range of index_t
//  241  *****************************************************************************/
//  242 
//  243 static index_t mSci2TxBufRefTrailingIndex=0;  /* Post-increment. */
//  244 
//  245 /******************************************************************************
//  246  * Name: maSci2RxBuf
//  247  * Description: UART_2 RX buffer
//  248  *              Each port has a small local circular Rx buffer to store data until the
//  249  *              application can retrieve it. In addition to the leading and trailing
//  250  *              indexes, the Rx code keeps a count of the number of bytes in the buffer.
//  251  * Valid ranges: 0..0xFF
//  252  *****************************************************************************/
//  253 
//  254 static unsigned char maSci2RxBuf[gUart2_ReceiveBufferSize_c];
//  255 
//  256 /******************************************************************************
//  257  * Name: pfSci2RxCallBack
//  258  * Description: callback function for UART_2 RX
//  259  * Valid ranges: -
//  260  *****************************************************************************/
//  261 
//  262 static void (*pfSci2RxCallBack)(void);
//  263 
//  264 #endif  //gUart2_Enabled_d
//  265 
//  266 /******************************************************************************
//  267 *******************************************************************************
//  268 * Public memory definitions
//  269 *******************************************************************************
//  270 ******************************************************************************/
//  271  
//  272 /******************************************************************************
//  273 *******************************************************************************
//  274 * Private prototypes
//  275 *******************************************************************************
//  276 ******************************************************************************/
//  277  
//  278 /******************************************************************************
//  279  * Name: UartReceiverIsr
//  280  * Description: UART RX interrupt handler. Called in interrupt context.
//  281  * Parameters: [IN]: UartNumber - the UART peripheral number
//  282  * Return: -
//  283  *****************************************************************************/
//  284 static void UartReceiverIsr 
//  285 (
//  286     uint8_t UartNumber
//  287 );
//  288 
//  289 /******************************************************************************
//  290  * Name: UartTransmitterIsr
//  291  * Description: UART TX interrupt handler. Called in interrupt context.
//  292  * Parameters: [IN]: UartNumber - the UART peripheral number
//  293  * Return: -
//  294  *****************************************************************************/
//  295 static void UartTransmitterIsr 
//  296 (
//  297     uint8_t UartNumber
//  298 );
//  299 
//  300 /******************************************************************************
//  301  * Name: UartReadComplete
//  302  * Description: UART read complete function.
//  303  * Parameters: [IN]: UartNumber - the UART peripheral number
//  304  * Return: -
//  305  *****************************************************************************/
//  306 static void UartReadComplete
//  307 (
//  308     uint8_t UartNumber
//  309 );
//  310 
//  311 /******************************************************************************
//  312  * Name: UartDivide
//  313  * Description: Integer division by repeated substractions.
//  314  * Parameters: [IN]: Number - the number to be divided
//  315  *             [IN]: Divisor - the number to divide to
//  316  * Return: the result of the division operation
//  317  *****************************************************************************/
//  318 static uint16_t UartDivide
//  319 (
//  320     int32_t Number, 
//  321     uint32_t Divisor
//  322 );
//  323 
//  324 /******************************************************************************
//  325  * Name: UartOpen
//  326  * Description: Open the specified UART port
//  327  * Parameters: [IN]: UartNumber - the UART port number to be opened
//  328  *             [IN]: PlatformClock - The platform clock in KHz
//  329  * Return: see definition of UartErr_t
//  330  *****************************************************************************/
//  331 static UartErr_t UartOpen
//  332 (
//  333         uint8_t UartNumber, 
//  334         uint32_t PlatformClock
//  335 );
//  336 
//  337 /******************************************************************************
//  338  * Name: UartSetConfig
//  339  * Description: configure the specified UART port
//  340  * Parameters: [IN]: UartNumber - the UART port number to be configured
//  341  *             [IN]: pConfig - pointer to UART configuration data structure
//  342  * Return: see definition of UartErr_t
//  343  *****************************************************************************/
//  344 static UartErr_t UartSetConfig
//  345 (
//  346     uint8_t UartNumber, 
//  347     UartConfig_t* pConfig
//  348 );
//  349 
//  350 /******************************************************************************
//  351  * Name: UartGetConfig
//  352  * Description: get the configuration of the specified UART port
//  353  * Parameters: [IN]:  UartNumber - the UART port number to read the 
//  354  *                               configuration from
//  355  *             [OUT]: pConfig - pointer to UART configuration structure where
//  356  *                            the configuration data shall be placed                  
//  357  * Return: see definition of UartErr_t
//  358  *****************************************************************************/
//  359 static UartErr_t UartGetConfig
//  360 (
//  361     uint8_t UartNumber, 
//  362     UartConfig_t* pConfig
//  363 );
//  364 
//  365 /******************************************************************************
//  366  * Name: UartSetReceiverThreshold
//  367  * Description: sets the receiver threshold
//  368  * Parameters: [IN]: UartNumber - the UART port number
//  369  *             [IN]: Threshold - the desired threshold
//  370  * Return: see definition of UartErr_t
//  371  *****************************************************************************/
//  372 static UartErr_t UartSetReceiverThreshold
//  373 (
//  374     uint8_t UartNumber,
//  375     uint8_t Threshold
//  376 );
//  377 
//  378 /******************************************************************************
//  379  * Name: UartSetTransmitterThreshold
//  380  * Description: sets the transmitter threshold
//  381  * Parameters: [IN]: UartNumber - the UART port number
//  382  *             [IN]: Threshold - the desired threshold
//  383  * Return: see definition of UartErr_t
//  384  *****************************************************************************/
//  385 static UartErr_t UartSetTransmitterThreshold
//  386 (
//  387     uint8_t UartNumber,
//  388     uint8_t Threshold
//  389 );
//  390 
//  391 /******************************************************************************
//  392  * Name: UartReadData
//  393  * Description: read data from the specified UART port
//  394  * Parameters: [IN]: UartNumber - the UART port number
//  395  *             [OUT]: pBuf - pointer to the buffer where the read data shall be 
//  396  *                         placed 
//  397  *             [IN]: NumberBytes - number of bytes to be read
//  398  * Return: see definition of UartErr_t
//  399  *****************************************************************************/
//  400 static UartErr_t UartReadData
//  401 (
//  402     uint8_t UartNumber, 
//  403     uint8_t* pBuf,
//  404     uint16_t NumberBytes
//  405 );
//  406 
//  407 /******************************************************************************
//  408  * Name: UartCancelReadData
//  409  * Description: cancels the read data operation
//  410  * Parameters: [IN]: UartNumber - the UART port number
//  411  * Return: see definition of UartErr_t
//  412  *****************************************************************************/
//  413 static UartErr_t UartCancelReadData
//  414 (
//  415     uint8_t UartNumber
//  416 );
//  417 
//  418 /******************************************************************************
//  419  * Name: UartCancelWriteData
//  420  * Description: cancels the write data operation
//  421  * Parameters: [IN]: UartNumber - the UART port number
//  422  * Return: see definition of UartErr_t
//  423  *****************************************************************************/
//  424 static UartErr_t UartCancelWriteData
//  425 (
//  426     uint8_t UartNumber
//  427 );
//  428 
//  429 /******************************************************************************
//  430  * Name: UartGetStatus
//  431  * Description: gets the status of the specified UART port
//  432  * Parameters: [IN]: UartNumber - the UART port number
//  433  * Return: see definition of UartErr_t
//  434  *****************************************************************************/
//  435 static UartErr_t UartGetStatus
//  436 (
//  437     uint8_t UartNumber
//  438 );
//  439 
//  440 /******************************************************************************
//  441  * Name: UartClose
//  442  * Description: closes the specified UART port
//  443  * Parameters: [IN] UartNumber - the UART port number
//  444  * Return: see definition of UartErr_t
//  445  *****************************************************************************/
//  446 static UartErr_t UartClose
//  447 (
//  448     uint8_t UartNumber
//  449 );
//  450 
//  451 /******************************************************************************
//  452  * Name: UartGetByteFromRxBuffer
//  453  * Description: gets a byte from the HW RX buffer and appends it to RAM buffer
//  454  * Parameters: [IN] UartNumber - the UART port number
//  455  *             [OUT] pDst - pointer to the RAM buffer
//  456  * Return: TRUE/FALSE
//  457  *****************************************************************************/
//  458 static bool_t UartGetByteFromRxBuffer
//  459 (
//  460     uint8_t UartNumber, 
//  461     uint8_t *pDst
//  462 );
//  463 
//  464 /******************************************************************************
//  465  * Name: UartOpenCloseTransceiver
//  466  * Description: opens or closes the UART transceiver
//  467  * Parameters: [IN] UartNumber - the UART port number
//  468  *             [IN] Pin - the bit in the control register that 
//  469  *                  enables/disables the transmiter and the receiver
//  470  *             [IN] Open - if TRUE, it opens the receiver/trasmitter; if FALSE
//  471  *                         it closes the receiver/transmiter
//  472  * Return: -
//  473  *****************************************************************************/
//  474 static void UartOpenCloseTransceiver
//  475 (
//  476     uint8_t UartNumber, 
//  477     uint8_t Pin, 
//  478     bool_t Open
//  479 );
//  480 
//  481 /******************************************************************************
//  482  * Name: UartClearErrors
//  483  * Description: clears the UART receive errors
//  484  * Parameters: [IN] UartNumber - the UART port number
//  485  * Return: -
//  486  *****************************************************************************/
//  487 static void UartClearErrors
//  488 (
//  489     uint8_t UartNumber
//  490 );
//  491 
//  492 /******************************************************************************
//  493  * Name: UartExecPendingCallbacks
//  494  * Description: execute any pending UART transmit callbacks
//  495  * Parameters: [IN] UartNumber - the UART port number
//  496  * Return: -
//  497  *****************************************************************************/
//  498 static void UartExecPendingCallbacks
//  499 (
//  500         uint8_t UartNumber
//  501 );
//  502 
//  503 /******************************************************************************
//  504 *******************************************************************************
//  505 * Private functions
//  506 *******************************************************************************
//  507 ******************************************************************************/
//  508  
//  509  /*****************************************************************************
//  510  * Name: UartReceiverIsr
//  511  * Description: UART RX interrupt handler. Called in interrupt context.
//  512  * Parameters: [IN]: UartNumber - the UART peripheral number
//  513  * Return: -
//  514  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  515 static void UartReceiverIsr 
//  516 (
//  517     uint8_t UartNumber
//  518 )
//  519 {
UartReceiverIsr:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
//  520   UartModule_t *pModule = &mUartModule[UartNumber];
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R5,R1,R4,R0
//  521 #if UART_USE_RX_FIFO  
//  522     	if(mUartModule[UartNumber].UartRxFifoSize > 1)
//  523 	{				
//  524 		while(mUartModule[UartNumber].UartRegs->RCFIFO)
//  525 		{ 
//  526 			/* read one character from RX FIFO */    					
//  527 			pModule->pUartRxBuffer[pModule->UartBufferLeadIndex] = pModule->UartRegs->D;
//  528                         
//  529 			if (++pModule->UartBufferLeadIndex >= pModule->UartNumberCharsToReceive) 
//  530 			{
//  531 				pModule->UartBufferLeadIndex = 0;
//  532 			}
//  533 
//  534 			if (pModule->UartUnreadBytesNumber < pModule->UartNumberCharsToReceive) 
//  535 			{
//  536 				++pModule->UartUnreadBytesNumber;
//  537 			}
//  538 			else 
//  539 			{
//  540 				/* A new character was received while the buffer is already full. 
//  541 				 * The oldest character in the buffer has been overwritten. 
//  542 				 * The trailing index must be also incremented to compensate the overwritten characters
//  543 				 */
//  544 				if(++pModule->UartBufferTrailIndex >= pModule->UartNumberCharsToReceive) 
//  545 				{
//  546 					pModule->UartBufferTrailIndex = 0;
//  547 				}
//  548 			}                                                
//  549 		}
//  550 	}    	    
//  551 	else  
//  552 #endif /* UART_USE_RX_FIFO */
//  553    	{
//  554 		pModule->pUartRxBuffer[pModule->UartBufferLeadIndex] = pModule->UartRegs->D;    		
        LDR      R0,[R5, #+4]
        LDRB     R0,[R0, #+7]
        LDR      R1,[R5, #+16]
        LDR      R2,[R5, #+36]
        STRB     R0,[R2, R1]
//  555 
//  556 		if (++pModule->UartBufferLeadIndex >= pModule->UartNumberCharsToReceive) 
        LDR      R0,[R5, #+36]
        ADDS     R0,R0,#+1
        STR      R0,[R5, #+36]
        LDR      R0,[R5, #+36]
        LDR      R1,[R5, #+20]
        CMP      R0,R1
        BCC.N    ??UartReceiverIsr_0
//  557 		{
//  558 			pModule->UartBufferLeadIndex = 0;
        MOVS     R0,#+0
        STR      R0,[R5, #+36]
//  559 		}
//  560 		if (pModule->UartUnreadBytesNumber < pModule->UartNumberCharsToReceive) 
??UartReceiverIsr_0:
        LDR      R0,[R5, #+44]
        LDR      R1,[R5, #+20]
        CMP      R0,R1
        BCS.N    ??UartReceiverIsr_1
//  561 		{
//  562 			++pModule->UartUnreadBytesNumber;
        LDR      R0,[R5, #+44]
        ADDS     R0,R0,#+1
        STR      R0,[R5, #+44]
        B.N      ??UartReceiverIsr_2
//  563 		}
//  564 		else 
//  565 		{
//  566 			/* A new character was received while the buffer is already full. 
//  567 			 * The oldest character in the buffer has been overwritten. 
//  568 			 * The trailing index must be also incremented to compensate the overwritten characters
//  569 			 */
//  570 			if(++pModule->UartBufferTrailIndex >= pModule->UartNumberCharsToReceive) 
??UartReceiverIsr_1:
        LDR      R0,[R5, #+40]
        ADDS     R0,R0,#+1
        STR      R0,[R5, #+40]
        LDR      R0,[R5, #+40]
        LDR      R1,[R5, #+20]
        CMP      R0,R1
        BCC.N    ??UartReceiverIsr_2
//  571 			{
//  572 				pModule->UartBufferTrailIndex = 0;
        MOVS     R0,#+0
        STR      R0,[R5, #+40]
//  573 			}
//  574 		}
//  575 	}
//  576 	
//  577 	/* Let the application know that one (or more) byte(s) have (has) been received */
//  578 #if (TRUE == gUart1_Enabled_d)	
//  579 	if(UartNumber == gUart1_c)
??UartReceiverIsr_2:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+1
        BNE.N    ??UartReceiverIsr_3
//  580 	{
//  581 #if gUart1_Hw_Sw_FlowControl_d
//  582         if (pModule->UartNumberCharsToReceive - pModule->UartUnreadBytesNumber <= gUart1_RxFlowControlSkew_d) 
//  583         {
//  584                 Uart1_DisableFlow();
//  585         }
//  586 #endif
//  587             if(pfSci1RxCallBack != NULL)
        LDR.W    R0,??DataTable10
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??UartReceiverIsr_3
//  588             {
//  589               pfSci1RxCallBack();
        LDR.W    R0,??DataTable10
        LDR      R0,[R0, #+0]
        BLX      R0
//  590             }
//  591         }
//  592 #endif /* gUart1_Enabled_d */
//  593         
//  594 #if (TRUE == gUart2_Enabled_d)        
//  595         if(UartNumber==gUart2_c)
//  596         {
//  597 #if gUart2_Hw_Sw_FlowControl_d
//  598             if (pModule->UartNumberCharsToReceive - pModule->UartUnreadBytesNumber <= gUart2_RxFlowControlSkew_d) 
//  599             {
//  600                     Uart2_DisableFlow();
//  601             }
//  602 #endif
//  603              if(pfSci2RxCallBack != NULL)
//  604              {  
//  605                 pfSci2RxCallBack();
//  606              }  
//  607         } 
//  608 #endif /* gUart2_Enabled_d */
//  609 }  
??UartReceiverIsr_3:
        POP      {R0,R4,R5,PC}    ;; return
//  610 
//  611 /******************************************************************************
//  612  * Name: UartTransmitterIsr
//  613  * Description: UART TX interrupt handler. Called in interrupt context.
//  614  * Parameters: [IN]: UartNumber - the UART peripheral number
//  615  * Return: -
//  616  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  617 static void UartTransmitterIsr 
//  618 (
//  619     uint8_t UartNumber
//  620 )
//  621 {	/*************************
UartTransmitterIsr:
        PUSH     {R4,LR}
        SUB      SP,SP,#+8
        MOVS     R4,R0
//  622 	 ******** UART_1 *********
//  623 	 *************************/
//  624 	
//  625 #if (gUart1_Enabled_d == TRUE)
//  626 
//  627     if(gUart1_c == UartNumber)
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+1
        BNE.W    ??UartTransmitterIsr_0
//  628     {
//  629         volatile uint8_t dummy;
//  630                 
//  631 #if gUART_USE_TX_FIFO_d
//  632         
//  633         if((mUartModule[gUart1_c].UartTxFifoSize > 1) && (mUartModule[gUart1_c].UartRegs->PFIFO & gUART_TX_FIFO_EN_BIT_c))
        LDR.W    R0,??DataTable8
        LDRB     R0,[R0, #+101]
        CMP      R0,#+2
        BLT.W    ??UartTransmitterIsr_1
        LDR.W    R0,??DataTable8
        LDR      R0,[R0, #+56]
        LDRB     R0,[R0, #+16]
        LSLS     R0,R0,#+24
        BPL.W    ??UartTransmitterIsr_1
//  634         {
//  635         	if(mUartModule[gUart1_c].UartRegs->S1 & gUART_S1_TDRE_MASK_c)
        LDR.W    R0,??DataTable8
        LDR      R0,[R0, #+56]
        LDRB     R0,[R0, #+4]
        LSLS     R0,R0,#+24
        BPL.W    ??UartTransmitterIsr_2
//  636         	{        		        	
//  637         		while(mUartModule[gUart1_c].UartTxFifoSize - mUartModule[gUart1_c].UartRegs->TCFIFO > 0)
??UartTransmitterIsr_3:
        LDR.W    R0,??DataTable8
        LDRB     R0,[R0, #+101]
        LDR.W    R1,??DataTable8
        LDR      R1,[R1, #+56]
        LDRB     R1,[R1, #+20]
        SUBS     R0,R0,R1
        CMP      R0,#+1
        BLT.N    ??UartTransmitterIsr_4
//  638         		{
//  639         			if(FALSE == mUartModule[gUart1_c].UartWriteOnGoing)
        LDR.W    R0,??DataTable8
        LDR      R0,[R0, #+52]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??UartTransmitterIsr_4
//  640         				break;
//  641         			
//  642         			/* Write a byte. */
//  643         			mUartModule[gUart1_c].UartRegs->D = maSci1TxBufRefTable[mSci1TxBufRefTrailingIndex].pBuf[mSci1TxCurIndex];        	
??UartTransmitterIsr_5:
        LDR.W    R0,??DataTable10_1
        LDR.W    R1,??DataTable10_2
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.W    R1,??DataTable10_3
        LDRB     R1,[R1, #+0]
        LDRB     R0,[R1, R0]
        LDR.W    R1,??DataTable8
        LDR      R1,[R1, #+56]
        STRB     R0,[R1, #+7]
//  644 
//  645         			/* Finished with this buffer? */
//  646         			if (++mSci1TxCurIndex >= maSci1TxBufLenTable[mSci1TxBufRefTrailingIndex]) 
        LDR.W    R0,??DataTable10_3
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR.W    R1,??DataTable10_3
        STRB     R0,[R1, #+0]
        LDR.W    R0,??DataTable10_3
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable11
        LDR.W    R2,??DataTable10_2
        LDRB     R2,[R2, #+0]
        LDRB     R1,[R2, R1]
        CMP      R0,R1
        BCC.N    ??UartTransmitterIsr_3
//  647         			{
//  648 
//  649         				/* Mark this one as done */
//  650         				maSci1TxBufLenTable[mSci1TxBufRefTrailingIndex] = 0;                
        MOVS     R0,#+0
        LDR.W    R1,??DataTable11
        LDR.W    R2,??DataTable10_2
        LDRB     R2,[R2, #+0]
        STRB     R0,[R2, R1]
//  651         				if ( maSci1TxBufRefTable[mSci1TxBufRefTrailingIndex].pfCallBack) 
        LDR.W    R0,??DataTable10_1
        LDR.W    R1,??DataTable10_2
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+3
        LDR      R0,[R0, #+4]
        CMP      R0,#+0
        BEQ.N    ??UartTransmitterIsr_6
//  652         				{
//  653                                                 UartExecPendingCallbacks(gUart1_c);
        MOVS     R0,#+1
        BL       UartExecPendingCallbacks
//  654         				}                
//  655 
//  656         				/* Reset the current buffer index */
//  657         				mSci1TxCurIndex = 0;
??UartTransmitterIsr_6:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable10_3
        STRB     R0,[R1, #+0]
//  658 
//  659         				/* Increment to the next buffer. */
//  660         				if (++mSci1TxBufRefTrailingIndex >= NumberOfElements(maSci1TxBufRefTable)) 
        LDR.W    R0,??DataTable10_2
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR.W    R1,??DataTable10_2
        STRB     R0,[R1, #+0]
        LDR.W    R0,??DataTable10_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+3
        BCC.N    ??UartTransmitterIsr_7
//  661         				{
//  662         					mSci1TxBufRefTrailingIndex = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable10_2
        STRB     R0,[R1, #+0]
//  663         				}
//  664 
//  665         				/* If there is no more data to send, turn off the transmit interrupt. */
//  666         				if (!maSci1TxBufLenTable[mSci1TxBufRefTrailingIndex]) 
??UartTransmitterIsr_7:
        LDR.W    R0,??DataTable11
        LDR.W    R1,??DataTable10_2
        LDRB     R1,[R1, #+0]
        LDRB     R0,[R1, R0]
        CMP      R0,#+0
        BNE.N    ??UartTransmitterIsr_3
//  667         				{
//  668         					mUartModule[gUart1_c].UartRegs->C2 &= ~(gUART_TIE_BIT_c);
        LDR.W    R0,??DataTable8
        LDR      R0,[R0, #+56]
        LDRB     R0,[R0, #+3]
        ANDS     R0,R0,#0xBF
        LDR.W    R1,??DataTable8
        LDR      R1,[R1, #+56]
        STRB     R0,[R1, #+3]
//  669         					/* clear the write ongoing flag */
//  670         					mUartModule[gUart1_c].UartWriteOnGoing = FALSE;
        LDR.W    R0,??DataTable8
        LDR      R0,[R0, #+52]
        BICS     R0,R0,#0x2
        LDR.W    R1,??DataTable8
        STR      R0,[R1, #+52]
        B.N      ??UartTransmitterIsr_3
//  671         				}
//  672         			} 
//  673         		}
//  674         		
//  675         		/* this read will clear the TDRE flag */
//  676         		dummy = mUartModule[gUart1_c].UartRegs->S1;
??UartTransmitterIsr_4:
        LDR.W    R0,??DataTable8
        LDR      R0,[R0, #+56]
        LDRB     R0,[R0, #+4]
        STRB     R0,[SP, #+0]
        B.N      ??UartTransmitterIsr_2
//  677         	}
//  678         }
//  679         else
//  680 #endif
//  681         {
//  682 #if gUart1_Hw_Sw_FlowControl_d
//  683         	if(Uart1_FlowConflict())
//  684         	{
//  685         		/* Disable the TX interrupt */
//  686         		mUartModule[gUart1_c].UartRegs->C2 &= ~(gUART_TIE_BIT_c);
//  687         		bUart1FlowConflict = TRUE;
//  688         	}
//  689         	else
//  690 #endif	
//  691         	{
//  692         		/* Dummy read - required before write to data register. */
//  693         		dummy = mUartModule[gUart1_c].UartRegs->S1;
??UartTransmitterIsr_1:
        LDR.W    R0,??DataTable8
        LDR      R0,[R0, #+56]
        LDRB     R0,[R0, #+4]
        STRB     R0,[SP, #+0]
//  694 
//  695         		/* Write a byte. */
//  696         		mUartModule[gUart1_c].UartRegs->D = maSci1TxBufRefTable[mSci1TxBufRefTrailingIndex].pBuf[mSci1TxCurIndex];        	
        LDR.W    R0,??DataTable10_1
        LDR.W    R1,??DataTable10_2
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.W    R1,??DataTable10_3
        LDRB     R1,[R1, #+0]
        LDRB     R0,[R1, R0]
        LDR.W    R1,??DataTable8
        LDR      R1,[R1, #+56]
        STRB     R0,[R1, #+7]
//  697 
//  698         		/* Finished with this buffer? */
//  699         		if (++mSci1TxCurIndex >= maSci1TxBufLenTable[mSci1TxBufRefTrailingIndex]) 
        LDR.W    R0,??DataTable10_3
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR.W    R1,??DataTable10_3
        STRB     R0,[R1, #+0]
        LDR.W    R0,??DataTable10_3
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable11
        LDR.W    R2,??DataTable10_2
        LDRB     R2,[R2, #+0]
        LDRB     R1,[R2, R1]
        CMP      R0,R1
        BCC.N    ??UartTransmitterIsr_2
//  700         		{
//  701 
//  702         			/* Mark this one as done */
//  703         			maSci1TxBufLenTable[mSci1TxBufRefTrailingIndex] = 0;                
        MOVS     R0,#+0
        LDR.W    R1,??DataTable11
        LDR.W    R2,??DataTable10_2
        LDRB     R2,[R2, #+0]
        STRB     R0,[R2, R1]
//  704         			if ( maSci1TxBufRefTable[mSci1TxBufRefTrailingIndex].pfCallBack) 
        LDR.W    R0,??DataTable10_1
        LDR.W    R1,??DataTable10_2
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+3
        LDR      R0,[R0, #+4]
        CMP      R0,#+0
        BEQ.N    ??UartTransmitterIsr_8
//  705         			{
//  706                                         UartExecPendingCallbacks(gUart1_c);                  
        MOVS     R0,#+1
        BL       UartExecPendingCallbacks
//  707         			}                
//  708 
//  709         			/* Reset the current buffer index */
//  710         			mSci1TxCurIndex = 0;
??UartTransmitterIsr_8:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable10_3
        STRB     R0,[R1, #+0]
//  711 
//  712         			/* Increment to the next buffer. */
//  713         			if (++mSci1TxBufRefTrailingIndex >= NumberOfElements(maSci1TxBufRefTable)) 
        LDR.W    R0,??DataTable10_2
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR.W    R1,??DataTable10_2
        STRB     R0,[R1, #+0]
        LDR.W    R0,??DataTable10_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+3
        BCC.N    ??UartTransmitterIsr_9
//  714         			{
//  715         				mSci1TxBufRefTrailingIndex = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable10_2
        STRB     R0,[R1, #+0]
//  716         			}
//  717 
//  718         			/* If there is no more data to send, turn off the transmit interrupt. */
//  719         			if (!maSci1TxBufLenTable[mSci1TxBufRefTrailingIndex]) 
??UartTransmitterIsr_9:
        LDR.W    R0,??DataTable11
        LDR.W    R1,??DataTable10_2
        LDRB     R1,[R1, #+0]
        LDRB     R0,[R1, R0]
        CMP      R0,#+0
        BNE.N    ??UartTransmitterIsr_2
//  720         			{
//  721         				mUartModule[gUart1_c].UartRegs->C2 &= ~(gUART_TIE_BIT_c);
        LDR.W    R0,??DataTable8
        LDR      R0,[R0, #+56]
        LDRB     R0,[R0, #+3]
        ANDS     R0,R0,#0xBF
        LDR.W    R1,??DataTable8
        LDR      R1,[R1, #+56]
        STRB     R0,[R1, #+3]
//  722         				/* clear the write ongoing flag */
//  723         				mUartModule[gUart1_c].UartWriteOnGoing = FALSE;
        LDR.W    R0,??DataTable8
        LDR      R0,[R0, #+52]
        BICS     R0,R0,#0x2
        LDR.W    R1,??DataTable8
        STR      R0,[R1, #+52]
//  724         			}
//  725         		} 
//  726         	}
//  727        	
//  728         }
//  729         (void)dummy;
??UartTransmitterIsr_2:
        LDRB     R0,[SP, #+0]
//  730     }   
//  731 #endif // gUart1_Enabled_d   
//  732     
//  733     /*************************
//  734      ******** UART_2 *********
//  735      *************************/
//  736     
//  737 #if (gUart2_Enabled_d == TRUE)
//  738 
//  739     if(gUart2_c == UartNumber)
//  740     {
//  741         volatile uint8_t dummy;
//  742                 
//  743 #if gUART_USE_TX_FIFO_d
//  744         
//  745         if((mUartModule[gUart2_c].UartTxFifoSize > 1) && (mUartModule[gUart2_c].UartRegs->PFIFO & gUART_TX_FIFO_EN_BIT_c))
//  746         {
//  747         	if(mUartModule[gUart2_c].UartRegs->S1 & gUART_S1_TDRE_MASK_c)
//  748         	{        		        	
//  749         		while(mUartModule[gUart2_c].UartTxFifoSize - mUartModule[gUart2_c].UartRegs->TCFIFO > 0)
//  750         		{
//  751         			if(FALSE == mUartModule[gUart2_c].UartWriteOnGoing)
//  752         				break;
//  753         			
//  754         			/* Write a byte. */
//  755         			mUartModule[gUart2_c].UartRegs->D = maSci2TxBufRefTable[mSci2TxBufRefTrailingIndex].pBuf[mSci2TxCurIndex];        	
//  756 
//  757         			/* Finished with this buffer? */
//  758         			if (++mSci2TxCurIndex >= maSci2TxBufLenTable[mSci2TxBufRefTrailingIndex]) 
//  759         			{
//  760 
//  761         				/* Mark this one as done */
//  762         				maSci2TxBufLenTable[mSci2TxBufRefTrailingIndex] = 0;                
//  763         				if ( maSci2TxBufRefTable[mSci2TxBufRefTrailingIndex].pfCallBack) 
//  764         				{
//  765                                                 UartExecPendingCallbacks(gUart2_c);
//  766         				}                
//  767 
//  768         				/* Reset the current buffer index */
//  769         				mSci2TxCurIndex = 0;
//  770 
//  771         				/* Increment to the next buffer. */
//  772         				if (++mSci2TxBufRefTrailingIndex >= NumberOfElements(maSci2TxBufRefTable)) 
//  773         				{
//  774         					mSci2TxBufRefTrailingIndex = 0;
//  775         				}
//  776 
//  777         				/* If there is no more data to send, turn off the transmit interrupt. */
//  778         				if (!maSci2TxBufLenTable[mSci2TxBufRefTrailingIndex]) 
//  779         				{
//  780         					mUartModule[gUart2_c].UartRegs->C2 &= ~(gUART_TIE_BIT_c);
//  781         					/* clear the write ongoing flag */
//  782         					mUartModule[gUart2_c].UartWriteOnGoing = FALSE;
//  783         				}
//  784         			} 
//  785         		}
//  786         		
//  787         		/* this read will clear the TDRE flag */
//  788         		dummy = mUartModule[gUart2_c].UartRegs->S1;
//  789         	}
//  790         }
//  791         else
//  792 #endif
//  793         {
//  794 #if gUart2_Hw_Sw_FlowControl_d
//  795         	if(Uart2_FlowConflict())
//  796         	{
//  797         		/* Disable the TX interrupt */
//  798         		mUartModule[gUart2_c].UartRegs->C2 &= ~(gUART_TIE_BIT_c);
//  799         		bUart2FlowConflict = TRUE;
//  800         	}
//  801         	else
//  802 #endif
//  803         	{
//  804         		/* Dummy read - required before write to data register. */
//  805         		dummy = mUartModule[gUart2_c].UartRegs->S1;
//  806 
//  807         		/* Write a byte. */
//  808         		mUartModule[gUart2_c].UartRegs->D = maSci2TxBufRefTable[mSci2TxBufRefTrailingIndex].pBuf[mSci2TxCurIndex];        	
//  809 
//  810         		/* Finished with this buffer? */
//  811         		if (++mSci2TxCurIndex >= maSci2TxBufLenTable[mSci2TxBufRefTrailingIndex]) 
//  812         		{
//  813 
//  814         			/* Mark this one as done */
//  815         			maSci2TxBufLenTable[mSci2TxBufRefTrailingIndex] = 0;                
//  816         			if ( maSci2TxBufRefTable[mSci2TxBufRefTrailingIndex].pfCallBack) 
//  817         			{
//  818                                         UartExecPendingCallbacks(gUart2_c); 
//  819         			}                
//  820 
//  821         			/* Reset the current buffer index */
//  822         			mSci2TxCurIndex = 0;
//  823 
//  824         			/* Increment to the next buffer. */
//  825         			if (++mSci2TxBufRefTrailingIndex >= NumberOfElements(maSci2TxBufRefTable)) 
//  826         			{
//  827         				mSci2TxBufRefTrailingIndex = 0;
//  828         			}
//  829 
//  830         			/* If there is no more data to send, turn off the transmit interrupt. */
//  831         			if (!maSci2TxBufLenTable[mSci2TxBufRefTrailingIndex]) 
//  832         			{
//  833         				mUartModule[gUart2_c].UartRegs->C2 &= ~(gUART_TIE_BIT_c);
//  834         				/* clear the write ongoing flag */
//  835         				mUartModule[gUart2_c].UartWriteOnGoing = FALSE;
//  836         			}
//  837         		} 
//  838         	}       	
//  839         }
//  840     }   
//  841 #endif // gUart2_Enabled_d  }    
//  842 }
??UartTransmitterIsr_0:
        POP      {R0,R1,R4,PC}    ;; return
//  843 
//  844 /******************************************************************************
//  845  * Name: UartReadComplete
//  846  * Description: UART read complete function.
//  847  * Parameters: [IN]: UartNumber - the UART peripheral number
//  848  * Return: -
//  849  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  850 static void UartReadComplete
//  851 (
//  852     uint8_t UartNumber
//  853 )
//  854 {    
UartReadComplete:
        PUSH     {R4,LR}
        MOVS     R4,R0
//  855 	/* Reset the internal write flag because the reception is over */
//  856 	mUartModule[UartNumber].UartReadOnGoing = FALSE;
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0x4
        LDR.W    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        STR      R0,[R1, #+0]
//  857 	
//  858 	/* Disable RX interrupt */ 
//  859 	mUartModule[UartNumber].UartRegs->C2 &= ~(gUART_RIE_BIT_c);
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDR.W    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        LDRB     R1,[R1, #+3]
        ANDS     R1,R1,#0xDF
        STRB     R1,[R0, #+3]
//  860    
//  861     /* Call to the read pCallback function */
//  862         if (UartNumber == gUart1_c)
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+1
        BNE.N    ??UartReadComplete_0
//  863         {
//  864           #if (TRUE == gUart1_Enabled_d)
//  865                   if(pfSci1RxCallBack != NULL)
        LDR.W    R0,??DataTable10
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??UartReadComplete_0
//  866                   {
//  867                     pfSci1RxCallBack();
        LDR.W    R0,??DataTable10
        LDR      R0,[R0, #+0]
        BLX      R0
//  868                   }
//  869           #endif
//  870         }
//  871         else
//  872         {
//  873           #if (TRUE == gUart2_Enabled_d)
//  874                 if(pfSci2RxCallBack != NULL)
//  875                 {
//  876                   pfSci2RxCallBack();
//  877                 } 
//  878           #endif    
//  879         }
//  880 }
??UartReadComplete_0:
        POP      {R4,PC}          ;; return
//  881 
//  882 /******************************************************************************
//  883  * Name: UartDivide
//  884  * Description: Integer division by repeated substractions.
//  885  * Parameters: [IN]: Number - the number to be divided
//  886  *             [IN]: Divisor - the number to divide to
//  887  * Return: the result of the division operation
//  888  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  889 static uint16_t UartDivide
//  890 (
//  891     int32_t Number, 
//  892     uint32_t Divisor
//  893 )
//  894 {
UartDivide:
        MOVS     R2,R0
//  895     /* Variable to store result of the operation */
//  896     uint16_t Result=0;
        MOVS     R0,#+0
//  897 
//  898     while(1)
//  899     {    
//  900         Number-=Divisor;
??UartDivide_0:
        SUBS     R2,R2,R1
//  901         if(Number<0) 
        CMP      R2,#+0
        BPL.N    ??UartDivide_1
//  902         {
//  903             return Result;
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        B.N      ??UartDivide_2
//  904         }
//  905         Result++;
??UartDivide_1:
        ADDS     R0,R0,#+1
        B.N      ??UartDivide_0
//  906     }
??UartDivide_2:
        BX       LR               ;; return
//  907 }
//  908 
//  909 /******************************************************************************
//  910  * Name: UartOpen
//  911  * Description: Open the specified UART port
//  912  * Parameters: [IN]: UartNumber - the UART port number to be opened
//  913  *             [IN]: PlatformClock - The platform clock in KHz
//  914  * Return: see definition of UartErr_t
//  915  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  916 static UartErr_t UartOpen
//  917 (
//  918     uint8_t UartNumber, 
//  919     uint32_t PlatformClock
//  920 )
//  921 {
UartOpen:
        PUSH     {R4,R5}
        MOVS     R2,R0
//  922    
//  923     /* Variable used to clear the UART status register */
//  924     register uint32_t dummy;
//  925 
//  926     /* Check if the first parameter received is valid  */
//  927     if (UartNumber >= gUART_HW_MODULES_AVAILABLE_c)
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+4
        BLT.N    ??UartOpen_0
//  928     {
//  929         return gUartErrWrongUartNumber_c;
        MOVS     R0,#+13
        B.N      ??UartOpen_1
//  930     }
//  931 
//  932     /* Check if UART is open */
//  933     if (mUartModule[UartNumber].UartIsOpen)
??UartOpen_0:
        LDR.W    R0,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+52
        MLA      R0,R4,R2,R0
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+31
        BPL.N    ??UartOpen_2
//  934     {
//  935         return gUartErrUartAlreadyOpen_c;
        MOVS     R0,#+1
        B.N      ??UartOpen_1
//  936     }
//  937 
//  938     if(NULL == mUartModule[UartNumber].UartRegs)
??UartOpen_2:
        LDR.W    R0,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+52
        MLA      R0,R4,R2,R0
        LDR      R0,[R0, #+4]
        CMP      R0,#+0
        BNE.N    ??UartOpen_3
//  939     {
//  940         return gUartErrNullPointer_c;
        MOVS     R0,#+6
        B.N      ??UartOpen_1
//  941     }
//  942 
//  943     /* Disable transceiver */
//  944     mUartModule[UartNumber].UartRegs->C2 &= ~(gUART_TX_EN_BIT_c | gUART_RX_EN_BIT_c);
??UartOpen_3:
        LDR.W    R0,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+52
        MLA      R0,R4,R2,R0
        LDR      R0,[R0, #+4]
        LDR.W    R4,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+52
        MLA      R4,R5,R2,R4
        LDR      R4,[R4, #+4]
        LDRB     R4,[R4, #+3]
        ANDS     R4,R4,#0xF3
        STRB     R4,[R0, #+3]
//  945 
//  946     /* Clear all bits in control registers; disable RX and TX interrupts */
//  947     mUartModule[UartNumber].UartRegs->C1 = 0x00;
        LDR.W    R0,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+52
        MLA      R0,R4,R2,R0
        LDR      R0,[R0, #+4]
        MOVS     R4,#+0
        STRB     R4,[R0, #+2]
//  948     mUartModule[UartNumber].UartRegs->C2 &= ~(gUART_TIE_BIT_c | gUART_RIE_BIT_c); 
        LDR.W    R0,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+52
        MLA      R0,R4,R2,R0
        LDR      R0,[R0, #+4]
        LDR.W    R4,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+52
        MLA      R4,R5,R2,R4
        LDR      R4,[R4, #+4]
        LDRB     R4,[R4, #+3]
        ANDS     R4,R4,#0x9F
        STRB     R4,[R0, #+3]
//  949     mUartModule[UartNumber].UartRegs->C3 = 0x00;
        LDR.W    R0,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+52
        MLA      R0,R4,R2,R0
        LDR      R0,[R0, #+4]
        MOVS     R4,#+0
        STRB     R4,[R0, #+6]
//  950     mUartModule[UartNumber].UartRegs->C4 = 0x00;
        LDR.W    R0,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+52
        MLA      R0,R4,R2,R0
        LDR      R0,[R0, #+4]
        MOVS     R4,#+0
        STRB     R4,[R0, #+10]
//  951     mUartModule[UartNumber].UartRegs->C5 = 0x00;
        LDR.W    R0,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+52
        MLA      R0,R4,R2,R0
        LDR      R0,[R0, #+4]
        MOVS     R4,#+0
        STRB     R4,[R0, #+11]
//  952 
//  953     /* Initialize the internal variables */
//  954     mUartModule[UartNumber].UartIsOpen = TRUE;
        LDR.W    R0,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+52
        MLA      R0,R4,R2,R0
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x1
        LDR.W    R4,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+52
        MLA      R4,R5,R2,R4
        STR      R0,[R4, #+0]
//  955     mUartModule[UartNumber].UartReadOnGoing = FALSE;
        LDR.W    R0,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+52
        MLA      R0,R4,R2,R0
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0x4
        LDR.W    R4,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+52
        MLA      R4,R5,R2,R4
        STR      R0,[R4, #+0]
//  956     mUartModule[UartNumber].UartWriteOnGoing = FALSE;
        LDR.W    R0,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+52
        MLA      R0,R4,R2,R0
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0x2
        LDR.W    R4,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+52
        MLA      R4,R5,R2,R4
        STR      R0,[R4, #+0]
//  957     mUartModule[UartNumber].UartPlatformClock = PlatformClock;    
        LDR.W    R0,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+52
        MLA      R0,R4,R2,R0
        STR      R1,[R0, #+32]
//  958 
//  959     /* Read status registers in order to clear error bits and interrupt receive bits */
//  960     dummy = mUartModule[UartNumber].UartRegs->S1;   
        LDR.W    R0,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+52
        MLA      R0,R4,R2,R0
        LDR      R0,[R0, #+4]
        LDRB     R0,[R0, #+4]
        MOVS     R3,R0
//  961     (void)dummy;
//  962     dummy = mUartModule[UartNumber].UartRegs->S2;
        LDR.W    R0,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+52
        MLA      R0,R4,R2,R0
        LDR      R0,[R0, #+4]
        LDRB     R0,[R0, #+5]
        MOVS     R3,R0
//  963     (void)dummy;
//  964 
//  965     /* Enable transceiver */
//  966     mUartModule[UartNumber].UartRegs->C2 |=  (gUART_TX_EN_BIT_c | gUART_RX_EN_BIT_c);
        LDR.W    R0,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+52
        MLA      R0,R4,R2,R0
        LDR      R0,[R0, #+4]
        LDR.W    R4,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+52
        MLA      R4,R5,R2,R4
        LDR      R4,[R4, #+4]
        LDRB     R4,[R4, #+3]
        ORRS     R4,R4,#0xC
        STRB     R4,[R0, #+3]
//  967 
//  968     /* Exit without error */
//  969     return gUartErrNoError_c;
        MOVS     R0,#+0
??UartOpen_1:
        POP      {R4,R5}
        BX       LR               ;; return
//  970 }
//  971 
//  972 /******************************************************************************
//  973  * Name: UartSetConfig
//  974  * Description: configure the specified UART port
//  975  * Parameters: [IN]: UartNumber - the UART port number to be configured
//  976  *             [IN]: pConfig - pointer to UART configuration data structure
//  977  * Return: see definition of UartErr_t
//  978  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  979 static UartErr_t UartSetConfig
//  980 (
//  981     uint8_t UartNumber, 
//  982     UartConfig_t* pConfig
//  983 )
//  984 {/* variables used for temporary store values for INC and MOD UART registers */
UartSetConfig:
        PUSH     {R4-R8,LR}
        MOVS     R4,R0
        MOVS     R5,R1
//  985     register uint16_t mUartSBR;
//  986     register uint32_t mUartBRDF;
//  987     register uint8_t mUartBRFA;    
//  988 
//  989     /* check if the first parameter received is valid */
//  990     if (UartNumber >= gUART_HW_MODULES_AVAILABLE_c)    
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+4
        BLT.N    ??UartSetConfig_0
//  991         return gUartErrWrongUartNumber_c;
        MOVS     R0,#+13
        B.N      ??UartSetConfig_1
//  992 
//  993     /* check if the second parameter received is valid */
//  994     if (NULL == pConfig)    
??UartSetConfig_0:
        CMP      R5,#+0
        BNE.N    ??UartSetConfig_2
//  995         return gUartErrNullPointer_c;
        MOVS     R0,#+6
        B.N      ??UartSetConfig_1
//  996 
//  997     /* check if UART has been opened */
//  998     if (!mUartModule[UartNumber].UartIsOpen)    
??UartSetConfig_2:
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+31
        BMI.N    ??UartSetConfig_3
//  999         return gUartErrUartNotOpen_c;
        MOVS     R0,#+2
        B.N      ??UartSetConfig_1
// 1000 
// 1001     /* check the possibility to set the specified baudrate considering the platform clock  (platform clock/baudrate >=8) */
// 1002     if ((((mUartModule[UartNumber].UartPlatformClock * 1000) >>3) < pConfig->UartBaudRate))    
??UartSetConfig_3:
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+32]
        MOV      R1,#+1000
        MULS     R0,R1,R0
        LSRS     R0,R0,#+3
        LDR      R1,[R5, #+0]
        CMP      R0,R1
        BCS.N    ??UartSetConfig_4
// 1003         return gUartErrInvalidBaudrate_c;
        MOVS     R0,#+8
        B.N      ??UartSetConfig_1
// 1004 
// 1005     /* check if the read operation is ongoing */
// 1006     if (mUartModule[UartNumber].UartReadOnGoing)    
??UartSetConfig_4:
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+0]
        UBFX     R0,R0,#+2,#+1
        CMP      R0,#+0
        BEQ.N    ??UartSetConfig_5
// 1007         return gUartErrReadOngoing_c;
        MOVS     R0,#+3
        B.N      ??UartSetConfig_1
// 1008 
// 1009     /* check if the write operation is ongoing */
// 1010     if (mUartModule[UartNumber].UartWriteOnGoing)
??UartSetConfig_5:
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+0]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??UartSetConfig_6
// 1011         return gUartErrWriteOngoing_c;
        MOVS     R0,#+4
        B.N      ??UartSetConfig_1
// 1012 
// 1013     /* set parity - set/reset PE and PT bits from UARTx_C2 */
// 1014     switch(pConfig->UartParity)
??UartSetConfig_6:
        LDRB     R0,[R5, #+4]
        CMP      R0,#+0
        BEQ.N    ??UartSetConfig_7
        CMP      R0,#+2
        BEQ.N    ??UartSetConfig_8
        BCC.N    ??UartSetConfig_9
        B.N      ??UartSetConfig_10
// 1015     {
// 1016     case gUartParityNone_c:
// 1017         /* reset the PE (parity enable) bit */
// 1018         mUartModule[UartNumber].UartRegs->C1 &= ~gUART_PARITY_EN_BIT_c;
??UartSetConfig_7:
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDR.W    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        LDRB     R1,[R1, #+2]
        ANDS     R1,R1,#0xFD
        STRB     R1,[R0, #+2]
// 1019         break;
        B.N      ??UartSetConfig_11
// 1020     case gUartParityEven_c:
// 1021         /* set the PE (parity enable) bit */
// 1022         mUartModule[UartNumber].UartRegs->C1 |= gUART_PARITY_EN_BIT_c;
??UartSetConfig_9:
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDR.W    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        LDRB     R1,[R1, #+2]
        ORRS     R1,R1,#0x2
        STRB     R1,[R0, #+2]
// 1023         /* reset the PT (parity type) bit */
// 1024         mUartModule[UartNumber].UartRegs->C1 &= ~gUART_PARITY_EVEN_BIT_c;
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDR.W    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        LDRB     R1,[R1, #+2]
        ANDS     R1,R1,#0xFE
        STRB     R1,[R0, #+2]
// 1025         break;
        B.N      ??UartSetConfig_11
// 1026     case gUartParityOdd_c:
// 1027         /* set the PE (parity enable) bit */
// 1028         mUartModule[UartNumber].UartRegs->C1 |=  gUART_PARITY_EN_BIT_c;
??UartSetConfig_8:
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDR.W    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        LDRB     R1,[R1, #+2]
        ORRS     R1,R1,#0x2
        STRB     R1,[R0, #+2]
// 1029         /* set the PT (parity type) bit */
// 1030         mUartModule[UartNumber].UartRegs->C1 |= gUART_PARITY_EVEN_BIT_c;
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDR.W    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        LDRB     R1,[R1, #+2]
        ORRS     R1,R1,#0x1
        STRB     R1,[R0, #+2]
// 1031         break;
        B.N      ??UartSetConfig_11
// 1032     default:
// 1033         /* on default case, return error */
// 1034         return gUartErrInvalidParity_c;
??UartSetConfig_10:
        MOVS     R0,#+9
        B.N      ??UartSetConfig_1
// 1035     }
// 1036 
// 1037     /* set the number of data bits - set/reset M bit from UARTx_C1 register */
// 1038     switch(pConfig->UartDataBits)
??UartSetConfig_11:
        LDRB     R0,[R5, #+5]
        CMP      R0,#+0
        BEQ.N    ??UartSetConfig_12
        CMP      R0,#+1
        BEQ.N    ??UartSetConfig_13
        B.N      ??UartSetConfig_14
// 1039     {
// 1040     case gUart_8bits_c:
// 1041         /* M = 0 (8 bits) */
// 1042         mUartModule[UartNumber].UartRegs->C1 &= ~gUART_DATA_BITS_BIT_c;
??UartSetConfig_12:
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDR.W    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        LDRB     R1,[R1, #+2]
        ANDS     R1,R1,#0xF7
        STRB     R1,[R0, #+2]
// 1043         break;
        B.N      ??UartSetConfig_15
// 1044     case gUart_9bits_c:
// 1045         /* M = 1 (9 bits) */
// 1046         mUartModule[UartNumber].UartRegs->C1 |=  gUART_DATA_BITS_BIT_c;
??UartSetConfig_13:
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDR.W    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        LDRB     R1,[R1, #+2]
        ORRS     R1,R1,#0x8
        STRB     R1,[R0, #+2]
// 1047         break;
        B.N      ??UartSetConfig_15
// 1048     default:
// 1049         /* on default case, return error */
// 1050         return gUartErrInvalidStop_c;
??UartSetConfig_14:
        MOVS     R0,#+10
        B.N      ??UartSetConfig_1
// 1051     }
// 1052 
// 1053     /* configure the HW flow control, if enabled */
// 1054     if(gFlowEnabled_c == pConfig->UartHWFlowCtrl)
??UartSetConfig_15:
        LDRB     R0,[R5, #+6]
        CMP      R0,#+1
        BNE.N    ??UartSetConfig_16
// 1055     {
// 1056     	
// 1057     	if(gUart1_c == UartNumber)
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+1
        BNE.N    ??UartSetConfig_17
// 1058     	{
// 1059     		/* Setup Port Control Register (PCR) for RTS pin */
// 1060     		gUART_1_RTS_PCR_c = PORT_PCR_MUX(gUART_1_MUX_c);
        MOV      R0,#+768
        LDR.W    R1,??DataTable22  ;; 0x4004d00c
        STR      R0,[R1, #+0]
// 1061     		/* Setup Port Control Register (PCR) for CTS pin */
// 1062     		gUART_1_CTS_PCR_c = PORT_PCR_MUX(gUART_1_MUX_c);
        MOV      R0,#+768
        LDR.W    R1,??DataTable22_1  ;; 0x4004d008
        STR      R0,[R1, #+0]
        B.N      ??UartSetConfig_18
// 1063     	} else if(gUart2_c == UartNumber)
??UartSetConfig_17:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+2
        BNE.N    ??UartSetConfig_18
// 1064     	{
// 1065     		/* Setup Port Control Register (PCR) for RTS pin */
// 1066     		gUART_2_RTS_PCR_c = PORT_PCR_MUX(gUART_2_MUX_c);
        MOV      R0,#+768
        LDR.W    R1,??DataTable22_2  ;; 0x4004d04c
        STR      R0,[R1, #+0]
// 1067     		/* Setup Port Control Register (PCR) for CTS pin */
// 1068     		gUART_2_CTS_PCR_c = PORT_PCR_MUX(gUART_2_MUX_c);
        MOV      R0,#+768
        LDR.W    R1,??DataTable23  ;; 0x4004d048
        STR      R0,[R1, #+0]
// 1069     	}
// 1070     	    	
// 1071         /* set the transmitter RTS polarity */
// 1072         if(gRtsActiveHi_c == pConfig->UartRTSActiveState) {
??UartSetConfig_18:
        LDRB     R0,[R5, #+7]
        CMP      R0,#+1
        BNE.N    ??UartSetConfig_19
// 1073             /* TXRTSPOL = 1 */
// 1074             mUartModule[UartNumber].UartRegs->MODEM |= gUART_TXRTSPOL_BIT_c;
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDR.W    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        LDRB     R1,[R1, #+13]
        ORRS     R1,R1,#0x4
        STRB     R1,[R0, #+13]
        B.N      ??UartSetConfig_20
// 1075         } else {
// 1076             /* TXRTSPOL = 0 */
// 1077             mUartModule[UartNumber].UartRegs->MODEM &= ~gUART_TXRTSPOL_BIT_c;
??UartSetConfig_19:
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDR.W    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        LDRB     R1,[R1, #+13]
        ANDS     R1,R1,#0xFB
        STRB     R1,[R0, #+13]
// 1078         }
// 1079 
// 1080         /* set the receiver RTS bit */
// 1081         mUartModule[UartNumber].UartRegs->MODEM |= gUART_RXRTSE_BIT_c;
??UartSetConfig_20:
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDR.W    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        LDRB     R1,[R1, #+13]
        ORRS     R1,R1,#0x8
        STRB     R1,[R0, #+13]
// 1082 
// 1083         /* set the transmitter CTS bit */
// 1084         mUartModule[UartNumber].UartRegs->MODEM |= gUART_TXCTSE_BIT_c;     
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDR.W    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        LDRB     R1,[R1, #+13]
        ORRS     R1,R1,#0x1
        STRB     R1,[R0, #+13]
        B.N      ??UartSetConfig_21
// 1085     } 
// 1086     else 
// 1087     {
// 1088         /* HW flow control is disabled */
// 1089         mUartModule[UartNumber].UartRegs->MODEM &= ~(gUART_RXRTSE_BIT_c | gUART_TXRTSPOL_BIT_c | gUART_TXCTSE_BIT_c);
??UartSetConfig_16:
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDR.W    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        LDRB     R1,[R1, #+13]
        ANDS     R1,R1,#0xF2
        STRB     R1,[R0, #+13]
// 1090     }
// 1091     
// 1092     /* default FIFO sizes */
// 1093     mUartModule[UartNumber].UartRxFifoSize = 1;
??UartSetConfig_21:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+48]
// 1094     mUartModule[UartNumber].UartTxFifoSize = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+49]
// 1095     
// 1096 #if (gUART_USE_RX_FIFO_d == TRUE)    
// 1097     /* get RX FIFO size */
// 1098     {
// 1099     	register uint8_t fifoSz = (uint8_t)(mUartModule[UartNumber].UartRegs->PFIFO & gUART_RX_FIFO_MASK_c);    	
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDRB     R0,[R0, #+16]
        ANDS     R0,R0,#0x7
// 1100     	fifoSz+=1;
        ADDS     R0,R0,#+1
// 1101     	
// 1102     	while(fifoSz-->0)
??UartSetConfig_22:
        MOVS     R1,R0
        SUBS     R0,R1,#+1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BEQ.N    ??UartSetConfig_23
// 1103     	{
// 1104     		mUartModule[UartNumber].UartRxFifoSize = mUartModule[UartNumber].UartRxFifoSize << 1;    		
        LDR.W    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDRB     R1,[R1, #+48]
        LSLS     R1,R1,#+1
        LDR.W    R2,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+52
        MLA      R2,R3,R4,R2
        STRB     R1,[R2, #+48]
        B.N      ??UartSetConfig_22
// 1105     	};    	
// 1106     }
// 1107         
// 1108     /* enable RX FIFO and set RX threshold, if FIFO is implemented by hardware */
// 1109     if(mUartModule[UartNumber].UartRxFifoSize > 1)
??UartSetConfig_23:
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDRB     R0,[R0, #+48]
        CMP      R0,#+2
        BLT.N    ??UartSetConfig_24
// 1110     {
// 1111     	UartSetReceiverThreshold(UartNumber, gUART_RX_THRESHOLD_c);    	
        MOVS     R1,#+1
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       UartSetReceiverThreshold
// 1112     }
// 1113 #endif
// 1114     
// 1115 #if (gUART_USE_TX_FIFO_d == TRUE)
// 1116     /* get TX FIFO size */
// 1117     {
// 1118     	register uint8_t fifoSz = (uint8_t)((mUartModule[UartNumber].UartRegs->PFIFO >> 4 ) & gUART_RX_FIFO_MASK_c);    	
??UartSetConfig_24:
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDRB     R0,[R0, #+16]
        UBFX     R0,R0,#+4,#+3
// 1119     	fifoSz+=1;
        ADDS     R0,R0,#+1
// 1120 
// 1121     	while(fifoSz-->0)
??UartSetConfig_25:
        MOVS     R1,R0
        SUBS     R0,R1,#+1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BEQ.N    ??UartSetConfig_26
// 1122     	{
// 1123     		mUartModule[UartNumber].UartTxFifoSize = mUartModule[UartNumber].UartTxFifoSize << 1;    		
        LDR.W    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDRB     R1,[R1, #+49]
        LSLS     R1,R1,#+1
        LDR.W    R2,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+52
        MLA      R2,R3,R4,R2
        STRB     R1,[R2, #+49]
        B.N      ??UartSetConfig_25
// 1124     	};    	
// 1125     }    
// 1126     
// 1127     /* enable TX FIFO and set TX threshold, if FIFO is implemented by hardware */
// 1128     if(mUartModule[UartNumber].UartTxFifoSize > 1)
??UartSetConfig_26:
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDRB     R0,[R0, #+49]
        CMP      R0,#+2
        BLT.N    ??UartSetConfig_27
// 1129     {
// 1130     	UartSetTransmitterThreshold(UartNumber, gUART_TX_THRESHOLD_c);    	
        MOVS     R1,#+4
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       UartSetTransmitterThreshold
// 1131     }    
// 1132 #endif
// 1133 
// 1134     /* setup the baud rate registers */
// 1135     if(0 != pConfig->UartBaudRate) {
??UartSetConfig_27:
        LDR      R0,[R5, #+0]
        CMP      R0,#+0
        BEQ.N    ??UartSetConfig_28
// 1136 
// 1137         mUartSBR = UartDivide( (mUartModule[UartNumber].UartPlatformClock * 1000), pConfig->UartBaudRate << 4);
        LDR      R0,[R5, #+0]
        LSLS     R1,R0,#+4
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R0,R2,R4,R0
        LDR      R0,[R0, #+32]
        MOV      R2,#+1000
        MULS     R0,R2,R0
        BL       UartDivide
        MOVS     R6,R0
// 1138         /* setup the baud rate registers BDH and BDL */
// 1139         mUartModule[UartNumber].UartRegs->BDH = 0x00;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        STRB     R0,[R1, #+0]
// 1140         mUartModule[UartNumber].UartRegs->BDH |= (uint8_t)((mUartSBR >> 8) & gUART_BDH_MASK_c);
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDRB     R0,[R0, #+0]
        UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
        LSRS     R1,R6,#+8
        ANDS     R1,R1,#0x1F
        ORRS     R0,R1,R0
        LDR.W    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        STRB     R0,[R1, #+0]
// 1141         mUartModule[UartNumber].UartRegs->BDL = (uint8_t) (mUartSBR & gUART_BDL_MASK_c);
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        STRB     R6,[R0, #+1]
// 1142         /* setup the baud rate fine adjust registers */
// 1143         mUartBRDF = UartDivide((mUartModule[UartNumber].UartPlatformClock * 100000), (pConfig->UartBaudRate<<4)) - (mUartSBR * 100);        
        LDR      R0,[R5, #+0]
        LSLS     R1,R0,#+4
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R0,R2,R4,R0
        LDR      R0,[R0, #+32]
        LDR.W    R2,??DataTable28  ;; 0x186a0
        MULS     R0,R2,R0
        BL       UartDivide
        UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
        MOVS     R1,#+100
        MLS      R0,R1,R6,R0
        MOVS     R7,R0
// 1144         mUartBRFA = UartDivide((mUartBRDF << 5), 100);
        MOVS     R1,#+100
        LSLS     R0,R7,#+5
        BL       UartDivide
        MOV      R8,R0
// 1145         mUartModule[UartNumber].UartRegs->C4 |= (uint8_t)(mUartBRFA & gUART_BRFA_MASK_c); 
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDR.W    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        LDRB     R1,[R1, #+10]
        ANDS     R2,R8,#0x1F
        ORRS     R1,R2,R1
        STRB     R1,[R0, #+10]
// 1146     }
// 1147 
// 1148     /* enable UART error(s) interrupts */
// 1149     mUartModule[UartNumber].UartRegs->C3 |= (gUART_PARITY_ERROR_FLAG_c | gUART_FRAME_ERROR_FLAG_c | gUART_NOISE_FLAG_c | gUART_OVERRUN_FLAG_c);
??UartSetConfig_28:
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDR.W    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        LDRB     R1,[R1, #+6]
        ORRS     R1,R1,#0xF
        STRB     R1,[R0, #+6]
// 1150 
// 1151     /* enable UART transceiver */
// 1152     mUartModule[UartNumber].UartRegs->C2 |=  (gUART_TX_EN_BIT_c | gUART_RX_EN_BIT_c);
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDR.W    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        LDRB     R1,[R1, #+3]
        ORRS     R1,R1,#0xC
        STRB     R1,[R0, #+3]
// 1153 
// 1154     /* exit function without error */
// 1155     return gUartErrNoError_c;
        MOVS     R0,#+0
??UartSetConfig_1:
        POP      {R4-R8,PC}       ;; return
// 1156 }
// 1157 
// 1158 /******************************************************************************
// 1159  * Name: UartGetConfig
// 1160  * Description: get the configuration of the specified UART port
// 1161  * Parameters: [IN]:  UartNumber - the UART port number to read the 
// 1162  *                               configuration from
// 1163  *             [OUT]: pConfig - pointer to UART configuration structure where
// 1164  *                            the configuration data shall be placed                  
// 1165  * Return: see definition of UartErr_t
// 1166  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1167 static UartErr_t UartGetConfig
// 1168 (
// 1169     uint8_t UartNumber, 
// 1170     UartConfig_t* pConfig
// 1171 )
// 1172 {
UartGetConfig:
        MOVS     R2,R0
// 1173     /* check if the first parameter received is valid */
// 1174     if (UartNumber >= gUART_HW_MODULES_AVAILABLE_c)
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+4
        BLT.N    ??UartGetConfig_0
// 1175         return gUartErrWrongUartNumber_c;
        MOVS     R0,#+13
        B.N      ??UartGetConfig_1
// 1176     /* check if the second parameter received is valid */
// 1177     if (NULL == pConfig)
??UartGetConfig_0:
        CMP      R1,#+0
        BNE.N    ??UartGetConfig_2
// 1178         return gUartErrNullPointer_c;
        MOVS     R0,#+6
        B.N      ??UartGetConfig_1
// 1179     /* check if UART has been opened */
// 1180     if (!mUartModule[UartNumber].UartIsOpen)
??UartGetConfig_2:
        LDR.W    R0,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R3,#+52
        MLA      R0,R3,R2,R0
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+31
        BMI.N    ??UartGetConfig_3
// 1181         return gUartErrUartNotOpen_c;
        MOVS     R0,#+2
        B.N      ??UartGetConfig_1
// 1182 
// 1183     /* get parity - look for the PE and PT bits in UARTx_C1 register */
// 1184     if (!(mUartModule[UartNumber].UartRegs->C1 & gUART_PARITY_EN_BIT_c))
??UartGetConfig_3:
        LDR.W    R0,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R3,#+52
        MLA      R0,R3,R2,R0
        LDR      R0,[R0, #+4]
        LDRB     R0,[R0, #+2]
        LSLS     R0,R0,#+30
        BMI.N    ??UartGetConfig_4
// 1185     {
// 1186         pConfig->UartParity=gUartParityNone_c;
        MOVS     R0,#+0
        STRB     R0,[R1, #+4]
        B.N      ??UartGetConfig_5
// 1187     }
// 1188     else
// 1189     {
// 1190         if (mUartModule[UartNumber].UartRegs->C1 & gUART_PARITY_EVEN_BIT_c)
??UartGetConfig_4:
        LDR.W    R0,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R3,#+52
        MLA      R0,R3,R2,R0
        LDR      R0,[R0, #+4]
        LDRB     R0,[R0, #+2]
        LSLS     R0,R0,#+31
        BPL.N    ??UartGetConfig_6
// 1191         {
// 1192             pConfig->UartParity=gUartParityEven_c;
        MOVS     R0,#+1
        STRB     R0,[R1, #+4]
        B.N      ??UartGetConfig_5
// 1193         }
// 1194         else
// 1195         {
// 1196             pConfig->UartParity=gUartParityOdd_c;
??UartGetConfig_6:
        MOVS     R0,#+2
        STRB     R0,[R1, #+4]
// 1197         }       
// 1198     }
// 1199 
// 1200     /* get the number of data bits - look for M bit in UARTx_C1 register */
// 1201     if (mUartModule[UartNumber].UartRegs->C1 & gUART_DATA_BITS_BIT_c)
??UartGetConfig_5:
        LDR.W    R0,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R3,#+52
        MLA      R0,R3,R2,R0
        LDR      R0,[R0, #+4]
        LDRB     R0,[R0, #+2]
        LSLS     R0,R0,#+28
        BPL.N    ??UartGetConfig_7
// 1202         pConfig->UartDataBits=gUart_9bits_c;
        MOVS     R0,#+1
        STRB     R0,[R1, #+5]
        B.N      ??UartGetConfig_8
// 1203     else
// 1204         pConfig->UartDataBits=gUart_8bits_c;
??UartGetConfig_7:
        MOVS     R0,#+0
        STRB     R0,[R1, #+5]
// 1205 
// 1206     /* get the flow control */
// 1207     if((mUartModule[UartNumber].UartRegs->MODEM & (gUART_RXRTSE_BIT_c | gUART_TXCTSE_BIT_c)))
??UartGetConfig_8:
        LDR.W    R0,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R3,#+52
        MLA      R0,R3,R2,R0
        LDR      R0,[R0, #+4]
        LDRB     R0,[R0, #+13]
        MOVS     R3,#+9
        TST      R0,R3
        BEQ.N    ??UartGetConfig_9
// 1208     {
// 1209         pConfig->UartHWFlowCtrl = gFlowEnabled_c; /* HW flow control enabled */
        MOVS     R0,#+1
        STRB     R0,[R1, #+6]
// 1210 
// 1211         if(mUartModule[UartNumber].UartRegs->MODEM & gUART_TXRTSPOL_BIT_c) 
        LDR.W    R0,??DataTable8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R3,#+52
        MLA      R0,R3,R2,R0
        LDR      R0,[R0, #+4]
        LDRB     R0,[R0, #+13]
        LSLS     R0,R0,#+29
        BPL.N    ??UartGetConfig_10
// 1212         {
// 1213             pConfig->UartRTSActiveState = gRtsActiveHi_c;
        MOVS     R0,#+1
        STRB     R0,[R1, #+7]
        B.N      ??UartGetConfig_11
// 1214         } else 
// 1215         {
// 1216             pConfig->UartRTSActiveState = gRtsActiveLow_c;
??UartGetConfig_10:
        MOVS     R0,#+0
        STRB     R0,[R1, #+7]
        B.N      ??UartGetConfig_11
// 1217         }       
// 1218     }
// 1219     else 
// 1220     {
// 1221         pConfig->UartHWFlowCtrl = gNoFlowControl_c;  /* HW flow control disabled */
??UartGetConfig_9:
        MOVS     R0,#+0
        STRB     R0,[R1, #+6]
// 1222     }
// 1223 
// 1224     /* exit function without error */
// 1225     return gUartErrNoError_c;    
??UartGetConfig_11:
        MOVS     R0,#+0
??UartGetConfig_1:
        BX       LR               ;; return
// 1226 }
// 1227 
// 1228 /******************************************************************************
// 1229  * Name: UartSetReceiverThreshold
// 1230  * Description: sets the receiver threshold
// 1231  * Parameters: [IN]: UartNumber - the UART port number
// 1232  *             [IN]: Threshold - the desired threshold
// 1233  * Return: see definition of UartErr_t
// 1234  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1235 static UartErr_t UartSetReceiverThreshold
// 1236 (
// 1237     uint8_t UartNumber,
// 1238     uint8_t Threshold
// 1239 )
// 1240 {	
UartSetReceiverThreshold:
        PUSH     {R4,R5,LR}
        SUB      SP,SP,#+12
        MOVS     R4,R0
        MOVS     R5,R1
// 1241 #if (gUART_USE_RX_FIFO_d == FALSE)
// 1242 	(void)UartNumber;
// 1243 	(void)Threshold;
// 1244     return gUartRXFIFONotInUse_c;
// 1245 #else
// 1246 
// 1247     UartConfig_t UartCfg;
// 1248 
// 1249     UartGetConfig(UartNumber, &UartCfg);
        ADD      R1,SP,#+0
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       UartGetConfig
// 1250 
// 1251     if (UartNumber >= gUART_HW_MODULES_AVAILABLE_c)
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+4
        BLT.N    ??UartSetReceiverThreshold_0
// 1252         return gUartErrWrongUartNumber_c;
        MOVS     R0,#+13
        B.N      ??UartSetReceiverThreshold_1
// 1253      
// 1254     if (Threshold > mUartModule[UartNumber].UartRxFifoSize)
??UartSetReceiverThreshold_0:
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDRB     R0,[R0, #+48]
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R0,R5
        BCS.N    ??UartSetReceiverThreshold_2
// 1255         return gUartErrInvalidThreshold_c;
        MOVS     R0,#+12
        B.N      ??UartSetReceiverThreshold_1
// 1256     
// 1257     if (!mUartModule[UartNumber].UartIsOpen)
??UartSetReceiverThreshold_2:
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+31
        BMI.N    ??UartSetReceiverThreshold_3
// 1258         return gUartErrUartNotOpen_c;
        MOVS     R0,#+2
        B.N      ??UartSetReceiverThreshold_1
// 1259     
// 1260     if (mUartModule[UartNumber].UartReadOnGoing)
??UartSetReceiverThreshold_3:
        LDR.W    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+0]
        UBFX     R0,R0,#+2,#+1
        CMP      R0,#+0
        BEQ.N    ??UartSetReceiverThreshold_4
// 1261         return gUartErrReadOngoing_c;
        MOVS     R0,#+3
        B.N      ??UartSetReceiverThreshold_1
// 1262 
// 1263     /* disable transceiver*/
// 1264     mUartModule[UartNumber].UartRegs->C2 &= ~(gUART_TX_EN_BIT_c | gUART_RX_EN_BIT_c);     
??UartSetReceiverThreshold_4:
        LDR.N    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDR.N    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        LDRB     R1,[R1, #+3]
        ANDS     R1,R1,#0xF3
        STRB     R1,[R0, #+3]
// 1265     
// 1266     /* enable RX FIFO */
// 1267     mUartModule[UartNumber].UartRegs->PFIFO |= gUART_RX_FIFO_EN_BIT_c;
        LDR.N    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDR.N    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        LDRB     R1,[R1, #+16]
        ORRS     R1,R1,#0x8
        STRB     R1,[R0, #+16]
// 1268     
// 1269     /* write the threshold to UART FIFO Receive Water-mark register */
// 1270     mUartModule[UartNumber].UartRegs->RWFIFO = Threshold;
        LDR.N    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        STRB     R5,[R0, #+21]
// 1271     
// 1272     /* Flush the FIFOs */
// 1273     mUartModule[UartNumber].UartRegs->CFIFO |= (gUART_TX_FIFO_FLUSH_c | gUART_RX_FIFO_FLUSH_c);
        LDR.N    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDR.N    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        LDRB     R1,[R1, #+17]
        ORRS     R1,R1,#0xC0
        STRB     R1,[R0, #+17]
// 1274 
// 1275     /* enable transceiver */    
// 1276     mUartModule[UartNumber].UartRegs->C2 |= (gUART_TX_EN_BIT_c | gUART_RX_EN_BIT_c);
        LDR.N    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDR.N    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        LDRB     R1,[R1, #+3]
        ORRS     R1,R1,#0xC
        STRB     R1,[R0, #+3]
// 1277 
// 1278     /* memorize internally the value of the threshold */     
// 1279     mUartModule[UartNumber].UartRxThreshold = Threshold;
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        LDR.N    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+0]
        BFI      R0,R5,#+8,#+8
        LDR.N    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        STR      R0,[R1, #+0]
// 1280 
// 1281     /* exit function without error */
// 1282     return gUartErrNoError_c;
        MOVS     R0,#+0
??UartSetReceiverThreshold_1:
        POP      {R1-R5,PC}       ;; return
// 1283 #endif
// 1284 }
// 1285 
// 1286 /******************************************************************************
// 1287  * Name: UartSetTransmitterThreshold
// 1288  * Description: sets the transmitter threshold
// 1289  * Parameters: [IN]: UartNumber - the UART port number
// 1290  *             [IN]: Threshold - the desired threshold
// 1291  * Return: see definition of UartErr_t
// 1292  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1293 static UartErr_t UartSetTransmitterThreshold
// 1294 (
// 1295     uint8_t UartNumber,
// 1296     uint8_t Threshold
// 1297 )
// 1298 {
UartSetTransmitterThreshold:
        PUSH     {R4,R5,LR}
        SUB      SP,SP,#+12
        MOVS     R4,R0
        MOVS     R5,R1
// 1299 #if (gUART_USE_TX_FIFO_d == FALSE)      
// 1300     (void)UartNumber;
// 1301     (void)Threshold;
// 1302     return gUartTXFIFONotInUse_c;
// 1303 #else
// 1304 
// 1305     UartConfig_t UartCfg;
// 1306 
// 1307     UartGetConfig(UartNumber, &UartCfg);
        ADD      R1,SP,#+0
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       UartGetConfig
// 1308     
// 1309     if (UartNumber >= gUART_HW_MODULES_AVAILABLE_c) 
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+4
        BLT.N    ??UartSetTransmitterThreshold_0
// 1310         return gUartErrWrongUartNumber_c;
        MOVS     R0,#+13
        B.N      ??UartSetTransmitterThreshold_1
// 1311         
// 1312     if (Threshold > mUartModule[UartNumber].UartTxFifoSize)
??UartSetTransmitterThreshold_0:
        LDR.N    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDRB     R0,[R0, #+49]
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R0,R5
        BCS.N    ??UartSetTransmitterThreshold_2
// 1313         return gUartErrInvalidThreshold_c;
        MOVS     R0,#+12
        B.N      ??UartSetTransmitterThreshold_1
// 1314     
// 1315     if (!mUartModule[UartNumber].UartIsOpen)
??UartSetTransmitterThreshold_2:
        LDR.N    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+31
        BMI.N    ??UartSetTransmitterThreshold_3
// 1316         return gUartErrUartNotOpen_c;
        MOVS     R0,#+2
        B.N      ??UartSetTransmitterThreshold_1
// 1317     
// 1318     if (mUartModule[UartNumber].UartWriteOnGoing)
??UartSetTransmitterThreshold_3:
        LDR.N    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+0]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??UartSetTransmitterThreshold_4
// 1319         return gUartErrWriteOngoing_c;
        MOVS     R0,#+4
        B.N      ??UartSetTransmitterThreshold_1
// 1320 
// 1321     /* disable transceiver*/
// 1322     mUartModule[UartNumber].UartRegs->C2 &= ~(gUART_TX_EN_BIT_c | gUART_RX_EN_BIT_c);   
??UartSetTransmitterThreshold_4:
        LDR.N    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDR.N    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        LDRB     R1,[R1, #+3]
        ANDS     R1,R1,#0xF3
        STRB     R1,[R0, #+3]
// 1323     
// 1324     /* enable TX FIFO */
// 1325     mUartModule[UartNumber].UartRegs->PFIFO |= gUART_TX_FIFO_EN_BIT_c;
        LDR.N    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDR.N    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        LDRB     R1,[R1, #+16]
        ORRS     R1,R1,#0x80
        STRB     R1,[R0, #+16]
// 1326 
// 1327     /* write the threshold to UART FIFO Transmit Water-mark register */
// 1328     mUartModule[UartNumber].UartRegs->TWFIFO = Threshold;
        LDR.N    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        STRB     R5,[R0, #+19]
// 1329     
// 1330     /* Flush the FIFOs */
// 1331     mUartModule[UartNumber].UartRegs->CFIFO |= (gUART_TX_FIFO_FLUSH_c | gUART_RX_FIFO_FLUSH_c);
        LDR.N    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDR.N    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        LDRB     R1,[R1, #+17]
        ORRS     R1,R1,#0xC0
        STRB     R1,[R0, #+17]
// 1332 
// 1333     /* enable transceiver */
// 1334     mUartModule[UartNumber].UartRegs->C2 |=  (gUART_TX_EN_BIT_c | gUART_RX_EN_BIT_c);
        LDR.N    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+4]
        LDR.N    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        LDR      R1,[R1, #+4]
        LDRB     R1,[R1, #+3]
        ORRS     R1,R1,#0xC
        STRB     R1,[R0, #+3]
// 1335 
// 1336     /* memorize internally the value of the threshold */
// 1337     mUartModule[UartNumber].UartTxThreshold = Threshold;
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        LDR.N    R0,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+0]
        BFI      R0,R5,#+16,#+8
        LDR.N    R1,??DataTable8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        STR      R0,[R1, #+0]
// 1338 
// 1339     /* exit function without error */
// 1340     return gUartErrNoError_c;
        MOVS     R0,#+0
??UartSetTransmitterThreshold_1:
        POP      {R1-R5,PC}       ;; return
// 1341 #endif  
// 1342 }
// 1343 
// 1344 /******************************************************************************
// 1345  * Name: UartReadData
// 1346  * Description: read data from the specified UART port
// 1347  * Parameters: [IN]: UartNumber - the UART port number
// 1348  *             [OUT]: pBuf - pointer to the buffer where the read data shall be 
// 1349  *                         placed 
// 1350  *             [IN]: NumberBytes - number of bytes to be read 
// 1351  * Return: see definition of UartErr_t
// 1352  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1353 static UartErr_t UartReadData
// 1354 (
// 1355     uint8_t UartNumber, 
// 1356     uint8_t* pBuf,
// 1357     uint16_t NumberBytes
// 1358 )
// 1359 {
UartReadData:
        PUSH     {R4-R6}
        MOVS     R3,R0
// 1360     /* Variable used for clear the Rx hardware FIFO */
// 1361     register uint8_t dummy;
// 1362 
// 1363     /* Check if the first parameter received is valid */ 
// 1364     if (UartNumber >= gUART_HW_MODULES_AVAILABLE_c) 
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+4
        BLT.N    ??UartReadData_0
// 1365         return gUartErrWrongUartNumber_c;
        MOVS     R0,#+13
        B.N      ??UartReadData_1
// 1366     
// 1367     /* Check if the pointer received is not null */
// 1368     if (NULL == pBuf)   
??UartReadData_0:
        CMP      R1,#+0
        BNE.N    ??UartReadData_2
// 1369         return gUartErrNullPointer_c;
        MOVS     R0,#+6
        B.N      ??UartReadData_1
// 1370     
// 1371     /* Check if the buffer length is not zero */
// 1372     if (NumberBytes==0) 
??UartReadData_2:
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        CMP      R2,#+0
        BNE.N    ??UartReadData_3
// 1373         return gUartErrInvalidNrBytes_c;
        MOVS     R0,#+7
        B.N      ??UartReadData_1
// 1374     
// 1375     /* Check if UART has been opened */
// 1376     if (!mUartModule[UartNumber].UartIsOpen)    
??UartReadData_3:
        LDR.W    R0,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R5,#+52
        MLA      R0,R5,R3,R0
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+31
        BMI.N    ??UartReadData_4
// 1377         return gUartErrUartNotOpen_c;
        MOVS     R0,#+2
        B.N      ??UartReadData_1
// 1378     
// 1379     /* Check if the read operation is ongoing  */
// 1380     if (mUartModule[UartNumber].UartReadOnGoing)    
??UartReadData_4:
        LDR.W    R0,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R5,#+52
        MLA      R0,R5,R3,R0
        LDR      R0,[R0, #+0]
        UBFX     R0,R0,#+2,#+1
        CMP      R0,#+0
        BEQ.N    ??UartReadData_5
// 1381         return gUartErrReadOngoing_c;
        MOVS     R0,#+3
        B.N      ??UartReadData_1
// 1382     
// 1383 
// 1384     /* Set the read status */
// 1385     mUartModule[UartNumber].UartRxStatus.UartReadStatus = gUartReadStatusComplete_c;
??UartReadData_5:
        MOVS     R0,#+0
        LDR.W    R5,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R6,#+52
        MLA      R5,R6,R3,R5
        STRB     R0,[R5, #+8]
// 1386     mUartModule[UartNumber].UartRxStatus.UartNumberBytesReceived = 0;
        MOVS     R0,#+0
        LDR.W    R5,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R6,#+52
        MLA      R5,R6,R3,R5
        STRH     R0,[R5, #+10]
// 1387     
// 1388     /* Set the read error flags to false */
// 1389     mUartModule[UartNumber].UartRxStatus.UartReadError.UartRecvOverrunError = FALSE;
        LDR.W    R0,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R5,#+52
        MLA      R0,R5,R3,R0
        LDR      R0,[R0, #+12]
        LSRS     R0,R0,#+1
        LSLS     R0,R0,#+1
        LDR.W    R5,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R6,#+52
        MLA      R5,R6,R3,R5
        STR      R0,[R5, #+12]
// 1390     mUartModule[UartNumber].UartRxStatus.UartReadError.UartParityError = FALSE;
        LDR.W    R0,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R5,#+52
        MLA      R0,R5,R3,R0
        LDR      R0,[R0, #+12]
        BICS     R0,R0,#0x2
        LDR.W    R5,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R6,#+52
        MLA      R5,R6,R3,R5
        STR      R0,[R5, #+12]
// 1391     mUartModule[UartNumber].UartRxStatus.UartReadError.UartFrameError = FALSE;
        LDR.W    R0,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R5,#+52
        MLA      R0,R5,R3,R0
        LDR      R0,[R0, #+12]
        BICS     R0,R0,#0x4
        LDR.W    R5,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R6,#+52
        MLA      R5,R6,R3,R5
        STR      R0,[R5, #+12]
// 1392     mUartModule[UartNumber].UartRxStatus.UartReadError.UartNoiseError = FALSE;
        LDR.W    R0,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R5,#+52
        MLA      R0,R5,R3,R0
        LDR      R0,[R0, #+12]
        BICS     R0,R0,#0x8
        LDR.W    R5,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R6,#+52
        MLA      R5,R6,R3,R5
        STR      R0,[R5, #+12]
// 1393     
// 1394     /* Set the internal variables */
// 1395     mUartModule[UartNumber].pUartRxBuffer = pBuf;
        LDR.W    R0,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R5,#+52
        MLA      R0,R5,R3,R0
        STR      R1,[R0, #+16]
// 1396     mUartModule[UartNumber].UartNumberCharsToReceive = NumberBytes;
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        LDR.W    R0,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R5,#+52
        MLA      R0,R5,R3,R0
        STR      R2,[R0, #+20]
// 1397     
// 1398     /* read ongoing */
// 1399     mUartModule[UartNumber].UartReadOnGoing = TRUE; 
        LDR.W    R0,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R5,#+52
        MLA      R0,R5,R3,R0
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x4
        LDR.W    R5,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R6,#+52
        MLA      R5,R6,R3,R5
        STR      R0,[R5, #+0]
// 1400 
// 1401     /* Read the status registers in order to clear the error flags */
// 1402     dummy = mUartModule[UartNumber].UartRegs->S1;
        LDR.W    R0,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R5,#+52
        MLA      R0,R5,R3,R0
        LDR      R0,[R0, #+4]
        LDRB     R0,[R0, #+4]
        MOVS     R4,R0
// 1403     dummy = mUartModule[UartNumber].UartRegs->D;    
        LDR.W    R0,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R5,#+52
        MLA      R0,R5,R3,R0
        LDR      R0,[R0, #+4]
        LDRB     R0,[R0, #+7]
        MOVS     R4,R0
// 1404     (void)dummy;
// 1405 
// 1406 #if gUART_USE_RX_FIFO_d     
// 1407     /* flush the RX FIFO */
// 1408     mUartModule[UartNumber].UartRegs->CFIFO |= gUART_RX_FIFO_FLUSH_c;  
        LDR.W    R0,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R5,#+52
        MLA      R0,R5,R3,R0
        LDR      R0,[R0, #+4]
        LDR.W    R5,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R6,#+52
        MLA      R5,R6,R3,R5
        LDR      R5,[R5, #+4]
        LDRB     R5,[R5, #+17]
        ORRS     R5,R5,#0x40
        STRB     R5,[R0, #+17]
// 1409 #endif
// 1410 
// 1411     mUartModule[UartNumber].UartBufferLeadIndex = 0;
        MOVS     R0,#+0
        LDR.W    R5,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R6,#+52
        MLA      R5,R6,R3,R5
        STR      R0,[R5, #+36]
// 1412     mUartModule[UartNumber].UartBufferTrailIndex = 0;
        MOVS     R0,#+0
        LDR.W    R5,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R6,#+52
        MLA      R5,R6,R3,R5
        STR      R0,[R5, #+40]
// 1413     mUartModule[UartNumber].UartUnreadBytesNumber = 0;
        MOVS     R0,#+0
        LDR.W    R5,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R6,#+52
        MLA      R5,R6,R3,R5
        STR      R0,[R5, #+44]
// 1414 
// 1415     /* Enable the RX interrupt */
// 1416     mUartModule[UartNumber].UartRegs->C2 |= gUART_RIE_BIT_c;
        LDR.W    R0,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R5,#+52
        MLA      R0,R5,R3,R0
        LDR      R0,[R0, #+4]
        LDR.W    R5,??DataTable32
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R6,#+52
        MLA      R5,R6,R3,R5
        LDR      R5,[R5, #+4]
        LDRB     R5,[R5, #+3]
        ORRS     R5,R5,#0x20
        STRB     R5,[R0, #+3]
// 1417 
// 1418     /* Exit function without error */
// 1419     return gUartErrNoError_c;
        MOVS     R0,#+0
??UartReadData_1:
        POP      {R4-R6}
        BX       LR               ;; return
// 1420 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable8:
        DC32     mUartModule
// 1421 
// 1422 /******************************************************************************
// 1423  * Name: UartCancelReadData
// 1424  * Description: cancels the read data operation
// 1425  * Parameters: [IN]: UartNumber - the UART port number
// 1426  * Return: see definition of UartErr_t
// 1427  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1428 static UartErr_t UartCancelReadData
// 1429 (
// 1430     uint8_t UartNumber
// 1431 )
// 1432 {
UartCancelReadData:
        PUSH     {R4,LR}
        MOVS     R4,R0
// 1433      /*Check if the first parameter received is valid*/ 
// 1434     if (UartNumber >= gUART_HW_MODULES_AVAILABLE_c) 
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+4
        BLT.N    ??UartCancelReadData_0
// 1435         return gUartErrWrongUartNumber_c;
        MOVS     R0,#+13
        B.N      ??UartCancelReadData_1
// 1436     
// 1437     /* Check if UART has been opened */
// 1438     if (!mUartModule[UartNumber].UartIsOpen)    
??UartCancelReadData_0:
        LDR.W    R0,??DataTable32
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+31
        BMI.N    ??UartCancelReadData_2
// 1439         return gUartErrUartNotOpen_c;
        MOVS     R0,#+2
        B.N      ??UartCancelReadData_1
// 1440     
// 1441     /* Check if the read operation is ongoing  */
// 1442     if (!mUartModule[UartNumber].UartReadOnGoing)   
??UartCancelReadData_2:
        LDR.W    R0,??DataTable32
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+52
        MLA      R0,R1,R4,R0
        LDR      R0,[R0, #+0]
        UBFX     R0,R0,#+2,#+1
        CMP      R0,#+0
        BNE.N    ??UartCancelReadData_3
// 1443         return gUartErrNoError_c;
        MOVS     R0,#+0
        B.N      ??UartCancelReadData_1
// 1444     
// 1445     /* Set the status operation to canceled */
// 1446     mUartModule[UartNumber].UartRxStatus.UartReadStatus = gUartReadStatusCanceled_c;
??UartCancelReadData_3:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable32
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+52
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+8]
// 1447     
// 1448     /*Call UartReadComplete */
// 1449     UartReadComplete(UartNumber); 
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       UartReadComplete
// 1450     
// 1451     /* Exit function without error */
// 1452     return gUartErrNoError_c;
        MOVS     R0,#+0
??UartCancelReadData_1:
        POP      {R4,PC}          ;; return
// 1453 }
// 1454 
// 1455 /******************************************************************************
// 1456  * Name: UartCancelWriteData
// 1457  * Description: cancels the write data operation
// 1458  * Parameters: [IN]: UartNumber - the UART port number
// 1459  * Return: see definition of UartErr_t
// 1460  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1461 static UartErr_t UartCancelWriteData
// 1462 (
// 1463     uint8_t UartNumber
// 1464 )
// 1465 {
UartCancelWriteData:
        MOVS     R1,R0
// 1466     /* check if the first parameter received is valid */ 
// 1467     if (UartNumber >= gUART_HW_MODULES_AVAILABLE_c) 
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BLT.N    ??UartCancelWriteData_0
// 1468         return gUartErrWrongUartNumber_c;
        MOVS     R0,#+13
        B.N      ??UartCancelWriteData_1
// 1469     
// 1470     /* Check if UART has been opened */
// 1471     if (!mUartModule[UartNumber].UartIsOpen)    
??UartCancelWriteData_0:
        LDR.W    R0,??DataTable32
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R2,#+52
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+31
        BMI.N    ??UartCancelWriteData_2
// 1472         return gUartErrUartNotOpen_c;
        MOVS     R0,#+2
        B.N      ??UartCancelWriteData_1
// 1473     
// 1474     /* Check if the read operation is ongoing */ 
// 1475     if (!mUartModule[UartNumber].UartWriteOnGoing)  
??UartCancelWriteData_2:
        LDR.W    R0,??DataTable32
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R2,#+52
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+0]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BNE.N    ??UartCancelWriteData_3
// 1476         return gUartErrNoError_c;
        MOVS     R0,#+0
        B.N      ??UartCancelWriteData_1
// 1477     
// 1478     /* set TX FIFO threshold to 0 in order for the next TX interrupt to be 
// 1479     triggered when all the characters in FIFO had been sent*/
// 1480     mUartModule[UartNumber].UartRegs->TWFIFO = 0;
??UartCancelWriteData_3:
        LDR.W    R0,??DataTable32
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R2,#+52
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+4]
        MOVS     R2,#+0
        STRB     R2,[R0, #+19]
// 1481         
// 1482     /* Exit function without error*/
// 1483     return gUartErrNoError_c;
        MOVS     R0,#+0
??UartCancelWriteData_1:
        BX       LR               ;; return
// 1484 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable10:
        DC32     pfSci1RxCallBack

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable10_1:
        DC32     maSci1TxBufRefTable

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable10_2:
        DC32     mSci1TxBufRefTrailingIndex

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable10_3:
        DC32     mSci1TxCurIndex
// 1485 
// 1486 /******************************************************************************
// 1487  * Name: UartGetStatus
// 1488  * Description: gets the status of the specified UART port
// 1489  * Parameters: [IN]: UartNumber - the UART port number
// 1490  * Return: see definition of UartErr_t
// 1491  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1492 static UartErr_t UartGetStatus
// 1493 (
// 1494     uint8_t UartNumber
// 1495 )
// 1496 {
UartGetStatus:
        MOVS     R1,R0
// 1497         /* Check if the parameter received is valid  */
// 1498     if (UartNumber >= gUART_HW_MODULES_AVAILABLE_c)     
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BLT.N    ??UartGetStatus_0
// 1499         return gUartErrWrongUartNumber_c;
        MOVS     R0,#+13
        B.N      ??UartGetStatus_1
// 1500     
// 1501     /* Check if UART has been opened */ 
// 1502     if (!mUartModule[UartNumber].UartIsOpen)    
??UartGetStatus_0:
        LDR.W    R0,??DataTable32
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R2,#+52
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+31
        BMI.N    ??UartGetStatus_2
// 1503         return gUartErrUartNotOpen_c;
        MOVS     R0,#+2
        B.N      ??UartGetStatus_1
// 1504     
// 1505     /* Verify if the read is ongoing */
// 1506     if(mUartModule[UartNumber].UartReadOnGoing) 
??UartGetStatus_2:
        LDR.W    R0,??DataTable32
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R2,#+52
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+0]
        UBFX     R0,R0,#+2,#+1
        CMP      R0,#+0
        BEQ.N    ??UartGetStatus_3
// 1507         return gUartErrReadOngoing_c;
        MOVS     R0,#+3
        B.N      ??UartGetStatus_1
// 1508     
// 1509     /* Verify if the write is ongoing */ 
// 1510     if(mUartModule[UartNumber].UartWriteOnGoing)    
??UartGetStatus_3:
        LDR.W    R0,??DataTable32
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R2,#+52
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+0]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??UartGetStatus_4
// 1511         return gUartErrWriteOngoing_c;
        MOVS     R0,#+4
        B.N      ??UartGetStatus_1
// 1512     
// 1513     /* no error  */
// 1514     return gUartErrNoError_c;
??UartGetStatus_4:
        MOVS     R0,#+0
??UartGetStatus_1:
        BX       LR               ;; return
// 1515 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable11:
        DC32     maSci1TxBufLenTable
// 1516 
// 1517 /******************************************************************************
// 1518  * Name: UartClose
// 1519  * Description: closes the specified UART port
// 1520  * Parameters: [IN] UartNumber - the UART port number
// 1521  * Return: see definition of UartErr_t
// 1522  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1523 static UartErr_t UartClose
// 1524 (
// 1525     uint8_t UartNumber
// 1526 )
// 1527 {
UartClose:
        MOVS     R1,R0
// 1528     /* Check if the parameter received is valid */ 
// 1529     if (UartNumber >= gUART_HW_MODULES_AVAILABLE_c) 
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BLT.N    ??UartClose_0
// 1530         return gUartErrWrongUartNumber_c;
        MOVS     R0,#+13
        B.N      ??UartClose_1
// 1531     
// 1532     /* Check if UART has been opened */
// 1533     if (mUartModule[UartNumber].UartIsOpen==FALSE)  
??UartClose_0:
        LDR.W    R0,??DataTable32
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R2,#+52
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+31
        BMI.N    ??UartClose_2
// 1534         return gUartErrNoError_c;
        MOVS     R0,#+0
        B.N      ??UartClose_1
// 1535     
// 1536     /* Verify if the read is ongoing */ 
// 1537     if(TRUE == mUartModule[UartNumber].UartReadOnGoing) 
??UartClose_2:
        LDR.W    R0,??DataTable32
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R2,#+52
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+0]
        UBFX     R0,R0,#+2,#+1
        CMP      R0,#+0
        BEQ.N    ??UartClose_3
// 1538         return gUartErrReadOngoing_c;
        MOVS     R0,#+3
        B.N      ??UartClose_1
// 1539     
// 1540     /* Verify if the write is ongoing */ 
// 1541     if(mUartModule[UartNumber].UartWriteOnGoing)    
??UartClose_3:
        LDR.W    R0,??DataTable32
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R2,#+52
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+0]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??UartClose_4
// 1542         return gUartErrWriteOngoing_c;
        MOVS     R0,#+4
        B.N      ??UartClose_1
// 1543     
// 1544     /* Disable UART interrupt enable flags */
// 1545     mUartModule[UartNumber].UartRegs->C2 &= ~(gUART_TIE_BIT_c | gUART_RIE_BIT_c);
??UartClose_4:
        LDR.W    R0,??DataTable32
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R2,#+52
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+4]
        LDR.W    R2,??DataTable32
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+52
        MLA      R2,R3,R1,R2
        LDR      R2,[R2, #+4]
        LDRB     R2,[R2, #+3]
        ANDS     R2,R2,#0x9F
        STRB     R2,[R0, #+3]
// 1546     /* Disable transceiver*/
// 1547     mUartModule[UartNumber].UartRegs->C2 &= ~(gUART_TX_EN_BIT_c | gUART_RX_EN_BIT_c) ;
        LDR.W    R0,??DataTable32
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R2,#+52
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+4]
        LDR.W    R2,??DataTable32
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+52
        MLA      R2,R3,R1,R2
        LDR      R2,[R2, #+4]
        LDRB     R2,[R2, #+3]
        ANDS     R2,R2,#0xF3
        STRB     R2,[R0, #+3]
// 1548     /* Clear the internal variable */ 
// 1549     mUartModule[UartNumber].UartIsOpen = FALSE;
        LDR.W    R0,??DataTable32
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R2,#+52
        MLA      R0,R2,R1,R0
        LDR      R0,[R0, #+0]
        LSRS     R0,R0,#+1
        LSLS     R0,R0,#+1
        LDR.W    R2,??DataTable32
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+52
        MLA      R2,R3,R1,R2
        STR      R0,[R2, #+0]
// 1550     /* Exit function with no error status */
// 1551     return gUartErrNoError_c;
        MOVS     R0,#+0
??UartClose_1:
        BX       LR               ;; return
// 1552 }
// 1553 
// 1554 /******************************************************************************
// 1555  * Name: UartGetByteFromRxBuffer
// 1556  * Description: gets a byte from the HW RX buffer and appends it to RAM buffer
// 1557  * Parameters: [IN] UartNumber - the UART port number
// 1558  *             [OUT] pDst - pointer to the RAM buffer
// 1559  * Return: TRUE/FALSE
// 1560  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1561 static bool_t UartGetByteFromRxBuffer
// 1562 (
// 1563     uint8_t UartNumber, 
// 1564     uint8_t *pDst
// 1565 )
// 1566 {
UartGetByteFromRxBuffer:
        PUSH     {R4,R5}
        MOVS     R2,R0
// 1567    UartModule_t *Module = &mUartModule[UartNumber];
        LDR.W    R0,??DataTable32
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R3,#+52
        MLA      R3,R3,R2,R0
// 1568     
// 1569     if(0 == Module->UartUnreadBytesNumber)
        LDR      R0,[R3, #+44]
        CMP      R0,#+0
        BNE.N    ??UartGetByteFromRxBuffer_0
// 1570     {
// 1571         return FALSE;
        MOVS     R0,#+0
        B.N      ??UartGetByteFromRxBuffer_1
// 1572     }
// 1573 
// 1574     /* Disable the RX interrupt while the counter is updated */    
// 1575     mUartModule[UartNumber].UartRegs->C2 &= ~gUART_RIE_BIT_c;
??UartGetByteFromRxBuffer_0:
        LDR.W    R0,??DataTable32
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+52
        MLA      R0,R4,R2,R0
        LDR      R0,[R0, #+4]
        LDR.W    R4,??DataTable32
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+52
        MLA      R4,R5,R2,R4
        LDR      R4,[R4, #+4]
        LDRB     R4,[R4, #+3]
        ANDS     R4,R4,#0xDF
        STRB     R4,[R0, #+3]
// 1576 
// 1577     *pDst = mUartModule[UartNumber].pUartRxBuffer[mUartModule[UartNumber].UartBufferTrailIndex];
        LDR.W    R0,??DataTable32
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+52
        MLA      R0,R4,R2,R0
        LDR      R0,[R0, #+16]
        LDR.W    R4,??DataTable32
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+52
        MLA      R4,R5,R2,R4
        LDR      R4,[R4, #+40]
        LDRB     R0,[R4, R0]
        STRB     R0,[R1, #+0]
// 1578     if (++mUartModule[UartNumber].UartBufferTrailIndex >= mUartModule[UartNumber].UartNumberCharsToReceive) 
        LDR.W    R0,??DataTable32
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+52
        MLA      R0,R4,R2,R0
        LDR      R0,[R0, #+40]
        ADDS     R0,R0,#+1
        LDR.W    R4,??DataTable32
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+52
        MLA      R4,R5,R2,R4
        STR      R0,[R4, #+40]
        LDR.W    R0,??DataTable32
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+52
        MLA      R0,R4,R2,R0
        LDR      R0,[R0, #+40]
        LDR.W    R4,??DataTable32
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+52
        MLA      R4,R5,R2,R4
        LDR      R4,[R4, #+20]
        CMP      R0,R4
        BCC.N    ??UartGetByteFromRxBuffer_2
// 1579     {
// 1580         mUartModule[UartNumber].UartBufferTrailIndex = 0;
        MOVS     R0,#+0
        LDR.W    R4,??DataTable32
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+52
        MLA      R4,R5,R2,R4
        STR      R0,[R4, #+40]
// 1581     }
// 1582     --mUartModule[UartNumber].UartUnreadBytesNumber;  
??UartGetByteFromRxBuffer_2:
        LDR.W    R0,??DataTable32
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+52
        MLA      R0,R4,R2,R0
        LDR      R0,[R0, #+44]
        SUBS     R0,R0,#+1
        LDR.W    R4,??DataTable32
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+52
        MLA      R4,R5,R2,R4
        STR      R0,[R4, #+44]
// 1583     
// 1584 #if gUart1_Hw_Sw_FlowControl_d
// 1585     if(gUart1_c == UartNumber)
// 1586     {
// 1587         if (mUartModule[UartNumber].UartUnreadBytesNumber <= gUart1_RxFlowControlResume_d) 
// 1588         {
// 1589             Uart1_EnableFlow();
// 1590         } 
// 1591     }
// 1592 #endif
// 1593 
// 1594 #if gUart2_Hw_Sw_FlowControl_d
// 1595     if(gUart2_c == UartNumber)
// 1596     {
// 1597         if (mUartModule[UartNumber].UartUnreadBytesNumber <= gUart2_RxFlowControlResume_d) 
// 1598         {
// 1599             Uart2_EnableFlow();
// 1600         } 
// 1601     }
// 1602 #endif  
// 1603        
// 1604     /* Enable the RX interrupt */   
// 1605     mUartModule[UartNumber].UartRegs->C2 |= gUART_RIE_BIT_c;
        LDR.W    R0,??DataTable32
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+52
        MLA      R0,R4,R2,R0
        LDR      R0,[R0, #+4]
        LDR.W    R4,??DataTable32
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+52
        MLA      R4,R5,R2,R4
        LDR      R4,[R4, #+4]
        LDRB     R4,[R4, #+3]
        ORRS     R4,R4,#0x20
        STRB     R4,[R0, #+3]
// 1606 
// 1607     return TRUE;
        MOVS     R0,#+1
??UartGetByteFromRxBuffer_1:
        POP      {R4,R5}
        BX       LR               ;; return
// 1608 }
// 1609 
// 1610 /******************************************************************************
// 1611  * Name: UartOpenCloseTransceiver
// 1612  * Description: opens or closes the UART transceiver
// 1613  * Parameters: [IN] UartNumber - the UART port number
// 1614  *             [IN] Pin - the bit in the control register that 
// 1615  *                  enables/disables the transmiter and the receiver
// 1616  *             [IN] Open - if TRUE, it opens the receiver/trasmitter; if FALSE
// 1617  *                         it closes the receiver/transmiter
// 1618  * Return: -
// 1619  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1620 static void UartOpenCloseTransceiver
// 1621 (
// 1622     uint8_t UartNumber, 
// 1623     uint8_t Pin, 
// 1624     bool_t Open
// 1625 )
// 1626 {  
UartOpenCloseTransceiver:
        PUSH     {R4,R5}
// 1627     if (Open)
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+0
        BEQ.N    ??UartOpenCloseTransceiver_0
// 1628     {
// 1629         mUartModule[UartNumber].UartRegs->C2 |= Pin;
        LDR.W    R3,??DataTable32
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R4,#+52
        MLA      R3,R4,R0,R3
        LDR      R3,[R3, #+4]
        LDR.W    R4,??DataTable32
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R5,#+52
        MLA      R4,R5,R0,R4
        LDR      R4,[R4, #+4]
        LDRB     R4,[R4, #+3]
        ORRS     R4,R1,R4
        STRB     R4,[R3, #+3]
        B.N      ??UartOpenCloseTransceiver_1
// 1630     }
// 1631     else
// 1632     {
// 1633         mUartModule[UartNumber].UartRegs->C2 &= ~(uint32_t)Pin;
??UartOpenCloseTransceiver_0:
        LDR.W    R3,??DataTable32
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R4,#+52
        MLA      R3,R4,R0,R3
        LDR      R3,[R3, #+4]
        LDR.W    R4,??DataTable32
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R5,#+52
        MLA      R4,R5,R0,R4
        LDR      R4,[R4, #+4]
        LDRB     R4,[R4, #+3]
        BICS     R4,R4,R1
        STRB     R4,[R3, #+3]
// 1634     }
// 1635 }
??UartOpenCloseTransceiver_1:
        POP      {R4,R5}
        BX       LR               ;; return
// 1636 
// 1637 /******************************************************************************
// 1638  * Name: UartClearErrors
// 1639  * Description: clears the UART receive errors
// 1640  * Parameters: [IN] UartNumber - the UART port number
// 1641  * Return: -
// 1642  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1643 static void UartClearErrors
// 1644 (
// 1645     uint8_t UartNumber
// 1646 )
// 1647 {  
UartClearErrors:
        PUSH     {R4}
// 1648     register uint8_t status;
// 1649     status = mUartModule[UartNumber].UartRegs->S1;
        LDR.W    R2,??DataTable32
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+52
        MLA      R2,R3,R0,R2
        LDR      R2,[R2, #+4]
        LDRB     R2,[R2, #+4]
        MOVS     R1,R2
// 1650     /* Check for errors */
// 1651     if(status & (gUART_PARITY_ERROR_FLAG_c | gUART_FRAME_ERROR_FLAG_c | gUART_NOISE_FLAG_c | gUART_OVERRUN_FLAG_c))
        MOVS     R2,#+15
        TST      R1,R2
        BEQ.N    ??UartClearErrors_0
// 1652     {
// 1653         /* dummy read to clear UART errors */
// 1654         status = mUartModule[UartNumber].UartRegs->D;
        LDR.W    R2,??DataTable32
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+52
        MLA      R2,R3,R0,R2
        LDR      R2,[R2, #+4]
        LDRB     R2,[R2, #+7]
        MOVS     R1,R2
// 1655         
// 1656 #if gUART_USE_RX_FIFO_d     
// 1657     /* flush the RX FIFO */
// 1658     mUartModule[UartNumber].UartRegs->CFIFO |= gUART_RX_FIFO_FLUSH_c;  
        LDR.W    R2,??DataTable32
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+52
        MLA      R2,R3,R0,R2
        LDR      R2,[R2, #+4]
        LDR.W    R3,??DataTable32
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R4,#+52
        MLA      R3,R4,R0,R3
        LDR      R3,[R3, #+4]
        LDRB     R3,[R3, #+17]
        ORRS     R3,R3,#0x40
        STRB     R3,[R2, #+17]
// 1659 #endif
// 1660     
// 1661 #if gUART_USE_TX_FIFO_d     
// 1662     /* flush the TX FIFO */
// 1663     mUartModule[UartNumber].UartRegs->CFIFO |= gUART_TX_FIFO_FLUSH_c;  
        LDR.W    R2,??DataTable32
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+52
        MLA      R2,R3,R0,R2
        LDR      R2,[R2, #+4]
        LDR.W    R3,??DataTable32
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R4,#+52
        MLA      R3,R4,R0,R3
        LDR      R3,[R3, #+4]
        LDRB     R3,[R3, #+17]
        ORRS     R3,R3,#0x80
        STRB     R3,[R2, #+17]
// 1664 #endif
// 1665     }
// 1666 }
??UartClearErrors_0:
        POP      {R4}
        BX       LR               ;; return
// 1667 
// 1668 /******************************************************************************
// 1669  * Name: UartExecPendingCallbacks
// 1670  * Description: execute any pending UART transmit callbacks
// 1671  * Parameters: [IN] UartNumber - the UART port number
// 1672  * Return: -
// 1673  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1674 static void UartExecPendingCallbacks
// 1675 (
// 1676         uint8_t UartNumber
// 1677 )
// 1678 {   
UartExecPendingCallbacks:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
// 1679 
// 1680     uint8_t loopCnt;
// 1681     
// 1682 #if (gUart1_Enabled_d == TRUE)
// 1683     if(UartNumber == gUart1_c)
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+1
        BNE.N    ??UartExecPendingCallbacks_0
// 1684     {
// 1685         for(loopCnt = 0; loopCnt < NumberOfElements(maSci1TxBufRefTable); loopCnt++ )
        MOVS     R0,#+0
        MOVS     R5,R0
??UartExecPendingCallbacks_1:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+3
        BCS.N    ??UartExecPendingCallbacks_0
// 1686         {
// 1687             if(maSci1TxBufLenTable[loopCnt] == 0 && (NULL != maSci1TxBufRefTable[loopCnt].pfCallBack) )
        LDR.W    R0,??DataTable32_1
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        LDRB     R0,[R5, R0]
        CMP      R0,#+0
        BNE.N    ??UartExecPendingCallbacks_2
        LDR.W    R0,??DataTable32_2
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        ADDS     R0,R0,R5, LSL #+3
        LDR      R0,[R0, #+4]
        CMP      R0,#+0
        BEQ.N    ??UartExecPendingCallbacks_2
// 1688             {
// 1689                 /* Call callback with buffer info as parameter */
// 1690                 (maSci1TxBufRefTable[loopCnt].pfCallBack)(maSci1TxBufRefTable[loopCnt].pBuf);
        LDR.W    R0,??DataTable32_2
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        LDR      R0,[R0, R5, LSL #+3]
        LDR.W    R1,??DataTable32_2
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        ADDS     R1,R1,R5, LSL #+3
        LDR      R1,[R1, #+4]
        BLX      R1
// 1691                 /* reset the callback */
// 1692                 maSci1TxBufRefTable[loopCnt].pfCallBack = NULL;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable32_2
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        ADDS     R1,R1,R5, LSL #+3
        STR      R0,[R1, #+4]
// 1693             }
// 1694         }
??UartExecPendingCallbacks_2:
        ADDS     R5,R5,#+1
        B.N      ??UartExecPendingCallbacks_1
// 1695     }
// 1696 #endif //gUart1_Enabled_d
// 1697     
// 1698 #if (gUart2_Enabled_d == TRUE)        
// 1699     if (UartNumber == gUart2_c)
// 1700     {
// 1701         for(loopCnt = 0; loopCnt < NumberOfElements(maSci2TxBufRefTable); loopCnt++ )
// 1702         {
// 1703             if(maSci2TxBufLenTable[loopCnt] == 0 && (NULL != maSci2TxBufRefTable[loopCnt].pfCallBack) )
// 1704             {
// 1705                 /*Call callback with buffer info as parameter*/
// 1706                 (maSci2TxBufRefTable[loopCnt].pfCallBack)(maSci2TxBufRefTable[loopCnt].pBuf);
// 1707                 /* reset the callback */
// 1708                 maSci2TxBufRefTable[loopCnt].pfCallBack = NULL;
// 1709             }
// 1710         }
// 1711     }
// 1712 #endif //gUart2_Enabled_d
// 1713 }
??UartExecPendingCallbacks_0:
        POP      {R0,R4,R5,PC}    ;; return
// 1714  
// 1715 /*****************************************************************************
// 1716 ******************************************************************************
// 1717 * Public functions
// 1718 ******************************************************************************
// 1719 *****************************************************************************/
// 1720 
// 1721 /******************************************************************************
// 1722  * Name: Uart_ModuleInit
// 1723  * Description: Initialize the serial port(s) and module internal variables
// 1724  * Parameters: -
// 1725  * Return: -
// 1726  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1727 void Uart_ModuleInit
// 1728 (
// 1729     void
// 1730 ) 
// 1731 {
Uart_ModuleInit:
        PUSH     {R4,R5,LR}
        SUB      SP,SP,#+12
// 1732    uint8_t res, loopCnt;
// 1733    UartConfig_t pConfig;    
// 1734 
// 1735 
// 1736 /************************
// 1737  ******** UART_1 ********
// 1738  ************************/
// 1739 #if gUart1_Enabled_d
// 1740     
// 1741     /* Initialize the UART peripheral base address */
// 1742     mUartModule[gUart1_c].UartRegs = (UART_MemMapPtr)UartBaseAddress_c[gUart1_c];
        LDR.W    R0,??DataTable32_3
        LDR      R0,[R0, #+4]
        LDR.W    R1,??DataTable32
        STR      R0,[R1, #+56]
// 1743     
// 1744     if(NULL == mUartModule[gUart1_c].UartRegs)
        LDR.W    R0,??DataTable32
        LDR      R0,[R0, #+56]
        CMP      R0,#+0
        BEQ.N    ??Uart_ModuleInit_0
// 1745     	return;
// 1746     
// 1747     /* Enable system clock gating for UART_1 */
// 1748     gUART_1_SIM_SCG_c |= (1 << gUART_1_SIM_SCG_BIT_c);
??Uart_ModuleInit_1:
        LDR.W    R0,??DataTable32_4  ;; 0x40048034
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x800
        LDR.W    R1,??DataTable32_4  ;; 0x40048034
        STR      R0,[R1, #+0]
// 1749         
// 1750     /* Enable clock gating for UART port in use */
// 1751     gUART_1_PORT_SIM_SCG_c |= gUART_1_PORT_SIM_SGC_BIT_c;
        LDR.W    R0,??DataTable32_5  ;; 0x40048038
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x2000
        LDR.W    R1,??DataTable32_5  ;; 0x40048038
        STR      R0,[R1, #+0]
// 1752     /* Setup Port Control Register (PCR) for RX pin */
// 1753     gUART_1_RX_PCR_c = PORT_PCR_MUX(gUART_1_MUX_c);
        MOV      R0,#+768
        LDR.W    R1,??DataTable32_6  ;; 0x4004d004
        STR      R0,[R1, #+0]
// 1754     /* Setup Port Control Register (PCR) for TX pin */
// 1755     gUART_1_TX_PCR_c = PORT_PCR_MUX(gUART_1_MUX_c);
        MOV      R0,#+768
        LDR.W    R1,??DataTable32_7  ;; 0x4004d000
        STR      R0,[R1, #+0]
// 1756 
// 1757 #if (gUart1_Hw_Sw_FlowControl_d == TRUE)
// 1758     /* Enable clock gating of the port used by CTS pin */
// 1759     gUART_1_SW_CTS_SIM_SCG_c |= (1<<gUART_1_SW_CTS_SIM_SCG_BIT_c);
// 1760     /* Setup Port Control Register (PCR) for CTS pin*/
// 1761     gUART_1_SW_CTS_PCR_c = PORT_PCR_MUX(gUART_1_SW_CTS_MUX_c);  
// 1762     
// 1763     /* Enable clock gating of the port used by RTS pin */
// 1764     gUART_1_SW_RTS_SIM_SCG_c |= (1<<gUART_1_SW_RTS_SIM_SCG_BIT_c);
// 1765     /* Setup Port Control Register (PCR) for CTS pin*/
// 1766     gUART_1_SW_RTS_PCR_c = PORT_PCR_MUX(gUART_1_SW_RTS_MUX_c);
// 1767     
// 1768     /* CTS set as input pin */
// 1769     gUART_1_SW_CTS_PDDR_c &= ~gUART_1_SW_CTS_PIN_c;     
// 1770     /* RTS set as output pin */
// 1771     gUART_1_SW_RTS_PDDR_c |= gUART_1_SW_RTS_PIN_c; 
// 1772 #endif
// 1773     
// 1774     /* Open the UART_1 port */               
// 1775     res =  UartOpen(gUart1_c, gSystemClock_c * gMhzToKHzConvert_c);
        MOVW     R1,#+48000
        MOVS     R0,#+1
        BL       UartOpen
        MOVS     R4,R0
// 1776     
// 1777     /* Set UART_1 communication parameters */ 
// 1778     pConfig.UartParity = gUART1_Parity_c;
        MOVS     R0,#+0
        STRB     R0,[SP, #+4]
// 1779     pConfig.UartDataBits = gUART1_DataBits_c;
        MOVS     R0,#+0
        STRB     R0,[SP, #+5]
// 1780     pConfig.UartBaudRate = gUART1_Baudrate_c;
        MOVS     R0,#+115200
        STR      R0,[SP, #+0]
// 1781     pConfig.UartHWFlowCtrl = gUart1_EnableHWFlowControl_c;   
        MOVS     R0,#+0
        STRB     R0,[SP, #+6]
// 1782     pConfig.UartRTSActiveState = gUart1_RTS_ActiveState_c;
        MOVS     R0,#+0
        STRB     R0,[SP, #+7]
// 1783     
// 1784     /* Apply UART_1 configuration */    
// 1785     res |= UartSetConfig(gUart1_c, &pConfig);  
        ADD      R1,SP,#+0
        MOVS     R0,#+1
        BL       UartSetConfig
        ORRS     R0,R0,R4
        MOVS     R4,R0
// 1786     
// 1787     for(loopCnt = 0; loopCnt < gUart_TransmitBuffers_c; loopCnt++)
        MOVS     R0,#+0
        MOVS     R5,R0
??Uart_ModuleInit_2:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+3
        BGE.N    ??Uart_ModuleInit_3
// 1788     {
// 1789         /* initialize TX callbacks to NULL */
// 1790         maSci1TxBufRefTable[loopCnt].pfCallBack = NULL;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable32_2
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        ADDS     R1,R1,R5, LSL #+3
        STR      R0,[R1, #+4]
// 1791     }
        ADDS     R5,R5,#+1
        B.N      ??Uart_ModuleInit_2
// 1792 
// 1793     /* Enables the interrupts corresponding to UART_1 driver */      
// 1794     NVIC_EnableIRQ(gUART_1_IRQ_NUM_c);
??Uart_ModuleInit_3:
        MOVS     R0,#+33
        BL       NVIC_EnableIRQ
// 1795     NVIC_SetPriority(gUART_1_IRQ_NUM_c, gUart1_InterruptPriority_c);
        MOVS     R1,#+9
        MOVS     R0,#+33
        BL       NVIC_SetPriority
// 1796 
// 1797     /* Enables the interrupts corresponding to UART_1 driver error */      
// 1798     NVIC_EnableIRQ(gUART_1_ERR_IRQ_NUM_c);
        MOVS     R0,#+34
        BL       NVIC_EnableIRQ
// 1799     NVIC_SetPriority(gUART_1_ERR_IRQ_NUM_c, gUart1_ErrInterruptPriority_c);
        MOVS     R1,#+8
        MOVS     R0,#+34
        BL       NVIC_SetPriority
// 1800 
// 1801     /* Enable reception */
// 1802     UartReadData(gUart1_c, maSci1RxBuf, sizeof(maSci1RxBuf));
        MOVS     R2,#+250
        LDR.W    R1,??DataTable32_8
        MOVS     R0,#+1
        BL       UartReadData
// 1803     
// 1804 #endif /* gUart1_Enabled_d */
// 1805     
// 1806 
// 1807 /************************
// 1808  ******** UART_2 ********
// 1809  ************************/
// 1810 #if gUart2_Enabled_d
// 1811     
// 1812     /* Initialize the UART peripheral base address */
// 1813     mUartModule[gUart2_c].UartRegs = UartBaseAddress_c[gUart2_c];
// 1814     
// 1815     if(NULL == mUartModule[gUart2_c].UartRegs)
// 1816     	return;
// 1817     
// 1818     /* Enable system clock gating for UART_2 */
// 1819     gUART_2_SIM_SCG_c |= (1 << gUART_2_SIM_SCG_BIT_c);       
// 1820     
// 1821     /* Enable clock gating for UART port in use */
// 1822     gUART_2_PORT_SIM_SCG_c |= gUART_2_PORT_SIM_SGC_BIT_c;
// 1823     /* Setup Port Control Register (PCR) for RX pin */
// 1824     gUART_2_RX_PCR_c = PORT_PCR_MUX(gUART_2_MUX_c);
// 1825     /* Setup Port Control Register (PCR) for TX pin*/
// 1826     gUART_2_TX_PCR_c = PORT_PCR_MUX(gUART_2_MUX_c);
// 1827     
// 1828 #if (gUart2_Hw_Sw_FlowControl_d == TRUE)
// 1829     /* Enable clock gating of the port used by CTS pin */
// 1830     gUART_2_SW_CTS_SIM_SCG_c |= (1<<gUART_2_SW_CTS_SIM_SCG_BIT_c);
// 1831     /* Setup Port Control Register (PCR) for CTS pin*/
// 1832     gUART_2_SW_CTS_PCR_c = PORT_PCR_MUX(gUART_2_SW_CTS_MUX_c);  
// 1833     
// 1834     /* Enable clock gating of the port used by RTS pin */
// 1835     gUART_2_SW_RTS_SIM_SCG_c |= (1<<gUART_2_SW_RTS_SIM_SCG_BIT_c);
// 1836     /* Setup Port Control Register (PCR) for CTS pin*/
// 1837     gUART_2_SW_RTS_PCR_c = PORT_PCR_MUX(gUART_2_SW_RTS_MUX_c);
// 1838     
// 1839     /* CTS set as input pin */
// 1840     gUART_2_SW_CTS_PDDR_c &= ~gUART_2_SW_CTS_PIN_c;     
// 1841     /* RTS set as output pin */
// 1842     gUART_2_SW_RTS_PDDR_c |= gUART_2_SW_RTS_PIN_c;
// 1843 #endif
// 1844             
// 1845     /* Open the UART_2 port */            
// 1846     res =  UartOpen(gUart2_c, gSystemClock_c * gMhzToKHzConvert_c);
// 1847     
// 1848     /* Set UART_2 communication parameters */ 
// 1849     pConfig.UartParity = gUART2_Parity_c;
// 1850     pConfig.UartDataBits = gUART2_DataBits_c;
// 1851     pConfig.UartBaudRate = gUART2_Baudrate_c;
// 1852     pConfig.UartHWFlowCtrl = gUart2_EnableHWFlowControl_c;   
// 1853     pConfig.UartRTSActiveState = gUart2_RTS_ActiveState_c;
// 1854     
// 1855     /* Apply UART_2 configuration */ 
// 1856     res |= UartSetConfig(gUart2_c, &pConfig);
// 1857 
// 1858     for(loopCnt = 0; loopCnt < gUart_TransmitBuffers_c; loopCnt++)
// 1859     {
// 1860         /* initialize TX callbacks to NULL */
// 1861         maSci2TxBufRefTable[loopCnt].pfCallBack = NULL;
// 1862     }
// 1863 
// 1864     /* Enables the interrupts corresponding to UART_2 driver */      
// 1865     NVIC_EnableIRQ(gUART_2_IRQ_NUM_c);
// 1866     NVIC_SetPriority(gUART_2_IRQ_NUM_c, gUart2_InterruptPriority_c);
// 1867 
// 1868     /* Enables the interrupts corresponding to UART_2 driver error */      
// 1869     NVIC_EnableIRQ(gUART_2_ERR_IRQ_NUM_c);
// 1870     NVIC_SetPriority(gUART_2_ERR_IRQ_NUM_c, gUart2_ErrInterruptPriority_c);
// 1871 
// 1872     UartReadData(gUart2_c, maSci2RxBuf, sizeof(maSci2RxBuf));    
// 1873 #endif /* gUart2_Enabled_d */
// 1874 
// 1875     /* Initialize the UART task */
// 1876    // gUartTaskId = TS_CreateTask(gTsUartTaskPriority_c, Uart_Task);
// 1877     
// 1878     (void)res;
// 1879 }
??Uart_ModuleInit_0:
        POP      {R0-R2,R4,R5,PC}  ;; return
// 1880 
// 1881 /******************************************************************************
// 1882  * Name: Uart_ModuleUninit
// 1883  * Description: Shut down the serial port(s)
// 1884  * Parameters: -
// 1885  * Return: -
// 1886  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1887 void Uart_ModuleUninit
// 1888 (
// 1889     void
// 1890 )
// 1891 {
Uart_ModuleUninit:
        PUSH     {R7,LR}
// 1892 #if gUart1_Enabled_d
// 1893     UartClose(gUart1_c);
        MOVS     R0,#+1
        BL       UartClose
// 1894 #endif /* gUart1_Enabled_d */
// 1895 
// 1896 #if gUart2_Enabled_d
// 1897     UartClose(gUart2_c);
// 1898 #endif /* gUart2_Enabled_d */
// 1899 }
        POP      {R0,PC}          ;; return
// 1900 
// 1901 
// 1902 /******************************************************************************
// 1903  * Name: Uart_ClearErrors
// 1904  * Description: Clear any error flags seen by the UART driver. In rare 
// 1905  *              conditions, an error flag can be set without triggering an 
// 1906  *              error interrupt, and will prevent Rx and/or Tx interrupts 
// 1907  *              from occuring. The most likely cause is a breakpoint set 
// 1908  *              during debugging, when a UART port is active.
// 1909  *              Calling this function occasionaly allows the UART code 
// 1910  *              to recover from these errors.
// 1911  * Parameters: -
// 1912  * Return: -
// 1913  ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1914 void Uart_ClearErrors
// 1915 (
// 1916     void
// 1917 )
// 1918 {
Uart_ClearErrors:
        PUSH     {R7,LR}
// 1919 #if gUart1_Enabled_d
// 1920     UartClearErrors(gUart1_c);
        MOVS     R0,#+1
        BL       UartClearErrors
// 1921 #endif
// 1922 
// 1923 #if gUart2_Enabled_d
// 1924     UartClearErrors(gUart2_c);
// 1925 #endif
// 1926 }
        POP      {R0,PC}          ;; return
// 1927 
// 1928 /******************************************************************************
// 1929  * Name: Uart1_GetByteFromRxBuffer
// 1930  * Description: Retrieve a byte from the driver's UART1 Rx buffer and store 
// 1931  *              it at *pDst
// 1932  * Parameters: [OUT] pDst - destination pointer
// 1933  * Return: TRUE if a byte was retrieved / FALSE if the Rx buffer is empty
// 1934  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1935 bool_t Uart1_GetByteFromRxBuffer
// 1936 (
// 1937     unsigned char *pDst
// 1938 ) 
// 1939 {
Uart1_GetByteFromRxBuffer:
        PUSH     {R4,LR}
        MOVS     R4,R0
// 1940 #if !gUart1_Enabled_d
// 1941     (void) pDst;
// 1942     return FALSE;
// 1943 #else  
// 1944     if (uart1_ungetFlag) 
        LDR.W    R0,??DataTable32_9
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??Uart1_GetByteFromRxBuffer_0
// 1945     {
// 1946         uart1_ungetFlag = FALSE;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable32_9
        STRB     R0,[R1, #+0]
// 1947         *pDst = uart1_ungetByte;
        LDR.W    R0,??DataTable32_10
        LDRB     R0,[R0, #+0]
        STRB     R0,[R4, #+0]
// 1948         return TRUE;
        MOVS     R0,#+1
        B.N      ??Uart1_GetByteFromRxBuffer_1
// 1949     } 
// 1950     else
// 1951     {  
// 1952         return UartGetByteFromRxBuffer(gUart1_c, pDst);
??Uart1_GetByteFromRxBuffer_0:
        MOVS     R1,R4
        MOVS     R0,#+1
        BL       UartGetByteFromRxBuffer
??Uart1_GetByteFromRxBuffer_1:
        POP      {R4,PC}          ;; return
// 1953     }
// 1954 #endif
// 1955 }
// 1956 
// 1957 /******************************************************************************
// 1958  * Name: Uart2_GetByteFromRxBuffer
// 1959  * Description: Retrieve a byte from the driver's UART2 Rx buffer and store 
// 1960  *              it at *pDst
// 1961  * Parameters: [OUT] pDst - destination pointer
// 1962  * Return: TRUE if a byte was retrieved / FALSE if the Rx buffer is empty
// 1963  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1964 bool_t Uart2_GetByteFromRxBuffer
// 1965 (
// 1966     unsigned char *pDst
// 1967 ) 
// 1968 {
Uart2_GetByteFromRxBuffer:
        MOVS     R1,R0
// 1969 #if !gUart2_Enabled_d
// 1970     (void) pDst;
// 1971     return 0;
        MOVS     R0,#+0
        BX       LR               ;; return
// 1972 #else
// 1973     if (uart2_ungetFlag)
// 1974     {
// 1975         uart2_ungetFlag = FALSE;
// 1976         *pDst = uart2_ungetByte;
// 1977         return TRUE;
// 1978     }
// 1979     else
// 1980     {
// 1981         return UartGetByteFromRxBuffer(gUart2_c, pDst);
// 1982     }
// 1983 #endif
// 1984 }
// 1985 
// 1986 /******************************************************************************
// 1987  * Name: Uart1_IsTxActive
// 1988  * Description: checks if UART_1 trasmitter is active
// 1989  * Parameters: -
// 1990  * Return: TRUE if there is data still not sent
// 1991  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1992 bool_t Uart1_IsTxActive
// 1993 (
// 1994     void
// 1995 ) 
// 1996 {
// 1997 #if !gUart1_Enabled_d
// 1998     return FALSE;
// 1999 #else
// 2000     
// 2001 #if gUart1_Hw_Sw_FlowControl_d
// 2002     bool_t status;
// 2003 
// 2004     status = (maSci1TxBufLenTable[mSci1TxBufRefTrailingIndex] != 0) || 
// 2005     (!(mUartModule[gUart1_c].UartRegs->S1 & 0x40));
// 2006 
// 2007     if(TRUE == bUart1FlowConflict)
// 2008     {
// 2009     	pfSci1RxCallBack();
// 2010     	if(0 == Uart1_FlowConflict())
// 2011     	{
// 2012     		bUart1FlowConflict = FALSE;
// 2013     		if(status)
// 2014     		{
// 2015     			mUartModule[gUart1_c].UartRegs->C2 |= (gUART_TIE_BIT_c);
// 2016     		}
// 2017     	}
// 2018     }
// 2019     return status ;
// 2020 #else     
// 2021     return (maSci1TxBufLenTable[mSci1TxBufRefTrailingIndex] != 0) || 
// 2022     (!(mUartModule[gUart1_c].UartRegs->S1 & 0x40));
Uart1_IsTxActive:
        LDR.W    R0,??DataTable32_1
        LDR.W    R1,??DataTable32_11
        LDRB     R1,[R1, #+0]
        LDRB     R0,[R1, R0]
        CMP      R0,#+0
        BNE.N    ??Uart1_IsTxActive_0
        LDR.W    R0,??DataTable32
        LDR      R0,[R0, #+56]
        LDRB     R0,[R0, #+4]
        UBFX     R0,R0,#+6,#+1
        ANDS     R0,R0,#0x1
        EORS     R0,R0,#0x1
        B.N      ??Uart1_IsTxActive_1
??Uart1_IsTxActive_0:
        MOVS     R0,#+1
??Uart1_IsTxActive_1:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BX       LR               ;; return
// 2023 #endif
// 2024 #endif
// 2025 }
// 2026 
// 2027 /******************************************************************************
// 2028  * Name: Uart2_IsTxActive
// 2029  * Description: checks if UART_1 trasmitter is active
// 2030  * Parameters: -
// 2031  * Return: TRUE if there is data still not sent
// 2032  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2033 bool_t Uart2_IsTxActive
// 2034 (
// 2035     void
// 2036 ) 
// 2037 {
// 2038 #if !gUart2_Enabled_d
// 2039     return FALSE;
Uart2_IsTxActive:
        MOVS     R0,#+0
        BX       LR               ;; return
// 2040 #else   
// 2041 
// 2042 #if gUart2_Hw_Sw_FlowControl_d
// 2043     bool_t status;
// 2044 
// 2045     status = (maSci2TxBufLenTable[mSci2TxBufRefTrailingIndex] != 0) || 
// 2046     (!(mUartModule[gUart2_c].UartRegs->S1 & 0x40));
// 2047 
// 2048     if(TRUE == bUart2FlowConflict)
// 2049     {
// 2050         pfSci2RxCallBack();
// 2051         if(0 == Uart2_FlowConflict())
// 2052         {
// 2053             bUart2FlowConflict = FALSE;
// 2054             if(status)
// 2055             {
// 2056                 mUartModule[gUart2_c].UartRegs->C2 |= (gUART_TIE_BIT_c);
// 2057             }
// 2058         }
// 2059     }
// 2060     return status ;
// 2061 #else    
// 2062     return (maSci2TxBufLenTable[mSci2TxBufRefTrailingIndex] != 0) || 
// 2063     (!(mUartModule[gUart2_c].UartRegs->S1 & 0x40));
// 2064 #endif
// 2065 #endif
// 2066 }
// 2067 
// 2068 /******************************************************************************
// 2069  * Name: Uart_ModuleEnableLowPowerWakeup
// 2070  * Description: Enables the Receive input active edge, RXEDGIF, to generate interrupt requests.
// 2071  *              The receive input active edge detect circuit is still active on low power modes
// 2072  *              (wait and stop). An active edge on the receive input brings the CPU out of low 
// 2073  *              power mode if the interrupt is not masked.
// 2074  * Parameters: -
// 2075  * Return: -
// 2076  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2077 void Uart_ModuleEnableLowPowerWakeup
// 2078 (
// 2079     void
// 2080 )
// 2081 {
// 2082 #if (gUart1_Enabled_d == FALSE)
// 2083 #else
// 2084   mUartModule[gUart1_c].UartRegs->BDH   &= ~(UART_BDH_RXEDGIE_MASK);
Uart_ModuleEnableLowPowerWakeup:
        LDR.W    R0,??DataTable32
        LDR      R0,[R0, #+56]
        LDRB     R0,[R0, #+0]
        ANDS     R0,R0,#0xBF
        LDR.W    R1,??DataTable32
        LDR      R1,[R1, #+56]
        STRB     R0,[R1, #+0]
// 2085   mUartModule[gUart1_c].UartRegs->S2    &= ~(UART_S2_RXINV_MASK);
        LDR.W    R0,??DataTable32
        LDR      R0,[R0, #+56]
        LDRB     R0,[R0, #+5]
        ANDS     R0,R0,#0xEF
        LDR.W    R1,??DataTable32
        LDR      R1,[R1, #+56]
        STRB     R0,[R1, #+5]
// 2086   mUartModule[gUart1_c].UartRegs->S2    |= UART_S2_RXEDGIF_MASK;
        LDR.W    R0,??DataTable32
        LDR      R0,[R0, #+56]
        LDRB     R0,[R0, #+5]
        ORRS     R0,R0,#0x40
        LDR.W    R1,??DataTable32
        LDR      R1,[R1, #+56]
        STRB     R0,[R1, #+5]
// 2087   mUartModule[gUart1_c].UartRegs->BDH   |= UART_BDH_RXEDGIE_MASK;
        LDR.W    R0,??DataTable32
        LDR      R0,[R0, #+56]
        LDRB     R0,[R0, #+0]
        ORRS     R0,R0,#0x40
        LDR.W    R1,??DataTable32
        LDR      R1,[R1, #+56]
        STRB     R0,[R1, #+0]
// 2088 #endif
// 2089   
// 2090 #if (gUart2_Enabled_d == FALSE)
// 2091 #else
// 2092   mUartModule[gUart2_c].UartRegs->BDH   &= ~(UART_BDH_RXEDGIE_MASK);
// 2093   mUartModule[gUart2_c].UartRegs->S2    &= ~(UART_S2_RXINV_MASK);
// 2094   mUartModule[gUart2_c].UartRegs->S2    |= UART_S2_RXEDGIF_MASK;
// 2095   mUartModule[gUart2_c].UartRegs->BDH   |= UART_BDH_RXEDGIE_MASK;
// 2096 #endif
// 2097 }
        BX       LR               ;; return
// 2098 
// 2099 /******************************************************************************
// 2100  * Name: Uart_ModuleDisableLowPowerWakeup
// 2101  * Description: Disables the Receive input active edge, RXEDGIF, to generate interrupt requests.
// 2102  * Parameters: -
// 2103  * Return: -
// 2104  *****************************************************************************/
// 2105 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2106 void Uart_ModuleDisableLowPowerWakeup
// 2107 (
// 2108     void
// 2109 )
// 2110 {
// 2111 #if (gUart1_Enabled_d == FALSE)
// 2112 #else
// 2113   mUartModule[gUart1_c].UartRegs->BDH   &= ~(UART_BDH_RXEDGIE_MASK);
Uart_ModuleDisableLowPowerWakeup:
        LDR.W    R0,??DataTable32
        LDR      R0,[R0, #+56]
        LDRB     R0,[R0, #+0]
        ANDS     R0,R0,#0xBF
        LDR.W    R1,??DataTable32
        LDR      R1,[R1, #+56]
        STRB     R0,[R1, #+0]
// 2114   mUartModule[gUart1_c].UartRegs->S2    |= UART_S2_RXEDGIF_MASK;
        LDR.W    R0,??DataTable32
        LDR      R0,[R0, #+56]
        LDRB     R0,[R0, #+5]
        ORRS     R0,R0,#0x40
        LDR.W    R1,??DataTable32
        LDR      R1,[R1, #+56]
        STRB     R0,[R1, #+5]
// 2115 #endif
// 2116   
// 2117 #if (gUart2_Enabled_d == FALSE)
// 2118 #else
// 2119   mUartModule[gUart2_c].UartRegs->BDH   &= ~(UART_BDH_RXEDGIE_MASK);
// 2120   mUartModule[gUart2_c].UartRegs->S2    |= UART_S2_RXEDGIF_MASK;
// 2121 #endif
// 2122 }
        BX       LR               ;; return
// 2123 
// 2124 /******************************************************************************
// 2125  * Name: Uart_IsWakeUpSource
// 2126  * Description: -
// 2127  * Parameters: -
// 2128  * Return: -
// 2129  *****************************************************************************/
// 2130 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2131 bool_t Uart_IsWakeUpSource
// 2132 (
// 2133     void
// 2134 )
// 2135 {
Uart_IsWakeUpSource:
        PUSH     {R3-R5,LR}
// 2136   bool_t res = FALSE;
        MOVS     R4,#+0
// 2137   uint32_t irqMaskRegister;
// 2138   irqMaskRegister = IntDisableAll();
        BL       IntDisableAll
        MOVS     R5,R0
// 2139   
// 2140 #if (gUart1_Enabled_d == FALSE)
// 2141 #else
// 2142   if( ( mUartModule[gUart1_c].UartRegs->S2 & UART_S2_RXEDGIF_MASK ) == UART_S2_RXEDGIF_MASK )
        LDR.W    R0,??DataTable32
        LDR      R0,[R0, #+56]
        LDRB     R0,[R0, #+5]
        LSLS     R0,R0,#+25
        BPL.N    ??Uart_IsWakeUpSource_0
// 2143   {
// 2144     mUartModule[gUart1_c].UartRegs->S2 |= UART_S2_RXEDGIF_MASK;
        LDR.W    R0,??DataTable32
        LDR      R0,[R0, #+56]
        LDRB     R0,[R0, #+5]
        ORRS     R0,R0,#0x40
        LDR.W    R1,??DataTable32
        LDR      R1,[R1, #+56]
        STRB     R0,[R1, #+5]
// 2145     res = TRUE;
        MOVS     R0,#+1
        MOVS     R4,R0
// 2146   }
// 2147 #endif
// 2148   
// 2149 #if (gUart2_Enabled_d == FALSE)
// 2150 #else
// 2151   if( ( mUartModule[gUart2_c].UartRegs->S2 & UART_S2_RXEDGIF_MASK ) == UART_S2_RXEDGIF_MASK )
// 2152   {
// 2153     mUartModule[gUart2_c].UartRegs->S2 |= UART_S2_RXEDGIF_MASK;
// 2154     res = TRUE;
// 2155   }
// 2156 #endif
// 2157   
// 2158   IntRestoreAll(irqMaskRegister);
??Uart_IsWakeUpSource_0:
        MOVS     R0,R5
        BL       IntRestoreAll
// 2159   return res;
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R1,R4,R5,PC}    ;; return
// 2160 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable22:
        DC32     0x4004d00c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable22_1:
        DC32     0x4004d008

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable22_2:
        DC32     0x4004d04c
// 2161 
// 2162 /******************************************************************************
// 2163  * Name: Uart1_SetRxCallBack
// 2164  * Description: Set the receive side callback function. This function will 
// 2165  *              be called whenever a byte is received by the driver. 
// 2166  *              The callback's bytesWaiting parameter is the number of bytes 
// 2167  *              available in the driver's Rx buffer.
// 2168  *              The callback function will be called in interrupt context, 
// 2169  *              so it should be kept very short.
// 2170  *              If the callback pointer is set to NULL, the Rx interrupt will 
// 2171  *              be turned off, and all data in the driver's Rx buffer will be 
// 2172  *              discarded.
// 2173  * Parameters: [IN] pfCallBack - pointer to callback function
// 2174  * Return: -
// 2175  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2176 void Uart1_SetRxCallBack
// 2177 (
// 2178     void (*pfCallBack)(void)
// 2179 )
// 2180 {
Uart1_SetRxCallBack:
        PUSH     {R4,LR}
        MOVS     R4,R0
// 2181 #if (gUart1_Enabled_d == FALSE)
// 2182     (void) pfCallBack;
// 2183 #else
// 2184     pfSci1RxCallBack = pfCallBack;
        LDR.W    R0,??DataTable32_12
        STR      R4,[R0, #+0]
// 2185     UartOpenCloseTransceiver(gUart1_c, gUART_RX_EN_BIT_c, NULL != pfSci1RxCallBack);  
        LDR.W    R0,??DataTable32_12
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??Uart1_SetRxCallBack_0
        MOVS     R2,#+1
        B.N      ??Uart1_SetRxCallBack_1
??Uart1_SetRxCallBack_0:
        MOVS     R2,#+0
??Uart1_SetRxCallBack_1:
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,#+4
        MOVS     R0,#+1
        BL       UartOpenCloseTransceiver
// 2186 #endif
// 2187 }
        POP      {R4,PC}          ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable23:
        DC32     0x4004d048
// 2188 
// 2189 /******************************************************************************
// 2190  * Name: Uart2_SetRxCallBack
// 2191  * Description: Set the receive side callback function. This function will 
// 2192  *              be called whenever a byte is received by the driver. 
// 2193  *              The callback's bytesWaiting parameter is the number of bytes 
// 2194  *              available in the driver's Rx buffer.
// 2195  *              The callback function will be called in interrupt context, 
// 2196  *              so it should be kept very short.
// 2197  *              If the callback pointer is set to NULL, the Rx interrupt will 
// 2198  *              be turned off, and all data in the driver's Rx buffer will be 
// 2199  *              discarded.
// 2200  * Parameters: [IN] pfCallBack - pointer to callback function
// 2201  * Return: -
// 2202  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2203 void Uart2_SetRxCallBack
// 2204 (
// 2205     void (*pfCallBack)(void)
// 2206 ) 
// 2207 {
// 2208 #if (gUart2_Enabled_d == FALSE)
// 2209     (void) pfCallBack;
// 2210 #else
// 2211     pfSci2RxCallBack = pfCallBack;  
// 2212     UartOpenCloseTransceiver(gUart2_c, gUART_RX_EN_BIT_c, NULL != pfSci2RxCallBack);  
// 2213 #endif
// 2214 }
Uart2_SetRxCallBack:
        BX       LR               ;; return
// 2215 
// 2216 /******************************************************************************
// 2217  * Name: Uart1_SetBaud
// 2218  * Description: Sets the UART_1 baud rate
// 2219  * Parameters: [IN] baudRate - baudrate value (bps)
// 2220  * Return: -
// 2221  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2222 void Uart1_SetBaud
// 2223 (
// 2224     uint32_t baudRate
// 2225 ) 
// 2226 {  
Uart1_SetBaud:
        PUSH     {R4-R7,LR}
        SUB      SP,SP,#+12
        MOVS     R4,R0
// 2227 #if (gUart1_Enabled_d == FALSE)
// 2228     (void) baudRate;
// 2229 #else  
// 2230     UartConfig_t Cfg;
// 2231     bool_t readStopped = FALSE;
        MOVS     R5,#+0
// 2232     register uint32_t i;
// 2233     UartErr_t err;
// 2234 
// 2235     err = UartGetStatus(gUart1_c);  
        MOVS     R0,#+1
        BL       UartGetStatus
        MOVS     R7,R0
// 2236     if(err != gUartErrUartNotOpen_c)
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+2
        BEQ.N    ??Uart1_SetBaud_0
// 2237     {  
// 2238         for (i = 0; i < 2; i++)
        MOVS     R0,#+0
        MOVS     R6,R0
??Uart1_SetBaud_1:
        CMP      R6,#+2
        BCS.N    ??Uart1_SetBaud_0
// 2239         {  
// 2240             if(err == gUartErrReadOngoing_c) 
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+3
        BNE.N    ??Uart1_SetBaud_2
// 2241             {  
// 2242                 UartCancelReadData(gUart1_c);
        MOVS     R0,#+1
        BL       UartCancelReadData
// 2243                 readStopped = TRUE;
        MOVS     R0,#+1
        MOVS     R5,R0
        B.N      ??Uart1_SetBaud_3
// 2244             }
// 2245             else
// 2246             {  
// 2247                 if(err == gUartErrWriteOngoing_c)
??Uart1_SetBaud_2:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+4
        BNE.N    ??Uart1_SetBaud_4
// 2248                 {  
// 2249                     UartCancelWriteData(gUart1_c);
        MOVS     R0,#+1
        BL       UartCancelWriteData
        B.N      ??Uart1_SetBaud_3
// 2250                 }  
// 2251                 else
// 2252                 {
// 2253                     break;
??Uart1_SetBaud_4:
        B.N      ??Uart1_SetBaud_0
// 2254                 }
// 2255             }
// 2256             /* UartGetStatus is returning one error code at a time. Read back the status to check again */
// 2257             err = UartGetStatus(gUart1_c);
??Uart1_SetBaud_3:
        MOVS     R0,#+1
        BL       UartGetStatus
        MOVS     R7,R0
// 2258         }
        ADDS     R6,R6,#+1
        B.N      ??Uart1_SetBaud_1
// 2259     }
// 2260     
// 2261     UartGetConfig(gUart1_c, &Cfg);
??Uart1_SetBaud_0:
        ADD      R1,SP,#+0
        MOVS     R0,#+1
        BL       UartGetConfig
// 2262     Cfg.UartBaudRate = baudRate;
        STR      R4,[SP, #+0]
// 2263     UartSetConfig(gUart1_c, &Cfg);
        ADD      R1,SP,#+0
        MOVS     R0,#+1
        BL       UartSetConfig
// 2264 
// 2265     if(TRUE == readStopped)
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+1
        BNE.N    ??Uart1_SetBaud_5
// 2266     {
// 2267         UartReadData(gUart1_c, maSci1RxBuf, sizeof(maSci1RxBuf));
        MOVS     R2,#+250
        LDR.N    R1,??DataTable32_8
        MOVS     R0,#+1
        BL       UartReadData
// 2268     }    
// 2269 #endif
// 2270 }
??Uart1_SetBaud_5:
        POP      {R0-R2,R4-R7,PC}  ;; return
// 2271 
// 2272 /******************************************************************************
// 2273  * Name: Uart2_SetBaud
// 2274  * Description: Sets the UART_1 baud rate
// 2275  * Parameters: [IN] baudRate - baudrate value (bps)
// 2276  * Return: -
// 2277  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2278 void Uart2_SetBaud
// 2279 (
// 2280     uint32_t baudRate
// 2281 ) 
// 2282 {
// 2283 #if (gUart2_Enabled_d == FALSE)
// 2284     (void) baudRate;
// 2285 #else
// 2286     UartConfig_t Cfg;
// 2287     bool_t readStopped = FALSE;
// 2288     register uint32_t i;
// 2289 
// 2290     UartErr_t err = UartGetStatus(gUart2_c);  
// 2291     if(err != gUartErrUartNotOpen_c)
// 2292     {  
// 2293         for (i = 0; i < 2; i++)
// 2294         {  
// 2295             if(err == gUartErrReadOngoing_c) 
// 2296             {  
// 2297                 UartCancelReadData(gUart2_c);
// 2298                 readStopped = TRUE;
// 2299             }
// 2300             else
// 2301             {  
// 2302                 if(err == gUartErrWriteOngoing_c)
// 2303                 {  
// 2304                     UartCancelWriteData(gUart2_c);
// 2305                 }  
// 2306                 else
// 2307                 {
// 2308                     break;
// 2309                 }
// 2310             }
// 2311             /* UartGetStatus is returning one error code at a time. Read back the status to check again */
// 2312             err = UartGetStatus(gUart2_c);
// 2313         }
// 2314     }
// 2315     
// 2316 	UartGetConfig(gUart2_c, &Cfg);
// 2317 	Cfg.UartBaudRate = baudRate;
// 2318 	UartSetConfig(gUart2_c, &Cfg);
// 2319 
// 2320     if(TRUE == readStopped)
// 2321     {
// 2322         UartReadData(gUart2_c, maSci2RxBuf, sizeof(maSci2RxBuf));
// 2323     } 
// 2324 #endif
// 2325 }
Uart2_SetBaud:
        BX       LR               ;; return
// 2326 
// 2327 /******************************************************************************
// 2328  * Name: Uart1_Transmit
// 2329  * Description: Transmit bufLen bytes of data from pBuffer over UART_1 port. 
// 2330  *              It calls *pfCallBack() when the entire buffer has been sent. 
// 2331  *              Returns FALSE if there are no more available Tx buffer slots, 
// 2332  *              TRUE otherwise. The caller must ensure that the buffer remains
// 2333  *              available until the call back function is called.
// 2334  *              pfCallBack must not be NULL.
// 2335  *              The callback function will be called in interrupt context, 
// 2336  *              so it should be kept very short.
// 2337  * Parameters: [IN] pBuf - pointer to the buffer to be transmitted
// 2338  *             [IN] bufLen - buffer length
// 2339  *             [IN] pfCallBack - pointer to the callback function
// 2340  * Return: Returns FALSE if there are no more slots in the buffer reference 
// 2341  *         table
// 2342  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2343 bool_t Uart1_Transmit
// 2344 (
// 2345     unsigned char const *pBuf, 
// 2346     index_t bufLen, 
// 2347     void (*pfCallBack)(unsigned char const *pBuf)
// 2348 ) 
// 2349 {
Uart1_Transmit:
        PUSH     {R4-R6,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
// 2350 #if (gUart1_Enabled_d == FALSE)
// 2351     (void) pBuf;
// 2352     (void) bufLen;
// 2353     (void) pfCallBack;
// 2354     return FALSE;
// 2355 #else
// 2356     /* Handle empty buffers */
// 2357     if (!bufLen) 
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BNE.N    ??Uart1_Transmit_0
// 2358     {
// 2359     	if(pfCallBack)
        MOVS     R0,R6
        CMP      R0,#+0
        BEQ.N    ??Uart1_Transmit_1
// 2360     		(*pfCallBack)(pBuf);    		 
        MOVS     R0,R4
        BLX      R6
// 2361     	
// 2362     	return TRUE;
??Uart1_Transmit_1:
        MOVS     R0,#+1
        B.N      ??Uart1_Transmit_2
// 2363     }
// 2364     
// 2365     if (maSci1TxBufLenTable[mSci1TxBufRefLeadingIndex])
??Uart1_Transmit_0:
        LDR.N    R0,??DataTable32_1
        LDR.N    R1,??DataTable32_13
        LDRB     R1,[R1, #+0]
        LDRB     R0,[R1, R0]
        CMP      R0,#+0
        BEQ.N    ??Uart1_Transmit_3
// 2366     	return FALSE;
        MOVS     R0,#+0
        B.N      ??Uart1_Transmit_2
// 2367     
// 2368     /* Room for one more */
// 2369     
// 2370     /* Handle the case when a previous message was transmitted but the callback was not yet executed. 
// 2371      * The buffer length of the new message must be stored before executing the callback because
// 2372      * the transmit function (this function) can be called again from that callback */
// 2373       
// 2374     maSci1TxBufLenTable[mSci1TxBufRefLeadingIndex] = bufLen;
??Uart1_Transmit_3:
        LDR.N    R0,??DataTable32_1
        LDR.N    R1,??DataTable32_13
        LDRB     R1,[R1, #+0]
        STRB     R5,[R1, R0]
// 2375     
// 2376     if(maSci1TxBufRefTable[mSci1TxBufRefLeadingIndex].pfCallBack)
        LDR.N    R0,??DataTable32_2
        LDR.N    R1,??DataTable32_13
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+3
        LDR      R0,[R0, #+4]
        CMP      R0,#+0
        BEQ.N    ??Uart1_Transmit_4
// 2377     	maSci1TxBufRefTable[mSci1TxBufRefLeadingIndex].pfCallBack(maSci1TxBufRefTable[mSci1TxBufRefLeadingIndex].pBuf);
        LDR.N    R0,??DataTable32_2
        LDR.N    R1,??DataTable32_13
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.N    R1,??DataTable32_2
        LDR.N    R2,??DataTable32_13
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #+4]
        BLX      R1
// 2378 
// 2379     /* store the new message to be transmitted */
// 2380     maSci1TxBufRefTable[mSci1TxBufRefLeadingIndex].pBuf = pBuf;
??Uart1_Transmit_4:
        LDR.N    R0,??DataTable32_2
        LDR.N    R1,??DataTable32_13
        LDRB     R1,[R1, #+0]
        STR      R4,[R0, R1, LSL #+3]
// 2381     maSci1TxBufRefTable[mSci1TxBufRefLeadingIndex].pfCallBack = pfCallBack;     
        LDR.N    R0,??DataTable32_2
        LDR.N    R1,??DataTable32_13
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+3
        STR      R6,[R0, #+4]
// 2382     
// 2383     if (++mSci1TxBufRefLeadingIndex >= NumberOfElements(maSci1TxBufRefTable)) 
        LDR.N    R0,??DataTable32_13
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR.N    R1,??DataTable32_13
        STRB     R0,[R1, #+0]
        LDR.N    R0,??DataTable32_13
        LDRB     R0,[R0, #+0]
        CMP      R0,#+3
        BCC.N    ??Uart1_Transmit_5
// 2384     {
// 2385     	mSci1TxBufRefLeadingIndex = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable32_13
        STRB     R0,[R1, #+0]
// 2386     }
// 2387 
// 2388     /* Set the write ongoing flag */
// 2389     mUartModule[gUart1_c].UartWriteOnGoing = TRUE;
??Uart1_Transmit_5:
        LDR.N    R0,??DataTable32
        LDR      R0,[R0, #+52]
        ORRS     R0,R0,#0x2
        LDR.N    R1,??DataTable32
        STR      R0,[R1, #+52]
// 2390     
// 2391     /* 
// 2392      * Enable the transmit interrupt. 
// 2393      * Harmless if the interrupt is already enabled. 
// 2394      */
// 2395     mUartModule[gUart1_c].UartRegs->C2 |= gUART_TIE_BIT_c;
        LDR.N    R0,??DataTable32
        LDR      R0,[R0, #+56]
        LDRB     R0,[R0, #+3]
        ORRS     R0,R0,#0x40
        LDR.N    R1,??DataTable32
        LDR      R1,[R1, #+56]
        STRB     R0,[R1, #+3]
// 2396            
// 2397     return TRUE;
        MOVS     R0,#+1
??Uart1_Transmit_2:
        POP      {R4-R6,PC}       ;; return
// 2398 #endif /* gUart1_Enabled_d */
// 2399 }
// 2400 
// 2401 /******************************************************************************
// 2402  * Name: Uart2_Transmit
// 2403  * Description: Transmit bufLen bytes of data from pBuffer over UART_2 port. 
// 2404  *              It calls *pfCallBack() when the entire buffer has been sent. 
// 2405  *              Returns FALSE if there are no more available Tx buffer slots, 
// 2406  *              TRUE otherwise. The caller must ensure that the buffer remains
// 2407  *              available until the call back function is called.
// 2408  *              pfCallBack must not be NULL.
// 2409  *              The callback function will be called in interrupt context, 
// 2410  *              so it should be kept very short.
// 2411  * Parameters: [IN] pBuf - pointer to the buffer to be transmitted
// 2412  *             [IN] bufLen - buffer length
// 2413  *             [IN] pfCallBack - pointer to the callback function
// 2414  * Return: Returns FALSE if there are no more slots in the buffer reference 
// 2415  *         table
// 2416  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2417 bool_t Uart2_Transmit
// 2418 (
// 2419     unsigned char const *pBuf, 
// 2420     index_t bufLen, 
// 2421     void (*pfCallBack)(unsigned char const *pBuf)
// 2422 )
// 2423 {
Uart2_Transmit:
        MOVS     R3,R0
// 2424 #if (gUart2_Enabled_d == FALSE)
// 2425     (void) pBuf;
// 2426     (void) bufLen;
// 2427     (void) pfCallBack;
// 2428     return FALSE;
        MOVS     R0,#+0
        BX       LR               ;; return
// 2429 #else
// 2430 
// 2431     /* Handle empty buffers */
// 2432     if (!bufLen) 
// 2433     {
// 2434     	if(pfCallBack)    	
// 2435     		(*pfCallBack)(pBuf);
// 2436     		
// 2437     	return TRUE;
// 2438     }
// 2439     
// 2440     if (maSci2TxBufLenTable[mSci2TxBufRefLeadingIndex])
// 2441     	return FALSE;
// 2442     
// 2443     /* Room for one more */
// 2444     
// 2445     /* Handle the case when a previous message was transmitted but the callback was not yet executed. 
// 2446      * The buffer length of the new message must be stored before executing the callback because
// 2447      * the transmit function (this function) can be called again from that callback */
// 2448     
// 2449     maSci2TxBufLenTable[mSci2TxBufRefLeadingIndex] = bufLen;
// 2450         
// 2451     if(maSci2TxBufRefTable[mSci2TxBufRefLeadingIndex].pfCallBack)
// 2452     	maSci2TxBufRefTable[mSci2TxBufRefLeadingIndex].pfCallBack(maSci2TxBufRefTable[mSci2TxBufRefLeadingIndex].pBuf);
// 2453 
// 2454     /* store the new message to be transmitted */
// 2455     maSci2TxBufRefTable[mSci2TxBufRefLeadingIndex].pBuf = pBuf;
// 2456     maSci2TxBufRefTable[mSci2TxBufRefLeadingIndex].pfCallBack = pfCallBack;     
// 2457     
// 2458 
// 2459     if (++mSci2TxBufRefLeadingIndex >= NumberOfElements(maSci2TxBufRefTable)) 
// 2460     {
// 2461     	mSci2TxBufRefLeadingIndex = 0;
// 2462     }
// 2463 
// 2464     /* Set the write ongoing flag */
// 2465     mUartModule[gUart2_c].UartWriteOnGoing = TRUE;
// 2466 
// 2467     /* 
// 2468      * Enable the transmit interrupt. 
// 2469      * Harmless if the interrupt is already enabled. 
// 2470      */
// 2471     mUartModule[gUart2_c].UartRegs->C2 |= gUART_TIE_BIT_c; 
// 2472    
// 2473     return TRUE;
// 2474 #endif  /* gUart2_Enabled_d */
// 2475 }                                      
// 2476 
// 2477 /******************************************************************************
// 2478  * Name: Uart1_UngetByte
// 2479  * Description: Unget a byte: store the byte so that it will be returned by 
// 2480  *              the next call to the get byte function. 
// 2481  *              Also call the Rx callback
// 2482  * Parameters: [IN] byte - the byte to be stored
// 2483  * Return: -
// 2484  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2485 void Uart1_UngetByte
// 2486 (
// 2487     unsigned char byte
// 2488 ) 
// 2489 {
Uart1_UngetByte:
        PUSH     {R4,LR}
        MOVS     R4,R0
// 2490 #if (gUart1_Enabled_d == FALSE)
// 2491     (void) byte;
// 2492 #else
// 2493     uart1_ungetFlag = TRUE;
        MOVS     R0,#+1
        LDR.N    R1,??DataTable32_9
        STRB     R0,[R1, #+0]
// 2494     uart1_ungetByte = byte;
        LDR.N    R0,??DataTable32_10
        STRB     R4,[R0, #+0]
// 2495 
// 2496     /* Likewise, it is the caller's responsibility to not call this function */
// 2497     /* if the callback pointer is not valid. */
// 2498     if(pfSci1RxCallBack != NULL)
        LDR.N    R0,??DataTable32_12
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??Uart1_UngetByte_0
// 2499     {  
// 2500         pfSci1RxCallBack();
        LDR.N    R0,??DataTable32_12
        LDR      R0,[R0, #+0]
        BLX      R0
// 2501     } 
// 2502 #endif /* gUart1_Enabled_d */
// 2503 }
??Uart1_UngetByte_0:
        POP      {R4,PC}          ;; return
// 2504 
// 2505 
// 2506 /******************************************************************************
// 2507  * Name: Uart2_UngetByte
// 2508  * Description: Unget a byte: store the byte so that it will be returned by 
// 2509  *              the next call to the get byte function. 
// 2510  *              Also call the Rx callback
// 2511  * Parameters: [IN] byte - the byte to be stored
// 2512  * Return: -
// 2513  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2514 void Uart2_UngetByte
// 2515 (
// 2516     unsigned char byte
// 2517 ) 
// 2518 {
// 2519 #if (gUart2_Enabled_d == FALSE)
// 2520     (void) byte;
// 2521 #else
// 2522     uart2_ungetFlag = TRUE;
// 2523     uart2_ungetByte = byte;
// 2524 
// 2525     /* Likewise, it is the caller's responsibility to not call this function */
// 2526     /* if the callback pointer is not valid. */
// 2527     if(pfSci2RxCallBack != NULL)
// 2528     {  
// 2529         pfSci2RxCallBack();
// 2530     } 
// 2531 #endif  /* gUart2_Enabled_d */
// 2532 }
Uart2_UngetByte:
        BX       LR               ;; return
// 2533 
// 2534 /******************************************************************************
// 2535  * Name: Uart1_RxBufferByteCount
// 2536  * Description: Return unread bytes number from UART_1 buffer
// 2537  * Parameters: -
// 2538  * Return: the number of unread bytes 
// 2539  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2540 uint32_t Uart1_RxBufferByteCount
// 2541 (
// 2542     void
// 2543 ) 
// 2544 {
// 2545     return mUartModule[gUart1_c].UartUnreadBytesNumber;
Uart1_RxBufferByteCount:
        LDR.N    R0,??DataTable32
        LDR      R0,[R0, #+96]
        BX       LR               ;; return
// 2546 }
// 2547 
// 2548 /******************************************************************************
// 2549  * Name: Uart2_RxBufferByteCount
// 2550  * Description: Return unread bytes number from UART_2 buffer
// 2551  * Parameters: -
// 2552  * Return: the number of unread bytes 
// 2553  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2554 uint32_t Uart2_RxBufferByteCount
// 2555 (
// 2556     void
// 2557 ) 
// 2558 {
// 2559     	return mUartModule[gUart2_c].UartUnreadBytesNumber;
Uart2_RxBufferByteCount:
        LDR.N    R0,??DataTable32
        LDR      R0,[R0, #+148]
        BX       LR               ;; return
// 2560 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable28:
        DC32     0x186a0
// 2561 
// 2562 /******************************************************************************
// 2563  * Name: Uart1Isr
// 2564  * Description: UART_1 Interrupt Service Routine
// 2565  * Parameters: -
// 2566  * Return: -
// 2567  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2568 void Uart1Isr
// 2569 (
// 2570     void
// 2571 )
// 2572 {
Uart1Isr:
        PUSH     {R7,LR}
// 2573      /* Store the status register in an internal variable, because a read of this register clears all the error and interrupt flags */
// 2574     mUartModule[gUart1_c].UartUstatRegister1 = mUartModule[gUart1_c].UartRegs->S1;
        LDR.N    R0,??DataTable32
        LDR      R0,[R0, #+56]
        LDRB     R0,[R0, #+4]
        LDR.N    R1,??DataTable32
        STR      R0,[R1, #+76]
// 2575     mUartModule[gUart1_c].UartUstatRegister2 = mUartModule[gUart1_c].UartRegs->S2;
        LDR.N    R0,??DataTable32
        LDR      R0,[R0, #+56]
        LDRB     R0,[R0, #+5]
        LDR.N    R1,??DataTable32
        STR      R0,[R1, #+80]
// 2576     if( (mUartModule[gUart1_c].UartUstatRegister2 & UART_S2_RXEDGIF_MASK) &&
// 2577         (mUartModule[gUart1_c].UartRegs->BDH & UART_BDH_RXEDGIE_MASK) )
        LDR.N    R0,??DataTable32
        LDRB     R0,[R0, #+80]
        LSLS     R0,R0,#+25
        BPL.N    ??Uart1Isr_0
        LDR.N    R0,??DataTable32
        LDR      R0,[R0, #+56]
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+25
        BPL.N    ??Uart1Isr_0
// 2578     {
// 2579       mUartModule[gUart1_c].UartRegs->S2 |= UART_S2_RXEDGIF_MASK;
        LDR.N    R0,??DataTable32
        LDR      R0,[R0, #+56]
        LDRB     R0,[R0, #+5]
        ORRS     R0,R0,#0x40
        LDR.N    R1,??DataTable32
        LDR      R1,[R1, #+56]
        STRB     R0,[R1, #+5]
// 2580     }
// 2581 
// 2582     /*If Rx module is enabled and Rx interrupt pending flag is set and Rx interrupt is enabled */
// 2583     if((mUartModule[gUart1_c].UartRegs->C2 & gUART_RX_EN_BIT_c) &&
// 2584             (mUartModule[gUart1_c].UartUstatRegister1 & gUART_RX_INT_BIT_c)  && 
// 2585             (mUartModule[gUart1_c].UartRegs->C2 & gUART_RIE_BIT_c))
??Uart1Isr_0:
        LDR.N    R0,??DataTable32
        LDR      R0,[R0, #+56]
        LDRB     R0,[R0, #+3]
        LSLS     R0,R0,#+29
        BPL.N    ??Uart1Isr_1
        LDR.N    R0,??DataTable32
        LDRB     R0,[R0, #+76]
        LSLS     R0,R0,#+26
        BPL.N    ??Uart1Isr_1
        LDR.N    R0,??DataTable32
        LDR      R0,[R0, #+56]
        LDRB     R0,[R0, #+3]
        LSLS     R0,R0,#+26
        BPL.N    ??Uart1Isr_1
// 2586     {
// 2587         UartReceiverIsr(gUart1_c);
        MOVS     R0,#+1
        BL       UartReceiverIsr
// 2588     }
// 2589     /*If Tx module is enabled and Tx interrupt pending flag is set and Tx interrupt is enabled */
// 2590     if((mUartModule[gUart1_c].UartRegs->C2 & gUART_TX_EN_BIT_c) &&
// 2591             (mUartModule[gUart1_c].UartUstatRegister1 & gUART_TX_INT_BIT_c)  &&
// 2592             (mUartModule[gUart1_c].UartRegs->C2 & gUART_TIE_BIT_c))
??Uart1Isr_1:
        LDR.N    R0,??DataTable32
        LDR      R0,[R0, #+56]
        LDRB     R0,[R0, #+3]
        LSLS     R0,R0,#+28
        BPL.N    ??Uart1Isr_2
        LDR.N    R0,??DataTable32
        LDRB     R0,[R0, #+76]
        LSLS     R0,R0,#+24
        BPL.N    ??Uart1Isr_2
        LDR.N    R0,??DataTable32
        LDR      R0,[R0, #+56]
        LDRB     R0,[R0, #+3]
        LSLS     R0,R0,#+25
        BPL.N    ??Uart1Isr_2
// 2593     {
// 2594         UartTransmitterIsr(gUart1_c);
        MOVS     R0,#+1
        BL       UartTransmitterIsr
// 2595     }
// 2596 }
??Uart1Isr_2:
        POP      {R0,PC}          ;; return
// 2597 
// 2598 /******************************************************************************
// 2599  * Name: Uart2Isr
// 2600  * Description: UART_2 Interrupt Service Routine
// 2601  * Parameters: -
// 2602  * Return: -
// 2603  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2604 void Uart2Isr
// 2605 (
// 2606     void
// 2607 )
// 2608 {
Uart2Isr:
        PUSH     {R7,LR}
// 2609      /* Store the status register in an internal variable, because a read of this register clears all the error and interrupt flags */
// 2610     mUartModule[gUart2_c].UartUstatRegister1 = mUartModule[gUart2_c].UartRegs->S1;
        LDR.N    R0,??DataTable32
        LDR      R0,[R0, #+108]
        LDRB     R0,[R0, #+4]
        LDR.N    R1,??DataTable32
        STR      R0,[R1, #+128]
// 2611     mUartModule[gUart2_c].UartUstatRegister2 = mUartModule[gUart2_c].UartRegs->S2;
        LDR.N    R0,??DataTable32
        LDR      R0,[R0, #+108]
        LDRB     R0,[R0, #+5]
        LDR.N    R1,??DataTable32
        STR      R0,[R1, #+132]
// 2612     if( (mUartModule[gUart2_c].UartUstatRegister2 & UART_S2_RXEDGIF_MASK) &&
// 2613         (mUartModule[gUart2_c].UartRegs->BDH & UART_BDH_RXEDGIE_MASK) )
        LDR.N    R0,??DataTable32
        LDRB     R0,[R0, #+132]
        LSLS     R0,R0,#+25
        BPL.N    ??Uart2Isr_0
        LDR.N    R0,??DataTable32
        LDR      R0,[R0, #+108]
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+25
        BPL.N    ??Uart2Isr_0
// 2614     {
// 2615       mUartModule[gUart2_c].UartRegs->S2 |= UART_S2_RXEDGIF_MASK;
        LDR.N    R0,??DataTable32
        LDR      R0,[R0, #+108]
        LDRB     R0,[R0, #+5]
        ORRS     R0,R0,#0x40
        LDR.N    R1,??DataTable32
        LDR      R1,[R1, #+108]
        STRB     R0,[R1, #+5]
// 2616     }
// 2617 
// 2618     /* If Rx module is enabled and Rx interrupt pending flag is set and Rx interrupt is enabled */
// 2619     if((mUartModule[gUart2_c].UartRegs->C2 & gUART_RX_EN_BIT_c) &&
// 2620             (mUartModule[gUart2_c].UartUstatRegister1 & gUART_RX_INT_BIT_c) && 
// 2621             (mUartModule[gUart2_c].UartRegs->C2 & gUART_RIE_BIT_c))
??Uart2Isr_0:
        LDR.N    R0,??DataTable32
        LDR      R0,[R0, #+108]
        LDRB     R0,[R0, #+3]
        LSLS     R0,R0,#+29
        BPL.N    ??Uart2Isr_1
        LDR.N    R0,??DataTable32
        LDRB     R0,[R0, #+128]
        LSLS     R0,R0,#+26
        BPL.N    ??Uart2Isr_1
        LDR.N    R0,??DataTable32
        LDR      R0,[R0, #+108]
        LDRB     R0,[R0, #+3]
        LSLS     R0,R0,#+26
        BPL.N    ??Uart2Isr_1
// 2622     {                    
// 2623         UartReceiverIsr(gUart2_c);
        MOVS     R0,#+2
        BL       UartReceiverIsr
// 2624     }
// 2625     /* If Tx module is enabled and Tx interrupt pending flag is set and Tx interrupt is enabled*/
// 2626     if((mUartModule[gUart2_c].UartRegs->C2 & gUART_TX_EN_BIT_c) &&
// 2627             (mUartModule[gUart2_c].UartUstatRegister1 & gUART_TX_INT_BIT_c) &&
// 2628             (mUartModule[gUart2_c].UartRegs->C2 & gUART_TIE_BIT_c))
??Uart2Isr_1:
        LDR.N    R0,??DataTable32
        LDR      R0,[R0, #+108]
        LDRB     R0,[R0, #+3]
        LSLS     R0,R0,#+28
        BPL.N    ??Uart2Isr_2
        LDR.N    R0,??DataTable32
        LDRB     R0,[R0, #+128]
        LSLS     R0,R0,#+24
        BPL.N    ??Uart2Isr_2
        LDR.N    R0,??DataTable32
        LDR      R0,[R0, #+108]
        LDRB     R0,[R0, #+3]
        LSLS     R0,R0,#+25
        BPL.N    ??Uart2Isr_2
// 2629     {
// 2630         UartTransmitterIsr(gUart2_c);
        MOVS     R0,#+2
        BL       UartTransmitterIsr
// 2631     }
// 2632 }
??Uart2Isr_2:
        POP      {R0,PC}          ;; return
// 2633 
// 2634 /******************************************************************************
// 2635  * Name: Uart1ErrorIsr
// 2636  * Description: Clear enabled UART_1 errors
// 2637  * Parameters: -
// 2638  * Return: -
// 2639  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2640 void Uart1ErrorIsr
// 2641 (
// 2642     void
// 2643 ) 
// 2644 {
// 2645 	/* Since the flag checking mechanism will clear any flags in a register
// 2646 	 * that are set, we have to save the value of the status register
// 2647 	 * and then check against the saved value to be able to detect all of
// 2648 	 * the flags that were set (if you read the status register over and 
// 2649 	 * over again, then you'll only capture the first one that was set.
// 2650 	 */
// 2651 
// 2652 	uint8_t status, dummy;
// 2653 
// 2654 	status = mUartModule[gUart1_c].UartRegs->S1;
Uart1ErrorIsr:
        LDR.N    R2,??DataTable32
        LDR      R2,[R2, #+56]
        LDRB     R2,[R2, #+4]
        MOVS     R0,R2
// 2655 
// 2656 	if(status & (gUART_PARITY_ERROR_FLAG_c | gUART_FRAME_ERROR_FLAG_c | gUART_NOISE_FLAG_c | gUART_OVERRUN_FLAG_c))
        MOVS     R2,#+15
        TST      R0,R2
        BEQ.N    ??Uart1ErrorIsr_0
// 2657 	{
// 2658 		/* dummy read to clear UART errors */
// 2659 		dummy = mUartModule[gUart1_c].UartRegs->D;
        LDR.N    R2,??DataTable32
        LDR      R2,[R2, #+56]
        LDRB     R2,[R2, #+7]
        MOVS     R1,R2
// 2660 	}
// 2661 
// 2662 	if (mUartModule[gUart1_c].UartRegs->SFIFO & (UART_SFIFO_TXOF_MASK))
??Uart1ErrorIsr_0:
        LDR.N    R2,??DataTable32
        LDR      R2,[R2, #+56]
        LDRB     R2,[R2, #+18]
        LSLS     R2,R2,#+30
        BPL.N    ??Uart1ErrorIsr_1
// 2663 	{
// 2664 		mUartModule[gUart1_c].UartRegs->SFIFO |= UART_SFIFO_TXOF_MASK;
        LDR.N    R2,??DataTable32
        LDR      R2,[R2, #+56]
        LDRB     R2,[R2, #+18]
        ORRS     R2,R2,#0x2
        LDR.N    R3,??DataTable32
        LDR      R3,[R3, #+56]
        STRB     R2,[R3, #+18]
// 2665 	}
// 2666 
// 2667 	if (mUartModule[gUart1_c].UartRegs->SFIFO & (UART_SFIFO_RXUF_MASK))
??Uart1ErrorIsr_1:
        LDR.N    R2,??DataTable32
        LDR      R2,[R2, #+56]
        LDRB     R2,[R2, #+18]
        LSLS     R2,R2,#+31
        BPL.N    ??Uart1ErrorIsr_2
// 2668 	{    	
// 2669 		mUartModule[gUart1_c].UartRegs->SFIFO |= UART_SFIFO_RXUF_MASK;    	
        LDR.N    R2,??DataTable32
        LDR      R2,[R2, #+56]
        LDRB     R2,[R2, #+18]
        ORRS     R2,R2,#0x1
        LDR.N    R3,??DataTable32
        LDR      R3,[R3, #+56]
        STRB     R2,[R3, #+18]
// 2670 	}
// 2671 	
// 2672 #if gUART_USE_RX_FIFO_d     
// 2673     /* flush the RX FIFO */
// 2674     mUartModule[gUart1_c].UartRegs->CFIFO |= gUART_RX_FIFO_FLUSH_c;  
??Uart1ErrorIsr_2:
        LDR.N    R2,??DataTable32
        LDR      R2,[R2, #+56]
        LDRB     R2,[R2, #+17]
        ORRS     R2,R2,#0x40
        LDR.N    R3,??DataTable32
        LDR      R3,[R3, #+56]
        STRB     R2,[R3, #+17]
// 2675 #endif
// 2676     
// 2677 #if gUART_USE_TX_FIFO_d     
// 2678     /* flush the TX FIFO */
// 2679     mUartModule[gUart1_c].UartRegs->CFIFO |= gUART_TX_FIFO_FLUSH_c;  
        LDR.N    R2,??DataTable32
        LDR      R2,[R2, #+56]
        LDRB     R2,[R2, #+17]
        ORRS     R2,R2,#0x80
        LDR.N    R3,??DataTable32
        LDR      R3,[R3, #+56]
        STRB     R2,[R3, #+17]
// 2680 #endif
// 2681         
// 2682     (void)dummy;
// 2683 }
        BX       LR               ;; return
// 2684 
// 2685 /******************************************************************************
// 2686  * Name: Uart2ErrorIsr
// 2687  * Description: Clear enabled UART_2 errors
// 2688  * Parameters: -
// 2689  * Return: -
// 2690  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2691 void Uart2ErrorIsr
// 2692 (
// 2693     void
// 2694 ) 
// 2695 {	
// 2696 	/* Since the flag checking mechanism will clear any flags in a register
// 2697 	 * that are set, we have to save the value of the status register
// 2698 	 * and then check against the saved value to be able to detect all of
// 2699 	 * the flags that were set (if you read the status register over and 
// 2700 	 * over again, then you'll only capture the first one that was set.
// 2701 	 */
// 2702     
// 2703 	uint8_t status, dummy;
// 2704 
// 2705     status = mUartModule[gUart2_c].UartRegs->S1;
Uart2ErrorIsr:
        LDR.N    R2,??DataTable32
        LDR      R2,[R2, #+108]
        LDRB     R2,[R2, #+4]
        MOVS     R0,R2
// 2706    
// 2707     if(status & (gUART_PARITY_ERROR_FLAG_c | gUART_FRAME_ERROR_FLAG_c | gUART_NOISE_FLAG_c | gUART_OVERRUN_FLAG_c))
        MOVS     R2,#+15
        TST      R0,R2
        BEQ.N    ??Uart2ErrorIsr_0
// 2708     {
// 2709         /* dummy read to clear UART errors */
// 2710     	dummy = mUartModule[gUart2_c].UartRegs->D;
        LDR.N    R2,??DataTable32
        LDR      R2,[R2, #+108]
        LDRB     R2,[R2, #+7]
        MOVS     R1,R2
// 2711     }
// 2712             
// 2713     if (mUartModule[gUart2_c].UartRegs->SFIFO & (UART_SFIFO_TXOF_MASK))
??Uart2ErrorIsr_0:
        LDR.N    R2,??DataTable32
        LDR      R2,[R2, #+108]
        LDRB     R2,[R2, #+18]
        LSLS     R2,R2,#+30
        BPL.N    ??Uart2ErrorIsr_1
// 2714     {
// 2715     	mUartModule[gUart2_c].UartRegs->SFIFO |= UART_SFIFO_TXOF_MASK;
        LDR.N    R2,??DataTable32
        LDR      R2,[R2, #+108]
        LDRB     R2,[R2, #+18]
        ORRS     R2,R2,#0x2
        LDR.N    R3,??DataTable32
        LDR      R3,[R3, #+108]
        STRB     R2,[R3, #+18]
// 2716     }
// 2717     
// 2718     if (mUartModule[gUart2_c].UartRegs->SFIFO & (UART_SFIFO_RXUF_MASK))
??Uart2ErrorIsr_1:
        LDR.N    R2,??DataTable32
        LDR      R2,[R2, #+108]
        LDRB     R2,[R2, #+18]
        LSLS     R2,R2,#+31
        BPL.N    ??Uart2ErrorIsr_2
// 2719     {    	
// 2720     	mUartModule[gUart2_c].UartRegs->SFIFO |= UART_SFIFO_RXUF_MASK;    	
        LDR.N    R2,??DataTable32
        LDR      R2,[R2, #+108]
        LDRB     R2,[R2, #+18]
        ORRS     R2,R2,#0x1
        LDR.N    R3,??DataTable32
        LDR      R3,[R3, #+108]
        STRB     R2,[R3, #+18]
// 2721     }
// 2722     
// 2723 #if gUART_USE_RX_FIFO_d     
// 2724     /* flush the RX FIFO */
// 2725     mUartModule[gUart2_c].UartRegs->CFIFO |= gUART_RX_FIFO_FLUSH_c;  
??Uart2ErrorIsr_2:
        LDR.N    R2,??DataTable32
        LDR      R2,[R2, #+108]
        LDRB     R2,[R2, #+17]
        ORRS     R2,R2,#0x40
        LDR.N    R3,??DataTable32
        LDR      R3,[R3, #+108]
        STRB     R2,[R3, #+17]
// 2726 #endif
// 2727     
// 2728 #if gUART_USE_TX_FIFO_d     
// 2729     /* flush the TX FIFO */
// 2730     mUartModule[gUart2_c].UartRegs->CFIFO |= gUART_TX_FIFO_FLUSH_c;  
        LDR.N    R2,??DataTable32
        LDR      R2,[R2, #+108]
        LDRB     R2,[R2, #+17]
        ORRS     R2,R2,#0x80
        LDR.N    R3,??DataTable32
        LDR      R3,[R3, #+108]
        STRB     R2,[R3, #+17]
// 2731 #endif
// 2732     
// 2733     (void)dummy;
// 2734 }
        BX       LR               ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32:
        DC32     mUartModule

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_1:
        DC32     maSci1TxBufLenTable

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_2:
        DC32     maSci1TxBufRefTable

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_3:
        DC32     UartBaseAddress_c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_4:
        DC32     0x40048034

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_5:
        DC32     0x40048038

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_6:
        DC32     0x4004d004

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_7:
        DC32     0x4004d000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_8:
        DC32     maSci1RxBuf

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_9:
        DC32     uart1_ungetFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_10:
        DC32     uart1_ungetByte

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_11:
        DC32     mSci1TxBufRefTrailingIndex

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_12:
        DC32     pfSci1RxCallBack

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_13:
        DC32     mSci1TxBufRefLeadingIndex

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        END
// 2735 
// 2736 #endif /* gUart1_Enabled_d || gUart2_Enabled_d */
// 
//   497 bytes in section .bss
//    16 bytes in section .rodata
// 5 984 bytes in section .text
// 
// 5 984 bytes of CODE  memory
//    16 bytes of CONST memory
//   497 bytes of DATA  memory
//
//Errors: none
//Warnings: none
