///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM       02/Sep/2018  14:19:42
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\Common\USB.c
//    Command line =  
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\Common\USB.c" -D IAR --preprocess "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\List\" -lC "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\List\" -lB "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\List\" --diag_suppress
//        Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\Obj\" --no_cse --no_unroll
//        --no_inline --no_code_motion --no_tbaa --no_clustering
//        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\APP\CDC\" -I "F:\Guardrail Work\Sensor Code\Git
//        Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\USB\APP\Descriptor\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Class\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Sys Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
//    List file    =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\USB.s
//
///////////////////////////////////////////////////////////////////////////////

        #define SHT_PROGBITS 0x1

        EXTERN IntDisableAll
        EXTERN IntRestoreAll
        EXTERN MemorySet
        EXTERN USB_Class_CDC_DeInit
        EXTERN USB_Class_CDC_Init
        EXTERN USB_SIM_Settings
        EXTERN USB_SIM_UsbIntDisable
        EXTERN USB_SIM_UsbIntEnable
        EXTERN UsbMsgQueue_GetFirstMsg
        EXTERN UsbMsgQueue_Init
        EXTERN UsbMsgQueue_MsgPending
        EXTERN UsbMsgQueue_Pop
        EXTERN UsbMsgQueue_Push

        PUBLIC USB_AddController
        PUBLIC USB_GetFirstAvailableController
        PUBLIC USB_Init
        PUBLIC USB_IsDeviceConnected
        PUBLIC USB_IsrEvent
        PUBLIC USB_Lock
        PUBLIC USB_RemoveController
        PUBLIC USB_UnLock
        PUBLIC gpaUsbClassDescriptor
        PUBLIC gpfClassFrameworkCallback

// F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\USB.c
//    1 /************************************************************************************
//    2 * Source file of the application specific utility services
//    3 *
//    4 * (c) Copyright 2010, Freescale, Inc. All rights reserved.
//    5 *
//    6 *
//    7 * No part of this document must be reproduced in any form - including copied,
//    8 * transcribed, printed or by any electronic means - without specific written
//    9 * permission from Freescale Semiconductor.
//   10 *
//   11 *****************************************************************************/
//   12 
//   13 #include "EmbeddedTypes.h"
//   14 #include "USB_Class.h"
//   15 #include "USB_Interface.h"
//   16 #include "USB_Configuration.h"
//   17 #include "USB_Framework.h"
//   18 #include "Utilities_Interface.h"
//   19 #include "USB.h"
//   20 #include "Interrupt.h"
//   21 #if gUsbHidEnabled_d
//   22 #include "usb_hid.h"
//   23 #endif
//   24 #if(gUsbCdcEnabled_d == TRUE)
//   25 #include "usb_cdc.h"    /* USB CDC Class Header File */
//   26 #endif
//   27 #include "UsbMsgQueue.h"
//   28 #include "usb_sim_settings.h"
//   29 #if gUsbIncluded_d
//   30 /******************************************************************************
//   31 *******************************************************************************
//   32 * Private macros
//   33 *******************************************************************************
//   34 ******************************************************************************/
//   35 /* Events for USB task */
//   36 #define gUsbIrqEvent_c  (1<<0)
//   37 
//   38 
//   39 /******************************************************************************
//   40 *******************************************************************************
//   41 * Private prototypes
//   42 *******************************************************************************
//   43 ******************************************************************************/
//   44 static usbError_t USB_AddControllerUnprotected( const usbClassDescriptor_t* pUsbClassDescriptor, uint8_t controllerId);
//   45 static usbError_t USB_RemoveControllerUnprotected(uint8_t controllerId);
//   46 
//   47 /******************************************************************************
//   48 *******************************************************************************
//   49 * Private type definitions
//   50 *******************************************************************************
//   51 ******************************************************************************/
//   52 
//   53 
//   54 /******************************************************************************
//   55 *******************************************************************************
//   56 * Private memory declarations
//   57 *******************************************************************************
//   58 ******************************************************************************/
//   59 /* Queue storing pending events from the USB ISR handler */

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   60 static uint8_t gUsbLockLevel = 0;
gUsbLockLevel:
        DS8 1
//   61 
//   62 /******************************************************************************
//   63 *******************************************************************************
//   64 * Public memory declarations
//   65 *******************************************************************************
//   66 ******************************************************************************/
//   67 /* Id for USB task */
//   68 //tsTaskID_t gUsbTaskId; //@SMAC

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   69 const usbClassDescriptor_t* gpaUsbClassDescriptor[gNumUsbControllers_d];
gpaUsbClassDescriptor:
        DS8 4
//   70 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   71 pfUsbToAppEventHandler_t gpfClassFrameworkCallback = NULL;
gpfClassFrameworkCallback:
        DS8 4
//   72 
//   73 /******************************************************************************
//   74 *******************************************************************************
//   75 * Public functions
//   76 *******************************************************************************
//   77 ******************************************************************************/
//   78 static void USB_Task(void);
//   79 
//   80 /************************************************************************************
//   81 * Usb_Init - 
//   82 *   
//   83 * Return value:
//   84 *    
//   85 * 
//   86 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//   87 void USB_Init(void)
//   88 {
USB_Init:
        PUSH     {R7,LR}
//   89   USB_SIM_Settings(); 
        BL       USB_SIM_Settings
//   90   /* Create the USB task */
//   91   gUsbLockLevel = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable7
        STRB     R0,[R1, #+0]
//   92 //  gUsbTaskId = TS_CreateTask(gTsUsbTaskPriority_c, USB_Task); //@SMAC
//   93   /* Init the queue storing events from ISR routine */
//   94   UsbMsgQueue_Init();
        BL       UsbMsgQueue_Init
//   95   /* Clear the table storing the class descriptor of each USB controller */
//   96   MemorySet( gpaUsbClassDescriptor, 0, (uint16_t)sizeof(gpaUsbClassDescriptor));
        MOVS     R2,#+4
        MOVS     R1,#+0
        LDR.N    R0,??DataTable7_1
        BL       MemorySet
//   97  }
        POP      {R0,PC}          ;; return
//   98 
//   99 
//  100 /************************************************************************************
//  101 * USB_AddController - 
//  102 *   
//  103 * Return value:
//  104 *    
//  105 * 
//  106 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  107 usbError_t USB_AddController( const usbClassDescriptor_t* pUsbClassDescriptor, uint8_t controllerId)
//  108 {
USB_AddController:
        PUSH     {R3-R7,LR}
        MOVS     R4,R0
        MOVS     R5,R1
//  109   usbError_t  usbError;
//  110   uint32_t ccr;
//  111    //USB_Lock();
//  112   ccr = IntDisableAll();
        BL       IntDisableAll
        MOVS     R7,R0
//  113   usbError = USB_AddControllerUnprotected(pUsbClassDescriptor,controllerId); 
        MOVS     R1,R5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R4
        BL       USB_AddControllerUnprotected
        MOVS     R6,R0
//  114   // USB_UnLock();
//  115   IntRestoreAll(ccr);
        MOVS     R0,R7
        BL       IntRestoreAll
//  116   return usbError;
        MOVS     R0,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R1,R4-R7,PC}    ;; return
//  117 }
//  118 
//  119 
//  120 
//  121 
//  122 /************************************************************************************
//  123 * USB_RemoveController - 
//  124 *   
//  125 * Return value:
//  126 *    
//  127 * 
//  128 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  129 usbError_t USB_RemoveController(uint8_t controllerId) 
//  130 {
USB_RemoveController:
        PUSH     {R4-R6,LR}
        MOVS     R4,R0
//  131   usbError_t  usbError;
//  132   uint32_t ccr;
//  133   //USB_Lock();
//  134   ccr = IntDisableAll();
        BL       IntDisableAll
        MOVS     R6,R0
//  135   usbError = USB_RemoveControllerUnprotected(controllerId); 
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_RemoveControllerUnprotected
        MOVS     R5,R0
//  136   //USB_UnLock();
//  137   IntRestoreAll(ccr);
        MOVS     R0,R6
        BL       IntRestoreAll
//  138   return usbError;
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R4-R6,PC}       ;; return
//  139 }
//  140 
//  141 
//  142 
//  143 /************************************************************************************
//  144 * USB_GetFirstFreeController
//  145 *   
//  146 * Return value:
//  147 *    
//  148 * 
//  149 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  150 uint8_t USB_GetFirstAvailableController(void)
//  151 {
//  152   uint8_t ctrlNo;
//  153   uint8_t firstAvailableController = gUsbInvalidControllerNumber_d;
USB_GetFirstAvailableController:
        MOVS     R0,#+255
//  154   for(ctrlNo = 0 ; ctrlNo < gNumUsbControllers_d; ctrlNo++)
        MOVS     R2,#+0
        MOVS     R1,R2
??USB_GetFirstAvailableController_0:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.N    ??USB_GetFirstAvailableController_1
//  155   {
//  156     if(gpaUsbClassDescriptor[ctrlNo]  ==  NULL)    
        LDR.N    R2,??DataTable7_1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR      R2,[R2, R1, LSL #+2]
        CMP      R2,#+0
        BNE.N    ??USB_GetFirstAvailableController_2
//  157     {
//  158       firstAvailableController =  ctrlNo;
        MOVS     R0,R1
//  159       break;     
        B.N      ??USB_GetFirstAvailableController_1
//  160     }
//  161   }
??USB_GetFirstAvailableController_2:
        ADDS     R1,R1,#+1
        B.N      ??USB_GetFirstAvailableController_0
//  162   return firstAvailableController;    
??USB_GetFirstAvailableController_1:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BX       LR               ;; return
//  163 }
//  164 
//  165 
//  166 
//  167 /************************************************************************************
//  168 * USB_IsrEvent - 
//  169 *   
//  170 * Return value:
//  171 *    
//  172 * 
//  173 ************************************************************************************/
//  174 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  175 void USB_IsrEvent(usbMsg_t* pUsbMsg)
//  176 {
USB_IsrEvent:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
//  177   /* Add the event in the queue */
//  178   usbMsgQueueErr_t usbMsgQueueErr;
//  179   usbMsgQueueErr = UsbMsgQueue_Push(pUsbMsg);
        MOVS     R0,R4
        BL       UsbMsgQueue_Push
        MOVS     R5,R0
//  180   if(usbMsgQueueErr == usbMsgQueueErr_NoError)
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BNE.N    ??USB_IsrEvent_0
//  181   {
//  182     /* Send message to USB task to process the event */
//  183 //    TS_SendEvent(gUsbTaskId, gUsbIrqEvent_c);  //@SMAC
//  184     USB_Task();
        BL       USB_Task
//  185     
//  186   }
//  187   #ifdef gUSB_Debug_d 
//  188   else
//  189   {
//  190    // asm bgnd;
//  191     while(TRUE);
//  192   }
//  193   #endif  
//  194 }          
??USB_IsrEvent_0:
        POP      {R0,R4,R5,PC}    ;; return
//  195 
//  196 /************************************************************************************
//  197 * USB_IsDeviceConnected 
//  198 *   
//  199 * Return value:
//  200 *    
//  201 * 
//  202 ************************************************************************************/
//  203 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  204 bool_t USB_IsDeviceConnected(uint8_t controllerId)
//  205 {
USB_IsDeviceConnected:
        MOVS     R1,R0
//  206   if( controllerId  >=  gNumUsbControllers_d )
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BEQ.N    ??USB_IsDeviceConnected_0
//  207   {
//  208     return FALSE;
        MOVS     R0,#+0
        B.N      ??USB_IsDeviceConnected_1
//  209   }
//  210   if(gpaUsbClassDescriptor[controllerId] == NULL) 
??USB_IsDeviceConnected_0:
        LDR.N    R0,??DataTable7_1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR      R0,[R0, R1, LSL #+2]
        CMP      R0,#+0
        BNE.N    ??USB_IsDeviceConnected_2
//  211   {
//  212     return FALSE;     
        MOVS     R0,#+0
        B.N      ??USB_IsDeviceConnected_1
//  213   }
//  214   else
//  215   {
//  216     return TRUE;  
??USB_IsDeviceConnected_2:
        MOVS     R0,#+1
??USB_IsDeviceConnected_1:
        BX       LR               ;; return
//  217   }
//  218 }          
//  219 /************************************************************************************
//  220 * USB_Lock 
//  221 *   
//  222 * Return value:
//  223 *    
//  224 * 
//  225 ************************************************************************************/
//  226 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  227 void USB_Lock(void)
//  228 {
USB_Lock:
        PUSH     {R7,LR}
//  229   if(gUsbLockLevel==0)
        LDR.N    R0,??DataTable7
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??USB_Lock_0
//  230   {
//  231     USB_SIM_UsbIntDisable();
        BL       USB_SIM_UsbIntDisable
//  232   }
//  233   gUsbLockLevel++;
??USB_Lock_0:
        LDR.N    R0,??DataTable7
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR.N    R1,??DataTable7
        STRB     R0,[R1, #+0]
//  234 }
        POP      {R0,PC}          ;; return
//  235 /************************************************************************************
//  236 * USB_Unlock 
//  237 *   
//  238 * Return value:
//  239 *    
//  240 * 
//  241 ************************************************************************************/
//  242 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  243 void USB_UnLock(void)
//  244 {
USB_UnLock:
        PUSH     {R7,LR}
//  245   if(gUsbLockLevel)
        LDR.N    R0,??DataTable7
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??USB_UnLock_0
//  246   {
//  247     gUsbLockLevel--;
        LDR.N    R0,??DataTable7
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        LDR.N    R1,??DataTable7
        STRB     R0,[R1, #+0]
//  248     if(gUsbLockLevel == 0) 
        LDR.N    R0,??DataTable7
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??USB_UnLock_0
//  249     {
//  250       USB_SIM_UsbIntEnable();
        BL       USB_SIM_UsbIntEnable
//  251     }
//  252   }
//  253 }
??USB_UnLock_0:
        POP      {R0,PC}          ;; return
//  254 /******************************************************************************
//  255 *******************************************************************************
//  256 * Private functions
//  257 *******************************************************************************
//  258 *******************************************************************************/
//  259 
//  260 /************************************************************************************
//  261 * USB_AddControllerUnprotected - 
//  262 *   
//  263 * Return value:
//  264 *    
//  265 * 
//  266 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  267 static usbError_t USB_AddControllerUnprotected( const usbClassDescriptor_t* pUsbClassDescriptor, uint8_t controllerId)
//  268 {
USB_AddControllerUnprotected:
        PUSH     {R4-R6,LR}
        MOVS     R4,R0
        MOVS     R5,R1
//  269   usbError_t  usbError = gUsbErr_NoError_c;
        MOVS     R6,#+0
//  270   if( controllerId  >=  gNumUsbControllers_d )
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BEQ.N    ??USB_AddControllerUnprotected_0
//  271   {
//  272     return gUsbErr_InvalidParam_c ;
        MOVS     R0,#+208
        B.N      ??USB_AddControllerUnprotected_1
//  273   }
//  274   if( gpaUsbClassDescriptor[controllerId]  !=  NULL)
??USB_AddControllerUnprotected_0:
        LDR.N    R0,??DataTable7_1
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        LDR      R0,[R0, R5, LSL #+2]
        CMP      R0,#+0
        BEQ.N    ??USB_AddControllerUnprotected_2
//  275   {
//  276     return gUsbErr_InvalidParam_c ;
        MOVS     R0,#+208
        B.N      ??USB_AddControllerUnprotected_1
//  277   }
//  278   if(pUsbClassDescriptor == NULL)
??USB_AddControllerUnprotected_2:
        CMP      R4,#+0
        BNE.N    ??USB_AddControllerUnprotected_3
//  279   {
//  280     return gUsbErr_InvalidParam_c ;      
        MOVS     R0,#+208
        B.N      ??USB_AddControllerUnprotected_1
//  281   }
//  282   
//  283   switch(pUsbClassDescriptor->classId)
??USB_AddControllerUnprotected_3:
        LDRB     R0,[R4, #+0]
        CMP      R0,#+2
        BEQ.N    ??USB_AddControllerUnprotected_4
        CMP      R0,#+3
        BEQ.N    ??USB_AddControllerUnprotected_5
        B.N      ??USB_AddControllerUnprotected_6
//  284   {
//  285     case gUsbClassId_Cdc_c:
//  286     #if(gUsbCdcEnabled_d == FALSE)
//  287       return gUsbErr_InvalidParam_c ;
//  288     #else  
//  289       gpaUsbClassDescriptor[controllerId] = pUsbClassDescriptor;
??USB_AddControllerUnprotected_4:
        LDR.N    R0,??DataTable7_1
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        STR      R4,[R0, R5, LSL #+2]
//  290       usbError = USB_Class_CDC_Init(controllerId);                    
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_Class_CDC_Init
        MOVS     R6,R0
//  291     #endif
//  292     break;
//  293     
//  294     case gUsbClassId_Hid_c:
//  295     #if(gUsbHidEnabled_d == FALSE)
//  296       return gUsbErr_InvalidParam_c ;
//  297     #else
//  298       gpaUsbClassDescriptor[controllerId] = pUsbClassDescriptor;
//  299       usbError = USB_Class_HID_Init(controllerId);                    
//  300     #endif
//  301     break;
//  302       
//  303   default:
//  304     return gUsbErr_InvalidParam_c ;
//  305   }
//  306   /* Check that controller 0 is a HUB. If not, return error as a new controller can only be added
//  307   on a HUB */ 
//  308    if(gUsbErr_NoError_c != usbError)
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BNE.N    ??USB_AddControllerUnprotected_7
        B.N      ??USB_AddControllerUnprotected_8
??USB_AddControllerUnprotected_5:
        MOVS     R0,#+208
        B.N      ??USB_AddControllerUnprotected_1
??USB_AddControllerUnprotected_6:
        MOVS     R0,#+208
        B.N      ??USB_AddControllerUnprotected_1
//  309   {
//  310     gpaUsbClassDescriptor[controllerId]  =  NULL ;
??USB_AddControllerUnprotected_7:
        MOVS     R0,#+0
        LDR.N    R1,??DataTable7_1
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        STR      R0,[R1, R5, LSL #+2]
//  311   }
//  312 
//  313   return usbError;
??USB_AddControllerUnprotected_8:
        MOVS     R0,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
??USB_AddControllerUnprotected_1:
        POP      {R4-R6,PC}       ;; return
//  314 }
//  315 
//  316 
//  317 /************************************************************************************
//  318 * USB_RemoveControllerUnprotected - 
//  319 *   
//  320 * Return value:
//  321 *    
//  322 * 
//  323 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  324 static usbError_t USB_RemoveControllerUnprotected(uint8_t controllerId)
//  325 {
USB_RemoveControllerUnprotected:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
//  326   usbError_t  usbError = gUsbErr_NoError_c;
        MOVS     R5,#+0
//  327   
//  328   if( controllerId  >=  gNumUsbControllers_d )
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+0
        BEQ.N    ??USB_RemoveControllerUnprotected_0
//  329   {
//  330     return gUsbErr_InvalidParam_c ;
        MOVS     R0,#+208
        B.N      ??USB_RemoveControllerUnprotected_1
//  331   }
//  332   if( gpaUsbClassDescriptor[controllerId]  ==  NULL)
??USB_RemoveControllerUnprotected_0:
        LDR.N    R0,??DataTable7_1
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDR      R0,[R0, R4, LSL #+2]
        CMP      R0,#+0
        BNE.N    ??USB_RemoveControllerUnprotected_2
//  333   {
//  334     return gUsbErr_InvalidParam_c ;
        MOVS     R0,#+208
        B.N      ??USB_RemoveControllerUnprotected_1
//  335   }
//  336 
//  337   switch(gpaUsbClassDescriptor[controllerId]->classId)
??USB_RemoveControllerUnprotected_2:
        LDR.N    R0,??DataTable7_1
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDR      R0,[R0, R4, LSL #+2]
        LDRB     R0,[R0, #+0]
        CMP      R0,#+2
        BEQ.N    ??USB_RemoveControllerUnprotected_3
        CMP      R0,#+3
        BEQ.N    ??USB_RemoveControllerUnprotected_4
        B.N      ??USB_RemoveControllerUnprotected_5
//  338   {
//  339     case gUsbClassId_Cdc_c:
//  340       #if(gUsbCdcEnabled_d == TRUE)
//  341       usbError = USB_Class_CDC_DeInit(controllerId);
??USB_RemoveControllerUnprotected_3:
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_Class_CDC_DeInit
        MOVS     R5,R0
//  342       #else
//  343       return gUsbErr_InvalidParam_c ;
//  344       #endif
//  345     break;
//  346     case gUsbClassId_Hid_c:
//  347      #if(gUsbHidEnabled_d == TRUE)
//  348       usbError = USB_Class_HID_DeInit(controllerId);                    
//  349      #else 
//  350       return gUsbErr_InvalidParam_c ;
//  351      #endif
//  352     break;
//  353     default:
//  354     return gUsbErr_InvalidParam_c ;
//  355     }
//  356  
//  357     gpaUsbClassDescriptor[controllerId] = NULL;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable7_1
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        STR      R0,[R1, R4, LSL #+2]
//  358     return usbError;  
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        B.N      ??USB_RemoveControllerUnprotected_1
??USB_RemoveControllerUnprotected_4:
        MOVS     R0,#+208
        B.N      ??USB_RemoveControllerUnprotected_1
??USB_RemoveControllerUnprotected_5:
        MOVS     R0,#+208
??USB_RemoveControllerUnprotected_1:
        POP      {R1,R4,R5,PC}    ;; return
//  359 }
//  360 
//  361 
//  362 /************************************************************************************
//  363 * USB_Task - 
//  364 *   
//  365 * Return value:
//  366 *    
//  367 * 
//  368 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  369 static void USB_Task(void)  //@SMAC
//  370 { 
USB_Task:
        PUSH     {R3-R5,LR}
//  371   usbMsg_t* pUsbMsg;
//  372   pfUsbToAppEventHandler_t pfUsbToAppEventHandler = NULL;
        MOVS     R5,#+0
//  373   
//  374   
//  375   if(gUsbIrqEvent_c)
//  376   {
//  377     /* Check if there are pending events in the ISR queue */
//  378     if(UsbMsgQueue_MsgPending())
        BL       UsbMsgQueue_MsgPending
        CMP      R0,#+0
        BEQ.N    ??USB_Task_0
//  379     {
//  380       /* Get event out of queue */
//  381       pUsbMsg = UsbMsgQueue_GetFirstMsg();
        BL       UsbMsgQueue_GetFirstMsg
        MOVS     R4,R0
//  382       #ifdef gUSB_Debug_d 
//  383       //debug start
//  384       if(pUsbMsg->controllerId >= gNumUsbControllers_d)
//  385        {
//  386          while(TRUE);
//  387        }
//  388       //debug end
//  389       #endif
//  390       if(gpaUsbClassDescriptor[pUsbMsg->controllerId] != NULL)
        LDR.N    R0,??DataTable7_1
        LDRB     R1,[R4, #+0]
        LDR      R0,[R0, R1, LSL #+2]
        CMP      R0,#+0
        BEQ.N    ??USB_Task_1
//  391       {
//  392         pfUsbToAppEventHandler = gpaUsbClassDescriptor[pUsbMsg->controllerId]->pfUsbToAppEventHandler;
        LDR.N    R0,??DataTable7_1
        LDRB     R1,[R4, #+0]
        LDR      R0,[R0, R1, LSL #+2]
        LDR      R0,[R0, #+4]
        MOVS     R5,R0
//  393       }
//  394       
//  395       if(pfUsbToAppEventHandler != NULL)
??USB_Task_1:
        MOVS     R0,R5
        CMP      R0,#+0
        BEQ.N    ??USB_Task_2
//  396         {
//  397          pfUsbToAppEventHandler(pUsbMsg->controllerId , pUsbMsg->eventType , pUsbMsg ) ;
        MOVS     R2,R4
        LDRB     R1,[R4, #+1]
        LDRB     R0,[R4, #+0]
        BLX      R5
//  398         }
//  399       
//  400       (void)UsbMsgQueue_Pop();
??USB_Task_2:
        BL       UsbMsgQueue_Pop
//  401     }
//  402   }
//  403    
//  404   /* If there are unprocessed events in the queue, send a message to the USB
//  405   task to run again  */
//  406   if(UsbMsgQueue_MsgPending())
??USB_Task_0:
        BL       UsbMsgQueue_MsgPending
        CMP      R0,#+0
        BEQ.N    ??USB_Task_3
//  407   {
//  408     //TS_SendEvent(gUsbTaskId, gUsbIrqEvent_c); //@SMAC
//  409     USB_Task();
        BL       USB_Task
//  410   }
//  411 }
??USB_Task_3:
        POP      {R0,R4,R5,PC}    ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7:
        DC32     gUsbLockLevel

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_1:
        DC32     gpaUsbClassDescriptor

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        END
//  412 
//  413 
//  414 #endif // gUsbIncluded_d
// 
//   9 bytes in section .bss
// 520 bytes in section .text
// 
// 520 bytes of CODE memory
//   9 bytes of DATA memory
//
//Errors: none
//Warnings: none
