###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        02/Sep/2018  13:33:21
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\CDC\usb_cdc_descriptor.c
#    Command line =  
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\CDC\usb_cdc_descriptor.c" -D IAR --preprocess
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\List\" -lC
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\List\" -lB
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\List\"
#        --diag_suppress Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\CDC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\Descriptor\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\USB\Class\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Sys Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
#    List file    =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\Debug\List\usb_cdc_descriptor.lst
#    Object file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\Debug\Obj\usb_cdc_descriptor.o
#
###############################################################################

F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\APP\CDC\usb_cdc_descriptor.c
      1          /******************************************************************************
      2           *
      3           * Virtual Com Application descriptor file
      4           * Freescale Semiconductor Inc.
      5           * (c) Copyright 2012 Freescale Semiconductor, Inc.
      6           * ALL RIGHTS RESERVED.
      7           *
      8           **************************************************************************/
      9           
     10          
     11          /******************************************************************************
     12           * Includes
     13           *****************************************************************************/
     14          #include "EmbeddedTypes.h"
     15          #include "usb_class.h"
     16          #include "USB.h"
     17          #include "usb_descriptor.h"
     18          #include "usb_cdc_descriptor.h"
     19          #include "usb_dciapi.h"
     20          #include "usb_cdc_pstn.h"
     21          #include "CDC_Interface.h" 
     22          
     23          #if gVirtualCOMPort_d
     24          /*****************************************************************************
     25           * Constant and Macro's
     26           *****************************************************************************/
     27          /* structure containing details of all the endpoints used by this device */

   \                                 In section .rodata, align 4
     28           const usbEpStruct_t  usbCdcDescEp[gNumUsbCdcNonControlEp_d]=
   \                     usbCdcDescEp:
   \   00000000   0x01 0x02          DC8 1, 2, 1, 0
   \              0x01 0x00    
   \   00000004   0x0010             DC16 16
   \   00000006   0x02 0x02          DC8 2, 2, 0, 0
   \              0x00 0x00    
   \   0000000A   0x0010             DC16 16
   \   0000000C   0x03 0x03          DC8 3, 3, 1, 0
   \              0x01 0x00    
   \   00000010   0x0010             DC16 16
   \   00000012   0x00 0x00          DC8 0, 0
     29          {
     30            {
     31              gCDC_DIC_BulkInEndpoint_d,
     32              gUsbEpType_Bulk_c,
     33              gUsbEpDirection_In_c,
     34              gUsbCdcBulkInEpSize_d,
     35            },
     36            {
     37              gCDC_DIC_BulkOutEndpoint_d,
     38              gUsbEpType_Bulk_c,
     39              gUsbEpDirection_Out_c,
     40              gUsbCdcBulkOutEpSize_d,
     41            },
     42            {
     43              gCDC_CIC_NotifyEndpoint_d,
     44              gUsbEpType_Interrupt_c,
     45              gUsbEpDirection_In_c,
     46              gUsbCdcInterruptInEpSize_d,
     47            }
     48          };
     49          

   \                                 In section .data, align 4
     50          uint8_t   gCDCDeviceDescriptor[gUSB_DescSize_DeviceDescriptorSize_d] =
   \                     gCDCDeviceDescriptor:
   \   00000000   0x12 0x01          DC8 18, 1, 0, 2, 2, 0, 0, 16, 4, 37, 0, 3, 2, 0, 1, 2, 0, 1, 0, 0
   \              0x00 0x02    
   \              0x02 0x00    
   \              0x00 0x10    
   \              0x04 0x25    
   \              0x00 0x03    
   \              0x02 0x00    
   \              0x01 0x02    
   \              0x00 0x01    
   \              0x00 0x00    
     51          
     52          {
     53            gUSB_DescSize_DeviceDescriptorSize_d,               /*  Device Dexcriptor Size         */
     54            gUSB_DescType_DeviceDescriptor_d,                /*  Device Type of descriptor      */
     55            0x00, 0x02,                           /*  BCD USB version                */
     56            0x02,                                 /*  Communications device class    */
     57            0x00,                                 /*  Device Subclass is indicated
     58                                                      in the interface descriptors   */
     59            0x00,                                 /*  Device Protocol                */
     60            gUsbCdcControlEpSize_d,              /*  Max Packet size                */
     61            0x04,0x25,                            /*  Vendor ID                      */
     62            0x00,0x03,                            /*  0300 is our Product ID for CDC */
     63            0x02,0x00,                            /*  BCD Device version             */
     64            0x01,                                 /*  Manufacturer string index      */
     65            0x02,                                 /*  Product string index           */
     66            #if gVirtualCOMPortSerialNoEnable_d
     67            0x03,
     68            #else
     69            0x00,
     70            #endif                                 /*  Serial number string index     */
     71            0x01                                  /*  Number of configurations       */
     72          };
     73          

   \                                 In section .data, align 4
     74          uint8_t    gCDCConfigDescriptor[gCDC_ConfigDescSize_d] =
   \                     gCDCConfigDescriptor:
   \   00000000   0x09 0x02          DC8 9, 2, 67, 0, 2, 1, 0, 224, 50, 9, 4, 0, 0, 1, 2, 2, 0, 0, 5, 36, 0
   \              0x43 0x00    
   \              0x02 0x01    
   \              0x00 0xE0    
   \              0x32 0x09    
   \              0x04 0x00    
   \              0x00 0x01    
   \              0x02 0x02    
   \              0x00 0x00    
   \              0x05 0x24    
   \              0x00         
   \   00000015   0x10 0x01          DC8 16, 1, 5, 36, 1, 1, 1, 4, 36, 2, 6, 5, 36, 6, 0, 1, 7, 5, 131, 3
   \              0x05 0x24    
   \              0x01 0x01    
   \              0x01 0x04    
   \              0x24 0x02    
   \              0x06 0x05    
   \              0x24 0x06    
   \              0x00 0x01    
   \              0x07 0x05    
   \              0x83 0x03    
   \   00000029   0x10 0x00          DC8 16, 0, 10, 9, 4, 1, 0, 2, 10, 0, 0, 0, 7, 5, 129, 2, 16, 0, 0, 7, 5
   \              0x0A 0x09    
   \              0x04 0x01    
   \              0x00 0x02    
   \              0x0A 0x00    
   \              0x00 0x00    
   \              0x07 0x05    
   \              0x81 0x02    
   \              0x10 0x00    
   \              0x00 0x07    
   \              0x05         
   \   0000003E   0x02 0x02          DC8 2, 2, 16, 0, 0, 0
   \              0x10 0x00    
   \              0x00 0x00    
     75          {
     76            gUSB_DescSize_ConfigOnlyDescriptorSize_d,  /*  Configuration Descriptor Size */
     77            gUSB_DescType_ConfigDescriptor_d,  /* "Configuration" type of descriptor */
     78            gCDC_ConfigDescSize_d, 0x00, /*  Total length of the Configuration descriptor */
     79            (uint8_t)(2),/*NumInterfaces*/
     80            0x01,                      /*  Configuration Value */
     81            0x00,                      /*  Configuration Description String Index*/
     82            gbmUsbAttributes_BusPowered_d|gbmUsbAttributes_SelfPowered_d|(gCDCRemoteWakeupSupport_d<<gCDC_RemoteWakeupShift_d),
     83                        /*  Attributes.support RemoteWakeup and self power*/
     84            0x32,                   /*  Current draw from bus -- 100mA*/
     85            /* CIC INTERFACE DESCRIPTOR */
     86            gUSB_DescSize_InterfaceOnlyDescriptorSize_d,
     87            gUSB_DescType_InterfaceDescriptor_d,
     88            0x00, /* bInterfaceNumber */
     89            0x00, /* bAlternateSetting */
     90            gCDC_CIC_EndpCount_d, /* management and notification(optional)element present */
     91            0x02, /* Communication Interface Class */
     92            gCDC_CIC_SubclassCode_d,
     93            gCDC_CIC_ProtocolCode_d,
     94            0x00, /* Interface Description String Index*/
     95          
     96            /* CDC Class-Specific descriptor */
     97            0x05,             /* size of Functional Desc in bytes */
     98            gCDC_DescType_CS_Interface_d,  /* descriptor type*/
     99            gUSB_CDC_DescType_HeaderFuncDesc_d,
    100            0x10, 0x01,  /* USB Class Definitions for CDC spec release number in BCD */
    101            0x05,             /* Size of this descriptor */
    102            gCDC_DescType_CS_Interface_d, /* descriptor type*/
    103            gUSB_CDC_DescType_CallManagementFuncDesc_d,
    104            0x01,/*may use 0x03 */  /* device handales call management itself(D0 set)
    105                        and will process commands multiplexed over the data interface */
    106            0x01,      /* Indicates multiplexed commands are
    107                          handled via data interface */
    108          
    109            0x04,             /* Size of this descriptor */
    110            gCDC_DescType_CS_Interface_d, /* descriptor type*/
    111            gUSB_CDC_DescType_AbstractControlFuncDesc_d,
    112            0x06, /*may use 0x0F */ /* Device Supports all commands for ACM - CDC
    113                                        PSTN SubClass bmCapabilities */
    114          
    115            0x05,             /* size of Functional Desc in bytes */
    116            gCDC_DescType_CS_Interface_d,  /* descriptor type*/
    117            gUSB_CDC_DescType_UnionFuncDesc_d,
    118            0x00,           /* Interface Number of Control */
    119            0x01,           /* Interface Number of Subordinate (Data Class) Interface */
    120            gUSB_DescSize_EndpOnlyDescriptorSize_d,
    121            gUSB_DescType_EndpointDescriptor_d,
    122            gCDC_CIC_NotifyEndpoint_d|(gUsbEpDirection_In_c << 7),
    123            gUsbEpType_Interrupt_c,
    124            gUsbCdcInterruptInEpSize_d, 0x00,
    125            0x0A,
    126            gUSB_DescSize_InterfaceOnlyDescriptorSize_d,
    127            gUSB_DescType_InterfaceDescriptor_d,
    128            (uint8_t)(1), /* bInterfaceNumber */
    129            0x00, /* bAlternateSetting */
    130            gCDC_DIC_EndpCount_d, /* notification element included */
    131            0x0A, /* DATA Interface Class */
    132            0x00, /* Data Interface SubClass Code */
    133            gCDC_DIC_ProtocolCode_d,
    134            0x00, /* Interface Description String Index*/
    135            /*Endpoint descriptor */
    136            gUSB_DescSize_EndpOnlyDescriptorSize_d,
    137            gUSB_DescType_EndpointDescriptor_d,
    138            gCDC_DIC_BulkInEndpoint_d|(gUsbEpDirection_In_c << 7),
    139            gUsbEpType_Bulk_c,
    140            gUsbCdcBulkInEpSize_d, 0x00,
    141            0x00,/* This value is ignored for Bulk ENDPOINT */
    142             /*Endpoint descriptor */
    143            gUSB_DescSize_EndpOnlyDescriptorSize_d,
    144            gUSB_DescType_EndpointDescriptor_d,
    145            gCDC_DIC_BulkOutEndpoint_d|(gUsbEpDirection_Out_c << 7),
    146            gUsbEpType_Bulk_c,
    147            gUsbCdcBulkOutEpSize_d, 0x00,
    148            0x00 /* This value is ignored for Bulk ENDPOINT */
    149          };
    150          

   \                                 In section .data, align 4
    151          uint8_t   gCDC_Str0[gCDC_Str0DescSize_d+gUSB_DescSize_StringDescriptorSize_d] =
   \                     gCDC_Str0:
   \   00000000   0x04 0x03          DC8 4, 3, 9, 4
   \              0x09 0x04    
    152          {
    153            sizeof(gCDC_Str0),
    154            gUSB_DescType_StringDescriptor_d,
    155            0x09,
    156            0x04/*equiavlent to 0x0409(English - United States)*/
    157          };
    158          

   \                                 In section .data, align 4
    159          uint8_t   gCDC_Str1[gCDC_Str1DescSize_d+gUSB_DescSize_StringDescriptorSize_d] = 
   \                     gCDC_Str1:
   \   00000000   0x3A 0x03          DC8 58, 3, 70, 0, 82, 0, 69, 0, 69, 0, 83, 0, 67, 0, 65, 0, 76, 0, 69
   \              0x46 0x00    
   \              0x52 0x00    
   \              0x45 0x00    
   \              0x45 0x00    
   \              0x53 0x00    
   \              0x43 0x00    
   \              0x41 0x00    
   \              0x4C 0x00    
   \              0x45         
   \   00000013   0x00 0x20          DC8 0, 32, 0, 83, 0, 69, 0, 77, 0, 73, 0, 67, 0, 79, 0, 78, 0, 68, 0
   \              0x00 0x53    
   \              0x00 0x45    
   \              0x00 0x4D    
   \              0x00 0x49    
   \              0x00 0x43    
   \              0x00 0x4F    
   \              0x00 0x4E    
   \              0x00 0x44    
   \              0x00         
   \   00000026   0x55 0x00          DC8 85, 0, 67, 0, 84, 0, 79, 0, 82, 0, 32, 0, 73, 0, 78, 0, 67, 0, 46
   \              0x43 0x00    
   \              0x54 0x00    
   \              0x4F 0x00    
   \              0x52 0x00    
   \              0x20 0x00    
   \              0x49 0x00    
   \              0x4E 0x00    
   \              0x43 0x00    
   \              0x2E         
   \   00000039   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    160          {
    161            sizeof(gCDC_Str1),
    162            gUSB_DescType_StringDescriptor_d,
    163            'F',0,
    164            'R',0,
    165            'E',0,
    166            'E',0,
    167            'S',0,
    168            'C',0,
    169            'A',0,
    170            'L',0,
    171            'E',0,
    172            ' ',0,
    173            'S',0,
    174            'E',0,
    175            'M',0,
    176            'I',0,
    177            'C',0,
    178            'O',0,
    179            'N',0,
    180            'D',0,
    181            'U',0,
    182            'C',0,
    183            'T',0,
    184            'O',0,
    185            'R',0,
    186            ' ',0,
    187            'I',0,
    188            'N',0,
    189            'C',0,
    190            '.',0
    191          };
    192          
    193          

   \                                 In section .data, align 4
    194          uint8_t   gCDC_Str2[gCDC_Str2DescSize_d+gUSB_DescSize_StringDescriptorSize_d] = 
   \                     gCDC_Str2:
   \   00000000   0x2E 0x03          DC8 46, 3, 70, 0, 82, 0, 69, 0, 69, 0, 83, 0, 67, 0, 65, 0, 76, 0, 69
   \              0x46 0x00    
   \              0x52 0x00    
   \              0x45 0x00    
   \              0x45 0x00    
   \              0x53 0x00    
   \              0x43 0x00    
   \              0x41 0x00    
   \              0x4C 0x00    
   \              0x45         
   \   00000013   0x00 0x20          DC8 0, 32, 0, 86, 0, 73, 0, 82, 0, 84, 0, 85, 0, 65, 0, 76, 0, 32, 0
   \              0x00 0x56    
   \              0x00 0x49    
   \              0x00 0x52    
   \              0x00 0x54    
   \              0x00 0x55    
   \              0x00 0x41    
   \              0x00 0x4C    
   \              0x00 0x20    
   \              0x00         
   \   00000026   0x43 0x00          DC8 67, 0, 79, 0, 77, 0, 32, 0, 0, 0
   \              0x4F 0x00    
   \              0x4D 0x00    
   \              0x20 0x00    
   \              0x00 0x00    
    195          {
    196            sizeof(gCDC_Str2),
    197            gUSB_DescType_StringDescriptor_d,
    198            'F',0,
    199            'R',0,
    200            'E',0,
    201            'E',0,
    202            'S',0,
    203            'C',0,
    204            'A',0,
    205            'L',0,
    206            'E',0,
    207            ' ',0,
    208            'V',0,
    209            'I',0,
    210            'R',0,
    211            'T',0,
    212            'U',0,
    213            'A',0,
    214            'L',0,
    215            ' ',0,
    216            'C',0,
    217            'O',0,
    218            'M',0,
    219            ' ',0
    220          };
    221               
    222          #if gVirtualCOMPortSerialNoEnable_d                          
    223          uint8_t   gCDC_Str3[gCDC_Str3DescSize_d+gUSB_DescSize_StringDescriptorSize_d] = 
    224          {
    225            sizeof(gCDC_Str3),
    226            gUSB_DescType_StringDescriptor_d,
    227            gDefaultValueOfVirtualCOMPortSerialNo_c
    228          };
    229          #endif
    230          

   \                                 In section .data, align 4
    231          uint8_t   gCDC_Strn[gCDC_StrNDescSize_d+gUSB_DescSize_StringDescriptorSize_d] =
   \                     gCDC_Strn:
   \   00000000   0x22 0x03          DC8 34, 3, 66, 0, 65, 0, 68, 0, 32, 0, 83, 0, 84, 0, 82, 0, 73, 0, 78
   \              0x42 0x00    
   \              0x41 0x00    
   \              0x44 0x00    
   \              0x20 0x00    
   \              0x53 0x00    
   \              0x54 0x00    
   \              0x52 0x00    
   \              0x49 0x00    
   \              0x4E         
   \   00000013   0x00 0x47          DC8 0, 71, 0, 32, 0, 73, 0, 78, 0, 68, 0, 69, 0, 88, 0, 0, 0
   \              0x00 0x20    
   \              0x00 0x49    
   \              0x00 0x4E    
   \              0x00 0x44    
   \              0x00 0x45    
   \              0x00 0x58    
   \              0x00 0x00    
   \              0x00         
    232          {
    233            sizeof(gCDC_Strn),
    234            gUSB_DescType_StringDescriptor_d,
    235            'B',0,
    236            'A',0,
    237            'D',0,
    238            ' ',0,
    239            'S',0,
    240            'T',0,
    241            'R',0,
    242            'I',0,
    243            'N',0,
    244            'G',0,
    245            ' ',0,
    246            'I',0,
    247            'N',0,
    248            'D',0,
    249            'E',0,
    250            'X',0
    251          };
    252          
    253          

   \                                 In section .rodata, align 4
    254          usbPacketSize_t const gCDC_StdDescSize[gCDC_Num_StdDescriptorsNum_d+1] =
   \                     gCDC_StdDescSize:
   \   00000000   0x0000 0x0012      DC16 0, 18, 67, 0, 0, 0, 0, 0
   \              0x0043 0x0000
   \              0x0000 0x0000
   \              0x0000 0x0000
    255          {
    256            0,
    257            gUSB_DescSize_DeviceDescriptorSize_d,
    258            gCDC_ConfigDescSize_d,
    259            0, /* string */
    260            0, /* Interface */
    261            0, /* Endpoint */
    262            0, /* Device Qualifier */
    263            0 /* other speed config */
    264          };
    265          

   \                                 In section .rodata, align 4
    266          uint8_t* const gCDC_StdDescriptors[gCDC_Num_StdDescriptorsNum_d+1] =
   \                     gCDC_StdDescriptors:
   \   00000000   0x00000000         DC32 0H, gCDCDeviceDescriptor, gCDCConfigDescriptor, 0H, 0H, 0H, 0H, 0H
   \              0x........   
   \              0x........   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
    267          {
    268            NULL,
    269            (uint8_t*)gCDCDeviceDescriptor,
    270            (uint8_t*)gCDCConfigDescriptor,
    271            NULL, /* string */
    272            NULL, /* Interface */
    273            NULL, /* Endpoint */
    274            NULL, /* Device Qualifier */
    275            NULL  /* other speed config*/
    276          };
    277          

   \                                 In section .rodata, align 4
    278          uint8_t const gCDC_StringDescSize[gCDC_Num_StringDescriptorsNum_d+1] =
   \                     gCDC_StringDescSize:
   \   00000000   0x04 0x3A          DC8 4, 58, 46, 34
   \              0x2E 0x22    
    279          {
    280            sizeof(gCDC_Str0),
    281            sizeof(gCDC_Str1),
    282            sizeof(gCDC_Str2),
    283          #if gVirtualCOMPortSerialNoEnable_d  
    284            sizeof(gCDC_Str3),
    285          #endif  
    286            sizeof(gCDC_Strn)
    287          };
    288          

   \                                 In section .rodata, align 4
    289          uint8_t* const gCDC_StringDescriptors[gCDC_Num_StringDescriptorsNum_d+1] =
   \                     gCDC_StringDescriptors:
   \   00000000   0x........         DC32 gCDC_Str0, gCDC_Str1, gCDC_Str2, gCDC_Strn
   \              0x........   
   \              0x........   
   \              0x........   
    290          {
    291            (uint8_t*)gCDC_Str0,
    292            (uint8_t*)gCDC_Str1,
    293            (uint8_t*)gCDC_Str2,
    294          #if gVirtualCOMPortSerialNoEnable_d  
    295            (uint8_t*)gCDC_Str3,
    296          #endif  
    297            (uint8_t*)gCDC_Strn
    298          };
    299          

   \                                 In section .rodata, align 4
    300          usbCDCAllLanguages_t gCDC_Languages = 
   \                     gCDC_Languages:
   \   00000000   0x........         DC32 gCDC_Str0
   \   00000004   0x04 0x00          DC8 4, 0, 0, 0
   \              0x00 0x00    
   \   00000008   0x0409             DC16 1033
   \   0000000A   0x00 0x00          DC8 0, 0
   \   0000000C   0x........         DC32 gCDC_StringDescriptors, gCDC_StringDescSize
   \              0x........   
    301          { 
    302          gCDC_Str0, sizeof(gCDC_Str0),
    303            { 
    304              {
    305                (uint16_t )0x0409,
    306                (const uint8_t **)gCDC_StringDescriptors,
    307                gCDC_StringDescSize
    308              }
    309            }
    310          };
    311          

   \                                 In section .rodata, align 2
    312          uint8_t const gCDC_ValidConfigValues[gCDC_Num_SupportedConfigNum_d+1]={0,1};
   \                     gCDC_ValidConfigValues:
   \   00000000   0x00 0x01          DC8 0, 1
    313          
    314          /****************************************************************************
    315           * Global Variables
    316           ****************************************************************************/
    317          
    318          

   \                                 In section .data, align 4
    319          static uint8_t gLineCoding[gCDC_Num_MaxSupportedDataInterfaces_d][gCDC_LineCodingSize_d] =
   \                     gLineCoding:
   \   00000000   0x00 0xC2          DC8 0, 194, 1, 0, 0, 0, 8, 0
   \              0x01 0x00    
   \              0x00 0x00    
   \              0x08 0x00    
    320          {
    321            {
    322              (gCDC_LineCodeDTERateIface0_d>> 0) & 0x000000FF,
    323              (gCDC_LineCodeDTERateIface0_d>> 8) & 0x000000FF,
    324              (gCDC_LineCodeDTERateIface0_d>>16) & 0x000000FF,
    325              (gCDC_LineCodeDTERateIface0_d>>24) & 0x000000FF,
    326              /*e.g. 0x00,0xC2,0x01,0x00 : 0x0001C200 is 115200 bits per second */
    327              gCDC_LineCodeCharFormatIface0_d,
    328              gCDC_LineCodeParityTypeIface0_d,
    329              gCDC_LineCodeDataBitsIface0_d
    330            }
    331          };
    332          

   \                                 In section .bss, align 2
    333          static uint8_t gAbstractState[gCDC_Num_MaxSupportedDataInterfaces_d][gUSB_CDC_CommFeatureDataSize_d] =
   \                     gAbstractState:
   \   00000000                      DS8 2
    334          {
    335            { 
    336              (gCDC_StatusAbstractStateIface0_d>>0) & 0x00FF,
    337              (gCDC_StatusAbstractStateIface0_d>>8) & 0x00FF
    338            }
    339          };
    340          

   \                                 In section .bss, align 2
    341          static uint8_t gCountryCode[gCDC_Num_MaxSupportedDataInterfaces_d][gUSB_CDC_CommFeatureDataSize_d] =
   \                     gCountryCode:
   \   00000000                      DS8 2
    342          {
    343            { 
    344              (gCDC_CountrySettingIface0_d>>0) & 0x00FF,
    345              (gCDC_CountrySettingIface0_d>>8) & 0x00FF
    346            }
    347          };
    348          

   \                                 In section .bss, align 2
    349          static uint8_t gAlternateInterface[gCDC_Num_MaxSupportedDataInterfaces_d + 1];
   \                     gAlternateInterface:
   \   00000000                      DS8 2
    350          
    351          /*****************************************************************************
    352           * Local Types - None
    353           *****************************************************************************/
    354          
    355          /*****************************************************************************
    356           * Local Functions Prototypes
    357           *****************************************************************************/
    358          
    359          /*****************************************************************************
    360           * Local Variables - None
    361           *****************************************************************************/
    362          
    363          
    364           /*****************************************************************************
    365           * Local Functions - None
    366           *****************************************************************************/
    367          
    368          /*****************************************************************************
    369           * Global Functions
    370           *****************************************************************************/
    371          
    372          /*****************************************************************************/
    373          

   \                                 In section .text, align 2, keep-with-next
    374          uint8_t USB_CDC_Desc_GetDescriptor 
    375          (
    376            uint8_t controllerId,   /* [IN] Controller ID */
    377            uint8_t type,            /* [IN] type of descriptor requested */
    378            uint8_t strNum,         /* [IN] string index for string descriptor */
    379            uint16_t index,          /* [IN] string descriptor language Id */
    380            uint8_t* *pDescriptor, /* [OUT] output descriptor pointer */
    381            usbPacketSize_t *pSize   /* [OUT] size of descriptor returned */
    382          )
    383          {
   \                     USB_CDC_Desc_GetDescriptor: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x9D05             LDR      R5,[SP, #+20]
   \   00000006   0x9E06             LDR      R6,[SP, #+24]
    384            (void) (controllerId);
    385             /* string descriptors are handled saperately */
    386            if (type == gUSB_DescType_StringDescriptor_d)
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x2903             CMP      R1,#+3
   \   0000000C   0xD13D             BNE.N    ??USB_CDC_Desc_GetDescriptor_0
    387            {
    388              if(index == 0)
   \   0000000E   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000010   0x2B00             CMP      R3,#+0
   \   00000012   0xD106             BNE.N    ??USB_CDC_Desc_GetDescriptor_1
    389              {
    390                /* return the string and size of all languages */
    391                *pDescriptor = (uint8_t*)gCDC_Languages.pLanguagesSupportedString;
   \   00000014   0x....             LDR.N    R0,??DataTable10
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x6028             STR      R0,[R5, #+0]
    392                *pSize = gCDC_Languages.languagesSupportedSize;
   \   0000001A   0x....             LDR.N    R0,??DataTable10
   \   0000001C   0x7900             LDRB     R0,[R0, #+4]
   \   0000001E   0x8030             STRH     R0,[R6, #+0]
   \   00000020   0xE048             B.N      ??USB_CDC_Desc_GetDescriptor_2
    393              }
    394              else
    395              {
    396                uint8_t langId ;
    397                uint8_t langIndex = gCDC_Num_SupportedLanguagesNum_d;
   \                     ??USB_CDC_Desc_GetDescriptor_1: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
    398                for(langId = 0;langId< gCDC_Num_SupportedLanguagesNum_d;langId++)
   \   00000024   0xF05F 0x0C00      MOVS     R12,#+0
   \   00000028   0x4667             MOV      R7,R12
   \                     ??USB_CDC_Desc_GetDescriptor_3: (+1)
   \   0000002A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD112             BNE.N    ??USB_CDC_Desc_GetDescriptor_4
    399                  {
    400                    /* check whether we have a string for this language */
    401                    if(index == gCDC_Languages.usbLanguage[langId].languageId)
   \   00000030   0x.... 0x....      LDR.W    R12,??DataTable10
   \   00000034   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000036   0xF05F 0x0E0C      MOVS     LR,#+12
   \   0000003A   0xFB0E 0xCC07      MLA      R12,LR,R7,R12
   \   0000003E   0xF8BC 0xC008      LDRH     R12,[R12, #+8]
   \   00000042   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000044   0x4563             CMP      R3,R12
   \   00000046   0xD104             BNE.N    ??USB_CDC_Desc_GetDescriptor_5
    402                      {   /* check for max descriptors */
    403                        if(strNum < gCDC_Num_StringDescriptorsNum_d)
   \   00000048   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000004A   0x2A03             CMP      R2,#+3
   \   0000004C   0xDA00             BGE.N    ??USB_CDC_Desc_GetDescriptor_6
    404                        {   /* setup index for the string to be returned */
    405                          langIndex=strNum;
   \   0000004E   0x0010             MOVS     R0,R2
    406                        }
    407          
    408                        break;
   \                     ??USB_CDC_Desc_GetDescriptor_6: (+1)
   \   00000050   0xE001             B.N      ??USB_CDC_Desc_GetDescriptor_4
    409                      }
    410          
    411                  }
   \                     ??USB_CDC_Desc_GetDescriptor_5: (+1)
   \   00000052   0x1C7F             ADDS     R7,R7,#+1
   \   00000054   0xE7E9             B.N      ??USB_CDC_Desc_GetDescriptor_3
    412          
    413                  /* set return val for descriptor and size */
    414                  *pDescriptor = (uint8_t*)gCDC_Languages.usbLanguage[langId].pLangDesc[langIndex];
   \                     ??USB_CDC_Desc_GetDescriptor_4: (+1)
   \   00000056   0x.... 0x....      LDR.W    R12,??DataTable10
   \   0000005A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005C   0xF05F 0x0E0C      MOVS     LR,#+12
   \   00000060   0xFB0E 0xCC07      MLA      R12,LR,R7,R12
   \   00000064   0xF8DC 0xC00C      LDR      R12,[R12, #+12]
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0xF85C 0xC020      LDR      R12,[R12, R0, LSL #+2]
   \   0000006E   0xF8C5 0xC000      STR      R12,[R5, #+0]
    415                  *pSize = gCDC_Languages.usbLanguage[langId].pLangDescSize[langIndex];
   \   00000072   0x.... 0x....      LDR.W    R12,??DataTable10
   \   00000076   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000078   0xF05F 0x0E0C      MOVS     LR,#+12
   \   0000007C   0xFB0E 0xC707      MLA      R7,LR,R7,R12
   \   00000080   0x693F             LDR      R7,[R7, #+16]
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0x5DC0             LDRB     R0,[R0, R7]
   \   00000086   0x8030             STRH     R0,[R6, #+0]
   \   00000088   0xE014             B.N      ??USB_CDC_Desc_GetDescriptor_2
    416              }
    417          
    418            }
    419            else if (type < gCDC_Num_StdDescriptorsNum_d+1)
   \                     ??USB_CDC_Desc_GetDescriptor_0: (+1)
   \   0000008A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008C   0x2908             CMP      R1,#+8
   \   0000008E   0xDA0F             BGE.N    ??USB_CDC_Desc_GetDescriptor_7
    420            {
    421              /* set return val for descriptor and size*/
    422              *pDescriptor = (uint8_t*)gCDC_StdDescriptors [type];
   \   00000090   0x....             LDR.N    R0,??DataTable10_1
   \   00000092   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000094   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000098   0x6028             STR      R0,[R5, #+0]
    423              /* if there is no descriptor then return error */
    424              if(*pDescriptor == NULL)
   \   0000009A   0x6828             LDR      R0,[R5, #+0]
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD101             BNE.N    ??USB_CDC_Desc_GetDescriptor_8
    425              {
    426                return gUsbErr_InvalidReqType_c;
   \   000000A0   0x20CD             MOVS     R0,#+205
   \   000000A2   0xE008             B.N      ??USB_CDC_Desc_GetDescriptor_9
    427              }
    428          
    429              *pSize = gCDC_StdDescSize[type];
   \                     ??USB_CDC_Desc_GetDescriptor_8: (+1)
   \   000000A4   0x....             LDR.N    R0,??DataTable10_2
   \   000000A6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A8   0xF830 0x0011      LDRH     R0,[R0, R1, LSL #+1]
   \   000000AC   0x8030             STRH     R0,[R6, #+0]
   \   000000AE   0xE001             B.N      ??USB_CDC_Desc_GetDescriptor_2
    430            }
    431            else /* invalid descriptor */
    432            {
    433              return gUsbErr_InvalidReqType_c;
   \                     ??USB_CDC_Desc_GetDescriptor_7: (+1)
   \   000000B0   0x20CD             MOVS     R0,#+205
   \   000000B2   0xE000             B.N      ??USB_CDC_Desc_GetDescriptor_9
    434            }
    435          
    436            return gUsbErr_NoError_c;
   \                     ??USB_CDC_Desc_GetDescriptor_2: (+1)
   \   000000B4   0x2000             MOVS     R0,#+0
   \                     ??USB_CDC_Desc_GetDescriptor_9: (+1)
   \   000000B6   0xBDF0             POP      {R4-R7,PC}       ;; return
    437          }
    438          
    439          /*****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    440          uint8_t USB_CDC_Desc_GetInterface 
    441          (
    442            uint8_t controllerId,     /* [IN] Controller ID */
    443            uint8_t interface,         /* [IN] interface number */
    444            uint8_t* pAltInterface  /* [OUT] output alternate interface */
    445          )
    446          {
   \                     USB_CDC_Desc_GetInterface: (+1)
   \   00000000   0x0003             MOVS     R3,R0
    447            (void) (controllerId);
    448            /* if interface valid */
    449            if(interface < gCDC_Num_MaxSupportedDataInterfaces_d + 1)
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2902             CMP      R1,#+2
   \   00000006   0xDA05             BGE.N    ??USB_CDC_Desc_GetInterface_0
    450            {
    451              /* get alternate interface*/
    452              *pAltInterface = gAlternateInterface[interface];
   \   00000008   0x....             LDR.N    R0,??DataTable10_3
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x5C08             LDRB     R0,[R1, R0]
   \   0000000E   0x7010             STRB     R0,[R2, #+0]
    453              return gUsbErr_NoError_c;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE000             B.N      ??USB_CDC_Desc_GetInterface_1
    454            }
    455            return gUsbErr_InvalidReqType_c;
   \                     ??USB_CDC_Desc_GetInterface_0: (+1)
   \   00000014   0x20CD             MOVS     R0,#+205
   \                     ??USB_CDC_Desc_GetInterface_1: (+1)
   \   00000016   0x4770             BX       LR               ;; return
    456          }
    457          
    458          /*****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    459          uint8_t USB_CDC_Desc_SetInterface
    460          (
    461            uint8_t controllerId, /* [IN] Controller ID */
    462            uint8_t interface,     /* [IN] interface number */
    463            uint8_t altInterface  /* [IN] input alternate interface */
    464          )
    465          {
   \                     USB_CDC_Desc_SetInterface: (+1)
   \   00000000   0x0003             MOVS     R3,R0
    466            (void) (controllerId);
    467            /* if interface valid */
    468            if(interface < gCDC_Num_MaxSupportedDataInterfaces_d + 1)
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2902             CMP      R1,#+2
   \   00000006   0xDA04             BGE.N    ??USB_CDC_Desc_SetInterface_0
    469            {
    470              /* set alternate interface*/
    471              gAlternateInterface[interface]=altInterface;
   \   00000008   0x....             LDR.N    R0,??DataTable10_3
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x540A             STRB     R2,[R1, R0]
    472              return gUsbErr_NoError_c;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE000             B.N      ??USB_CDC_Desc_SetInterface_1
    473            }
    474              return gUsbErr_InvalidReqType_c;
   \                     ??USB_CDC_Desc_SetInterface_0: (+1)
   \   00000012   0x20CD             MOVS     R0,#+205
   \                     ??USB_CDC_Desc_SetInterface_1: (+1)
   \   00000014   0x4770             BX       LR               ;; return
    475          }
    476          
    477          /*****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    478          bool_t USB_CDC_Desc_ValidConfiguration 
    479          (
    480            uint8_t controllerId,/*[IN] Controller ID */
    481            uint16_t configVal   /*[IN] configuration value */
    482          )
    483          {
   \                     USB_CDC_Desc_ValidConfiguration: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    484            uint8_t loopIndex=0;
   \   00000002   0x2300             MOVS     R3,#+0
    485            (void) (controllerId);
    486            /* check with only supported val right now */
    487            while(loopIndex < (gCDC_Num_SupportedConfigNum_d+1))
   \                     ??USB_CDC_Desc_ValidConfiguration_0: (+1)
   \   00000004   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000006   0x2B02             CMP      R3,#+2
   \   00000008   0xDA0A             BGE.N    ??USB_CDC_Desc_ValidConfiguration_1
    488            {
    489              if(configVal == gCDC_ValidConfigValues[loopIndex])
   \   0000000A   0x....             LDR.N    R0,??DataTable10_4
   \   0000000C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000000E   0x5C18             LDRB     R0,[R3, R0]
   \   00000010   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000012   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000014   0x4281             CMP      R1,R0
   \   00000016   0xD101             BNE.N    ??USB_CDC_Desc_ValidConfiguration_2
    490              {
    491                return TRUE;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE002             B.N      ??USB_CDC_Desc_ValidConfiguration_3
    492              }
    493              loopIndex++;
   \                     ??USB_CDC_Desc_ValidConfiguration_2: (+1)
   \   0000001C   0x1C5B             ADDS     R3,R3,#+1
   \   0000001E   0xE7F1             B.N      ??USB_CDC_Desc_ValidConfiguration_0
    494            }
    495            return FALSE;
   \                     ??USB_CDC_Desc_ValidConfiguration_1: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \                     ??USB_CDC_Desc_ValidConfiguration_3: (+1)
   \   00000022   0x4770             BX       LR               ;; return
    496          }
    497          
    498          /*****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    499          bool_t USB_CDC_Desc_ValidInterface 
    500          (
    501            uint8_t controllerId, /*[IN] Controller ID */
    502            uint8_t interface      /*[IN] target interface */
    503          )
    504          {
   \                     USB_CDC_Desc_ValidInterface: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    505            uint8_t loopIndex=0;
   \   00000002   0x2300             MOVS     R3,#+0
    506            (void) (controllerId);
    507            /* check with only supported val right now */
    508            while(loopIndex < gCDC_Num_MaxSupportedDataInterfaces_d)
   \                     ??USB_CDC_Desc_ValidInterface_0: (+1)
   \   00000004   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000006   0x2B00             CMP      R3,#+0
   \   00000008   0xD109             BNE.N    ??USB_CDC_Desc_ValidInterface_1
    509            {
    510              if(interface == gAlternateInterface[loopIndex])
   \   0000000A   0x....             LDR.N    R0,??DataTable10_3
   \   0000000C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000000E   0x5C18             LDRB     R0,[R3, R0]
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x4281             CMP      R1,R0
   \   00000014   0xD101             BNE.N    ??USB_CDC_Desc_ValidInterface_2
    511              {
    512                return TRUE;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE002             B.N      ??USB_CDC_Desc_ValidInterface_3
    513              }
    514              loopIndex++;
   \                     ??USB_CDC_Desc_ValidInterface_2: (+1)
   \   0000001A   0x1C5B             ADDS     R3,R3,#+1
   \   0000001C   0xE7F2             B.N      ??USB_CDC_Desc_ValidInterface_0
    515            }
    516          
    517            return FALSE;
   \                     ??USB_CDC_Desc_ValidInterface_1: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \                     ??USB_CDC_Desc_ValidInterface_3: (+1)
   \   00000020   0x4770             BX       LR               ;; return
    518          }
    519          
    520          /*****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    521          bool_t USB_CDC_Desc_RemoteWakeup 
    522          (
    523            uint8_t controllerId  /* [IN] Controller ID */
    524          )
    525          {
   \                     USB_CDC_Desc_RemoteWakeup: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    526            (void) (controllerId);
    527            return gCDCRemoteWakeupSupport_d;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x4770             BX       LR               ;; return
    528          }
    529          
    530          
    531          /*****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    532          uint8_t USB_CDC_Desc_GetLineCoding 
    533          (
    534            uint8_t controllerId,       /* [IN] Controller ID */
    535            uint8_t interface,           /* [IN] Interface Number */
    536            uint8_t* *pCodingData     /* [OUT] Line Coding Data */
    537          )
    538          {
   \                     USB_CDC_Desc_GetLineCoding: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0003             MOVS     R3,R0
    539            (void) (controllerId);
    540            /* if interface valid */
    541            if(interface < gCDC_Num_MaxSupportedDataInterfaces_d)
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD107             BNE.N    ??USB_CDC_Desc_GetLineCoding_0
    542            {
    543              /* get line coding data*/
    544              *pCodingData = gLineCoding[interface];
   \   0000000A   0x....             LDR.N    R0,??DataTable10_5
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0x2407             MOVS     R4,#+7
   \   00000010   0xFB04 0x0001      MLA      R0,R4,R1,R0
   \   00000014   0x6010             STR      R0,[R2, #+0]
    545              return gUsbErr_NoError_c;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE000             B.N      ??USB_CDC_Desc_GetLineCoding_1
    546            }
    547            return gUsbErr_InvalidReqType_c;
   \                     ??USB_CDC_Desc_GetLineCoding_0: (+1)
   \   0000001A   0x20CD             MOVS     R0,#+205
   \                     ??USB_CDC_Desc_GetLineCoding_1: (+1)
   \   0000001C   0xBC10             POP      {R4}
   \   0000001E   0x4770             BX       LR               ;; return
    548          }
    549          
    550          /*****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    551          uint8_t USB_CDC_Desc_SetLineCoding
    552          (
    553            uint8_t controllerId,       /* [IN] Controller ID */
    554            uint8_t interface,           /* [IN] Interface Number */
    555            uint8_t* *pCodingData     /* [IN] Line Coding Data */
    556          )
    557          {
   \                     USB_CDC_Desc_SetLineCoding: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0003             MOVS     R3,R0
    558            uint8_t count;
    559            (void)(controllerId);
    560             /* if interface valid */
    561            if(interface < gCDC_Num_MaxSupportedDataInterfaces_d)
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD112             BNE.N    ??USB_CDC_Desc_SetLineCoding_0
    562            {
    563            /* set line coding data*/
    564              for (count = 0; count < gCDC_LineCodingSize_d; count++)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0004             MOVS     R4,R0
   \                     ??USB_CDC_Desc_SetLineCoding_1: (+1)
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x2C07             CMP      R4,#+7
   \   00000012   0xDA0B             BGE.N    ??USB_CDC_Desc_SetLineCoding_2
    565              {
    566                gLineCoding[interface][count] = *(*pCodingData + count);
   \   00000014   0x....             LDR.N    R0,??DataTable10_5
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0x2507             MOVS     R5,#+7
   \   0000001A   0xFB05 0x0001      MLA      R0,R5,R1,R0
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x6815             LDR      R5,[R2, #+0]
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0x5D65             LDRB     R5,[R4, R5]
   \   00000026   0x5425             STRB     R5,[R4, R0]
    567              }
   \   00000028   0x1C64             ADDS     R4,R4,#+1
   \   0000002A   0xE7F0             B.N      ??USB_CDC_Desc_SetLineCoding_1
    568              return gUsbErr_NoError_c;
   \                     ??USB_CDC_Desc_SetLineCoding_2: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE000             B.N      ??USB_CDC_Desc_SetLineCoding_3
    569            }
    570            return gUsbErr_InvalidReqType_c;
   \                     ??USB_CDC_Desc_SetLineCoding_0: (+1)
   \   00000030   0x20CD             MOVS     R0,#+205
   \                     ??USB_CDC_Desc_SetLineCoding_3: (+1)
   \   00000032   0xBC30             POP      {R4,R5}
   \   00000034   0x4770             BX       LR               ;; return
    571          }
    572          
    573          /*****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    574          uint8_t USB_CDC_Desc_GetAbstractState 
    575          (
    576            uint8_t controllerId,       /* [IN] Controller ID */
    577            uint8_t interface,           /* [IN] Interface Number */
    578            uint8_t* *pFeatureData    /* [OUT] Output Comm Feature Data */
    579          )
    580          {
   \                     USB_CDC_Desc_GetAbstractState: (+1)
   \   00000000   0x0003             MOVS     R3,R0
    581            (void)(controllerId);
    582            /* if interface valid */
    583            if(interface < gCDC_Num_MaxSupportedDataInterfaces_d)
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD106             BNE.N    ??USB_CDC_Desc_GetAbstractState_0
    584            {
    585              /* get line coding data*/
    586              *pFeatureData = gAbstractState[interface];
   \   00000008   0x....             LDR.N    R0,??DataTable10_6
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0xEB10 0x0041      ADDS     R0,R0,R1, LSL #+1
   \   00000010   0x6010             STR      R0,[R2, #+0]
    587              return gUsbErr_NoError_c;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE000             B.N      ??USB_CDC_Desc_GetAbstractState_1
    588            }
    589            return gUsbErr_InvalidReqType_c;
   \                     ??USB_CDC_Desc_GetAbstractState_0: (+1)
   \   00000016   0x20CD             MOVS     R0,#+205
   \                     ??USB_CDC_Desc_GetAbstractState_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    590          }
    591          
    592          
    593          /*****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    594          uint8_t USB_CDC_Desc_GetCountrySetting
    595          (
    596            uint8_t controllerId,       /* [IN] Controller ID */
    597            uint8_t interface,           /* [IN] Interface Number */
    598            uint8_t* *pFeatureData    /* [OUT] Output Comm Feature Data */
    599          )
    600          {
   \                     USB_CDC_Desc_GetCountrySetting: (+1)
   \   00000000   0x0003             MOVS     R3,R0
    601            (void)(controllerId);
    602            /* if interface valid */
    603            if(interface < gCDC_Num_MaxSupportedDataInterfaces_d)
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD106             BNE.N    ??USB_CDC_Desc_GetCountrySetting_0
    604            {
    605              /* get line coding data*/
    606              *pFeatureData = gCountryCode[interface];
   \   00000008   0x....             LDR.N    R0,??DataTable10_7
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0xEB10 0x0041      ADDS     R0,R0,R1, LSL #+1
   \   00000010   0x6010             STR      R0,[R2, #+0]
    607              return gUsbErr_NoError_c;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE000             B.N      ??USB_CDC_Desc_GetCountrySetting_1
    608            }
    609            return gUsbErr_InvalidReqType_c;
   \                     ??USB_CDC_Desc_GetCountrySetting_0: (+1)
   \   00000016   0x20CD             MOVS     R0,#+205
   \                     ??USB_CDC_Desc_GetCountrySetting_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    610          }
    611          
    612          /*****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    613          uint8_t USB_CDC_Desc_SetAbstractState
    614          (
    615            uint8_t controllerId,       /* [IN] Controller ID */
    616            uint8_t interface,           /* [IN] Interface Number */
    617            uint8_t* *pFeatureData    /* [OUT] Output Comm Feature Data */
    618          )
    619          {
   \                     USB_CDC_Desc_SetAbstractState: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0003             MOVS     R3,R0
    620            uint8_t count;
    621            (void)(controllerId);
    622            /* if interface valid */
    623            if(interface < gCDC_Num_MaxSupportedDataInterfaces_d)
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD111             BNE.N    ??USB_CDC_Desc_SetAbstractState_0
    624            {
    625              /* set Abstract State Feature*/
    626              for (count = 0; count < gUSB_CDC_CommFeatureDataSize_d; count++)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0004             MOVS     R4,R0
   \                     ??USB_CDC_Desc_SetAbstractState_1: (+1)
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x2C02             CMP      R4,#+2
   \   00000012   0xDA0A             BGE.N    ??USB_CDC_Desc_SetAbstractState_2
    627              {
    628                gAbstractState[interface][count] = *(*pFeatureData + count);
   \   00000014   0x....             LDR.N    R0,??DataTable10_6
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0xEB10 0x0041      ADDS     R0,R0,R1, LSL #+1
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x6815             LDR      R5,[R2, #+0]
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x5D65             LDRB     R5,[R4, R5]
   \   00000024   0x5425             STRB     R5,[R4, R0]
    629              }
   \   00000026   0x1C64             ADDS     R4,R4,#+1
   \   00000028   0xE7F1             B.N      ??USB_CDC_Desc_SetAbstractState_1
    630              return gUsbErr_NoError_c;
   \                     ??USB_CDC_Desc_SetAbstractState_2: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE000             B.N      ??USB_CDC_Desc_SetAbstractState_3
    631            }
    632            return gUsbErr_InvalidReqType_c;
   \                     ??USB_CDC_Desc_SetAbstractState_0: (+1)
   \   0000002E   0x20CD             MOVS     R0,#+205
   \                     ??USB_CDC_Desc_SetAbstractState_3: (+1)
   \   00000030   0xBC30             POP      {R4,R5}
   \   00000032   0x4770             BX       LR               ;; return
    633          }
    634          
    635          /*****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    636          uint8_t USB_CDC_Desc_SetCountrySetting
    637          (
    638            uint8_t controllerId,       /* [IN] Controller ID */
    639            uint8_t interface,           /* [IN] Interface Number */
    640            uint8_t* *pFeatureData    /* [OUT] Output Comm Feature Data */
    641          )
    642          {
   \                     USB_CDC_Desc_SetCountrySetting: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0003             MOVS     R3,R0
    643            uint8_t count;
    644            (void)(controllerId);
    645            /* if interface valid */
    646            if(interface < gCDC_Num_MaxSupportedDataInterfaces_d)
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD111             BNE.N    ??USB_CDC_Desc_SetCountrySetting_0
    647            {
    648              for (count = 0; count < gUSB_CDC_CommFeatureDataSize_d; count++)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0004             MOVS     R4,R0
   \                     ??USB_CDC_Desc_SetCountrySetting_1: (+1)
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x2C02             CMP      R4,#+2
   \   00000012   0xDA0A             BGE.N    ??USB_CDC_Desc_SetCountrySetting_2
    649              {
    650                gCountryCode[interface][count] = *(*pFeatureData + count);
   \   00000014   0x....             LDR.N    R0,??DataTable10_7
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0xEB10 0x0041      ADDS     R0,R0,R1, LSL #+1
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x6815             LDR      R5,[R2, #+0]
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x5D65             LDRB     R5,[R4, R5]
   \   00000024   0x5425             STRB     R5,[R4, R0]
    651              }
   \   00000026   0x1C64             ADDS     R4,R4,#+1
   \   00000028   0xE7F1             B.N      ??USB_CDC_Desc_SetCountrySetting_1
    652              return gUsbErr_NoError_c;
   \                     ??USB_CDC_Desc_SetCountrySetting_2: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE000             B.N      ??USB_CDC_Desc_SetCountrySetting_3
    653            }
    654            return gUsbErr_InvalidReqType_c;
   \                     ??USB_CDC_Desc_SetCountrySetting_0: (+1)
   \   0000002E   0x20CD             MOVS     R0,#+205
   \                     ??USB_CDC_Desc_SetCountrySetting_3: (+1)
   \   00000030   0xBC30             POP      {R4,R5}
   \   00000032   0x4770             BX       LR               ;; return
    655          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     gCDC_Languages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     gCDC_StdDescriptors

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     gCDC_StdDescSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     gAlternateInterface

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     gCDC_ValidConfigValues

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     gLineCoding

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     gAbstractState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     gCountryCode
    656          
    657          
    658          
    659            
    660          #endif//gVirtualCOMPort_d

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   USB_CDC_Desc_GetAbstractState
       0   USB_CDC_Desc_GetCountrySetting
      20   USB_CDC_Desc_GetDescriptor
       0   USB_CDC_Desc_GetInterface
       4   USB_CDC_Desc_GetLineCoding
       0   USB_CDC_Desc_RemoteWakeup
       8   USB_CDC_Desc_SetAbstractState
       8   USB_CDC_Desc_SetCountrySetting
       0   USB_CDC_Desc_SetInterface
       8   USB_CDC_Desc_SetLineCoding
       0   USB_CDC_Desc_ValidConfiguration
       0   USB_CDC_Desc_ValidInterface


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
      26  USB_CDC_Desc_GetAbstractState
      26  USB_CDC_Desc_GetCountrySetting
     184  USB_CDC_Desc_GetDescriptor
      24  USB_CDC_Desc_GetInterface
      32  USB_CDC_Desc_GetLineCoding
       6  USB_CDC_Desc_RemoteWakeup
      52  USB_CDC_Desc_SetAbstractState
      52  USB_CDC_Desc_SetCountrySetting
      22  USB_CDC_Desc_SetInterface
      54  USB_CDC_Desc_SetLineCoding
      36  USB_CDC_Desc_ValidConfiguration
      34  USB_CDC_Desc_ValidInterface
       2  gAbstractState
       2  gAlternateInterface
      68  gCDCConfigDescriptor
      20  gCDCDeviceDescriptor
      20  gCDC_Languages
      16  gCDC_StdDescSize
      32  gCDC_StdDescriptors
       4  gCDC_Str0
      60  gCDC_Str1
      48  gCDC_Str2
       4  gCDC_StringDescSize
      16  gCDC_StringDescriptors
      36  gCDC_Strn
       2  gCDC_ValidConfigValues
       2  gCountryCode
       8  gLineCoding
      20  usbCdcDescEp

 
   6 bytes in section .bss
 244 bytes in section .data
 110 bytes in section .rodata
 580 bytes in section .text
 
 580 bytes of CODE  memory
 110 bytes of CONST memory
 250 bytes of DATA  memory

Errors: none
Warnings: none
