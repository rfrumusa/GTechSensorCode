///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM       02/Sep/2018  13:33:21
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\Driver\usb_driver.c
//    Command line =  
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\Driver\usb_driver.c" -D IAR --preprocess
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\" -lC
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\" -lB
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\"
//        --diag_suppress Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\Obj\" --no_cse
//        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
//        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\APP\CDC\" -I "F:\Guardrail Work\Sensor Code\Git
//        Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\USB\APP\Descriptor\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Class\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Sys Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
//    List file    =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\usb_driver.s
//
///////////////////////////////////////////////////////////////////////////////

        #define SHT_PROGBITS 0x1

        EXTERN MemorySet
        EXTERN USB_DCI_DeInit
        EXTERN USB_DCI_DeinitEndpoint
        EXTERN USB_DCI_Init
        EXTERN USB_DCI_InitEndpoint
        EXTERN USB_DeviceStallEndpoint
        EXTERN USB_DeviceUnstallEndpoint

        PUBLIC USB_DeviceCallService
        PUBLIC USB_DeviceDeinit
        PUBLIC USB_DeviceDeinitEndpoint
        PUBLIC USB_DeviceGetStatus
        PUBLIC USB_DeviceInit
        PUBLIC USB_DeviceInitEndpoint
        PUBLIC USB_DeviceRegisterService
        PUBLIC USB_DeviceSetStatus
        PUBLIC USB_DeviceUnregisterService

// F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\usb_driver.c
//    1 /******************************************************************************
//    2  *
//    3  * Freescale Semiconductor Inc.
//    4  * (c) Copyright 2004-2010 Freescale Semiconductor, Inc.
//    5  * ALL RIGHTS RESERVED.
//    6  *
//    7  ******************************************************************************
//    8  *
//    9  * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR 
//   10  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
//   11  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
//   12  * IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
//   13  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
//   14  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
//   15  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
//   16  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
//   17  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
//   18  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
//   19  * THE POSSIBILITY OF SUCH DAMAGE.
//   20  *
//   21  **************************************************************************//*!
//   22  *
//   23  * @file usb_driver.c
//   24  *
//   25  * @author
//   26  *
//   27  * @version
//   28  *
//   29  * @date
//   30  *
//   31  * @brief The file contains S08 USB stack device layer implementation.
//   32  *
//   33  *****************************************************************************/
//   34 
//   35 /******************************************************************************
//   36  * Includes
//   37  *****************************************************************************/
//   38 #include "USB_Interface.h"
//   39 #include "USB.h"
//   40 #include "usb_devapi.h" /* USB Device Layer API Header File */
//   41 #include "usb_dciapi.h" /* USB Controller API Header File */
//   42 #include "Utilities_Interface.h" 
//   43 
//   44 #if gUsbIncluded_d
//   45 /*****************************************************************************
//   46  * Constant and Macro's
//   47  *****************************************************************************/
//   48 
//   49 
//   50 /****************************************************************************
//   51  * Global Variables
//   52  ****************************************************************************/
//   53 
//   54 /* Array of USB Service pointers */
//   55 #define gUsbCB(controller_ID) gUsbCB_

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   56 static usbServiceCallback_t gUsbCB_[gUsbService_Max_d];  
gUsbCB_:
        DS8 88
//   57 /* Array of USB Component Status */
//   58 /* Test mode is the last service */
//   59 #define gUsbComponentStatus(controller_ID) gUsbComponentStatus_

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   60 static uint16_t gUsbComponentStatus_[gUsbComponentStatus_TestMode_d]; 
gUsbComponentStatus_:
        DS8 16
//   61 /* Array of USB Endpoint Status */
//   62 #define gUsbEpStatus(controller_ID) gUsbEpStatus_

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   63 static uint16_t gUsbEpStatus_[gNumMaxEnpNumber_d];
gUsbEpStatus_:
        DS8 32
//   64 /* Current un-initialized non CONTROL Endpoint */
//   65 #define gEpNo(controller_ID) gEpNo_

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   66 static uint8_t gEpNo_=0;     
gEpNo_:
        DS8 1
//   67 /* Maximum number of Non CONTROL Endpoint required by upper layer */
//   68 #define gEpNoMax(controller_ID) gEpNoMax_

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   69 static uint8_t gEpNoMax_=0; 
gEpNoMax_:
        DS8 1
//   70 
//   71 /*****************************************************************************
//   72  * Local Types - None
//   73  *****************************************************************************/
//   74 
//   75 /*****************************************************************************
//   76  * Local Functions Prototypes - None
//   77  *****************************************************************************/
//   78 static void USB_DeviceInitParams(uint8_t    controllerId);
//   79 
//   80 /*****************************************************************************
//   81  * Local Variables - None
//   82  *****************************************************************************/
//   83 
//   84 /*****************************************************************************
//   85  * Local Functions 
//   86  *****************************************************************************/
//   87 /**************************************************************************//*!
//   88  *
//   89  * @name  USB_DeviceInitParams
//   90  *
//   91  * @brief The funtion initializes the Device Layer Structures
//   92  *
//   93  * @param  None
//   94  *
//   95  * @return None
//   96  *
//   97  ******************************************************************************
//   98  * Initializes USB Device Layer Structures
//   99  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  100 static void USB_DeviceInitParams(uint8_t    controllerId)
//  101 {
//  102   uint8_t loopIndex=0;
USB_DeviceInitParams:
        MOVS     R1,#+0
//  103   (void)controllerId;
//  104   gEpNo(controllerId)= gEpNoMax(controllerId); /* 1 control endpoint */
        LDR.N    R2,??DataTable9
        LDRB     R2,[R2, #+0]
        LDR.N    R3,??DataTable9_1
        STRB     R2,[R3, #+0]
//  105     /* 
//  106        Initialize gUsbComponentStatus_DeviceState_d, gUsbComponentStatus_Interface_d,
//  107        gUsbComponentStatus_Address_d, gUsbComponentStatus_CurrentConfig_d, gUsbComponentStatus_SOFCount_d
//  108        and gUsbComponentStatus_Device_d to gUsbStatus_Unknown_d 
//  109     */
//  110   for(loopIndex = 0; loopIndex < gUsbComponentStatus_TestMode_d; loopIndex++)
        MOVS     R2,#+0
        MOVS     R1,R2
??USB_DeviceInitParams_0:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+7
        BGE.N    ??USB_DeviceInitParams_1
//  111   {
//  112     gUsbComponentStatus(controllerId)[loopIndex] = gUsbStatus_Unknown_d;
        MOVW     R2,#+65535
        LDR.N    R3,??DataTable9_2
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRH     R2,[R3, R1, LSL #+1]
//  113   }
        ADDS     R1,R1,#+1
        B.N      ??USB_DeviceInitParams_0
//  114   /* Initialize status of All Endpoints to gUsbStatus_Disabled_d */
//  115   for(loopIndex = 0; loopIndex < gNumMaxEnpNumber_d; loopIndex++)
??USB_DeviceInitParams_1:
        MOVS     R2,#+0
        MOVS     R1,R2
??USB_DeviceInitParams_2:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+16
        BGE.N    ??USB_DeviceInitParams_3
//  116   {
//  117     gUsbEpStatus(controllerId)[loopIndex] = gUsbStatus_Disabled_d;
        MOVS     R2,#+5
        LDR.N    R3,??DataTable9_3
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRH     R2,[R3, R1, LSL #+1]
//  118   }
        ADDS     R1,R1,#+1
        B.N      ??USB_DeviceInitParams_2
//  119 }
??USB_DeviceInitParams_3:
        BX       LR               ;; return
//  120 
//  121 
//  122 
//  123 /*****************************************************************************
//  124  * Global Functions
//  125  *****************************************************************************/
//  126 
//  127 
//  128 /**************************************************************************//*!
//  129  *
//  130  * @name  USB_DeviceInit
//  131  *
//  132  * @brief The funtion initializes the Device and Controller layer
//  133  *
//  134  * @param controller_ID : Controller ID
//  135  * @param endpoints     : Endpoint count of the application
//  136  *
//  137  * @return status
//  138  *         gUsbErr_NoError_c                              : When Successfull
//  139  *         gUsbErr_InvalidNumOfEndpoints_c     : When endpoints > max Supported
//  140  ******************************************************************************
//  141  * This function initializes the Device layer and the Controller layer of the
//  142  * S08 USB stack. It initialised the variables used for this layer and then
//  143  * calls the controller layer initialize function
//  144  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  145 uint8_t USB_DeviceInit (
//  146     uint8_t    controllerId, /* [IN] Controller ID */
//  147     uint8_t    endpoints      /* [IN] Endpoint count of the application */
//  148 )
//  149 {
USB_DeviceInit:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
        MOVS     R5,R1
//  150 
//  151   /* validate endpoints param */
//  152   if((endpoints > gNumMaxEnpNumber_d) || (endpoints < gNumMinEnpNumber_d))
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+17
        BGE.N    ??USB_DeviceInit_0
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BNE.N    ??USB_DeviceInit_1
//  153   {
//  154     return gUsbErr_InvalidNumOfEndpoints_c;
??USB_DeviceInit_0:
        MOVS     R0,#+153
        B.N      ??USB_DeviceInit_2
//  155   }
//  156   /*init variables */
//  157   gEpNoMax(controllerId) = endpoints - 1;
??USB_DeviceInit_1:
        SUBS     R0,R5,#+1
        LDR.N    R1,??DataTable9
        STRB     R0,[R1, #+0]
//  158   USB_DeviceInitParams(controllerId);
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceInitParams
//  159   /* Initialize all services to null value */
//  160   MemorySet(gUsbCB(controllerId), 0, (uint16_t)(sizeof(usbServiceCallback_t) * gUsbService_Max_d));
        MOVS     R2,#+88
        MOVS     R1,#+0
        LDR.N    R0,??DataTable9_4
        BL       MemorySet
//  161     /* Call controller layer initialization function */
//  162   return USB_DCI_Init(controllerId);
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_Init
??USB_DeviceInit_2:
        POP      {R1,R4,R5,PC}    ;; return
//  163 
//  164 }
//  165 /**************************************************************************//*!
//  166  *
//  167  * @name  USB_DeviceDeinit
//  168  *
//  169  * @brief The funtion initializes the Device and Controller layer
//  170  *
//  171  * @param controller_ID : Controller ID
//  172  * @param endpoints     : Endpoint count of the application
//  173  *
//  174  * @return status
//  175  *         gUsbErr_NoError_c                              : When Successfull
//  176  *         gUsbErr_InvalidNumOfEndpoints_c     : When endpoints > max Supported
//  177  ******************************************************************************
//  178  * This function initializes the Device layer and the Controller layer of the
//  179  * S08 USB stack. It initialised the variables used for this layer and then
//  180  * calls the controller layer initialize function
//  181  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  182 uint8_t USB_DeviceDeinit (
//  183     uint8_t    controllerId /* [IN] Controller ID */
//  184 )
//  185 {
USB_DeviceDeinit:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
//  186   uint8_t error;
//  187   error = USB_DCI_DeInit(controllerId );
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_DeInit
        MOVS     R5,R0
//  188   gEpNoMax(controllerId) = 0; //Keep this order
        MOVS     R0,#+0
        LDR.N    R1,??DataTable9
        STRB     R0,[R1, #+0]
//  189   USB_DeviceInitParams(controllerId);
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceInitParams
//  190   /* Initialize all services to null value */
//  191   MemorySet(gUsbCB(controllerId), 0, (uint16_t)(sizeof(usbServiceCallback_t) * gUsbService_Max_d));
        MOVS     R2,#+88
        MOVS     R1,#+0
        LDR.N    R0,??DataTable9_4
        BL       MemorySet
//  192   return error;
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R1,R4,R5,PC}    ;; return
//  193 }
//  194 
//  195 /**************************************************************************//*!
//  196  *
//  197  * @name  USB_DeviceInitEndpoint
//  198  *
//  199  * @brief The funtion initializes the endpoint
//  200  *
//  201  * @param controller_ID : Controller ID
//  202  * @param ep_ptr        : Pointer to endpoint detail structure
//  203  * @param flag          : Zero termination flag
//  204  *
//  205  * @return status
//  206  *         gUsbErr_NoError_c                              : When Successfull
//  207  *         gUsbErr_EpInitFailed_c     : When endpoints > max Supported
//  208  ******************************************************************************
//  209  *
//  210  * This function initializes an endpoint the Device layer and the Controller
//  211  * layer in the S08 USB stack. It validate whether all endpoints have already
//  212  * been initialized or not and then calls the controller layer endpoint
//  213  *  initialize function
//  214  *
//  215  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  216 uint8_t USB_DeviceInitEndpoint (
//  217     uint8_t               controllerId, /* [IN] Controller ID */
//  218     usbEpStruct_t*        pUsbEpStruct,        /* [IN] Pointer to endpoint detail
//  219                                             structure */
//  220     uint8_t               flag           /* [IN] Zero termination flag */
//  221 )
//  222 {
USB_DeviceInitEndpoint:
        PUSH     {R3-R7,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
//  223   uint8_t status=gUsbErr_NoError_c;
        MOVS     R7,#+0
//  224   /* check if all endpoint have already been initialised */
//  225   if((gEpNo(controllerId) == 0) && (pUsbEpStruct->number != gUsbControlEndpoint_d))
        LDR.N    R0,??DataTable9_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??USB_DeviceInitEndpoint_0
        LDRB     R0,[R5, #+0]
        CMP      R0,#+0
        BEQ.N    ??USB_DeviceInitEndpoint_0
//  226   {
//  227     return gUsbErr_EpInitFailed_c;
        MOVS     R0,#+149
        B.N      ??USB_DeviceInitEndpoint_1
//  228   }
//  229   /* call controller layer for initiazation */
//  230   status = USB_DCI_InitEndpoint(controllerId, pUsbEpStruct, flag);
??USB_DeviceInitEndpoint_0:
        MOVS     R2,R6
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,R5
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_InitEndpoint
        MOVS     R7,R0
//  231   /* if endpoint successfully initialised update counter */
//  232   if ((pUsbEpStruct->number != gUsbControlEndpoint_d) && (status == gUsbErr_NoError_c))
        LDRB     R0,[R5, #+0]
        CMP      R0,#+0
        BEQ.N    ??USB_DeviceInitEndpoint_2
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+0
        BNE.N    ??USB_DeviceInitEndpoint_2
//  233   {
//  234     gEpNo(controllerId)--;
        LDR.N    R0,??DataTable9_1
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        LDR.N    R1,??DataTable9_1
        STRB     R0,[R1, #+0]
//  235   }
//  236 
//  237   return status;
??USB_DeviceInitEndpoint_2:
        MOVS     R0,R7
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
??USB_DeviceInitEndpoint_1:
        POP      {R1,R4-R7,PC}    ;; return
//  238 }
//  239 
//  240 
//  241 /**************************************************************************//*!
//  242  *
//  243  * @name  USB_DeviceDeinitEndpoint
//  244  *
//  245  * @brief The funtion De-initializes the endpoint
//  246  *
//  247  * @param controller_ID : Controller ID
//  248  * @param ep_ptr        : Pointer to endpoint detail structure
//  249  * @param flag          : Zero termination flag
//  250  *
//  251  * @return status
//  252  *         gUsbErr_NoError_c                              : When Successfull
//  253  *         gUsbErr_EpDeinitFailed_c     : When endpoints > max Supported
//  254  ******************************************************************************
//  255  *
//  256  * This function deinitializes an endpoint the Device layer and the Controller
//  257  * layer in the S08 USB stack. It validate whether all endpoints have already
//  258  * been deinitialized or not and then calls the controller layer endpoint
//  259  * deinitialize function
//  260  *
//  261  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  262 uint8_t USB_DeviceDeinitEndpoint (
//  263     uint8_t    controllerId,  /* [IN] Controller ID */
//  264     uint8_t    epNum,         /* [IN] Endpoint number */
//  265     uint8_t    direction       /* [IN] Direction */
//  266 )
//  267 {
USB_DeviceDeinitEndpoint:
        PUSH     {R3-R7,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
//  268   uint8_t status=gUsbErr_NoError_c;
        MOVS     R7,#+0
//  269   /* check if all endpoint have already been initialised */
//  270   if((gEpNo(controllerId) == gEpNoMax(controllerId)) && (epNum != gUsbControlEndpoint_d))
        LDR.N    R0,??DataTable9_1
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable9
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BNE.N    ??USB_DeviceDeinitEndpoint_0
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BEQ.N    ??USB_DeviceDeinitEndpoint_0
//  271   {
//  272     return gUsbErr_EpDeinitFailed_c;
        MOVS     R0,#+150
        B.N      ??USB_DeviceDeinitEndpoint_1
//  273   }
//  274   /* call controller layer for initiazation */
//  275   status = USB_DCI_DeinitEndpoint(controllerId, epNum, direction);
??USB_DeviceDeinitEndpoint_0:
        MOVS     R2,R6
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,R5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_DeinitEndpoint
        MOVS     R7,R0
//  276   /* if endpoint successfully deinitialised update counter */
//  277   if ((epNum != gUsbControlEndpoint_d) && (status == gUsbErr_NoError_c))
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BEQ.N    ??USB_DeviceDeinitEndpoint_2
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+0
        BNE.N    ??USB_DeviceDeinitEndpoint_2
//  278   {
//  279     gEpNo(controllerId)++;
        LDR.N    R0,??DataTable9_1
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR.N    R1,??DataTable9_1
        STRB     R0,[R1, #+0]
//  280   }
//  281 
//  282     return status;
??USB_DeviceDeinitEndpoint_2:
        MOVS     R0,R7
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
??USB_DeviceDeinitEndpoint_1:
        POP      {R1,R4-R7,PC}    ;; return
//  283 }
//  284 
//  285 /**************************************************************************//*!
//  286  *
//  287  * @name  USB_DeviceGetStatus
//  288  *
//  289  * @brief The funtion retrieves various endpoint as well as USB component status
//  290  *
//  291  * @param controller_ID : Controller ID
//  292  * @param component     : USB component
//  293  * @param status        : Pointer to 16 bit return value
//  294  *
//  295  * @return status
//  296  *         gUsbErr_NoError_c                : When Successfull
//  297  *         gUsbErr_BadStatus_c     : When error
//  298  *
//  299  ******************************************************************************
//  300  * This function retrieves the endpoint as well USB component status which is
//  301  * stored by calling USB_DeviceSetStatus. This function can be called by Ap-
//  302  * plication as well as the DCI layer.
//  303  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  304 uint8_t USB_DeviceGetStatus (
//  305     uint8_t        controllerId,  /* [IN]  Controller ID  */
//  306     uint8_t        component,      /* [IN]  USB component */
//  307     uint16_t*   status          /* [OUT] Pointer to 16 bit return value */
//  308 )
//  309 {
USB_DeviceGetStatus:
        PUSH     {R4}
        MOVS     R3,R0
//  310   /* get the endpoint number from component input variable */
//  311   uint8_t epNum = (uint8_t)(component & gUsbComponentStatus_EpNumberMask_d);
        ANDS     R4,R1,#0xF
//  312   (void)controllerId;
//  313   
//  314   if((component <= gUsbComponentStatus_TestMode_d) && (component >= gUsbComponentStatus_DeviceState_d))
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+8
        BGE.N    ??USB_DeviceGetStatus_0
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BEQ.N    ??USB_DeviceGetStatus_0
//  315   {
//  316   /* Get the corresponding component status  -1 as components start from 1 */
//  317     *status = gUsbComponentStatus(controllerId)[component-1];
        LDR.N    R0,??DataTable9_2
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        ADDS     R0,R0,R1, LSL #+1
        LDRH     R0,[R0, #-2]
        STRH     R0,[R2, #+0]
        B.N      ??USB_DeviceGetStatus_1
//  318   }
//  319   else if ((component & gUsbComponentStatus_Endpoint_d) && (epNum < gNumMaxEnpNumber_d))
??USB_DeviceGetStatus_0:
        LSLS     R0,R1,#+27
        BPL.N    ??USB_DeviceGetStatus_2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+16
        BGE.N    ??USB_DeviceGetStatus_2
//  320   {
//  321     /* Get the corresponding endpoint status */
//  322     *status = gUsbEpStatus(controllerId)[epNum];
        LDR.N    R0,??DataTable9_3
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRH     R0,[R0, R4, LSL #+1]
        STRH     R0,[R2, #+0]
        B.N      ??USB_DeviceGetStatus_1
//  323   }
//  324   else
//  325   {
//  326     return gUsbErr_BadStatus_c;
??USB_DeviceGetStatus_2:
        MOVS     R0,#+130
        B.N      ??USB_DeviceGetStatus_3
//  327   }
//  328 
//  329   return gUsbErr_NoError_c;
??USB_DeviceGetStatus_1:
        MOVS     R0,#+0
??USB_DeviceGetStatus_3:
        POP      {R4}
        BX       LR               ;; return
//  330 }
//  331 
//  332 /**************************************************************************//*!
//  333  *
//  334  * @name  USB_DeviceSetStatus
//  335  *
//  336  * @brief The funtion saves status of endpoints as well as USB components.
//  337  *
//  338  * @param controller_ID : Controller ID
//  339  * @param component     : USB component
//  340  * @param setting       : Value to be set
//  341  *
//  342  * @return status
//  343  *         gUsbErr_NoError_c                : When Successfull
//  344  *         gUsbErr_BadStatus_c     : When error
//  345  *
//  346  ******************************************************************************
//  347  * This function sets the endpoint as well USB component status which can be
//  348  * retrieved by calling USB_DeviceGetStatus. This function can be called by
//  349  * Application as well as the DCI layer.
//  350  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  351 uint8_t USB_DeviceSetStatus(
//  352     uint8_t    controllerId,  /* [IN] Controller ID */
//  353     uint8_t    component,      /* [IN] USB component */
//  354     uint16_t   setting         /* [IN] Value to be set */
//  355 )
//  356 {
USB_DeviceSetStatus:
        PUSH     {R4-R8,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
//  357   /* get the endpoint number from component input variable */
//  358   uint8_t epNum = (uint8_t)(component & gUsbComponentStatus_EpNumberMask_d);
        ANDS     R7,R5,#0xF
//  359   if((component <= gUsbComponentStatus_TestMode_d) && (component >= gUsbComponentStatus_DeviceState_d))
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+8
        BGE.N    ??USB_DeviceSetStatus_0
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BEQ.N    ??USB_DeviceSetStatus_0
//  360   {
//  361     /* Set the corresponding component setting  -1 as components start from 1   */
//  362     gUsbComponentStatus(controllerId)[component-1] = setting;
        LDR.N    R0,??DataTable9_2
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        ADDS     R0,R0,R5, LSL #+1
        STRH     R6,[R0, #-2]
        B.N      ??USB_DeviceSetStatus_1
//  363   }
//  364   else if ((component & gUsbComponentStatus_Endpoint_d) && (epNum < gNumMaxEnpNumber_d))
??USB_DeviceSetStatus_0:
        LSLS     R0,R5,#+27
        BPL.N    ??USB_DeviceSetStatus_2
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+16
        BGE.N    ??USB_DeviceSetStatus_2
//  365   {
//  366     uint8_t direction = (uint8_t)((component >> gUsbComponent_DirectionShift_d) & gUsbComponent_DirectionMask_d);
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        LSRS     R8,R5,#+7
//  367     /* HALT Endpoint */
//  368     if(setting == gUsbStatus_Stalled_d)
        UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
        CMP      R6,#+1
        BNE.N    ??USB_DeviceSetStatus_3
//  369     {
//  370       USB_DeviceStallEndpoint(controllerId, epNum, direction);
        MOV      R2,R8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,R7
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceStallEndpoint
        B.N      ??USB_DeviceSetStatus_4
//  371     }
//  372     else if((setting == gUsbStatus_Idle_d) && (gUsbEpStatus(controllerId)[epNum] == gUsbStatus_Stalled_d))
??USB_DeviceSetStatus_3:
        UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
        CMP      R6,#+0
        BNE.N    ??USB_DeviceSetStatus_4
        LDR.N    R0,??DataTable9_3
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRH     R0,[R0, R7, LSL #+1]
        CMP      R0,#+1
        BNE.N    ??USB_DeviceSetStatus_4
//  373     {
//  374       USB_DeviceUnstallEndpoint(controllerId, epNum, direction);
        MOV      R2,R8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,R7
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceUnstallEndpoint
//  375       if(epNum == gUsbControlEndpoint_d)
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+0
        BNE.N    ??USB_DeviceSetStatus_4
//  376       {
//  377         direction = (uint8_t)((direction == gUsbEpDirection_In_c)?(gUsbEpDirection_Out_c):(gUsbEpDirection_In_c));
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+1
        BNE.N    ??USB_DeviceSetStatus_5
        MOVS     R8,#+0
        B.N      ??USB_DeviceSetStatus_6
??USB_DeviceSetStatus_5:
        MOVS     R8,#+1
//  378         USB_DeviceUnstallEndpoint(controllerId, epNum, direction);
??USB_DeviceSetStatus_6:
        MOV      R2,R8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,R7
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceUnstallEndpoint
//  379       }
//  380     }
//  381         /* Set the corresponding endpoint setting */
//  382     gUsbEpStatus(controllerId)[epNum] = setting;
??USB_DeviceSetStatus_4:
        LDR.N    R0,??DataTable9_3
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        STRH     R6,[R0, R7, LSL #+1]
        B.N      ??USB_DeviceSetStatus_1
//  383   }
//  384   else
//  385   {
//  386     return gUsbErr_BadStatus_c;
??USB_DeviceSetStatus_2:
        MOVS     R0,#+130
        B.N      ??USB_DeviceSetStatus_7
//  387   }
//  388   return gUsbErr_NoError_c;
??USB_DeviceSetStatus_1:
        MOVS     R0,#+0
??USB_DeviceSetStatus_7:
        POP      {R4-R8,PC}       ;; return
//  389 }
//  390 
//  391 /**************************************************************************//*!
//  392  *
//  393  * @name  USB_DeviceRegisterService
//  394  *
//  395  * @brief The funtion registers a callback function from the Application layer
//  396  *
//  397  * @param controller_ID : Controller ID
//  398  * @param type          : event type or endpoint number
//  399  * @param service       : callback function pointer
//  400  *
//  401  * @return status
//  402  *         gUsbErr_NoError_c                   : When Successfull
//  403  *         gUsbErr_AllocService_c     : When invalid type or already registered
//  404  *
//  405  ******************************************************************************
//  406  * This function registers a callback function from the application if it is
//  407  * called not already registered so that the regitered callback function can
//  408  * be if the event of that type occurs
//  409  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  410 uint8_t USB_DeviceRegisterService(
//  411     uint8_t                    controllerId, /* [IN] Controller ID           */
//  412     uint8_t                    type,          /* [IN] type of event or endpoint
//  413                                                      number to service       */
//  414     usbServiceCallback_t      service        /* [IN] pointer to callback
//  415                                                      function                */
//  416 )
//  417 {
USB_DeviceRegisterService:
        MOVS     R3,R0
//  418   (void)controllerId;
//  419   /* check if the type is valid and callback for the type is not already registered */
//  420   if(((type  <= gUsbService_EpMax_d) ||
//  421         ((type < gUsbService_Max_d) && (type >= gUsbService_BusReset_d))) &&
//  422        (gUsbCB(controllerId)[type] == NULL))
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+16
        BLT.N    ??USB_DeviceRegisterService_0
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+22
        BGE.N    ??USB_DeviceRegisterService_1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+16
        BLT.N    ??USB_DeviceRegisterService_1
??USB_DeviceRegisterService_0:
        LDR.N    R0,??DataTable9_4
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR      R0,[R0, R1, LSL #+2]
        CMP      R0,#+0
        BNE.N    ??USB_DeviceRegisterService_1
//  423   {
//  424     /* register the callback function */
//  425     gUsbCB(controllerId)[type] = service;
        LDR.N    R0,??DataTable9_4
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STR      R2,[R0, R1, LSL #+2]
//  426     return gUsbErr_NoError_c;
        MOVS     R0,#+0
        B.N      ??USB_DeviceRegisterService_2
//  427   }
//  428   else
//  429   {
//  430     return gUsbErr_AllocService_c;
??USB_DeviceRegisterService_1:
        MOVS     R0,#+140
??USB_DeviceRegisterService_2:
        BX       LR               ;; return
//  431   }
//  432 }
//  433 
//  434 /**************************************************************************//*!
//  435  *
//  436  * @name  USB_DeviceUnregisterService
//  437  *
//  438  * @brief The funtion unregisters an event or endpoint callback function
//  439  *
//  440  * @param controller_ID : Controller ID
//  441  * @param type          : event type or endpoint number
//  442  *
//  443  * @return status
//  444  *         gUsbErr_NoError_c                   : When Successfull
//  445  *         gUsbErr_UnknownError_c     : When invalid type or not registered
//  446  *
//  447  *****************************************************************************
//  448  * This function un registers a callback function which has been previously
//  449  * registered by the application layer
//  450  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  451 uint8_t USB_DeviceUnregisterService(
//  452       uint8_t controllerId, /* [IN] Controller ID */
//  453       uint8_t type           /* [IN] type of event or endpoint number
//  454                                 to service */
//  455 )
//  456 {
USB_DeviceUnregisterService:
        MOVS     R2,R0
//  457    (void)controllerId;
//  458   /* check if the type is valid and callback for the type is already registered */
//  459   if(((type  <= gUsbService_EpMax_d) ||
//  460      ((type < gUsbService_Max_d) && (type >= gUsbService_BusReset_d))) &&
//  461      (gUsbCB(controllerId)[type] != NULL))
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+16
        BLT.N    ??USB_DeviceUnregisterService_0
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+22
        BGE.N    ??USB_DeviceUnregisterService_1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+16
        BLT.N    ??USB_DeviceUnregisterService_1
??USB_DeviceUnregisterService_0:
        LDR.N    R0,??DataTable9_4
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR      R0,[R0, R1, LSL #+2]
        CMP      R0,#+0
        BEQ.N    ??USB_DeviceUnregisterService_1
//  462   {
//  463     /* unregister the callback */
//  464     gUsbCB(controllerId)[type] = NULL;
        MOVS     R0,#+0
        LDR.N    R3,??DataTable9_4
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STR      R0,[R3, R1, LSL #+2]
//  465     return gUsbErr_NoError_c;
        MOVS     R0,#+0
        B.N      ??USB_DeviceUnregisterService_2
//  466   }
//  467   else
//  468   {
//  469     return gUsbErr_UnknownError_c;
??USB_DeviceUnregisterService_1:
        MOVS     R0,#+196
??USB_DeviceUnregisterService_2:
        BX       LR               ;; return
//  470   }
//  471 }
//  472 
//  473 /**************************************************************************//*!
//  474  *
//  475  * @name  USB_DeviceCallService
//  476  *
//  477  * @brief The funtion is a device layer event handler
//  478  *
//  479  * @param type  : Type of service or endpoint
//  480  * @param event : Pointer to event structure
//  481  *
//  482  * @return status
//  483  *         gUsbErr_NoError_c      : Always
//  484  *
//  485  *****************************************************************************
//  486  *
//  487  * This function calls the registered service callback function of the applic-
//  488  * ation layer based on the type of event received. This function is called
//  489  * from the DCI layer.
//  490  *
//  491  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  492 uint8_t USB_DeviceCallService(
//  493     uint8_t             type,    /* [IN] Type of service or endpoint */
//  494     usbDeviceEvent_t *  pUsbDeviceEvent    /* [IN] Pointer to event structure  */
//  495 )
//  496 {
USB_DeviceCallService:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
        MOVS     R5,R1
//  497   if(type == gUsbService_BusReset_d)
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+16
        BNE.N    ??USB_DeviceCallService_0
//  498   {    /* if it is an reset interrupt then reset all status structures */
//  499     USB_DeviceInitParams(pUsbDeviceEvent->controllerId);
        LDRB     R0,[R5, #+0]
        BL       USB_DeviceInitParams
//  500   }
//  501 
//  502   /* check if the callback is registered or not */
//  503   if(gUsbCB(pUsbDeviceEvent->controllerId)[type] != NULL)
??USB_DeviceCallService_0:
        LDR.N    R0,??DataTable9_4
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDR      R0,[R0, R4, LSL #+2]
        CMP      R0,#+0
        BEQ.N    ??USB_DeviceCallService_1
//  504   {
//  505     /* call the callback function */
//  506     gUsbCB(pUsbDeviceEvent->controllerId)[type](pUsbDeviceEvent);
        MOVS     R0,R5
        LDR.N    R1,??DataTable9_4
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDR      R1,[R1, R4, LSL #+2]
        BLX      R1
//  507   }
//  508 
//  509   return gUsbErr_NoError_c;
??USB_DeviceCallService_1:
        MOVS     R0,#+0
        POP      {R1,R4,R5,PC}    ;; return
//  510 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable9:
        DC32     gEpNoMax_

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable9_1:
        DC32     gEpNo_

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable9_2:
        DC32     gUsbComponentStatus_

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable9_3:
        DC32     gUsbEpStatus_

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable9_4:
        DC32     gUsbCB_

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        END
//  511 
//  512 #endif// gUsbIncluded_d
// 
// 138 bytes in section .bss
// 720 bytes in section .text
// 
// 720 bytes of CODE memory
// 138 bytes of DATA memory
//
//Errors: none
//Warnings: none
