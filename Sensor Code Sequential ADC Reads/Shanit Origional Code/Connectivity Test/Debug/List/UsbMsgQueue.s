///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM       02/Sep/2018  14:19:44
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\Common\UsbMsgQueue.c
//    Command line =  
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\Common\UsbMsgQueue.c" -D IAR --preprocess
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\" -lC
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\" -lB
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\"
//        --diag_suppress Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\Obj\" --no_cse
//        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
//        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\APP\CDC\" -I "F:\Guardrail Work\Sensor Code\Git
//        Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\USB\APP\Descriptor\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Class\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Sys Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
//    List file    =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\Debug\List\UsbMsgQueue.s
//
///////////////////////////////////////////////////////////////////////////////

        #define SHT_PROGBITS 0x1

        EXTERN USB_Lock
        EXTERN USB_UnLock
        EXTERN __aeabi_memcpy4

        PUBLIC UsbMsgQueue_GetFirstMsg
        PUBLIC UsbMsgQueue_Init
        PUBLIC UsbMsgQueue_MsgNo
        PUBLIC UsbMsgQueue_MsgPending
        PUBLIC UsbMsgQueue_Pop
        PUBLIC UsbMsgQueue_Push

// F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\UsbMsgQueue.c
//    1 /************************************************************************************
//    2 * Source file of the application specific memory system
//    3 *
//    4 * (c) Copyright 2010, Freescale, Inc. All rights reserved.
//    5 *
//    6 *
//    7 * No part of this document must be reproduced in any form - including copied,
//    8 * transcribed, printed or by any electronic means - without specific written
//    9 * permission from Freescale Semiconductor.
//   10 *
//   11 *****************************************************************************/
//   12 
//   13 #include "EmbeddedTypes.h"
//   14 #include "Interrupt.h"
//   15 #include "UsbMsgQueue.h" 
//   16 #include "USB.h" 
//   17 #include "USB_Configuration.h" 
//   18 
//   19 #if gUsbIncluded_d
//   20 
//   21 /******************************************************************************
//   22 *******************************************************************************
//   23 * Private macros
//   24 *******************************************************************************
//   25 ******************************************************************************/
//   26 /* The USB module uses one single pool of messages containing messages used 
//   27 from the Interrupt handler to signal events to the USB task */
//   28 
//   29 #define mUsbMsgQueueSize (6*gNumUsbControllers_d + gNumUsbEp_d )
//   30 /******************************************************************************
//   31 *******************************************************************************
//   32 * Private prototypes
//   33 *******************************************************************************
//   34 ******************************************************************************/
//   35 
//   36 /******************************************************************************
//   37 *******************************************************************************
//   38 * Private type definitions
//   39 *******************************************************************************
//   40 ******************************************************************************/
//   41 
//   42 /******************************************************************************
//   43 *******************************************************************************
//   44 * Private memory declarations
//   45 *******************************************************************************
//   46 ******************************************************************************/

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   47 static uint8_t usbMsgQueue_head;
usbMsgQueue_head:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   48 static uint8_t usbMsgQueue_tail;
usbMsgQueue_tail:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   49 static uint8_t usbMsgQueue_msgNo;
usbMsgQueue_msgNo:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   50 static usbMsg_t maUsbMsgQueue[mUsbMsgQueueSize];
maUsbMsgQueue:
        DS8 176
//   51 
//   52 /******************************************************************************
//   53 *******************************************************************************
//   54 * Public memory declarations
//   55 *******************************************************************************
//   56 ******************************************************************************/
//   57 
//   58 /******************************************************************************
//   59 *******************************************************************************
//   60 * Public functions
//   61 *******************************************************************************
//   62 ******************************************************************************/
//   63 
//   64 /******************************************************************************
//   65 * UsbMsgQueueInit
//   66 This function suppose to be used in the app init when interrupts are disabled
//   67 ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//   68 void UsbMsgQueue_Init(void)
//   69 {
//   70 usbMsgQueue_head = usbMsgQueue_tail = usbMsgQueue_msgNo = 0;
UsbMsgQueue_Init:
        MOVS     R0,#+0
        LDR.N    R1,??DataTable5
        STRB     R0,[R1, #+0]
        LDR.N    R1,??DataTable5_1
        STRB     R0,[R1, #+0]
        LDR.N    R1,??DataTable5_2
        STRB     R0,[R1, #+0]
//   71 } 
        BX       LR               ;; return
//   72 
//   73 /******************************************************************************
//   74 * UsbMsgQueue_Push
//   75 To be used only from the USB interrupt.
//   76 ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//   77 usbMsgQueueErr_t UsbMsgQueue_Push(usbMsg_t* pUsbMsg)
//   78 {
UsbMsgQueue_Push:
        PUSH     {R4,LR}
        MOVS     R4,R0
//   79   if(usbMsgQueue_msgNo == mUsbMsgQueueSize)
        LDR.N    R0,??DataTable5
        LDRB     R0,[R0, #+0]
        CMP      R0,#+11
        BNE.N    ??UsbMsgQueue_Push_0
//   80     {
//   81       return usbMsgQueueErr_QueueFull;
        MOVS     R0,#+1
        B.N      ??UsbMsgQueue_Push_1
//   82     }
//   83   maUsbMsgQueue[usbMsgQueue_head] = *pUsbMsg;
??UsbMsgQueue_Push_0:
        LDR.N    R0,??DataTable5_3
        LDR.N    R1,??DataTable5_2
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+4
        MOVS     R1,R4
        MOVS     R2,#+16
        BL       __aeabi_memcpy4
//   84   if(++usbMsgQueue_head == mUsbMsgQueueSize)
        LDR.N    R0,??DataTable5_2
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR.N    R1,??DataTable5_2
        STRB     R0,[R1, #+0]
        LDR.N    R0,??DataTable5_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+11
        BNE.N    ??UsbMsgQueue_Push_2
//   85     {
//   86       usbMsgQueue_head = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable5_2
        STRB     R0,[R1, #+0]
//   87     }
//   88   usbMsgQueue_msgNo++;
??UsbMsgQueue_Push_2:
        LDR.N    R0,??DataTable5
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR.N    R1,??DataTable5
        STRB     R0,[R1, #+0]
//   89   return usbMsgQueueErr_NoError; 
        MOVS     R0,#+0
??UsbMsgQueue_Push_1:
        POP      {R4,PC}          ;; return
//   90 }
//   91 
//   92 
//   93 /******************************************************************************
//   94 * UsbMsgQueue_Pop
//   95 To be used only from USB task.
//   96 ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//   97 usbMsgQueueErr_t UsbMsgQueue_Pop(void)
//   98 {
UsbMsgQueue_Pop:
        PUSH     {R4,LR}
//   99   usbMsgQueueErr_t usbMsgQueueErr = usbMsgQueueErr_NoError; 
        MOVS     R4,#+0
//  100   USB_Lock();
        BL       USB_Lock
//  101   if(usbMsgQueue_msgNo == 0)
        LDR.N    R0,??DataTable5
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??UsbMsgQueue_Pop_0
//  102   {
//  103     usbMsgQueueErr = usbMsgQueueErr_QueueEmpty;
        MOVS     R0,#+2
        MOVS     R4,R0
        B.N      ??UsbMsgQueue_Pop_1
//  104   }
//  105   
//  106   else
//  107   {
//  108     if(++usbMsgQueue_tail == mUsbMsgQueueSize)
??UsbMsgQueue_Pop_0:
        LDR.N    R0,??DataTable5_1
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR.N    R1,??DataTable5_1
        STRB     R0,[R1, #+0]
        LDR.N    R0,??DataTable5_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+11
        BNE.N    ??UsbMsgQueue_Pop_2
//  109     {
//  110       usbMsgQueue_tail = 0; 
        MOVS     R0,#+0
        LDR.N    R1,??DataTable5_1
        STRB     R0,[R1, #+0]
//  111     }
//  112     usbMsgQueue_msgNo--;   
??UsbMsgQueue_Pop_2:
        LDR.N    R0,??DataTable5
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        LDR.N    R1,??DataTable5
        STRB     R0,[R1, #+0]
//  113   }
//  114   USB_UnLock();
??UsbMsgQueue_Pop_1:
        BL       USB_UnLock
//  115   return usbMsgQueueErr;
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R4,PC}          ;; return
//  116 }
//  117 
//  118 /******************************************************************************
//  119 * UsbMsgQueue_GetFirstMsg
//  120 ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  121 usbMsg_t* UsbMsgQueue_GetFirstMsg(void)
//  122 {
//  123   return (maUsbMsgQueue + usbMsgQueue_tail);  
UsbMsgQueue_GetFirstMsg:
        LDR.N    R0,??DataTable5_3
        LDR.N    R1,??DataTable5_1
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+4
        BX       LR               ;; return
//  124 }
//  125 
//  126 
//  127 /******************************************************************************
//  128 * UsbMsgQueue_MsgNo
//  129 ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  130 uint8_t UsbMsgQueue_MsgNo()
//  131 {
//  132   return usbMsgQueue_msgNo;
UsbMsgQueue_MsgNo:
        LDR.N    R0,??DataTable5
        LDRB     R0,[R0, #+0]
        BX       LR               ;; return
//  133 }
//  134 
//  135 /******************************************************************************
//  136 * UsbMsgQueue_MsgPending
//  137 ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  138 bool_t UsbMsgQueue_MsgPending()
//  139 {
//  140   return (usbMsgQueue_msgNo != 0);
UsbMsgQueue_MsgPending:
        LDR.N    R0,??DataTable5
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??UsbMsgQueue_MsgPending_0
        MOVS     R0,#+1
        B.N      ??UsbMsgQueue_MsgPending_1
??UsbMsgQueue_MsgPending_0:
        MOVS     R0,#+0
??UsbMsgQueue_MsgPending_1:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BX       LR               ;; return
//  141 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5:
        DC32     usbMsgQueue_msgNo

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_1:
        DC32     usbMsgQueue_tail

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_2:
        DC32     usbMsgQueue_head

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_3:
        DC32     maUsbMsgQueue

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        END
//  142 
//  143 /******************************************************************************
//  144 *******************************************************************************
//  145 * Private functions
//  146 *******************************************************************************
//  147 *******************************************************************************/
//  148 
//  149 #endif// gUsbIncluded_d
// 
// 179 bytes in section .bss
// 206 bytes in section .text
// 
// 206 bytes of CODE memory
// 179 bytes of DATA memory
//
//Errors: none
//Warnings: none
