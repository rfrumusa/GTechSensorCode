###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        02/Sep/2018  14:19:38
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\AD1.c
#    Command line =  
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\AD1.c" -D
#        IAR --preprocess "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code
#        Sequential ADC Reads\Shanit Origional Code\Connectivity
#        Test\Debug\List\" -lC "F:\Guardrail Work\Sensor Code\Git Repo\Sensor
#        Code Sequential ADC Reads\Shanit Origional Code\Connectivity
#        Test\Debug\List\" -lB "F:\Guardrail Work\Sensor Code\Git Repo\Sensor
#        Code Sequential ADC Reads\Shanit Origional Code\Connectivity
#        Test\Debug\List\" --diag_suppress
#        Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\Obj\" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\CDC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\Descriptor\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\USB\Class\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Sys Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
#    List file    =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\List\AD1.lst
#    Object file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\Obj\AD1.o
#
###############################################################################

F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\AD1.c
      1             
      2          
      3          /* MODULE AD1. */
      4          
      5          #include "AD1.h"
      6          /* {Default RTOS Adapter} No RTOS includes */
      7          #define CHECK_BIT(var,pos) ((var) & (1<<(pos)))
      8          
      9             /** !!!!! IMPORTANT NOTE THE TWO FOLLOWING LINES ARE USED FOR TAKING THE BATTERY MEASURMENTS 
     10             FOR THE MEASURMENTS ON THE SENSOR THE ADCCFG1 MAY NEED TO BE 39, f9 or something for a faster sample rate
     11             */
     12          

   \                                 In section .text, align 2, keep-with-next
     13          bool_t ADCInit()
     14          /*
     15          initilize the ADC modules that connect tothe accelerometer and the temperature sensor.
     16          */
     17          {
   \                     ADCInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
     18            uint16_t PlusSideConv;
     19            uint16_t MinusSideConv;
     20            
     21            // enable the clock to the ADC0 Module
     22            SIM_SCGC6 |= (uint32_t)(1<<27);
   \   00000002   0x....             LDR.N    R0,??DataTable16  ;; 0x4004803c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   0000000A   0x....             LDR.N    R1,??DataTable16  ;; 0x4004803c
   \   0000000C   0x6008             STR      R0,[R1, #+0]
     23            //enable the clock gating to PTE
     24            SIM_SCGC5 |= (uint32_t)(1<<13);
   \   0000000E   0x....             LDR.N    R0,??DataTable16_1  ;; 0x40048038
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000016   0x....             LDR.N    R1,??DataTable16_1  ;; 0x40048038
   \   00000018   0x6008             STR      R0,[R1, #+0]
     25           //set all of the values to a known state
     26            ClearADCContents();
   \   0000001A   0x.... 0x....      BL       ClearADCContents
     27            //set the correct pin muxing for the 4 pins
     28            PORTD_PCR6 = PORT_PCR_MUX(0x0);
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x....             LDR.N    R1,??DataTable16_2  ;; 0x4004c018
   \   00000022   0x6008             STR      R0,[R1, #+0]
     29            PORTD_PCR7 = PORT_PCR_MUX(0x0);
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x....             LDR.N    R1,??DataTable16_3  ;; 0x4004c01c
   \   00000028   0x6008             STR      R0,[R1, #+0]
     30            
     31            
     32            //set the correct colck gating to the three pins for the ADC module
     33            PORTE_PCR16 = PORT_PCR_MUX(0x0);              //ADCA 4
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x....             LDR.N    R1,??DataTable16_4  ;; 0x4004d040
   \   0000002E   0x6008             STR      R0,[R1, #+0]
     34            PORTE_PCR17 = PORT_PCR_MUX(0x0);              //ADCA 5
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x....             LDR.N    R1,??DataTable16_5  ;; 0x4004d044
   \   00000034   0x6008             STR      R0,[R1, #+0]
     35            PORTE_PCR18 = PORT_PCR_MUX(0x0);              //ADCA 6
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x....             LDR.N    R1,??DataTable16_6  ;; 0x4004d048
   \   0000003A   0x6008             STR      R0,[R1, #+0]
     36            PORTE_PCR19 = PORT_PCR_MUX(0x0);              //ADCA 7
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x....             LDR.N    R1,??DataTable16_7  ;; 0x4004d04c
   \   00000040   0x6008             STR      R0,[R1, #+0]
     37            
     38             ADC0_SC1A |= (uint32_t)0x16; 
   \   00000042   0x....             LDR.N    R0,??DataTable16_8  ;; 0x4003b000
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF050 0x0016      ORRS     R0,R0,#0x16
   \   0000004A   0x....             LDR.N    R1,??DataTable16_8  ;; 0x4003b000
   \   0000004C   0x6008             STR      R0,[R1, #+0]
     39             
     40            
     41            ADC0_CFG1 |= (uint32_t)0x1F9;
   \   0000004E   0x....             LDR.N    R0,??DataTable16_9  ;; 0x4003b008
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF240 0x11F9      MOVW     R1,#+505
   \   00000056   0x4308             ORRS     R0,R1,R0
   \   00000058   0x....             LDR.N    R1,??DataTable16_9  ;; 0x4003b008
   \   0000005A   0x6008             STR      R0,[R1, #+0]
     42            
     43            ADC0_SC3 = (uint32_t)0xf;
   \   0000005C   0x200F             MOVS     R0,#+15
   \   0000005E   0x....             LDR.N    R1,??DataTable16_10  ;; 0x4003b024
   \   00000060   0x6008             STR      R0,[R1, #+0]
     44            
     45            //start the calibrtion
     46            ADC0_SC3 |= (uint32_t)(1<<6);
   \   00000062   0x....             LDR.N    R0,??DataTable16_10  ;; 0x4003b024
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000006A   0x....             LDR.N    R1,??DataTable16_10  ;; 0x4003b024
   \   0000006C   0x6008             STR      R0,[R1, #+0]
     47            
     48           while(ADC0_SC1A & ADC_SC1_COCO_MASK)
   \                     ??ADCInit_0: (+1)
   \   0000006E   0x....             LDR.N    R0,??DataTable16_8  ;; 0x4003b000
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x0600             LSLS     R0,R0,#+24
   \   00000074   0xD4FB             BMI.N    ??ADCInit_0
     49             {
     50              //calibration is not completed
     51            }
     52            //calibration is now complete
     53            if(ADC0_SC3 & ADC_SC3_CALF_MASK)
   \   00000076   0x....             LDR.N    R0,??DataTable16_10  ;; 0x4003b024
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x0640             LSLS     R0,R0,#+25
   \   0000007C   0xD501             BPL.N    ??ADCInit_1
     54            {
     55              //calibration failed need to retry
     56              return 0;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xE03F             B.N      ??ADCInit_2
     57            }
     58            
     59            //calibration passed
     60            //need to set the plus side gain and the minus side gain registers
     61            
     62            PlusSideConv= ADC0_CLP0 + ADC0_CLP1 + ADC0_CLP2 + ADC0_CLP3 + ADC0_CLP4 + ADC0_CLPS;
   \                     ??ADCInit_1: (+1)
   \   00000082   0x....             LDR.N    R0,??DataTable16_11  ;; 0x4003b04c
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x....             LDR.N    R1,??DataTable16_12  ;; 0x4003b048
   \   00000088   0x6809             LDR      R1,[R1, #+0]
   \   0000008A   0x....             LDR.N    R2,??DataTable16_13  ;; 0x4003b044
   \   0000008C   0x6812             LDR      R2,[R2, #+0]
   \   0000008E   0x....             LDR.N    R3,??DataTable16_14  ;; 0x4003b040
   \   00000090   0x681B             LDR      R3,[R3, #+0]
   \   00000092   0x....             LDR.N    R6,??DataTable16_15  ;; 0x4003b03c
   \   00000094   0x6836             LDR      R6,[R6, #+0]
   \   00000096   0x1808             ADDS     R0,R1,R0
   \   00000098   0x1810             ADDS     R0,R2,R0
   \   0000009A   0x1818             ADDS     R0,R3,R0
   \   0000009C   0x1830             ADDS     R0,R6,R0
   \   0000009E   0x....             LDR.N    R1,??DataTable16_16  ;; 0x4003b038
   \   000000A0   0x6809             LDR      R1,[R1, #+0]
   \   000000A2   0x1808             ADDS     R0,R1,R0
   \   000000A4   0x0005             MOVS     R5,R0
     63            PlusSideConv = PlusSideConv /2;
   \   000000A6   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000A8   0x2002             MOVS     R0,#+2
   \   000000AA   0xFB95 0xF5F0      SDIV     R5,R5,R0
     64            //ADC0_CLPD = PlusSideConv | 0x8000;
     65            ADC0_PG = PlusSideConv | 0x8000;
   \   000000AE   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000B0   0xF455 0x4000      ORRS     R0,R5,#0x8000
   \   000000B4   0x....             LDR.N    R1,??DataTable16_17  ;; 0x4003b02c
   \   000000B6   0x6008             STR      R0,[R1, #+0]
     66            
     67            MinusSideConv= ADC0_CLM0 + ADC0_CLM1 + ADC0_CLM2 + ADC0_CLM3 + ADC0_CLM4 + ADC0_CLMS;
   \   000000B8   0x....             LDR.N    R0,??DataTable16_18  ;; 0x4003b06c
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0x....             LDR.N    R1,??DataTable16_19  ;; 0x4003b068
   \   000000BE   0x6809             LDR      R1,[R1, #+0]
   \   000000C0   0x....             LDR.N    R2,??DataTable16_20  ;; 0x4003b064
   \   000000C2   0x6812             LDR      R2,[R2, #+0]
   \   000000C4   0x....             LDR.N    R3,??DataTable16_21  ;; 0x4003b060
   \   000000C6   0x681B             LDR      R3,[R3, #+0]
   \   000000C8   0x....             LDR.N    R6,??DataTable16_22  ;; 0x4003b05c
   \   000000CA   0x6836             LDR      R6,[R6, #+0]
   \   000000CC   0x1808             ADDS     R0,R1,R0
   \   000000CE   0x1810             ADDS     R0,R2,R0
   \   000000D0   0x1818             ADDS     R0,R3,R0
   \   000000D2   0x1830             ADDS     R0,R6,R0
   \   000000D4   0x....             LDR.N    R1,??DataTable16_23  ;; 0x4003b058
   \   000000D6   0x6809             LDR      R1,[R1, #+0]
   \   000000D8   0x1808             ADDS     R0,R1,R0
   \   000000DA   0x0004             MOVS     R4,R0
     68            MinusSideConv = MinusSideConv /2;
   \   000000DC   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000DE   0x2002             MOVS     R0,#+2
   \   000000E0   0xFB94 0xF4F0      SDIV     R4,R4,R0
     69            //ADC0_CLMD = MinusSideConv | 0x8000;
     70            ADC0_MG = MinusSideConv | 0x8000;
   \   000000E4   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000E6   0xF454 0x4000      ORRS     R0,R4,#0x8000
   \   000000EA   0x....             LDR.N    R1,??DataTable16_24  ;; 0x4003b030
   \   000000EC   0x6008             STR      R0,[R1, #+0]
     71            
     72            ADC0_SC2 = (uint32_t)0x0;
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x....             LDR.N    R1,??DataTable16_25  ;; 0x4003b020
   \   000000F2   0x6008             STR      R0,[R1, #+0]
     73            
     74            
     75            /* set the time back to faster sample rates. from the conversion times */
     76             ADC0_CFG1 = (uint32_t)0x19;
   \   000000F4   0x2019             MOVS     R0,#+25
   \   000000F6   0x....             LDR.N    R1,??DataTable16_9  ;; 0x4003b008
   \   000000F8   0x6008             STR      R0,[R1, #+0]
     77             ADC0_SC3 = (uint32_t)0x0;              //this well set the ADC for continous conversion, 32 samples and hardware average is enabled
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0x....             LDR.N    R1,??DataTable16_10  ;; 0x4003b024
   \   000000FE   0x6008             STR      R0,[R1, #+0]
     78            
     79            
     80            return 1;
   \   00000100   0x2001             MOVS     R0,#+1
   \                     ??ADCInit_2: (+1)
   \   00000102   0xBD70             POP      {R4-R6,PC}       ;; return
     81          }
     82          

   \                                 In section .text, align 2, keep-with-next
     83          void ClearADCContents()
     84          /*
     85          Set all of the contents from the ADC registers to a known value so there are no issues with the set up of the ADC registers
     86          */
     87          {
     88              ADC0_CFG1 = (uint32_t)0x0;
   \                     ClearADCContents: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable16_9  ;; 0x4003b008
   \   00000004   0x6008             STR      R0,[R1, #+0]
     89              ADC0_CFG2 = (uint32_t)0x0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x....             LDR.N    R1,??DataTable16_26  ;; 0x4003b00c
   \   0000000A   0x6008             STR      R0,[R1, #+0]
     90              ADC0_CV1 = (uint32_t)0x0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x....             LDR.N    R1,??DataTable16_27  ;; 0x4003b018
   \   00000010   0x6008             STR      R0,[R1, #+0]
     91              ADC0_CV2 = (uint32_t)0x0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x....             LDR.N    R1,??DataTable16_28  ;; 0x4003b01c
   \   00000016   0x6008             STR      R0,[R1, #+0]
     92              ADC0_SC2 = (uint32_t)0x0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x....             LDR.N    R1,??DataTable16_25  ;; 0x4003b020
   \   0000001C   0x6008             STR      R0,[R1, #+0]
     93              ADC0_SC3 = (uint32_t)0x0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x....             LDR.N    R1,??DataTable16_10  ;; 0x4003b024
   \   00000022   0x6008             STR      R0,[R1, #+0]
     94          }
   \   00000024   0x4770             BX       LR               ;; return
     95          
     96          

   \                                 In section .text, align 2, keep-with-next
     97          bool_t CheckConversionActive()
     98          {
     99            if(ADC0_SC2 & ADC_SC2_ADACT_MASK)
   \                     CheckConversionActive: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16_25  ;; 0x4003b020
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0600             LSLS     R0,R0,#+24
   \   00000006   0xD501             BPL.N    ??CheckConversionActive_0
    100            {
    101              return 1;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE000             B.N      ??CheckConversionActive_1
    102            }
    103            return 0;
   \                     ??CheckConversionActive_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \                     ??CheckConversionActive_1: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
    104          }
    105          

   \                                 In section .text, align 2, keep-with-next
    106          bool_t ConversionAComplete()
    107          /*
    108          Checks to see if the conversion is complete
    109          */
    110          {
    111            //check if 1 conversion is complete bit 7
    112            if(ADC0_SC1A & ADC_SC1_COCO_MASK)
   \                     ConversionAComplete: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16_8  ;; 0x4003b000
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0600             LSLS     R0,R0,#+24
   \   00000006   0xD501             BPL.N    ??ConversionAComplete_0
    113            {
    114              return 1;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE000             B.N      ??ConversionAComplete_1
    115            }
    116            
    117            return 0;
   \                     ??ConversionAComplete_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \                     ??ConversionAComplete_1: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
    118          }
    119          

   \                                 In section .text, align 2, keep-with-next
    120          bool_t ConversionBComplete()
    121          /*
    122          Checks to see if the conversion is complete for the B ADC
    123          */
    124          {
    125            //check if 1 conversion is complete bit 7
    126            if(ADC0_SC1B & ADC_SC1_COCO_MASK)
   \                     ConversionBComplete: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16_29  ;; 0x4003b004
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0600             LSLS     R0,R0,#+24
   \   00000006   0xD501             BPL.N    ??ConversionBComplete_0
    127            {
    128              return 1;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE000             B.N      ??ConversionBComplete_1
    129            }
    130            
    131            return 0;
   \                     ??ConversionBComplete_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \                     ??ConversionBComplete_1: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
    132          }
    133          

   \                                 In section .text, align 2, keep-with-next
    134          void StartBattConversion()
    135          /*
    136          selects the correct chanel to start the conversion and starts the conversion
    137          */
    138          {
    139            /* Old way to try and start the conversion in channel B
    140            //need to connect to the B chanel
    141            ADC0_CFG2 = (uint32_t)0x10;
    142            //set the conversionchanel in the B channel
    143            ADC0_SC1B = (uint32_t)0x5;
    144            */
    145            
    146            //need to connect to the A chanel
    147            ADC0_CFG2 = (uint32_t)0x0;             
   \                     StartBattConversion: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable16_26  ;; 0x4003b00c
   \   00000004   0x6008             STR      R0,[R1, #+0]
    148            
    149            ADC0_SC1A =  (uint32_t)0x7 ;
   \   00000006   0x2007             MOVS     R0,#+7
   \   00000008   0x....             LDR.N    R1,??DataTable16_8  ;; 0x4003b000
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    150           
    151            //set the first 5 bits equal to the correct location 
    152          
    153            
    154          }
   \   0000000C   0x4770             BX       LR               ;; return
    155          

   \                                 In section .text, align 2, keep-with-next
    156          void StartXConversion()
    157          /*
    158          selects the correct chanel to start the conversion and starts the conversion
    159          */
    160          {
    161            /* Old way to try and start the conversion in channel B
    162            //need to connect to the B chanel
    163            ADC0_CFG2 = (uint32_t)0x10;
    164            //set the conversionchanel in the B channel
    165            ADC0_SC1B = (uint32_t)0x5;
    166            */
    167            
    168            //need to connect to the A chanel
    169            ADC0_CFG2 = (uint32_t)0x0;             
   \                     StartXConversion: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable16_26  ;; 0x4003b00c
   \   00000004   0x6008             STR      R0,[R1, #+0]
    170            
    171            ADC0_SC1A =  (uint32_t)0x4 ;
   \   00000006   0x2004             MOVS     R0,#+4
   \   00000008   0x....             LDR.N    R1,??DataTable16_8  ;; 0x4003b000
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    172           
    173            //set the first 5 bits equal to the correct location 
    174          
    175            
    176          }
   \   0000000C   0x4770             BX       LR               ;; return
    177          
    178          

   \                                 In section .text, align 2, keep-with-next
    179          void StartYConversion()
    180          /*
    181          selects the correct chanel to start the conversion and starts the conversion
    182          */
    183          {
    184            
    185            /*Code that was used for old conversion techquine when Was connected to the B channel
    186            ADC0_CFG2 = (uint32_t)0x10;
    187            //dissable differential mode set the first 5 bits equal to the correct location 
    188            //this shoud start the conversion
    189            ADC0_SC1B = (uint32_t)0x6;
    190            */
    191            
    192            //need to connect to the A chanel
    193            ADC0_CFG2 = (uint32_t)0x0;             
   \                     StartYConversion: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable16_26  ;; 0x4003b00c
   \   00000004   0x6008             STR      R0,[R1, #+0]
    194            
    195            ADC0_SC1A =  (uint32_t)0x5 ;
   \   00000006   0x2005             MOVS     R0,#+5
   \   00000008   0x....             LDR.N    R1,??DataTable16_8  ;; 0x4003b000
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    196           
    197            //set the first 5 bits equal to the correct location 
    198          }
   \   0000000C   0x4770             BX       LR               ;; return
    199          

   \                                 In section .text, align 2, keep-with-next
    200          void StartZConversion()
    201          /*
    202          selects the correct chanel to start the conversion and starts the conversion
    203          */
    204          {
    205            /*  this is old code for when it was connected to channel 
    206            ADC0_SC2 = (uint32_t)0x40;
    207            
    208            ADC0_SC3 = (uint32_t)0xc;
    209            //need to connect to the B chanel
    210            ADC0_CFG2 = (uint32_t)0x10;
    211            //dissable differential mode
    212            //this shoud start the conversion
    213            ADC0_SC1B = (uint32_t)0x7;
    214            */
    215            
    216            //need to connect to the A chanel
    217            ADC0_CFG2 = (uint32_t)0x0;             
   \                     StartZConversion: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable16_26  ;; 0x4003b00c
   \   00000004   0x6008             STR      R0,[R1, #+0]
    218            
    219            ADC0_SC1A =  (uint32_t)0x6 ;
   \   00000006   0x2006             MOVS     R0,#+6
   \   00000008   0x....             LDR.N    R1,??DataTable16_8  ;; 0x4003b000
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    220            //set the first 5 bits equal to the correct location 
    221            
    222          }
   \   0000000C   0x4770             BX       LR               ;; return
    223          

   \                                 In section .text, align 2, keep-with-next
    224          void StartTempConversion()
    225          /*
    226          selects the correct chanel to start the conversion and starts the conversion
    227          */
    228          {
    229            //need to connect to the A chanel
    230            ADC0_CFG2 = (uint32_t)0x0;             
   \                     StartTempConversion: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable16_26  ;; 0x4003b00c
   \   00000004   0x6008             STR      R0,[R1, #+0]
    231            
    232            ADC0_SC1A =  (uint32_t)0x16 ;
   \   00000006   0x2016             MOVS     R0,#+22
   \   00000008   0x....             LDR.N    R1,??DataTable16_8  ;; 0x4003b000
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    233           
    234            //set the first 5 bits equal to the correct location 
    235          }
   \   0000000C   0x4770             BX       LR               ;; return
    236          

   \                                 In section .text, align 2, keep-with-next
    237          uint32_t GetConversionValueXYZ()
    238          /*
    239          returns the value of the converstion
    240          */
    241          {
    242            return ADC0_RB;
   \                     GetConversionValueXYZ: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16_30  ;; 0x4003b014
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    243          }
    244          

   \                                 In section .text, align 2, keep-with-next
    245          uint32_t GetConversionValue()
    246          /*
    247          returns the value of the converstion
    248          */
    249          {
    250            return ADC0_RA;
   \                     GetConversionValue: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16_31  ;; 0x4003b010
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    251          }
    252          

   \                                 In section .text, align 2, keep-with-next
    253          void DisableADC()
    254          {
    255            ADC0_SC1A = 0x1F;
   \                     DisableADC: (+1)
   \   00000000   0x201F             MOVS     R0,#+31
   \   00000002   0x....             LDR.N    R1,??DataTable16_8  ;; 0x4003b000
   \   00000004   0x6008             STR      R0,[R1, #+0]
    256            ADC0_SC1B = 0x1F;
   \   00000006   0x201F             MOVS     R0,#+31
   \   00000008   0x....             LDR.N    R1,??DataTable16_29  ;; 0x4003b004
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    257          }
   \   0000000C   0x4770             BX       LR               ;; return
    258          
    259          
    260          
    261          
    262          
    263          
    264          
    265          
    266          
    267          /*this method initilizes the PDB module
    268          Params- NONE
    269          return - VOID
    270          Function
    271            sets things to the values to use the PDB to start the ADC conversions
    272          PDB0_SC -> LDMOD 00 -> PDBEIE 0 -> SWTRIG 0(this will be set periodically to reset the counter) -> DMAEN 0 -> PRESCALER 010 -> TRGSEL 0000(this will be cahnging with SWTRIG to change the channel
    273                  ->PDBEN 0 -> PDBIF 0 -> PDBIE 0 -> reserved 0 -> CONT 0 -> LDOK 0( this needs to change with PDBEN being set to 1) 0x800
    274          
    275          PDB0_MOD -> this is the resgister that will be the comnparitor, when the internal counter reaches this value it will acitvate a conversion. 0x1
    276          
    277          PDB0_CNT -> contains the value of the counter
    278          
    279          PDB0_CH0C1 -> BB 00000000(dont want back to back operations) -> TOS 00000001 (this will be changing from this to 00000010 and 00000100 for other chanels) -> EN 1 -> 0x3
    280          
    281          PDB0_CH0DLY0 -> DLY 0 -> 0x0
    282          PDB0_CH0DLY1 -> DLY 0 -> 0x0
    283          PDB0_POEN -> POEN 0 -> 0x0
    284          
    285          NEED TO SET UP THE INTERUPT FOR THE ADC SO IT WILL READ THE VALUE WHEN IT IS FINISHED WITH THE CONVERSION
    286          
    287          */

   \                                 In section .text, align 2, keep-with-next
    288          void PDBinit()
    289          {
    290            //need to enable this in the sistem registers
    291            SIM_SCGC6 |= (uint32_t) (1<<22);
   \                     PDBinit: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16  ;; 0x4004803c
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF450 0x0080      ORRS     R0,R0,#0x400000
   \   00000008   0x....             LDR.N    R1,??DataTable16  ;; 0x4004803c
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    292            PDB0_SC = (uint32_t)0x800;
   \   0000000C   0xF44F 0x6000      MOV      R0,#+2048
   \   00000010   0x....             LDR.N    R1,??DataTable16_32  ;; 0x40036000
   \   00000012   0x6008             STR      R0,[R1, #+0]
    293            
    294            PDB0_MOD = (uint32_t)0x1;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x....             LDR.N    R1,??DataTable16_33  ;; 0x40036004
   \   00000018   0x6008             STR      R0,[R1, #+0]
    295            
    296            PDB0_CH0C1 = (uint32_t)0x1;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x....             LDR.N    R1,??DataTable16_34  ;; 0x40036010
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    297            
    298            PDB0_CH0DLY0 = (uint32_t)0x0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x....             LDR.N    R1,??DataTable16_35  ;; 0x40036018
   \   00000024   0x6008             STR      R0,[R1, #+0]
    299            PDB0_CH1DLY0 = (uint32_t)0x0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x....             LDR.N    R1,??DataTable16_36  ;; 0x40036040
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    300            PDB0_POEN = (uint32_t)0x0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x....             LDR.N    R1,??DataTable16_37  ;; 0x40036190
   \   00000030   0x6008             STR      R0,[R1, #+0]
    301            
    302            
    303          }
   \   00000032   0x4770             BX       LR               ;; return
    304          /*
    305          Params -None
    306          returns - void
    307           starts the timmer and enables the chanel 0 from CH0C1 register 
    308          */

   \                                 In section .text, align 2, keep-with-next
    309          void startOutputChanel1Timmer()
    310          {
    311            //enable PBEN and LDOK and set chanel 0 trigger
    312            PDB0_SC = (uint32_t)0x821;
   \                     startOutputChanel1Timmer: (+1)
   \   00000000   0xF640 0x0021      MOVW     R0,#+2081
   \   00000004   0x....             LDR.N    R1,??DataTable16_32  ;; 0x40036000
   \   00000006   0x6008             STR      R0,[R1, #+0]
    313            //enable the output for the first ADC channel
    314            PDB0_CH0C1 = (uint32_t)0x3;
   \   00000008   0x2003             MOVS     R0,#+3
   \   0000000A   0x....             LDR.N    R1,??DataTable16_34  ;; 0x40036010
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    315            //this may want to be a different channel, channel 0 should be for ADC0 A and channel 2 should be for ADC0 B
    316            
    317          }
   \   0000000E   0x4770             BX       LR               ;; return
    318                                                                                                                                                     /*(
    319          void startOutputChanel1Timmer()
    320          {
    321            //enable PBEN and LDOK and set chanel 0 trigger
    322            PDB0_SC = (uint32_t)0x821;
    323            //enable the output for the first ADC channel
    324            PDB0_CH0C1 = (uint32_t)0x3;
    325            //this may want to be a different channel, channel 0 should be for ADC0 A and channel 2 should be for ADC0 B
    326            
    327          }
    328                                                                                                                                                     */
    329          /*
    330          
    331          
    332          The next two functions may not be correct may only want to use the first one to set up the starting of the conversion and then change it to the
    333          correct ADC channel
    334          
    335          
    336          */

   \                                 In section .text, align 2, keep-with-next
    337          void startOutputChanel2Timmer()
    338          {
    339            //enable PBEN and LDOK and set chanel 0 trigger
    340            PDB0_SC = (uint32_t)0x821;
   \                     startOutputChanel2Timmer: (+1)
   \   00000000   0xF640 0x0021      MOVW     R0,#+2081
   \   00000004   0x....             LDR.N    R1,??DataTable16_32  ;; 0x40036000
   \   00000006   0x6008             STR      R0,[R1, #+0]
    341            //enable the output for the first ADC channel
    342            PDB0_CH0C1 = (uint32_t)0xB;
   \   00000008   0x200B             MOVS     R0,#+11
   \   0000000A   0x....             LDR.N    R1,??DataTable16_34  ;; 0x40036010
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    343            //this may want to be a different channel, channel 0 should be for ADC0 A and channel 2 should be for ADC0 B
    344            
    345          }
   \   0000000E   0x4770             BX       LR               ;; return
    346          

   \                                 In section .text, align 2, keep-with-next
    347          void startOutputChanel3Timmer()
    348          {
    349            //enable PBEN and LDOK and set chanel 0 trigger
    350            PDB0_SC = (uint32_t)0x821;
   \                     startOutputChanel3Timmer: (+1)
   \   00000000   0xF640 0x0021      MOVW     R0,#+2081
   \   00000004   0x....             LDR.N    R1,??DataTable16_32  ;; 0x40036000
   \   00000006   0x6008             STR      R0,[R1, #+0]
    351            //enable the output for the first ADC channel
    352            PDB0_CH0C1 = (uint32_t)0xB;
   \   00000008   0x200B             MOVS     R0,#+11
   \   0000000A   0x....             LDR.N    R1,??DataTable16_34  ;; 0x40036010
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    353            //this may want to be a different channel, channel 0 should be for ADC0 A and channel 2 should be for ADC0 B
    354            
    355          }
   \   0000000E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x40048038         DC32     0x40048038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x4004C018         DC32     0x4004c018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x4004C01C         DC32     0x4004c01c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x4004D040         DC32     0x4004d040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x4004D044         DC32     0x4004d044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x4004D048         DC32     0x4004d048

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0x4004D04C         DC32     0x4004d04c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   0x4003B000         DC32     0x4003b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   0x4003B008         DC32     0x4003b008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   0x4003B024         DC32     0x4003b024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   0x4003B04C         DC32     0x4003b04c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \   00000000   0x4003B048         DC32     0x4003b048

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \   00000000   0x4003B044         DC32     0x4003b044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \   00000000   0x4003B040         DC32     0x4003b040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_15:
   \   00000000   0x4003B03C         DC32     0x4003b03c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_16:
   \   00000000   0x4003B038         DC32     0x4003b038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_17:
   \   00000000   0x4003B02C         DC32     0x4003b02c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_18:
   \   00000000   0x4003B06C         DC32     0x4003b06c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_19:
   \   00000000   0x4003B068         DC32     0x4003b068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_20:
   \   00000000   0x4003B064         DC32     0x4003b064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_21:
   \   00000000   0x4003B060         DC32     0x4003b060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_22:
   \   00000000   0x4003B05C         DC32     0x4003b05c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_23:
   \   00000000   0x4003B058         DC32     0x4003b058

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_24:
   \   00000000   0x4003B030         DC32     0x4003b030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_25:
   \   00000000   0x4003B020         DC32     0x4003b020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_26:
   \   00000000   0x4003B00C         DC32     0x4003b00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_27:
   \   00000000   0x4003B018         DC32     0x4003b018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_28:
   \   00000000   0x4003B01C         DC32     0x4003b01c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_29:
   \   00000000   0x4003B004         DC32     0x4003b004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_30:
   \   00000000   0x4003B014         DC32     0x4003b014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_31:
   \   00000000   0x4003B010         DC32     0x4003b010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_32:
   \   00000000   0x40036000         DC32     0x40036000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_33:
   \   00000000   0x40036004         DC32     0x40036004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_34:
   \   00000000   0x40036010         DC32     0x40036010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_35:
   \   00000000   0x40036018         DC32     0x40036018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_36:
   \   00000000   0x40036040         DC32     0x40036040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_37:
   \   00000000   0x40036190         DC32     0x40036190
    356          
    357          
    358          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   ADCInit
        16   -> ClearADCContents
       0   CheckConversionActive
       0   ClearADCContents
       0   ConversionAComplete
       0   ConversionBComplete
       0   DisableADC
       0   GetConversionValue
       0   GetConversionValueXYZ
       0   PDBinit
       0   StartBattConversion
       0   StartTempConversion
       0   StartXConversion
       0   StartYConversion
       0   StartZConversion
       0   startOutputChanel1Timmer
       0   startOutputChanel2Timmer
       0   startOutputChanel3Timmer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_15
       4  ??DataTable16_16
       4  ??DataTable16_17
       4  ??DataTable16_18
       4  ??DataTable16_19
       4  ??DataTable16_2
       4  ??DataTable16_20
       4  ??DataTable16_21
       4  ??DataTable16_22
       4  ??DataTable16_23
       4  ??DataTable16_24
       4  ??DataTable16_25
       4  ??DataTable16_26
       4  ??DataTable16_27
       4  ??DataTable16_28
       4  ??DataTable16_29
       4  ??DataTable16_3
       4  ??DataTable16_30
       4  ??DataTable16_31
       4  ??DataTable16_32
       4  ??DataTable16_33
       4  ??DataTable16_34
       4  ??DataTable16_35
       4  ??DataTable16_36
       4  ??DataTable16_37
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
     260  ADCInit
      16  CheckConversionActive
      38  ClearADCContents
      16  ConversionAComplete
      16  ConversionBComplete
      14  DisableADC
       6  GetConversionValue
       6  GetConversionValueXYZ
      52  PDBinit
      14  StartBattConversion
      14  StartTempConversion
      14  StartXConversion
      14  StartYConversion
      14  StartZConversion
      16  startOutputChanel1Timmer
      16  startOutputChanel2Timmer
      16  startOutputChanel3Timmer

 
 694 bytes in section .text
 
 694 bytes of CODE memory

Errors: none
Warnings: none
