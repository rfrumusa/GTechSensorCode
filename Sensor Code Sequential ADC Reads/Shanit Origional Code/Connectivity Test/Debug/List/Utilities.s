///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM       02/Sep/2018  14:19:44
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Generic
//        Services\Source\Utilities.c
//    Command line =  
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Generic
//        Services\Source\Utilities.c" -D IAR --preprocess "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\List\" -lC "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\List\" -lB "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\List\" --diag_suppress
//        Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\Obj\" --no_cse --no_unroll
//        --no_inline --no_code_motion --no_tbaa --no_clustering
//        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\APP\CDC\" -I "F:\Guardrail Work\Sensor Code\Git
//        Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\USB\APP\Descriptor\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Class\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Sys Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
//    List file    =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\Utilities.s
//
///////////////////////////////////////////////////////////////////////////////

        #define SHT_PROGBITS 0x1

        EXTERN CommUtil_Print
        EXTERN MCG_PLLInit
        EXTERN gMCG_coreClkKHz
        EXTERN gMCG_coreClkMHz
        EXTERN gMCG_periphClkKHz

        PUBLIC FLib_MemCpyAligned32bit
        PUBLIC HexString2Dec16
        PUBLIC HexToAscii
        PUBLIC HexaToAscii
        PUBLIC MCU_InitClock
        PUBLIC MemoryCpy
        PUBLIC MemorySet
        PUBLIC PrintByteOnHexFormatBlocking
        PUBLIC PrintWordOnDecimalFormatBlocking
        PUBLIC convert_2_bcd
        PUBLIC delayMs
        PUBLIC int2BCD
        PUBLIC stringComp

// F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\Generic Services\Source\Utilities.c
//    1 /*****************************************************************************
//    2 * Source file for Utilities.
//    3 * 
//    4 * 
//    5 * Copyright (c) 2009, Freescale, Inc. All rights reserved.
//    6 *
//    7 * 
//    8 * No part of this document must be reproduced in any form - including copied,
//    9 * transcribed, printed or by any electronic means - without specific written
//   10 * permission from Freescale Semiconductor.
//   11 *
//   12 *****************************************************************************/
//   13 
//   14 #include "Utilities_Interface.h"
//   15 #include "mcg.h"
//   16 
//   17 /************************************************************************************
//   18 * Delay_ms
//   19 *
//   20 ************************************************************************************/
//   21 /*
//   22 void Delay_ms
//   23 (
//   24   uint16_t u16ms
//   25 ) 
//   26 {                                            
//   27   uint16_t u16ctr;                                          
//   28   for(u16ctr = 0; u16ctr < ((gSystemClock_d/40000)*u16ms); u16ctr++){
//   29     asm NOP; 
//   30     asm NOP;
//   31   }    
//   32 }
//   33 */
//   34 /************************************************************************************
//   35 * Delay_ms
//   36 *
//   37 ************************************************************************************/
//   38 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//   39  void delayMs(uint16_t val)
//   40 {
//   41 	/* Turn on clock to LPTMR module */
//   42 	SIM_SCGC5 |= SIM_SCGC5_LPTIMER_MASK;
delayMs:
        LDR.W    R1,??DataTable3  ;; 0x40048038
        LDR      R1,[R1, #+0]
        ORRS     R1,R1,#0x1
        LDR.W    R2,??DataTable3  ;; 0x40048038
        STR      R1,[R2, #+0]
//   43         
//   44 	/* Disable LPTMR */
//   45 	LPTMR0_CSR &= ~(LPTMR_CSR_TEN_MASK);
        LDR.W    R1,??DataTable3_1  ;; 0x40040000
        LDR      R1,[R1, #+0]
        LSRS     R1,R1,#+1
        LSLS     R1,R1,#+1
        LDR.W    R2,??DataTable3_1  ;; 0x40040000
        STR      R1,[R2, #+0]
//   46 
//   47 	/* Set compare value */
//   48 	LPTMR0_CMR = val;
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        LDR.W    R1,??DataTable3_2  ;; 0x40040008
        STR      R0,[R1, #+0]
//   49 
//   50 	/* Use 1Khz LPO clock and bypass prescaler */
//   51 	LPTMR0_PSR = LPTMR_PSR_PCS(1)|LPTMR_PSR_PBYP_MASK;
        MOVS     R1,#+5
        LDR.W    R2,??DataTable3_3  ;; 0x40040004
        STR      R1,[R2, #+0]
//   52 
//   53 	/* Start counting */
//   54 	LPTMR0_CSR |= LPTMR_CSR_TEN_MASK;
        LDR.W    R1,??DataTable3_1  ;; 0x40040000
        LDR      R1,[R1, #+0]
        ORRS     R1,R1,#0x1
        LDR.W    R2,??DataTable3_1  ;; 0x40040000
        STR      R1,[R2, #+0]
//   55 
//   56 	/* Wait for counter to reach compare value */
//   57 	while (!(LPTMR0_CSR & LPTMR_CSR_TCF_MASK)) {}
??delayMs_0:
        LDR.W    R1,??DataTable3_1  ;; 0x40040000
        LDR      R1,[R1, #+0]
        LSLS     R1,R1,#+24
        BPL.N    ??delayMs_0
//   58 
//   59 	/* Clear Timer Compare Flag */
//   60 	LPTMR0_CSR &= ~LPTMR_CSR_TEN_MASK;
        LDR.W    R1,??DataTable3_1  ;; 0x40040000
        LDR      R1,[R1, #+0]
        LSRS     R1,R1,#+1
        LSLS     R1,R1,#+1
        LDR.W    R2,??DataTable3_1  ;; 0x40040000
        STR      R1,[R2, #+0]
//   61 
//   62 	/* Turn off clock to LPTMR module */
//   63 	SIM_SCGC5 &= ~SIM_SCGC5_LPTIMER_MASK;	
        LDR.W    R1,??DataTable3  ;; 0x40048038
        LDR      R1,[R1, #+0]
        LSRS     R1,R1,#+1
        LSLS     R1,R1,#+1
        LDR.W    R2,??DataTable3  ;; 0x40048038
        STR      R1,[R2, #+0]
//   64 }
        BX       LR               ;; return
//   65 /************************************************************************************
//   66 * Delay_us
//   67 *
//   68 ************************************************************************************/
//   69 /*
//   70 void Delay_us
//   71 (
//   72   uint16_t u16us
//   73 ) 
//   74 {
//   75   uint16_t u16ctr;                                          
//   76   for(u16ctr = 0; u16ctr < (((gSystemClock_d*10/40000000)*u16us)/10); u16ctr++){
//   77     asm NOP; 
//   78     asm NOP;     
//   79   }      
//   80 }
//   81 */
//   82 
//   83  
//   84 /*******************************************************************************  
//   85 * HexToAscii
//   86 *
//   87 * This function converts an hexadecimal value in ascii code.
//   88 *******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//   89 uint8_t HexToAscii(uint8_t u8Hex)
//   90 {
//   91   u8Hex &= 0x0F;
HexToAscii:
        ANDS     R0,R0,#0xF
//   92   return u8Hex + ((u8Hex <= 9) ? '0' : ('A'-10));
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+10
        BGE.N    ??HexToAscii_0
        MOVS     R1,#+48
        B.N      ??HexToAscii_1
??HexToAscii_0:
        MOVS     R1,#+55
??HexToAscii_1:
        ADDS     R0,R1,R0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BX       LR               ;; return
//   93 }
//   94 
//   95 
//   96 
//   97 /**************************************************************************************/
//   98 
//   99 
//  100 
//  101 /************************************************************************************
//  102 * convert_2_bcd function
//  103 *
//  104 * This function converts the received data as parameter to bcd format
//  105 *
//  106 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  107 sixDigitBcd_t convert_2_bcd(uint16_t u16Value)
//  108 {
convert_2_bcd:
        SUB      SP,SP,#+4
        MOVS     R1,R0
//  109   sixDigitBcd_t u16RtrnVal;
//  110   uint16_t tmp;
//  111   u16RtrnVal.u8Units = 0;
        LDRB     R0,[SP, #+0]
        ANDS     R0,R0,#0xF0
        STRB     R0,[SP, #+0]
//  112   u16RtrnVal.u8Tens = 0;
        LDRB     R0,[SP, #+0]
        ANDS     R0,R0,#0xF
        STRB     R0,[SP, #+0]
//  113   u16RtrnVal.u8Houndreds = 0;
        LDRB     R0,[SP, #+1]
        ANDS     R0,R0,#0xF0
        STRB     R0,[SP, #+1]
//  114   u16RtrnVal.u8Thousands = 0;
        LDRB     R0,[SP, #+1]
        ANDS     R0,R0,#0xF
        STRB     R0,[SP, #+1]
//  115   u16RtrnVal.u8TensThousands = 0;
        LDRB     R0,[SP, #+2]
        ANDS     R0,R0,#0xF0
        STRB     R0,[SP, #+2]
//  116   u16RtrnVal.u8HoundredsThousands = 0;
        LDRB     R0,[SP, #+2]
        ANDS     R0,R0,#0xF
        STRB     R0,[SP, #+2]
//  117   if(65535 > u16Value)
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        MOVW     R0,#+65535
        CMP      R1,R0
        BEQ.N    ??convert_2_bcd_0
//  118   {
//  119     tmp = u16Value;
        MOVS     R2,R1
//  120     if(10000 <= u16Value)
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        MOVW     R0,#+10000
        CMP      R1,R0
        BLT.N    ??convert_2_bcd_1
//  121     {
//  122       tmp = u16Value/10000;
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        MOVW     R0,#+10000
        SDIV     R0,R1,R0
        MOVS     R2,R0
//  123       u16RtrnVal.u8TensThousands = (uint8_t)tmp;
        MOVS     R0,R2
        LDRB     R3,[SP, #+2]
        BFI      R3,R0,#+0,#+4
        STRB     R3,[SP, #+2]
//  124       tmp = u16Value%10000;
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        MOVW     R0,#+10000
        SDIV     R3,R1,R0
        MLS      R0,R0,R3,R1
        MOVS     R2,R0
//  125       u16Value = tmp;
        MOVS     R1,R2
//  126     }
//  127 
//  128     if(1000 <= u16Value)
??convert_2_bcd_1:
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        CMP      R1,#+1000
        BLT.N    ??convert_2_bcd_2
//  129     {
//  130       tmp = u16Value/1000;
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        MOV      R0,#+1000
        SDIV     R0,R1,R0
        MOVS     R2,R0
//  131       u16RtrnVal.u8Thousands = (uint8_t)tmp;
        LDRB     R0,[SP, #+1]
        ANDS     R0,R0,#0xF
        ORRS     R0,R0,R2, LSL #+4
        STRB     R0,[SP, #+1]
//  132       tmp = u16Value%1000;
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        MOV      R0,#+1000
        SDIV     R3,R1,R0
        MLS      R0,R0,R3,R1
        MOVS     R2,R0
//  133       u16Value = tmp;
        MOVS     R1,R2
//  134     }
//  135     if(100 <= u16Value)
??convert_2_bcd_2:
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        CMP      R1,#+100
        BLT.N    ??convert_2_bcd_3
//  136     {
//  137       tmp = u16Value/100;
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        MOVS     R0,#+100
        SDIV     R0,R1,R0
        MOVS     R2,R0
//  138       u16RtrnVal.u8Houndreds = (uint8_t)tmp;
        MOVS     R0,R2
        LDRB     R3,[SP, #+1]
        BFI      R3,R0,#+0,#+4
        STRB     R3,[SP, #+1]
//  139       tmp = u16Value%100;
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        MOVS     R0,#+100
        SDIV     R3,R1,R0
        MLS      R0,R0,R3,R1
        MOVS     R2,R0
//  140       u16Value = tmp;
        MOVS     R1,R2
//  141     }
//  142     if(10 <= u16Value)
??convert_2_bcd_3:
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        CMP      R1,#+10
        BLT.N    ??convert_2_bcd_4
//  143     {
//  144       tmp = u16Value/10;
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        MOVS     R0,#+10
        SDIV     R0,R1,R0
        MOVS     R2,R0
//  145       u16RtrnVal.u8Tens = (uint8_t)tmp;
        LDRB     R0,[SP, #+0]
        ANDS     R0,R0,#0xF
        ORRS     R0,R0,R2, LSL #+4
        STRB     R0,[SP, #+0]
//  146       tmp = u16Value%10;
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        MOVS     R0,#+10
        SDIV     R3,R1,R0
        MLS      R0,R0,R3,R1
        MOVS     R2,R0
//  147       u16Value = tmp;
        MOVS     R1,R2
//  148     }
//  149     u16RtrnVal.u8Units = (uint8_t)tmp;
??convert_2_bcd_4:
        MOVS     R0,R2
        LDRB     R3,[SP, #+0]
        BFI      R3,R0,#+0,#+4
        STRB     R3,[SP, #+0]
//  150   }
//  151   return u16RtrnVal;
??convert_2_bcd_0:
        LDR      R0,[SP, #+0]
        ADD      SP,SP,#+4
        BX       LR               ;; return
//  152 } 
//  153 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  154 uint8_t HexaToAscii(uint8_t u8Hex)
//  155 {
//  156   u8Hex &= 0x0F;
HexaToAscii:
        ANDS     R0,R0,#0xF
//  157   return u8Hex + ((u8Hex <= 9) ? '0' : ('A'-10));
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+10
        BGE.N    ??HexaToAscii_0
        MOVS     R1,#+48
        B.N      ??HexaToAscii_1
??HexaToAscii_0:
        MOVS     R1,#+55
??HexaToAscii_1:
        ADDS     R0,R1,R0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BX       LR               ;; return
//  158 }
//  159 
//  160 /************************************************************************************
//  161 * stringComp
//  162 *
//  163 * ...
//  164 *
//  165 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  166 bool_t stringComp(char * au8leftString, char * au8RightString, uint8_t bytesToCompare)
//  167 {
stringComp:
        PUSH     {R4}
//  168   do
//  169   {
//  170   }while((*au8leftString++ == *au8RightString++) && --bytesToCompare);
??stringComp_0:
        MOVS     R3,R0
        ADDS     R0,R3,#+1
        MOVS     R4,R1
        ADDS     R1,R4,#+1
        LDRB     R3,[R3, #+0]
        LDRB     R4,[R4, #+0]
        CMP      R3,R4
        BNE.N    ??stringComp_1
        SUBS     R2,R2,#+1
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+0
        BNE.N    ??stringComp_0
//  171   return(0 == bytesToCompare);
??stringComp_1:
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+0
        BNE.N    ??stringComp_2
        MOVS     R0,#+1
        B.N      ??stringComp_3
??stringComp_2:
        MOVS     R0,#+0
??stringComp_3:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R4}
        BX       LR               ;; return
//  172 }
//  173 
//  174 
//  175 /************************************************************************************
//  176 * MemoryCpy
//  177 *
//  178 * This function copy a buffer source to a buffer destination
//  179 *
//  180 ************************************************************************************/
//  181 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  182 void MemoryCpy
//  183 (
//  184   void *pDst, // Destination buffer
//  185   void *pSrc, // Source buffer
//  186   uint8_t n   // Byte count
//  187 )
//  188 {
//  189     // Code looks weird, but is quite optimal on a HCS08 CPU
//  190   while(n) {
MemoryCpy:
??MemoryCpy_0:
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+0
        BEQ.N    ??MemoryCpy_1
//  191     *((uint8_t *)pDst) = *((uint8_t *)pSrc);
        LDRB     R3,[R1, #+0]
        STRB     R3,[R0, #+0]
//  192     pDst=((uint8_t *)pDst)+1;
        ADDS     R0,R0,#+1
//  193     pSrc=((uint8_t *)pSrc)+1;
        ADDS     R1,R1,#+1
//  194     n--;
        SUBS     R2,R2,#+1
        B.N      ??MemoryCpy_0
//  195   }
//  196 }
??MemoryCpy_1:
        BX       LR               ;; return
//  197 
//  198 /************************************************************************************
//  199 * MemorySet
//  200 *
//  201 * This function set an specific value into a buffer destination
//  202 *
//  203 ************************************************************************************/
//  204 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  205 void MemorySet
//  206 (
//  207   void *pDst,    // Buffer to be reset
//  208   uint8_t value, // Byte value
//  209   uint16_t cnt    // Byte count
//  210 )
//  211 {
//  212   while(cnt) {
MemorySet:
??MemorySet_0:
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        CMP      R2,#+0
        BEQ.N    ??MemorySet_1
//  213     ((uint8_t *)pDst)[--cnt] = value;
        SUBS     R2,R2,#+1
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        STRB     R1,[R2, R0]
        B.N      ??MemorySet_0
//  214   }
//  215 }
??MemorySet_1:
        BX       LR               ;; return
//  216 
//  217 /**************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  218 void PrintByteOnHexFormatBlocking(uint8_t u8Byte, bool_t bPrintComma, uint8_t port)
//  219 {
PrintByteOnHexFormatBlocking:
        PUSH     {R4-R6,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
//  220   static uint8_t HexString[4] = {0};
//  221     
//  222   HexString[0] = HexToAscii(u8Byte>>4);
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LSRS     R0,R4,#+4
        BL       HexToAscii
        LDR.N    R1,??DataTable3_4
        STRB     R0,[R1, #+0]
//  223   HexString[1] = HexToAscii(u8Byte);
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       HexToAscii
        LDR.N    R1,??DataTable3_4
        STRB     R0,[R1, #+1]
//  224   
//  225   if(bPrintComma){
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BEQ.N    ??PrintByteOnHexFormatBlocking_0
//  226     HexString[2] = ',';  
        MOVS     R0,#+44
        LDR.N    R1,??DataTable3_4
        STRB     R0,[R1, #+2]
        B.N      ??PrintByteOnHexFormatBlocking_1
//  227   }else{
//  228     HexString[2] = 0;      
??PrintByteOnHexFormatBlocking_0:
        MOVS     R0,#+0
        LDR.N    R1,??DataTable3_4
        STRB     R0,[R1, #+2]
//  229   }
//  230   HexString[3] = 0;      
??PrintByteOnHexFormatBlocking_1:
        MOVS     R0,#+0
        LDR.N    R1,??DataTable3_4
        STRB     R0,[R1, #+3]
//  231   
//  232   CommUtil_Print((char *)HexString, gAllowToBlock_d);
        MOVS     R1,#+1
        LDR.N    R0,??DataTable3_4
        BL       CommUtil_Print
//  233 }
        POP      {R4-R6,PC}       ;; return

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
??HexString:
        DS8 4
//  234 
//  235 
//  236 /**************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  237 void PrintWordOnDecimalFormatBlocking(uint16_t u16Dec, uint8_t u8MinDigs,bool_t bNegative, uint8_t port)
//  238 {
PrintWordOnDecimalFormatBlocking:
        PUSH     {R3-R9,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
        MOVS     R7,R3
//  239   static uint8_t decString[7] = {0};
//  240   uint8_t ind,Sing;
//  241     
//  242   int2BCD(u16Dec, &decString[1]);
        LDR.N    R1,??DataTable3_5
        MOVS     R0,R4
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        BL       int2BCD
//  243   
//  244   Sing=0;
        MOVS     R0,#+0
        MOV      R9,R0
//  245   decString[0]=0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable3_6
        STRB     R0,[R1, #+0]
//  246   if(u8MinDigs > 5) u8MinDigs = 5;
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+6
        BLT.N    ??PrintWordOnDecimalFormatBlocking_0
        MOVS     R0,#+5
        MOVS     R5,R0
//  247   while((0 == decString[Sing+1]) && (Sing < 5-u8MinDigs)){
??PrintWordOnDecimalFormatBlocking_0:
        LDR.N    R0,??DataTable3_6
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        ADDS     R0,R9,R0
        LDRB     R0,[R0, #+1]
        CMP      R0,#+0
        BNE.N    ??PrintWordOnDecimalFormatBlocking_1
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        RSBS     R0,R5,#+5
        CMP      R9,R0
        BGE.N    ??PrintWordOnDecimalFormatBlocking_1
//  248     Sing++; 
        ADDS     R9,R9,#+1
        B.N      ??PrintWordOnDecimalFormatBlocking_0
//  249   }
//  250   for(ind=Sing;ind<6;ind++){
??PrintWordOnDecimalFormatBlocking_1:
        MOV      R8,R9
??PrintWordOnDecimalFormatBlocking_2:
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+6
        BGE.N    ??PrintWordOnDecimalFormatBlocking_3
//  251     decString[ind] += '0';  
        LDR.N    R0,??DataTable3_6
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDRB     R0,[R8, R0]
        ADDS     R0,R0,#+48
        LDR.N    R1,??DataTable3_6
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRB     R0,[R8, R1]
//  252   }
        ADDS     R8,R8,#+1
        B.N      ??PrintWordOnDecimalFormatBlocking_2
//  253   if(bNegative){
??PrintWordOnDecimalFormatBlocking_3:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BEQ.N    ??PrintWordOnDecimalFormatBlocking_4
//  254     decString[Sing] = '-';
        MOVS     R0,#+45
        LDR.N    R1,??DataTable3_6
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        STRB     R0,[R9, R1]
        B.N      ??PrintWordOnDecimalFormatBlocking_5
//  255   }else{
//  256     Sing++;
??PrintWordOnDecimalFormatBlocking_4:
        ADDS     R9,R9,#+1
//  257   }
//  258   CommUtil_Print((char*)&decString[Sing], gAllowToBlock_d);
??PrintWordOnDecimalFormatBlocking_5:
        MOVS     R1,#+1
        LDR.N    R0,??DataTable3_6
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        ADDS     R0,R9,R0
        BL       CommUtil_Print
//  259 }
        POP      {R0,R4-R9,PC}    ;; return

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
??decString:
        DS8 8
//  260 
//  261 /**************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  262 void int2BCD(uint16_t u16Num, uint8_t * pu8BCDOut)
//  263 {
int2BCD:
        PUSH     {R4,R5}
//  264   uint8_t cont=16;
        MOVS     R2,#+16
//  265   uint8_t aux=0;
        MOVS     R3,#+0
//  266 
//  267   for (aux=0;aux<5;aux++){
        MOVS     R4,#+0
        MOVS     R3,R4
??int2BCD_0:
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+5
        BGE.N    ??int2BCD_1
//  268     pu8BCDOut[aux]=0;
        MOVS     R4,#+0
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        STRB     R4,[R3, R1]
//  269   }
        ADDS     R3,R3,#+1
        B.N      ??int2BCD_0
//  270   do{
//  271     for(aux=0;aux<5;aux++) {
??int2BCD_1:
        MOVS     R4,#+0
        MOVS     R3,R4
??int2BCD_2:
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+5
        BGE.N    ??int2BCD_3
//  272       pu8BCDOut[aux]<<=1;
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        LDRB     R4,[R3, R1]
        LSLS     R4,R4,#+1
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        STRB     R4,[R3, R1]
//  273     }
        ADDS     R3,R3,#+1
        B.N      ??int2BCD_2
//  274     if(u16Num&0x8000){
??int2BCD_3:
        LSLS     R4,R0,#+16
        BPL.N    ??int2BCD_4
//  275       pu8BCDOut[4]+=1;
        LDRB     R4,[R1, #+4]
        ADDS     R4,R4,#+1
        STRB     R4,[R1, #+4]
//  276     }
//  277     u16Num<<=1;
??int2BCD_4:
        LSLS     R0,R0,#+1
//  278     for(aux=4;aux>0;aux--){
        MOVS     R4,#+4
        MOVS     R3,R4
??int2BCD_5:
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+0
        BEQ.N    ??int2BCD_6
//  279       if (pu8BCDOut[aux]>=10){
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        LDRB     R4,[R3, R1]
        CMP      R4,#+10
        BLT.N    ??int2BCD_7
//  280         pu8BCDOut[aux-1]++;
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        ADDS     R4,R3,R1
        LDRB     R4,[R4, #-1]
        ADDS     R4,R4,#+1
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        ADDS     R5,R3,R1
        STRB     R4,[R5, #-1]
//  281         pu8BCDOut[aux]-=10;
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        LDRB     R4,[R3, R1]
        SUBS     R4,R4,#+10
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        STRB     R4,[R3, R1]
//  282       }
//  283     }
??int2BCD_7:
        SUBS     R3,R3,#+1
        B.N      ??int2BCD_5
//  284     cont--;
??int2BCD_6:
        SUBS     R2,R2,#+1
//  285   }while(cont);
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+0
        BNE.N    ??int2BCD_1
//  286 }
        POP      {R4,R5}
        BX       LR               ;; return
//  287 
//  288 /**************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  289 uint16_t HexString2Dec16(uint8_t * au8String)
//  290 {
HexString2Dec16:
        PUSH     {R4,R5}
        MOVS     R1,R0
//  291   uint8_t u8LocIndex=0;
        MOVS     R3,#+0
//  292   uint8_t u8LocIndex2=0;
        MOVS     R2,#+0
//  293   uint16_t u16DecValue = 0;
        MOVS     R0,#+0
//  294   
//  295   while(au8String[u8LocIndex]){
??HexString2Dec16_0:
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        LDRB     R4,[R3, R1]
        CMP      R4,#+0
        BEQ.N    ??HexString2Dec16_1
//  296     u8LocIndex++;
        ADDS     R3,R3,#+1
        B.N      ??HexString2Dec16_0
//  297   }
//  298   
//  299   while(u8LocIndex--){
??HexString2Dec16_1:
        MOVS     R4,R3
        SUBS     R3,R4,#+1
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+0
        BEQ.N    ??HexString2Dec16_2
//  300     if((au8String[u8LocIndex] >= '0') && (au8String[u8LocIndex] <= '9'))
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        LDRB     R4,[R3, R1]
        CMP      R4,#+48
        BLT.N    ??HexString2Dec16_3
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        LDRB     R4,[R3, R1]
        CMP      R4,#+58
        BGE.N    ??HexString2Dec16_3
//  301      u16DecValue |= ((uint16_t)(au8String[u8LocIndex] - '0'))<<(u8LocIndex2*4);
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        LDRB     R4,[R3, R1]
        SUBS     R4,R4,#+48
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        LSLS     R5,R2,#+2
        LSLS     R4,R4,R5
        ORRS     R0,R4,R0
        B.N      ??HexString2Dec16_4
//  302     else if((au8String[u8LocIndex] >= 'A') && (au8String[u8LocIndex] <= 'F')){
??HexString2Dec16_3:
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        LDRB     R4,[R3, R1]
        CMP      R4,#+65
        BLT.N    ??HexString2Dec16_5
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        LDRB     R4,[R3, R1]
        CMP      R4,#+71
        BGE.N    ??HexString2Dec16_5
//  303      u16DecValue |= ((uint16_t)(au8String[u8LocIndex] - 'A' + 0x0A))<<(u8LocIndex2*4);    
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        LDRB     R4,[R3, R1]
        SUBS     R4,R4,#+55
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        LSLS     R5,R2,#+2
        LSLS     R4,R4,R5
        ORRS     R0,R4,R0
        B.N      ??HexString2Dec16_4
//  304     }else{
//  305      u16DecValue |= ((uint16_t)(au8String[u8LocIndex] - 'a' + 0x0A))<<(u8LocIndex2*4);        
??HexString2Dec16_5:
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        LDRB     R4,[R3, R1]
        SUBS     R4,R4,#+87
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        LSLS     R5,R2,#+2
        LSLS     R4,R4,R5
        ORRS     R0,R4,R0
//  306     }
//  307     u8LocIndex2++;
??HexString2Dec16_4:
        ADDS     R2,R2,#+1
        B.N      ??HexString2Dec16_1
//  308   }
//  309   
//  310   return u16DecValue;
??HexString2Dec16_2:
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        POP      {R4,R5}
        BX       LR               ;; return
//  311   
//  312 }
//  313 /**************************************************************************************/
//  314 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  315 void MCU_InitClock(void)
//  316 {
MCU_InitClock:
        PUSH     {R7,LR}
//  317     gMCG_coreClkMHz = MCG_PLLInit();
        BL       MCG_PLLInit
        LDR.N    R1,??DataTable3_7
        STR      R0,[R1, #+0]
//  318    /*
//  319    * Use the value obtained from the pll_init function to define variables
//  320    * for the core clock in kHz and also the peripheral clock. These
//  321    * variables can be used by other functions that need awareness of the
//  322    * system frequency.
//  323    */
//  324   gMCG_coreClkKHz = gMCG_coreClkMHz * 1000;
        LDR.N    R0,??DataTable3_7
        LDR      R0,[R0, #+0]
        MOV      R1,#+1000
        MULS     R0,R1,R0
        LDR.N    R1,??DataTable3_8
        STR      R0,[R1, #+0]
//  325   gMCG_periphClkKHz = gMCG_coreClkKHz / (((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV2_MASK) >> 24)+ 1);
        LDR.N    R0,??DataTable3_8
        LDR      R0,[R0, #+0]
        LDR.N    R1,??DataTable3_9  ;; 0x40048044
        LDR      R1,[R1, #+0]
        UBFX     R1,R1,#+24,#+4
        ADDS     R1,R1,#+1
        UDIV     R0,R0,R1
        LDR.N    R1,??DataTable3_10
        STR      R0,[R1, #+0]
//  326 
//  327 }
        POP      {R0,PC}          ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable3:
        DC32     0x40048038

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable3_1:
        DC32     0x40040000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable3_2:
        DC32     0x40040008

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable3_3:
        DC32     0x40040004

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable3_4:
        DC32     ??HexString

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable3_5:
        DC32     ??decString+0x1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable3_6:
        DC32     ??decString

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable3_7:
        DC32     gMCG_coreClkMHz

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable3_8:
        DC32     gMCG_coreClkKHz

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable3_9:
        DC32     0x40048044

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable3_10:
        DC32     gMCG_periphClkKHz
//  328 
//  329 /************************************************************************************
//  330 * This function copies the specified number of bytes from the
//  331 * source address to the destination address.  No attempt is made
//  332 * to handle overlapping copies to prevent loss of data.
//  333 * The copying is optimized to avoid alignment problems, and attempts
//  334 * to copy 32bit numbers optimally.
//  335 *   
//  336 * Interface assumptions:
//  337 *   None
//  338 *   
//  339 * Return value:
//  340 *   None
//  341 * 
//  342 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  343 void FLib_MemCpyAligned32bit
//  344   (
//  345      /* [IN] address to copy data from */
//  346      void*  from_ptr,
//  347 
//  348      /* [IN] address to copy data to */
//  349      void*  to_ptr,
//  350 
//  351      /* [IN] number of bytes to copy */
//  352      register uint32_t number_of_bytes
//  353   )
//  354 {
FLib_MemCpyAligned32bit:
        PUSH     {R4-R8,LR}
//  355 
//  356    uint8_t*  	from8_ptr = (uint8_t*) from_ptr;
        MOV      R12,R0
//  357    uint8_t*  	to8_ptr = (uint8_t*) to_ptr;
        MOV      LR,R1
//  358    uint16_t* 	from16_ptr = (uint16_t*) from_ptr;
        MOVS     R3,R0
//  359    uint16_t* 	to16_ptr = (uint16_t*) to_ptr;
        MOVS     R4,R1
//  360    register 	uint32_t* from32_ptr = (uint32_t*) from_ptr;
        MOVS     R5,R0
//  361    register 	uint32_t* to32_ptr = (uint32_t*) to_ptr;
        MOVS     R6,R1
//  362    
//  363    register 	uint32_t loops;
//  364 
//  365    if (number_of_bytes > 3) 
        CMP      R2,#+4
        BCC.N    ??FLib_MemCpyAligned32bit_0
//  366    {
//  367       /* Try to align source on word */
//  368       if ((uint32_t)from_ptr & 1) 
        MOV      R8,R0
        LSLS     R8,R8,#+31
        BPL.N    ??FLib_MemCpyAligned32bit_1
//  369       {
//  370          from8_ptr = (uint8_t* ) from_ptr;
        MOV      R12,R0
//  371          to8_ptr = (uint8_t* ) to_ptr;
        MOV      LR,R1
//  372 
//  373          *to8_ptr++ = *from8_ptr++;
        LDRB     R8,[R12, #+0]
        STRB     R8,[LR, #+0]
        ADDS     R12,R12,#+1
        ADDS     LR,LR,#+1
//  374 
//  375          from_ptr = from8_ptr;
        MOV      R0,R12
//  376          to_ptr = to8_ptr;
        MOV      R1,LR
//  377          --number_of_bytes;
        SUBS     R2,R2,#+1
//  378       }
//  379 
//  380       /* Try to align source on longword */
//  381       if ((uint32_t)from_ptr & 2) 
??FLib_MemCpyAligned32bit_1:
        MOV      R8,R0
        LSLS     R8,R8,#+30
        BPL.N    ??FLib_MemCpyAligned32bit_2
//  382       {
//  383          from16_ptr = (uint16_t*) from_ptr;
        MOVS     R3,R0
//  384          to16_ptr = (uint16_t*) to_ptr;
        MOVS     R4,R1
//  385 
//  386          *to16_ptr++ = *from16_ptr++;
        LDRH     R8,[R3, #+0]
        STRH     R8,[R4, #+0]
        ADDS     R3,R3,#+2
        ADDS     R4,R4,#+2
//  387 
//  388          from_ptr = from16_ptr;
        MOVS     R0,R3
//  389          to_ptr = to16_ptr;
        MOVS     R1,R4
//  390          number_of_bytes -= 2;
        SUBS     R2,R2,#+2
//  391       }
//  392 
//  393       from32_ptr = (uint32_t*) from_ptr;
??FLib_MemCpyAligned32bit_2:
        MOVS     R5,R0
//  394       to32_ptr = (uint32_t*) to_ptr;
        MOVS     R6,R1
//  395 
//  396       for (loops = number_of_bytes >> 2; loops != 0; loops--) 
        LSRS     R8,R2,#+2
        MOV      R7,R8
??FLib_MemCpyAligned32bit_3:
        CMP      R7,#+0
        BEQ.N    ??FLib_MemCpyAligned32bit_4
//  397       {
//  398          *to32_ptr++ = *from32_ptr++;
        LDR      R8,[R5, #+0]
        STR      R8,[R6, #+0]
        ADDS     R5,R5,#+4
        ADDS     R6,R6,#+4
//  399       }
        SUBS     R7,R7,#+1
        B.N      ??FLib_MemCpyAligned32bit_3
//  400 
//  401       from_ptr = from32_ptr;
??FLib_MemCpyAligned32bit_4:
        MOVS     R0,R5
//  402       to_ptr = to32_ptr;
        MOVS     R1,R6
//  403    } 
//  404 
//  405    /* Copy all remaining bytes */
//  406    if (number_of_bytes & 2) 
??FLib_MemCpyAligned32bit_0:
        LSLS     R8,R2,#+30
        BPL.N    ??FLib_MemCpyAligned32bit_5
//  407    {
//  408       from16_ptr = (uint16_t*) from_ptr;
        MOVS     R3,R0
//  409       to16_ptr = (uint16_t*) to_ptr;
        MOVS     R4,R1
//  410 
//  411       *to16_ptr++ = *from16_ptr++;
        LDRH     R8,[R3, #+0]
        STRH     R8,[R4, #+0]
        ADDS     R3,R3,#+2
        ADDS     R4,R4,#+2
//  412 
//  413       from_ptr = from16_ptr;
        MOVS     R0,R3
//  414       to_ptr = to16_ptr;
        MOVS     R1,R4
//  415    } 
//  416 
//  417    if (number_of_bytes & 1) 
??FLib_MemCpyAligned32bit_5:
        LSLS     R8,R2,#+31
        BPL.N    ??FLib_MemCpyAligned32bit_6
//  418    {
//  419       * (uint8_t* ) to_ptr = * (uint8_t* ) from_ptr;
        LDRB     R8,[R0, #+0]
        STRB     R8,[R1, #+0]
//  420    }
//  421 }
??FLib_MemCpyAligned32bit_6:
        POP      {R4-R8,PC}       ;; return

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        END
//  422 
// 
//    12 bytes in section .bss
// 1 276 bytes in section .text
// 
// 1 276 bytes of CODE memory
//    12 bytes of DATA memory
//
//Errors: none
//Warnings: none
