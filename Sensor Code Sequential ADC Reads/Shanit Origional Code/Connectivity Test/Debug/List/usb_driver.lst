###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        02/Sep/2018  14:19:43
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\Driver\usb_driver.c
#    Command line =  
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\Driver\usb_driver.c" -D IAR --preprocess
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\List\" -lC
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\List\" -lB
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\List\"
#        --diag_suppress Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\CDC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\Descriptor\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\USB\Class\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Sys Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
#    List file    =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\Debug\List\usb_driver.lst
#    Object file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\Obj\usb_driver.o
#
###############################################################################

F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\usb_driver.c
      1          /******************************************************************************
      2           *
      3           * Freescale Semiconductor Inc.
      4           * (c) Copyright 2004-2010 Freescale Semiconductor, Inc.
      5           * ALL RIGHTS RESERVED.
      6           *
      7           ******************************************************************************
      8           *
      9           * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR 
     10           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
     11           * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
     12           * IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
     13           * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
     14           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
     15           * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
     16           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
     17           * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
     18           * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
     19           * THE POSSIBILITY OF SUCH DAMAGE.
     20           *
     21           **************************************************************************//*!
     22           *
     23           * @file usb_driver.c
     24           *
     25           * @author
     26           *
     27           * @version
     28           *
     29           * @date
     30           *
     31           * @brief The file contains S08 USB stack device layer implementation.
     32           *
     33           *****************************************************************************/
     34          
     35          /******************************************************************************
     36           * Includes
     37           *****************************************************************************/
     38          #include "USB_Interface.h"
     39          #include "USB.h"
     40          #include "usb_devapi.h" /* USB Device Layer API Header File */
     41          #include "usb_dciapi.h" /* USB Controller API Header File */
     42          #include "Utilities_Interface.h" 
     43          
     44          #if gUsbIncluded_d
     45          /*****************************************************************************
     46           * Constant and Macro's
     47           *****************************************************************************/
     48          
     49          
     50          /****************************************************************************
     51           * Global Variables
     52           ****************************************************************************/
     53          
     54          /* Array of USB Service pointers */
     55          #define gUsbCB(controller_ID) gUsbCB_

   \                                 In section .bss, align 4
     56          static usbServiceCallback_t gUsbCB_[gUsbService_Max_d];  
   \                     gUsbCB_:
   \   00000000                      DS8 88
     57          /* Array of USB Component Status */
     58          /* Test mode is the last service */
     59          #define gUsbComponentStatus(controller_ID) gUsbComponentStatus_

   \                                 In section .bss, align 4
     60          static uint16_t gUsbComponentStatus_[gUsbComponentStatus_TestMode_d]; 
   \                     gUsbComponentStatus_:
   \   00000000                      DS8 16
     61          /* Array of USB Endpoint Status */
     62          #define gUsbEpStatus(controller_ID) gUsbEpStatus_

   \                                 In section .bss, align 4
     63          static uint16_t gUsbEpStatus_[gNumMaxEnpNumber_d];
   \                     gUsbEpStatus_:
   \   00000000                      DS8 32
     64          /* Current un-initialized non CONTROL Endpoint */
     65          #define gEpNo(controller_ID) gEpNo_

   \                                 In section .bss, align 1
     66          static uint8_t gEpNo_=0;     
   \                     gEpNo_:
   \   00000000                      DS8 1
     67          /* Maximum number of Non CONTROL Endpoint required by upper layer */
     68          #define gEpNoMax(controller_ID) gEpNoMax_

   \                                 In section .bss, align 1
     69          static uint8_t gEpNoMax_=0; 
   \                     gEpNoMax_:
   \   00000000                      DS8 1
     70          
     71          /*****************************************************************************
     72           * Local Types - None
     73           *****************************************************************************/
     74          
     75          /*****************************************************************************
     76           * Local Functions Prototypes - None
     77           *****************************************************************************/
     78          static void USB_DeviceInitParams(uint8_t    controllerId);
     79          
     80          /*****************************************************************************
     81           * Local Variables - None
     82           *****************************************************************************/
     83          
     84          /*****************************************************************************
     85           * Local Functions 
     86           *****************************************************************************/
     87          /**************************************************************************//*!
     88           *
     89           * @name  USB_DeviceInitParams
     90           *
     91           * @brief The funtion initializes the Device Layer Structures
     92           *
     93           * @param  None
     94           *
     95           * @return None
     96           *
     97           ******************************************************************************
     98           * Initializes USB Device Layer Structures
     99           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    100          static void USB_DeviceInitParams(uint8_t    controllerId)
    101          {
    102            uint8_t loopIndex=0;
   \                     USB_DeviceInitParams: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    103            (void)controllerId;
    104            gEpNo(controllerId)= gEpNoMax(controllerId); /* 1 control endpoint */
   \   00000002   0x....             LDR.N    R2,??DataTable9
   \   00000004   0x7812             LDRB     R2,[R2, #+0]
   \   00000006   0x....             LDR.N    R3,??DataTable9_1
   \   00000008   0x701A             STRB     R2,[R3, #+0]
    105              /* 
    106                 Initialize gUsbComponentStatus_DeviceState_d, gUsbComponentStatus_Interface_d,
    107                 gUsbComponentStatus_Address_d, gUsbComponentStatus_CurrentConfig_d, gUsbComponentStatus_SOFCount_d
    108                 and gUsbComponentStatus_Device_d to gUsbStatus_Unknown_d 
    109              */
    110            for(loopIndex = 0; loopIndex < gUsbComponentStatus_TestMode_d; loopIndex++)
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x0011             MOVS     R1,R2
   \                     ??USB_DeviceInitParams_0: (+1)
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x2907             CMP      R1,#+7
   \   00000012   0xDA07             BGE.N    ??USB_DeviceInitParams_1
    111            {
    112              gUsbComponentStatus(controllerId)[loopIndex] = gUsbStatus_Unknown_d;
   \   00000014   0xF64F 0x72FF      MOVW     R2,#+65535
   \   00000018   0x....             LDR.N    R3,??DataTable9_2
   \   0000001A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   0xF823 0x2011      STRH     R2,[R3, R1, LSL #+1]
    113            }
   \   00000020   0x1C49             ADDS     R1,R1,#+1
   \   00000022   0xE7F4             B.N      ??USB_DeviceInitParams_0
    114            /* Initialize status of All Endpoints to gUsbStatus_Disabled_d */
    115            for(loopIndex = 0; loopIndex < gNumMaxEnpNumber_d; loopIndex++)
   \                     ??USB_DeviceInitParams_1: (+1)
   \   00000024   0x2200             MOVS     R2,#+0
   \   00000026   0x0011             MOVS     R1,R2
   \                     ??USB_DeviceInitParams_2: (+1)
   \   00000028   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002A   0x2910             CMP      R1,#+16
   \   0000002C   0xDA06             BGE.N    ??USB_DeviceInitParams_3
    116            {
    117              gUsbEpStatus(controllerId)[loopIndex] = gUsbStatus_Disabled_d;
   \   0000002E   0x2205             MOVS     R2,#+5
   \   00000030   0x....             LDR.N    R3,??DataTable9_3
   \   00000032   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000034   0xF823 0x2011      STRH     R2,[R3, R1, LSL #+1]
    118            }
   \   00000038   0x1C49             ADDS     R1,R1,#+1
   \   0000003A   0xE7F5             B.N      ??USB_DeviceInitParams_2
    119          }
   \                     ??USB_DeviceInitParams_3: (+1)
   \   0000003C   0x4770             BX       LR               ;; return
    120          
    121          
    122          
    123          /*****************************************************************************
    124           * Global Functions
    125           *****************************************************************************/
    126          
    127          
    128          /**************************************************************************//*!
    129           *
    130           * @name  USB_DeviceInit
    131           *
    132           * @brief The funtion initializes the Device and Controller layer
    133           *
    134           * @param controller_ID : Controller ID
    135           * @param endpoints     : Endpoint count of the application
    136           *
    137           * @return status
    138           *         gUsbErr_NoError_c                              : When Successfull
    139           *         gUsbErr_InvalidNumOfEndpoints_c     : When endpoints > max Supported
    140           ******************************************************************************
    141           * This function initializes the Device layer and the Controller layer of the
    142           * S08 USB stack. It initialised the variables used for this layer and then
    143           * calls the controller layer initialize function
    144           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    145          uint8_t USB_DeviceInit (
    146              uint8_t    controllerId, /* [IN] Controller ID */
    147              uint8_t    endpoints      /* [IN] Endpoint count of the application */
    148          )
    149          {
   \                     USB_DeviceInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    150          
    151            /* validate endpoints param */
    152            if((endpoints > gNumMaxEnpNumber_d) || (endpoints < gNumMinEnpNumber_d))
   \   00000006   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000008   0x2D11             CMP      R5,#+17
   \   0000000A   0xDA02             BGE.N    ??USB_DeviceInit_0
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD101             BNE.N    ??USB_DeviceInit_1
    153            {
    154              return gUsbErr_InvalidNumOfEndpoints_c;
   \                     ??USB_DeviceInit_0: (+1)
   \   00000012   0x2099             MOVS     R0,#+153
   \   00000014   0xE00F             B.N      ??USB_DeviceInit_2
    155            }
    156            /*init variables */
    157            gEpNoMax(controllerId) = endpoints - 1;
   \                     ??USB_DeviceInit_1: (+1)
   \   00000016   0x1E68             SUBS     R0,R5,#+1
   \   00000018   0x....             LDR.N    R1,??DataTable9
   \   0000001A   0x7008             STRB     R0,[R1, #+0]
    158            USB_DeviceInitParams(controllerId);
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x.... 0x....      BL       USB_DeviceInitParams
    159            /* Initialize all services to null value */
    160            MemorySet(gUsbCB(controllerId), 0, (uint16_t)(sizeof(usbServiceCallback_t) * gUsbService_Max_d));
   \   00000024   0x2258             MOVS     R2,#+88
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x....             LDR.N    R0,??DataTable9_4
   \   0000002A   0x.... 0x....      BL       MemorySet
    161              /* Call controller layer initialization function */
    162            return USB_DCI_Init(controllerId);
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x.... 0x....      BL       USB_DCI_Init
   \                     ??USB_DeviceInit_2: (+1)
   \   00000036   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    163          
    164          }
    165          /**************************************************************************//*!
    166           *
    167           * @name  USB_DeviceDeinit
    168           *
    169           * @brief The funtion initializes the Device and Controller layer
    170           *
    171           * @param controller_ID : Controller ID
    172           * @param endpoints     : Endpoint count of the application
    173           *
    174           * @return status
    175           *         gUsbErr_NoError_c                              : When Successfull
    176           *         gUsbErr_InvalidNumOfEndpoints_c     : When endpoints > max Supported
    177           ******************************************************************************
    178           * This function initializes the Device layer and the Controller layer of the
    179           * S08 USB stack. It initialised the variables used for this layer and then
    180           * calls the controller layer initialize function
    181           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    182          uint8_t USB_DeviceDeinit (
    183              uint8_t    controllerId /* [IN] Controller ID */
    184          )
    185          {
   \                     USB_DeviceDeinit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    186            uint8_t error;
    187            error = USB_DCI_DeInit(controllerId );
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       USB_DCI_DeInit
   \   0000000C   0x0005             MOVS     R5,R0
    188            gEpNoMax(controllerId) = 0; //Keep this order
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x....             LDR.N    R1,??DataTable9
   \   00000012   0x7008             STRB     R0,[R1, #+0]
    189            USB_DeviceInitParams(controllerId);
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x.... 0x....      BL       USB_DeviceInitParams
    190            /* Initialize all services to null value */
    191            MemorySet(gUsbCB(controllerId), 0, (uint16_t)(sizeof(usbServiceCallback_t) * gUsbService_Max_d));
   \   0000001C   0x2258             MOVS     R2,#+88
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x....             LDR.N    R0,??DataTable9_4
   \   00000022   0x.... 0x....      BL       MemorySet
    192            return error;
   \   00000026   0x0028             MOVS     R0,R5
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    193          }
    194          
    195          /**************************************************************************//*!
    196           *
    197           * @name  USB_DeviceInitEndpoint
    198           *
    199           * @brief The funtion initializes the endpoint
    200           *
    201           * @param controller_ID : Controller ID
    202           * @param ep_ptr        : Pointer to endpoint detail structure
    203           * @param flag          : Zero termination flag
    204           *
    205           * @return status
    206           *         gUsbErr_NoError_c                              : When Successfull
    207           *         gUsbErr_EpInitFailed_c     : When endpoints > max Supported
    208           ******************************************************************************
    209           *
    210           * This function initializes an endpoint the Device layer and the Controller
    211           * layer in the S08 USB stack. It validate whether all endpoints have already
    212           * been initialized or not and then calls the controller layer endpoint
    213           *  initialize function
    214           *
    215           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    216          uint8_t USB_DeviceInitEndpoint (
    217              uint8_t               controllerId, /* [IN] Controller ID */
    218              usbEpStruct_t*        pUsbEpStruct,        /* [IN] Pointer to endpoint detail
    219                                                      structure */
    220              uint8_t               flag           /* [IN] Zero termination flag */
    221          )
    222          {
   \                     USB_DeviceInitEndpoint: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    223            uint8_t status=gUsbErr_NoError_c;
   \   00000008   0x2700             MOVS     R7,#+0
    224            /* check if all endpoint have already been initialised */
    225            if((gEpNo(controllerId) == 0) && (pUsbEpStruct->number != gUsbControlEndpoint_d))
   \   0000000A   0x....             LDR.N    R0,??DataTable9_1
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD104             BNE.N    ??USB_DeviceInitEndpoint_0
   \   00000012   0x7828             LDRB     R0,[R5, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD001             BEQ.N    ??USB_DeviceInitEndpoint_0
    226            {
    227              return gUsbErr_EpInitFailed_c;
   \   00000018   0x2095             MOVS     R0,#+149
   \   0000001A   0xE014             B.N      ??USB_DeviceInitEndpoint_1
    228            }
    229            /* call controller layer for initiazation */
    230            status = USB_DCI_InitEndpoint(controllerId, pUsbEpStruct, flag);
   \                     ??USB_DeviceInitEndpoint_0: (+1)
   \   0000001C   0x0032             MOVS     R2,R6
   \   0000001E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000020   0x0029             MOVS     R1,R5
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x.... 0x....      BL       USB_DCI_InitEndpoint
   \   0000002A   0x0007             MOVS     R7,R0
    231            /* if endpoint successfully initialised update counter */
    232            if ((pUsbEpStruct->number != gUsbControlEndpoint_d) && (status == gUsbErr_NoError_c))
   \   0000002C   0x7828             LDRB     R0,[R5, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD007             BEQ.N    ??USB_DeviceInitEndpoint_2
   \   00000032   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000034   0x2F00             CMP      R7,#+0
   \   00000036   0xD104             BNE.N    ??USB_DeviceInitEndpoint_2
    233            {
    234              gEpNo(controllerId)--;
   \   00000038   0x....             LDR.N    R0,??DataTable9_1
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x1E40             SUBS     R0,R0,#+1
   \   0000003E   0x....             LDR.N    R1,??DataTable9_1
   \   00000040   0x7008             STRB     R0,[R1, #+0]
    235            }
    236          
    237            return status;
   \                     ??USB_DeviceInitEndpoint_2: (+1)
   \   00000042   0x0038             MOVS     R0,R7
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceInitEndpoint_1: (+1)
   \   00000046   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    238          }
    239          
    240          
    241          /**************************************************************************//*!
    242           *
    243           * @name  USB_DeviceDeinitEndpoint
    244           *
    245           * @brief The funtion De-initializes the endpoint
    246           *
    247           * @param controller_ID : Controller ID
    248           * @param ep_ptr        : Pointer to endpoint detail structure
    249           * @param flag          : Zero termination flag
    250           *
    251           * @return status
    252           *         gUsbErr_NoError_c                              : When Successfull
    253           *         gUsbErr_EpDeinitFailed_c     : When endpoints > max Supported
    254           ******************************************************************************
    255           *
    256           * This function deinitializes an endpoint the Device layer and the Controller
    257           * layer in the S08 USB stack. It validate whether all endpoints have already
    258           * been deinitialized or not and then calls the controller layer endpoint
    259           * deinitialize function
    260           *
    261           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    262          uint8_t USB_DeviceDeinitEndpoint (
    263              uint8_t    controllerId,  /* [IN] Controller ID */
    264              uint8_t    epNum,         /* [IN] Endpoint number */
    265              uint8_t    direction       /* [IN] Direction */
    266          )
    267          {
   \                     USB_DeviceDeinitEndpoint: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    268            uint8_t status=gUsbErr_NoError_c;
   \   00000008   0x2700             MOVS     R7,#+0
    269            /* check if all endpoint have already been initialised */
    270            if((gEpNo(controllerId) == gEpNoMax(controllerId)) && (epNum != gUsbControlEndpoint_d))
   \   0000000A   0x....             LDR.N    R0,??DataTable9_1
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x....             LDR.N    R1,??DataTable9
   \   00000010   0x7809             LDRB     R1,[R1, #+0]
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD104             BNE.N    ??USB_DeviceDeinitEndpoint_0
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD001             BEQ.N    ??USB_DeviceDeinitEndpoint_0
    271            {
    272              return gUsbErr_EpDeinitFailed_c;
   \   0000001C   0x2096             MOVS     R0,#+150
   \   0000001E   0xE015             B.N      ??USB_DeviceDeinitEndpoint_1
    273            }
    274            /* call controller layer for initiazation */
    275            status = USB_DCI_DeinitEndpoint(controllerId, epNum, direction);
   \                     ??USB_DeviceDeinitEndpoint_0: (+1)
   \   00000020   0x0032             MOVS     R2,R6
   \   00000022   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000024   0x0029             MOVS     R1,R5
   \   00000026   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x.... 0x....      BL       USB_DCI_DeinitEndpoint
   \   00000030   0x0007             MOVS     R7,R0
    276            /* if endpoint successfully deinitialised update counter */
    277            if ((epNum != gUsbControlEndpoint_d) && (status == gUsbErr_NoError_c))
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD007             BEQ.N    ??USB_DeviceDeinitEndpoint_2
   \   00000038   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003A   0x2F00             CMP      R7,#+0
   \   0000003C   0xD104             BNE.N    ??USB_DeviceDeinitEndpoint_2
    278            {
    279              gEpNo(controllerId)++;
   \   0000003E   0x....             LDR.N    R0,??DataTable9_1
   \   00000040   0x7800             LDRB     R0,[R0, #+0]
   \   00000042   0x1C40             ADDS     R0,R0,#+1
   \   00000044   0x....             LDR.N    R1,??DataTable9_1
   \   00000046   0x7008             STRB     R0,[R1, #+0]
    280            }
    281          
    282              return status;
   \                     ??USB_DeviceDeinitEndpoint_2: (+1)
   \   00000048   0x0038             MOVS     R0,R7
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceDeinitEndpoint_1: (+1)
   \   0000004C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    283          }
    284          
    285          /**************************************************************************//*!
    286           *
    287           * @name  USB_DeviceGetStatus
    288           *
    289           * @brief The funtion retrieves various endpoint as well as USB component status
    290           *
    291           * @param controller_ID : Controller ID
    292           * @param component     : USB component
    293           * @param status        : Pointer to 16 bit return value
    294           *
    295           * @return status
    296           *         gUsbErr_NoError_c                : When Successfull
    297           *         gUsbErr_BadStatus_c     : When error
    298           *
    299           ******************************************************************************
    300           * This function retrieves the endpoint as well USB component status which is
    301           * stored by calling USB_DeviceSetStatus. This function can be called by Ap-
    302           * plication as well as the DCI layer.
    303           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    304          uint8_t USB_DeviceGetStatus (
    305              uint8_t        controllerId,  /* [IN]  Controller ID  */
    306              uint8_t        component,      /* [IN]  USB component */
    307              uint16_t*   status          /* [OUT] Pointer to 16 bit return value */
    308          )
    309          {
   \                     USB_DeviceGetStatus: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0003             MOVS     R3,R0
    310            /* get the endpoint number from component input variable */
    311            uint8_t epNum = (uint8_t)(component & gUsbComponentStatus_EpNumberMask_d);
   \   00000004   0xF011 0x040F      ANDS     R4,R1,#0xF
    312            (void)controllerId;
    313            
    314            if((component <= gUsbComponentStatus_TestMode_d) && (component >= gUsbComponentStatus_DeviceState_d))
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x2908             CMP      R1,#+8
   \   0000000C   0xDA0A             BGE.N    ??USB_DeviceGetStatus_0
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD007             BEQ.N    ??USB_DeviceGetStatus_0
    315            {
    316            /* Get the corresponding component status  -1 as components start from 1 */
    317              *status = gUsbComponentStatus(controllerId)[component-1];
   \   00000014   0x....             LDR.N    R0,??DataTable9_2
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0xEB10 0x0041      ADDS     R0,R0,R1, LSL #+1
   \   0000001C   0xF830 0x0C02      LDRH     R0,[R0, #-2]
   \   00000020   0x8010             STRH     R0,[R2, #+0]
   \   00000022   0xE00C             B.N      ??USB_DeviceGetStatus_1
    318            }
    319            else if ((component & gUsbComponentStatus_Endpoint_d) && (epNum < gNumMaxEnpNumber_d))
   \                     ??USB_DeviceGetStatus_0: (+1)
   \   00000024   0x06C8             LSLS     R0,R1,#+27
   \   00000026   0xD508             BPL.N    ??USB_DeviceGetStatus_2
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x2C10             CMP      R4,#+16
   \   0000002C   0xDA05             BGE.N    ??USB_DeviceGetStatus_2
    320            {
    321              /* Get the corresponding endpoint status */
    322              *status = gUsbEpStatus(controllerId)[epNum];
   \   0000002E   0x....             LDR.N    R0,??DataTable9_3
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0xF830 0x0014      LDRH     R0,[R0, R4, LSL #+1]
   \   00000036   0x8010             STRH     R0,[R2, #+0]
   \   00000038   0xE001             B.N      ??USB_DeviceGetStatus_1
    323            }
    324            else
    325            {
    326              return gUsbErr_BadStatus_c;
   \                     ??USB_DeviceGetStatus_2: (+1)
   \   0000003A   0x2082             MOVS     R0,#+130
   \   0000003C   0xE000             B.N      ??USB_DeviceGetStatus_3
    327            }
    328          
    329            return gUsbErr_NoError_c;
   \                     ??USB_DeviceGetStatus_1: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \                     ??USB_DeviceGetStatus_3: (+1)
   \   00000040   0xBC10             POP      {R4}
   \   00000042   0x4770             BX       LR               ;; return
    330          }
    331          
    332          /**************************************************************************//*!
    333           *
    334           * @name  USB_DeviceSetStatus
    335           *
    336           * @brief The funtion saves status of endpoints as well as USB components.
    337           *
    338           * @param controller_ID : Controller ID
    339           * @param component     : USB component
    340           * @param setting       : Value to be set
    341           *
    342           * @return status
    343           *         gUsbErr_NoError_c                : When Successfull
    344           *         gUsbErr_BadStatus_c     : When error
    345           *
    346           ******************************************************************************
    347           * This function sets the endpoint as well USB component status which can be
    348           * retrieved by calling USB_DeviceGetStatus. This function can be called by
    349           * Application as well as the DCI layer.
    350           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    351          uint8_t USB_DeviceSetStatus(
    352              uint8_t    controllerId,  /* [IN] Controller ID */
    353              uint8_t    component,      /* [IN] USB component */
    354              uint16_t   setting         /* [IN] Value to be set */
    355          )
    356          {
   \                     USB_DeviceSetStatus: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    357            /* get the endpoint number from component input variable */
    358            uint8_t epNum = (uint8_t)(component & gUsbComponentStatus_EpNumberMask_d);
   \   0000000A   0xF015 0x070F      ANDS     R7,R5,#0xF
    359            if((component <= gUsbComponentStatus_TestMode_d) && (component >= gUsbComponentStatus_DeviceState_d))
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x2D08             CMP      R5,#+8
   \   00000012   0xDA09             BGE.N    ??USB_DeviceSetStatus_0
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD006             BEQ.N    ??USB_DeviceSetStatus_0
    360            {
    361              /* Set the corresponding component setting  -1 as components start from 1   */
    362              gUsbComponentStatus(controllerId)[component-1] = setting;
   \   0000001A   0x....             LDR.N    R0,??DataTable9_2
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0xEB10 0x0045      ADDS     R0,R0,R5, LSL #+1
   \   00000022   0xF820 0x6C02      STRH     R6,[R0, #-2]
   \   00000026   0xE040             B.N      ??USB_DeviceSetStatus_1
    363            }
    364            else if ((component & gUsbComponentStatus_Endpoint_d) && (epNum < gNumMaxEnpNumber_d))
   \                     ??USB_DeviceSetStatus_0: (+1)
   \   00000028   0x06E8             LSLS     R0,R5,#+27
   \   0000002A   0xD53C             BPL.N    ??USB_DeviceSetStatus_2
   \   0000002C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002E   0x2F10             CMP      R7,#+16
   \   00000030   0xDA39             BGE.N    ??USB_DeviceSetStatus_2
    365            {
    366              uint8_t direction = (uint8_t)((component >> gUsbComponent_DirectionShift_d) & gUsbComponent_DirectionMask_d);
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0xEA5F 0x18D5      LSRS     R8,R5,#+7
    367              /* HALT Endpoint */
    368              if(setting == gUsbStatus_Stalled_d)
   \   00000038   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000003A   0x2E01             CMP      R6,#+1
   \   0000003C   0xD108             BNE.N    ??USB_DeviceSetStatus_3
    369              {
    370                USB_DeviceStallEndpoint(controllerId, epNum, direction);
   \   0000003E   0x4642             MOV      R2,R8
   \   00000040   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000042   0x0039             MOVS     R1,R7
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0x.... 0x....      BL       USB_DeviceStallEndpoint
   \   0000004E   0xE025             B.N      ??USB_DeviceSetStatus_4
    371              }
    372              else if((setting == gUsbStatus_Idle_d) && (gUsbEpStatus(controllerId)[epNum] == gUsbStatus_Stalled_d))
   \                     ??USB_DeviceSetStatus_3: (+1)
   \   00000050   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000052   0x2E00             CMP      R6,#+0
   \   00000054   0xD122             BNE.N    ??USB_DeviceSetStatus_4
   \   00000056   0x....             LDR.N    R0,??DataTable9_3
   \   00000058   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005A   0xF830 0x0017      LDRH     R0,[R0, R7, LSL #+1]
   \   0000005E   0x2801             CMP      R0,#+1
   \   00000060   0xD11C             BNE.N    ??USB_DeviceSetStatus_4
    373              {
    374                USB_DeviceUnstallEndpoint(controllerId, epNum, direction);
   \   00000062   0x4642             MOV      R2,R8
   \   00000064   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000066   0x0039             MOVS     R1,R7
   \   00000068   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0x.... 0x....      BL       USB_DeviceUnstallEndpoint
    375                if(epNum == gUsbControlEndpoint_d)
   \   00000072   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000074   0x2F00             CMP      R7,#+0
   \   00000076   0xD111             BNE.N    ??USB_DeviceSetStatus_4
    376                {
    377                  direction = (uint8_t)((direction == gUsbEpDirection_In_c)?(gUsbEpDirection_Out_c):(gUsbEpDirection_In_c));
   \   00000078   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000007C   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000080   0xD102             BNE.N    ??USB_DeviceSetStatus_5
   \   00000082   0xF05F 0x0800      MOVS     R8,#+0
   \   00000086   0xE001             B.N      ??USB_DeviceSetStatus_6
   \                     ??USB_DeviceSetStatus_5: (+1)
   \   00000088   0xF05F 0x0801      MOVS     R8,#+1
    378                  USB_DeviceUnstallEndpoint(controllerId, epNum, direction);
   \                     ??USB_DeviceSetStatus_6: (+1)
   \   0000008C   0x4642             MOV      R2,R8
   \   0000008E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000090   0x0039             MOVS     R1,R7
   \   00000092   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000094   0x0020             MOVS     R0,R4
   \   00000096   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000098   0x.... 0x....      BL       USB_DeviceUnstallEndpoint
    379                }
    380              }
    381                  /* Set the corresponding endpoint setting */
    382              gUsbEpStatus(controllerId)[epNum] = setting;
   \                     ??USB_DeviceSetStatus_4: (+1)
   \   0000009C   0x....             LDR.N    R0,??DataTable9_3
   \   0000009E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000A0   0xF820 0x6017      STRH     R6,[R0, R7, LSL #+1]
   \   000000A4   0xE001             B.N      ??USB_DeviceSetStatus_1
    383            }
    384            else
    385            {
    386              return gUsbErr_BadStatus_c;
   \                     ??USB_DeviceSetStatus_2: (+1)
   \   000000A6   0x2082             MOVS     R0,#+130
   \   000000A8   0xE000             B.N      ??USB_DeviceSetStatus_7
    387            }
    388            return gUsbErr_NoError_c;
   \                     ??USB_DeviceSetStatus_1: (+1)
   \   000000AA   0x2000             MOVS     R0,#+0
   \                     ??USB_DeviceSetStatus_7: (+1)
   \   000000AC   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    389          }
    390          
    391          /**************************************************************************//*!
    392           *
    393           * @name  USB_DeviceRegisterService
    394           *
    395           * @brief The funtion registers a callback function from the Application layer
    396           *
    397           * @param controller_ID : Controller ID
    398           * @param type          : event type or endpoint number
    399           * @param service       : callback function pointer
    400           *
    401           * @return status
    402           *         gUsbErr_NoError_c                   : When Successfull
    403           *         gUsbErr_AllocService_c     : When invalid type or already registered
    404           *
    405           ******************************************************************************
    406           * This function registers a callback function from the application if it is
    407           * called not already registered so that the regitered callback function can
    408           * be if the event of that type occurs
    409           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    410          uint8_t USB_DeviceRegisterService(
    411              uint8_t                    controllerId, /* [IN] Controller ID           */
    412              uint8_t                    type,          /* [IN] type of event or endpoint
    413                                                               number to service       */
    414              usbServiceCallback_t      service        /* [IN] pointer to callback
    415                                                               function                */
    416          )
    417          {
   \                     USB_DeviceRegisterService: (+1)
   \   00000000   0x0003             MOVS     R3,R0
    418            (void)controllerId;
    419            /* check if the type is valid and callback for the type is not already registered */
    420            if(((type  <= gUsbService_EpMax_d) ||
    421                  ((type < gUsbService_Max_d) && (type >= gUsbService_BusReset_d))) &&
    422                 (gUsbCB(controllerId)[type] == NULL))
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2910             CMP      R1,#+16
   \   00000006   0xDB05             BLT.N    ??USB_DeviceRegisterService_0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x2916             CMP      R1,#+22
   \   0000000C   0xDA0E             BGE.N    ??USB_DeviceRegisterService_1
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x2910             CMP      R1,#+16
   \   00000012   0xDB0B             BLT.N    ??USB_DeviceRegisterService_1
   \                     ??USB_DeviceRegisterService_0: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable9_4
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD105             BNE.N    ??USB_DeviceRegisterService_1
    423            {
    424              /* register the callback function */
    425              gUsbCB(controllerId)[type] = service;
   \   00000020   0x....             LDR.N    R0,??DataTable9_4
   \   00000022   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000024   0xF840 0x2021      STR      R2,[R0, R1, LSL #+2]
    426              return gUsbErr_NoError_c;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE000             B.N      ??USB_DeviceRegisterService_2
    427            }
    428            else
    429            {
    430              return gUsbErr_AllocService_c;
   \                     ??USB_DeviceRegisterService_1: (+1)
   \   0000002C   0x208C             MOVS     R0,#+140
   \                     ??USB_DeviceRegisterService_2: (+1)
   \   0000002E   0x4770             BX       LR               ;; return
    431            }
    432          }
    433          
    434          /**************************************************************************//*!
    435           *
    436           * @name  USB_DeviceUnregisterService
    437           *
    438           * @brief The funtion unregisters an event or endpoint callback function
    439           *
    440           * @param controller_ID : Controller ID
    441           * @param type          : event type or endpoint number
    442           *
    443           * @return status
    444           *         gUsbErr_NoError_c                   : When Successfull
    445           *         gUsbErr_UnknownError_c     : When invalid type or not registered
    446           *
    447           *****************************************************************************
    448           * This function un registers a callback function which has been previously
    449           * registered by the application layer
    450           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    451          uint8_t USB_DeviceUnregisterService(
    452                uint8_t controllerId, /* [IN] Controller ID */
    453                uint8_t type           /* [IN] type of event or endpoint number
    454                                          to service */
    455          )
    456          {
   \                     USB_DeviceUnregisterService: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    457             (void)controllerId;
    458            /* check if the type is valid and callback for the type is already registered */
    459            if(((type  <= gUsbService_EpMax_d) ||
    460               ((type < gUsbService_Max_d) && (type >= gUsbService_BusReset_d))) &&
    461               (gUsbCB(controllerId)[type] != NULL))
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2910             CMP      R1,#+16
   \   00000006   0xDB05             BLT.N    ??USB_DeviceUnregisterService_0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x2916             CMP      R1,#+22
   \   0000000C   0xDA0F             BGE.N    ??USB_DeviceUnregisterService_1
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x2910             CMP      R1,#+16
   \   00000012   0xDB0C             BLT.N    ??USB_DeviceUnregisterService_1
   \                     ??USB_DeviceUnregisterService_0: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable9_4
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD006             BEQ.N    ??USB_DeviceUnregisterService_1
    462            {
    463              /* unregister the callback */
    464              gUsbCB(controllerId)[type] = NULL;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x....             LDR.N    R3,??DataTable9_4
   \   00000024   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000026   0xF843 0x0021      STR      R0,[R3, R1, LSL #+2]
    465              return gUsbErr_NoError_c;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE000             B.N      ??USB_DeviceUnregisterService_2
    466            }
    467            else
    468            {
    469              return gUsbErr_UnknownError_c;
   \                     ??USB_DeviceUnregisterService_1: (+1)
   \   0000002E   0x20C4             MOVS     R0,#+196
   \                     ??USB_DeviceUnregisterService_2: (+1)
   \   00000030   0x4770             BX       LR               ;; return
    470            }
    471          }
    472          
    473          /**************************************************************************//*!
    474           *
    475           * @name  USB_DeviceCallService
    476           *
    477           * @brief The funtion is a device layer event handler
    478           *
    479           * @param type  : Type of service or endpoint
    480           * @param event : Pointer to event structure
    481           *
    482           * @return status
    483           *         gUsbErr_NoError_c      : Always
    484           *
    485           *****************************************************************************
    486           *
    487           * This function calls the registered service callback function of the applic-
    488           * ation layer based on the type of event received. This function is called
    489           * from the DCI layer.
    490           *
    491           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    492          uint8_t USB_DeviceCallService(
    493              uint8_t             type,    /* [IN] Type of service or endpoint */
    494              usbDeviceEvent_t *  pUsbDeviceEvent    /* [IN] Pointer to event structure  */
    495          )
    496          {
   \                     USB_DeviceCallService: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    497            if(type == gUsbService_BusReset_d)
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C10             CMP      R4,#+16
   \   0000000A   0xD102             BNE.N    ??USB_DeviceCallService_0
    498            {    /* if it is an reset interrupt then reset all status structures */
    499              USB_DeviceInitParams(pUsbDeviceEvent->controllerId);
   \   0000000C   0x7828             LDRB     R0,[R5, #+0]
   \   0000000E   0x.... 0x....      BL       USB_DeviceInitParams
    500            }
    501          
    502            /* check if the callback is registered or not */
    503            if(gUsbCB(pUsbDeviceEvent->controllerId)[type] != NULL)
   \                     ??USB_DeviceCallService_0: (+1)
   \   00000012   0x....             LDR.N    R0,??DataTable9_4
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD005             BEQ.N    ??USB_DeviceCallService_1
    504            {
    505              /* call the callback function */
    506              gUsbCB(pUsbDeviceEvent->controllerId)[type](pUsbDeviceEvent);
   \   0000001E   0x0028             MOVS     R0,R5
   \   00000020   0x....             LDR.N    R1,??DataTable9_4
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000028   0x4788             BLX      R1
    507            }
    508          
    509            return gUsbErr_NoError_c;
   \                     ??USB_DeviceCallService_1: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    510          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     gEpNoMax_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     gEpNo_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     gUsbComponentStatus_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     gUsbEpStatus_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     gUsbCB_
    511          
    512          #endif// gUsbIncluded_d

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   USB_DeviceCallService
        16   -- Indirect call
        16   -> USB_DeviceInitParams
      16   USB_DeviceDeinit
        16   -> MemorySet
        16   -> USB_DCI_DeInit
        16   -> USB_DeviceInitParams
      24   USB_DeviceDeinitEndpoint
        24   -> USB_DCI_DeinitEndpoint
       4   USB_DeviceGetStatus
      16   USB_DeviceInit
        16   -> MemorySet
        16   -> USB_DCI_Init
        16   -> USB_DeviceInitParams
      24   USB_DeviceInitEndpoint
        24   -> USB_DCI_InitEndpoint
       0   USB_DeviceInitParams
       0   USB_DeviceRegisterService
      24   USB_DeviceSetStatus
        24   -> USB_DeviceStallEndpoint
        24   -> USB_DeviceUnstallEndpoint
       0   USB_DeviceUnregisterService


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
      46  USB_DeviceCallService
      44  USB_DeviceDeinit
      78  USB_DeviceDeinitEndpoint
      68  USB_DeviceGetStatus
      56  USB_DeviceInit
      72  USB_DeviceInitEndpoint
      62  USB_DeviceInitParams
      48  USB_DeviceRegisterService
     176  USB_DeviceSetStatus
      50  USB_DeviceUnregisterService
       1  gEpNoMax_
       1  gEpNo_
      88  gUsbCB_
      16  gUsbComponentStatus_
      32  gUsbEpStatus_

 
 138 bytes in section .bss
 720 bytes in section .text
 
 720 bytes of CODE memory
 138 bytes of DATA memory

Errors: none
Warnings: none
