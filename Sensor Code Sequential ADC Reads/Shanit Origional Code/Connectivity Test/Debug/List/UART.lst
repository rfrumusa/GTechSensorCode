###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        02/Sep/2018  13:33:20
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Uart\UART.c
#    Command line =  
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Uart\UART.c"
#        -D IAR --preprocess "F:\Guardrail Work\Sensor Code\Git Repo\Sensor
#        Code Sequential ADC Reads\Shanit Origional Code\Connectivity
#        Test\Debug\List\" -lC "F:\Guardrail Work\Sensor Code\Git Repo\Sensor
#        Code Sequential ADC Reads\Shanit Origional Code\Connectivity
#        Test\Debug\List\" -lB "F:\Guardrail Work\Sensor Code\Git Repo\Sensor
#        Code Sequential ADC Reads\Shanit Origional Code\Connectivity
#        Test\Debug\List\" --diag_suppress
#        Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\Obj\" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\CDC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\Descriptor\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\USB\Class\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Sys Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
#    List file    =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\List\UART.lst
#    Object file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\Obj\UART.o
#
###############################################################################

F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Uart\UART.c
      1          /******************************************************************************
      2           * Source file for UART/SCI driver.
      3           * 
      4           * Freescale Semiconductor Inc.
      5           * (c) Copyright 2004-2011 Freescale Semiconductor, Inc.
      6           * ALL RIGHTS RESERVED.
      7           *
      8          *******************************************************************************
      9           *
     10           * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR 
     11           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
     12           * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
     13           * IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
     14           * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
     15           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
     16           * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
     17           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
     18           * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
     19           * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
     20           * THE POSSIBILITY OF SUCH DAMAGE.
     21           *
     22          ***************************************************************************//*!
     23          ******************************************************************************/
     24          
     25          /******************************************************************************
     26          *******************************************************************************
     27          * Includes
     28          *******************************************************************************
     29          ******************************************************************************/
     30          #include "Uart_Interface.h"
     31          #include "Uart.h"
     32          #include "PortConfig.h"
     33          #include "Interrupt.h"
     34          //#include "Platform.h"
     35          
     36          /* if neither UART enabled, then no code or data */
     37          #if gUart1_Enabled_d || gUart2_Enabled_d
     38          
     39          /******************************************************************************
     40          *******************************************************************************
     41          * Private memory declarations
     42          *******************************************************************************
     43          ******************************************************************************/
     44           
     45          /******************************************************************************
     46           * Name: UartBaseAddress_c
     47           * Description: UART memory map base addresses 
     48           * Valid ranges: see MCU reference manual
     49           *****************************************************************************/

   \                                 In section .rodata, align 4
     50          const UART_MemMapPtr UartBaseAddress_c[] = {
   \                     UartBaseAddress_c:
   \   00000000   0x4006A000         DC32 4006A000H, 4006B000H, 4006C000H, 4006D000H
   \              0x4006B000   
   \              0x4006C000   
   \              0x4006D000   
     51          
     52          #if gUART_HW_MODULES_AVAILABLE_c > 0
     53                  gUART0_BASE_PTR_c,
     54          #endif
     55          
     56          #if gUART_HW_MODULES_AVAILABLE_c > 1        
     57                  gUART1_BASE_PTR_c,
     58          #endif
     59          
     60          #if gUART_HW_MODULES_AVAILABLE_c > 2
     61                  gUART2_BASE_PTR_c,
     62          #endif
     63          
     64          #if gUART_HW_MODULES_AVAILABLE_c > 3
     65                  gUART3_BASE_PTR_c,
     66          #endif
     67          
     68          #if gUART_HW_MODULES_AVAILABLE_c > 4
     69                  gUART4_BASE_PTR_c,
     70          #endif
     71          
     72          #if gUART_HW_MODULES_AVAILABLE_c > 5
     73                  gUART5_BASE_PTR_c
     74          #endif
     75          };
     76          
     77          /******************************************************************************
     78           * Name: mUartModule
     79           * Description: UART module internal status & configuration variable 
     80           * Valid ranges: see definition of UartModule_t
     81           *****************************************************************************/
     82          

   \                                 In section .bss, align 4
     83          static UartModule_t mUartModule[gUART_HW_MODULES_AVAILABLE_c];
   \                     mUartModule:
   \   00000000                      DS8 208
     84          
     85          /************************************
     86           * UART_1
     87           ************************************/
     88          #if gUart1_Enabled_d
     89          
     90          /******************************************************************************
     91           * Name: bUart1FlowConflict
     92           * Description: UART_1 flow conflict
     93           * Valid ranges: TRUE/FALSE
     94           *****************************************************************************/  
     95          #if gUart1_Hw_Sw_FlowControl_d
     96            static bool_t bUart1FlowConflict = FALSE;
     97          #endif
     98          
     99          /******************************************************************************
    100           * Name: uart1_ungetFlag
    101           * Description: UART_1 unget byte flag
    102           * Valid ranges: TRUE/FALSE
    103           *****************************************************************************/

   \                                 In section .bss, align 1
    104          static bool_t uart1_ungetFlag = FALSE;
   \                     uart1_ungetFlag:
   \   00000000                      DS8 1
    105          
    106          /******************************************************************************
    107           * Name: uart1_ungetByte
    108           * Description: UART_1 unget byte
    109           *              Each port can store one unget byte
    110           * Valid ranges: 0..0xFF
    111           *****************************************************************************/

   \                                 In section .bss, align 1
    112          static unsigned char uart1_ungetByte;
   \                     uart1_ungetByte:
   \   00000000                      DS8 1
    113          
    114          /******************************************************************************
    115           * Name: maSci1TxBufRefTable
    116           * Description: UART_1 TX buffer reference table
    117           * Valid ranges: see definition of SciTxBufRef_t
    118           *****************************************************************************/

   \                                 In section .bss, align 4
    119          static SciTxBufRef_t maSci1TxBufRefTable[gUart_TransmitBuffers_c];
   \                     maSci1TxBufRefTable:
   \   00000000                      DS8 24
    120          
    121          /******************************************************************************
    122           * Name: maSci1TxBufLenTable
    123           * Description: UART_1 table for TX buffer lengths
    124           * Valid ranges: range of index_t
    125           *****************************************************************************/
    126          

   \                                 In section .bss, align 4
    127          static index_t maSci1TxBufLenTable[gUart_TransmitBuffers_c] = { 0, 0, 0 };
   \                     maSci1TxBufLenTable:
   \   00000000                      DS8 4
    128          
    129          /******************************************************************************
    130           * Name: mSci1TxCurIndex
    131           * Description: UART_1 current index in TX buffers array
    132           * Valid ranges: range of index_t
    133           *****************************************************************************/
    134          

   \                                 In section .bss, align 1
    135          static index_t mSci1TxCurIndex = 0;
   \                     mSci1TxCurIndex:
   \   00000000                      DS8 1
    136          
    137          /******************************************************************************
    138           * Name: mSci1TxBufRefLeadingIndex
    139           * Description: The leading index is the next position to store 
    140           *              a buffer reference
    141           * Valid ranges: range of index_t
    142           *****************************************************************************/
    143          

   \                                 In section .bss, align 1
    144          static index_t mSci1TxBufRefLeadingIndex = 0;   /* Post-increment. */
   \                     mSci1TxBufRefLeadingIndex:
   \   00000000                      DS8 1
    145          
    146          /******************************************************************************
    147           * Name: mSci1TxBufRefTrailingIndex
    148           * Description: The trailing index is the buffer currently being transmitted
    149           * Valid ranges: range of index_t
    150           *****************************************************************************/
    151          

   \                                 In section .bss, align 1
    152          static index_t mSci1TxBufRefTrailingIndex = 0;  /* Post-increment. */
   \                     mSci1TxBufRefTrailingIndex:
   \   00000000                      DS8 1
    153          
    154          /******************************************************************************
    155           * Name: maSci1RxBuf
    156           * Description: UART_1 RX buffer
    157           *              Each port has a small local circular Rx buffer to store data until the
    158           *              application can retrieve it. In addition to the leading and trailing
    159           *              indexes, the Rx code keeps a count of the number of bytes in the buffer.
    160           * Valid ranges: 0..0xFF
    161           *****************************************************************************/
    162          

   \                                 In section .bss, align 4
    163          static unsigned char maSci1RxBuf[gUart1_ReceiveBufferSize_c];
   \                     maSci1RxBuf:
   \   00000000                      DS8 252
    164          
    165          /******************************************************************************
    166           * Name: pfSci1RxCallBack
    167           * Description: callback function for UART_1 RX
    168           * Valid ranges: -
    169           *****************************************************************************/

   \                                 In section .bss, align 4
    170          static void (*pfSci1RxCallBack)(void);
   \                     pfSci1RxCallBack:
   \   00000000                      DS8 4
    171          
    172          #endif // gUart1_Enabled_d
    173          
    174          /************************************
    175           * UART_2
    176           ************************************/
    177          
    178          #if gUart2_Enabled_d
    179          
    180          /******************************************************************************
    181           * Name: bUart2FlowConflict
    182           * Description: UART_2 flow conflict
    183           * Valid ranges: TRUE/FALSE
    184           *****************************************************************************/
    185          
    186          #if gUart2_Hw_Sw_FlowControl_d
    187            static bool_t bUart2FlowConflict = FALSE; 
    188          #endif
    189          
    190          /******************************************************************************
    191           * Name: uart2_ungetFlag
    192           * Description: UART_2 unget byte flag
    193           * Valid ranges: TRUE/FALSE
    194           *****************************************************************************/
    195          static bool_t uart2_ungetFlag = FALSE;
    196          
    197          /******************************************************************************
    198           * Name: uart2_ungetByte
    199           * Description: UART_2 unget byte
    200           *              Each port can store one unget byte
    201           * Valid ranges: 0..0xFF
    202           *****************************************************************************/
    203          static unsigned char uart2_ungetByte;
    204          
    205          /******************************************************************************
    206           * Name: maSci2TxBufRefTable
    207           * Description: UART_2 TX buffer reference table
    208           * Valid ranges: see definition of SciTxBufRef_t
    209           *****************************************************************************/
    210          static SciTxBufRef_t maSci2TxBufRefTable[gUart_TransmitBuffers_c];
    211          
    212          /******************************************************************************
    213           * Name: maSci2TxBufLenTable
    214           * Description: UART_2 table for TX buffer lengths
    215           * Valid ranges: range of index_t
    216           *****************************************************************************/
    217          
    218          static index_t maSci2TxBufLenTable[gUart_TransmitBuffers_c];
    219          
    220          /******************************************************************************
    221           * Name: mSci2TxCurIndex
    222           * Description: UART_2 current index in TX buffers array
    223           * Valid ranges: range of index_t
    224           *****************************************************************************/
    225          
    226          static index_t mSci2TxCurIndex=0;
    227          
    228          /******************************************************************************
    229           * Name: mSci2TxBufRefLeadingIndex
    230           * Description: The leading index is the next position to store 
    231           *              a buffer reference
    232           * Valid ranges: range of index_t
    233           *****************************************************************************/
    234          
    235          static index_t mSci2TxBufRefLeadingIndex=0;   /* Post-increment. */
    236          
    237          /******************************************************************************
    238           * Name: mSci2TxBufRefTrailingIndex
    239           * Description: The trailing index is the buffer currently being transmitted
    240           * Valid ranges: range of index_t
    241           *****************************************************************************/
    242          
    243          static index_t mSci2TxBufRefTrailingIndex=0;  /* Post-increment. */
    244          
    245          /******************************************************************************
    246           * Name: maSci2RxBuf
    247           * Description: UART_2 RX buffer
    248           *              Each port has a small local circular Rx buffer to store data until the
    249           *              application can retrieve it. In addition to the leading and trailing
    250           *              indexes, the Rx code keeps a count of the number of bytes in the buffer.
    251           * Valid ranges: 0..0xFF
    252           *****************************************************************************/
    253          
    254          static unsigned char maSci2RxBuf[gUart2_ReceiveBufferSize_c];
    255          
    256          /******************************************************************************
    257           * Name: pfSci2RxCallBack
    258           * Description: callback function for UART_2 RX
    259           * Valid ranges: -
    260           *****************************************************************************/
    261          
    262          static void (*pfSci2RxCallBack)(void);
    263          
    264          #endif  //gUart2_Enabled_d
    265          
    266          /******************************************************************************
    267          *******************************************************************************
    268          * Public memory definitions
    269          *******************************************************************************
    270          ******************************************************************************/
    271           
    272          /******************************************************************************
    273          *******************************************************************************
    274          * Private prototypes
    275          *******************************************************************************
    276          ******************************************************************************/
    277           
    278          /******************************************************************************
    279           * Name: UartReceiverIsr
    280           * Description: UART RX interrupt handler. Called in interrupt context.
    281           * Parameters: [IN]: UartNumber - the UART peripheral number
    282           * Return: -
    283           *****************************************************************************/
    284          static void UartReceiverIsr 
    285          (
    286              uint8_t UartNumber
    287          );
    288          
    289          /******************************************************************************
    290           * Name: UartTransmitterIsr
    291           * Description: UART TX interrupt handler. Called in interrupt context.
    292           * Parameters: [IN]: UartNumber - the UART peripheral number
    293           * Return: -
    294           *****************************************************************************/
    295          static void UartTransmitterIsr 
    296          (
    297              uint8_t UartNumber
    298          );
    299          
    300          /******************************************************************************
    301           * Name: UartReadComplete
    302           * Description: UART read complete function.
    303           * Parameters: [IN]: UartNumber - the UART peripheral number
    304           * Return: -
    305           *****************************************************************************/
    306          static void UartReadComplete
    307          (
    308              uint8_t UartNumber
    309          );
    310          
    311          /******************************************************************************
    312           * Name: UartDivide
    313           * Description: Integer division by repeated substractions.
    314           * Parameters: [IN]: Number - the number to be divided
    315           *             [IN]: Divisor - the number to divide to
    316           * Return: the result of the division operation
    317           *****************************************************************************/
    318          static uint16_t UartDivide
    319          (
    320              int32_t Number, 
    321              uint32_t Divisor
    322          );
    323          
    324          /******************************************************************************
    325           * Name: UartOpen
    326           * Description: Open the specified UART port
    327           * Parameters: [IN]: UartNumber - the UART port number to be opened
    328           *             [IN]: PlatformClock - The platform clock in KHz
    329           * Return: see definition of UartErr_t
    330           *****************************************************************************/
    331          static UartErr_t UartOpen
    332          (
    333                  uint8_t UartNumber, 
    334                  uint32_t PlatformClock
    335          );
    336          
    337          /******************************************************************************
    338           * Name: UartSetConfig
    339           * Description: configure the specified UART port
    340           * Parameters: [IN]: UartNumber - the UART port number to be configured
    341           *             [IN]: pConfig - pointer to UART configuration data structure
    342           * Return: see definition of UartErr_t
    343           *****************************************************************************/
    344          static UartErr_t UartSetConfig
    345          (
    346              uint8_t UartNumber, 
    347              UartConfig_t* pConfig
    348          );
    349          
    350          /******************************************************************************
    351           * Name: UartGetConfig
    352           * Description: get the configuration of the specified UART port
    353           * Parameters: [IN]:  UartNumber - the UART port number to read the 
    354           *                               configuration from
    355           *             [OUT]: pConfig - pointer to UART configuration structure where
    356           *                            the configuration data shall be placed                  
    357           * Return: see definition of UartErr_t
    358           *****************************************************************************/
    359          static UartErr_t UartGetConfig
    360          (
    361              uint8_t UartNumber, 
    362              UartConfig_t* pConfig
    363          );
    364          
    365          /******************************************************************************
    366           * Name: UartSetReceiverThreshold
    367           * Description: sets the receiver threshold
    368           * Parameters: [IN]: UartNumber - the UART port number
    369           *             [IN]: Threshold - the desired threshold
    370           * Return: see definition of UartErr_t
    371           *****************************************************************************/
    372          static UartErr_t UartSetReceiverThreshold
    373          (
    374              uint8_t UartNumber,
    375              uint8_t Threshold
    376          );
    377          
    378          /******************************************************************************
    379           * Name: UartSetTransmitterThreshold
    380           * Description: sets the transmitter threshold
    381           * Parameters: [IN]: UartNumber - the UART port number
    382           *             [IN]: Threshold - the desired threshold
    383           * Return: see definition of UartErr_t
    384           *****************************************************************************/
    385          static UartErr_t UartSetTransmitterThreshold
    386          (
    387              uint8_t UartNumber,
    388              uint8_t Threshold
    389          );
    390          
    391          /******************************************************************************
    392           * Name: UartReadData
    393           * Description: read data from the specified UART port
    394           * Parameters: [IN]: UartNumber - the UART port number
    395           *             [OUT]: pBuf - pointer to the buffer where the read data shall be 
    396           *                         placed 
    397           *             [IN]: NumberBytes - number of bytes to be read
    398           * Return: see definition of UartErr_t
    399           *****************************************************************************/
    400          static UartErr_t UartReadData
    401          (
    402              uint8_t UartNumber, 
    403              uint8_t* pBuf,
    404              uint16_t NumberBytes
    405          );
    406          
    407          /******************************************************************************
    408           * Name: UartCancelReadData
    409           * Description: cancels the read data operation
    410           * Parameters: [IN]: UartNumber - the UART port number
    411           * Return: see definition of UartErr_t
    412           *****************************************************************************/
    413          static UartErr_t UartCancelReadData
    414          (
    415              uint8_t UartNumber
    416          );
    417          
    418          /******************************************************************************
    419           * Name: UartCancelWriteData
    420           * Description: cancels the write data operation
    421           * Parameters: [IN]: UartNumber - the UART port number
    422           * Return: see definition of UartErr_t
    423           *****************************************************************************/
    424          static UartErr_t UartCancelWriteData
    425          (
    426              uint8_t UartNumber
    427          );
    428          
    429          /******************************************************************************
    430           * Name: UartGetStatus
    431           * Description: gets the status of the specified UART port
    432           * Parameters: [IN]: UartNumber - the UART port number
    433           * Return: see definition of UartErr_t
    434           *****************************************************************************/
    435          static UartErr_t UartGetStatus
    436          (
    437              uint8_t UartNumber
    438          );
    439          
    440          /******************************************************************************
    441           * Name: UartClose
    442           * Description: closes the specified UART port
    443           * Parameters: [IN] UartNumber - the UART port number
    444           * Return: see definition of UartErr_t
    445           *****************************************************************************/
    446          static UartErr_t UartClose
    447          (
    448              uint8_t UartNumber
    449          );
    450          
    451          /******************************************************************************
    452           * Name: UartGetByteFromRxBuffer
    453           * Description: gets a byte from the HW RX buffer and appends it to RAM buffer
    454           * Parameters: [IN] UartNumber - the UART port number
    455           *             [OUT] pDst - pointer to the RAM buffer
    456           * Return: TRUE/FALSE
    457           *****************************************************************************/
    458          static bool_t UartGetByteFromRxBuffer
    459          (
    460              uint8_t UartNumber, 
    461              uint8_t *pDst
    462          );
    463          
    464          /******************************************************************************
    465           * Name: UartOpenCloseTransceiver
    466           * Description: opens or closes the UART transceiver
    467           * Parameters: [IN] UartNumber - the UART port number
    468           *             [IN] Pin - the bit in the control register that 
    469           *                  enables/disables the transmiter and the receiver
    470           *             [IN] Open - if TRUE, it opens the receiver/trasmitter; if FALSE
    471           *                         it closes the receiver/transmiter
    472           * Return: -
    473           *****************************************************************************/
    474          static void UartOpenCloseTransceiver
    475          (
    476              uint8_t UartNumber, 
    477              uint8_t Pin, 
    478              bool_t Open
    479          );
    480          
    481          /******************************************************************************
    482           * Name: UartClearErrors
    483           * Description: clears the UART receive errors
    484           * Parameters: [IN] UartNumber - the UART port number
    485           * Return: -
    486           *****************************************************************************/
    487          static void UartClearErrors
    488          (
    489              uint8_t UartNumber
    490          );
    491          
    492          /******************************************************************************
    493           * Name: UartExecPendingCallbacks
    494           * Description: execute any pending UART transmit callbacks
    495           * Parameters: [IN] UartNumber - the UART port number
    496           * Return: -
    497           *****************************************************************************/
    498          static void UartExecPendingCallbacks
    499          (
    500                  uint8_t UartNumber
    501          );
    502          
    503          /******************************************************************************
    504          *******************************************************************************
    505          * Private functions
    506          *******************************************************************************
    507          ******************************************************************************/
    508           
    509           /*****************************************************************************
    510           * Name: UartReceiverIsr
    511           * Description: UART RX interrupt handler. Called in interrupt context.
    512           * Parameters: [IN]: UartNumber - the UART peripheral number
    513           * Return: -
    514           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    515          static void UartReceiverIsr 
    516          (
    517              uint8_t UartNumber
    518          )
    519          {
   \                     UartReceiverIsr: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    520            UartModule_t *pModule = &mUartModule[UartNumber];
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2134             MOVS     R1,#+52
   \   0000000C   0xFB01 0x0504      MLA      R5,R1,R4,R0
    521          #if UART_USE_RX_FIFO  
    522              	if(mUartModule[UartNumber].UartRxFifoSize > 1)
    523          	{				
    524          		while(mUartModule[UartNumber].UartRegs->RCFIFO)
    525          		{ 
    526          			/* read one character from RX FIFO */    					
    527          			pModule->pUartRxBuffer[pModule->UartBufferLeadIndex] = pModule->UartRegs->D;
    528                                  
    529          			if (++pModule->UartBufferLeadIndex >= pModule->UartNumberCharsToReceive) 
    530          			{
    531          				pModule->UartBufferLeadIndex = 0;
    532          			}
    533          
    534          			if (pModule->UartUnreadBytesNumber < pModule->UartNumberCharsToReceive) 
    535          			{
    536          				++pModule->UartUnreadBytesNumber;
    537          			}
    538          			else 
    539          			{
    540          				/* A new character was received while the buffer is already full. 
    541          				 * The oldest character in the buffer has been overwritten. 
    542          				 * The trailing index must be also incremented to compensate the overwritten characters
    543          				 */
    544          				if(++pModule->UartBufferTrailIndex >= pModule->UartNumberCharsToReceive) 
    545          				{
    546          					pModule->UartBufferTrailIndex = 0;
    547          				}
    548          			}                                                
    549          		}
    550          	}    	    
    551          	else  
    552          #endif /* UART_USE_RX_FIFO */
    553             	{
    554          		pModule->pUartRxBuffer[pModule->UartBufferLeadIndex] = pModule->UartRegs->D;    		
   \   00000010   0x6868             LDR      R0,[R5, #+4]
   \   00000012   0x79C0             LDRB     R0,[R0, #+7]
   \   00000014   0x6929             LDR      R1,[R5, #+16]
   \   00000016   0x6A6A             LDR      R2,[R5, #+36]
   \   00000018   0x5450             STRB     R0,[R2, R1]
    555          
    556          		if (++pModule->UartBufferLeadIndex >= pModule->UartNumberCharsToReceive) 
   \   0000001A   0x6A68             LDR      R0,[R5, #+36]
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0x6268             STR      R0,[R5, #+36]
   \   00000020   0x6A68             LDR      R0,[R5, #+36]
   \   00000022   0x6969             LDR      R1,[R5, #+20]
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD301             BCC.N    ??UartReceiverIsr_0
    557          		{
    558          			pModule->UartBufferLeadIndex = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x6268             STR      R0,[R5, #+36]
    559          		}
    560          		if (pModule->UartUnreadBytesNumber < pModule->UartNumberCharsToReceive) 
   \                     ??UartReceiverIsr_0: (+1)
   \   0000002C   0x6AE8             LDR      R0,[R5, #+44]
   \   0000002E   0x6969             LDR      R1,[R5, #+20]
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD203             BCS.N    ??UartReceiverIsr_1
    561          		{
    562          			++pModule->UartUnreadBytesNumber;
   \   00000034   0x6AE8             LDR      R0,[R5, #+44]
   \   00000036   0x1C40             ADDS     R0,R0,#+1
   \   00000038   0x62E8             STR      R0,[R5, #+44]
   \   0000003A   0xE008             B.N      ??UartReceiverIsr_2
    563          		}
    564          		else 
    565          		{
    566          			/* A new character was received while the buffer is already full. 
    567          			 * The oldest character in the buffer has been overwritten. 
    568          			 * The trailing index must be also incremented to compensate the overwritten characters
    569          			 */
    570          			if(++pModule->UartBufferTrailIndex >= pModule->UartNumberCharsToReceive) 
   \                     ??UartReceiverIsr_1: (+1)
   \   0000003C   0x6AA8             LDR      R0,[R5, #+40]
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \   00000040   0x62A8             STR      R0,[R5, #+40]
   \   00000042   0x6AA8             LDR      R0,[R5, #+40]
   \   00000044   0x6969             LDR      R1,[R5, #+20]
   \   00000046   0x4288             CMP      R0,R1
   \   00000048   0xD301             BCC.N    ??UartReceiverIsr_2
    571          			{
    572          				pModule->UartBufferTrailIndex = 0;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x62A8             STR      R0,[R5, #+40]
    573          			}
    574          		}
    575          	}
    576          	
    577          	/* Let the application know that one (or more) byte(s) have (has) been received */
    578          #if (TRUE == gUart1_Enabled_d)	
    579          	if(UartNumber == gUart1_c)
   \                     ??UartReceiverIsr_2: (+1)
   \   0000004E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000050   0x2C01             CMP      R4,#+1
   \   00000052   0xD108             BNE.N    ??UartReceiverIsr_3
    580          	{
    581          #if gUart1_Hw_Sw_FlowControl_d
    582                  if (pModule->UartNumberCharsToReceive - pModule->UartUnreadBytesNumber <= gUart1_RxFlowControlSkew_d) 
    583                  {
    584                          Uart1_DisableFlow();
    585                  }
    586          #endif
    587                      if(pfSci1RxCallBack != NULL)
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD003             BEQ.N    ??UartReceiverIsr_3
    588                      {
    589                        pfSci1RxCallBack();
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x4780             BLX      R0
    590                      }
    591                  }
    592          #endif /* gUart1_Enabled_d */
    593                  
    594          #if (TRUE == gUart2_Enabled_d)        
    595                  if(UartNumber==gUart2_c)
    596                  {
    597          #if gUart2_Hw_Sw_FlowControl_d
    598                      if (pModule->UartNumberCharsToReceive - pModule->UartUnreadBytesNumber <= gUart2_RxFlowControlSkew_d) 
    599                      {
    600                              Uart2_DisableFlow();
    601                      }
    602          #endif
    603                       if(pfSci2RxCallBack != NULL)
    604                       {  
    605                          pfSci2RxCallBack();
    606                       }  
    607                  } 
    608          #endif /* gUart2_Enabled_d */
    609          }  
   \                     ??UartReceiverIsr_3: (+1)
   \   00000066   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    610          
    611          /******************************************************************************
    612           * Name: UartTransmitterIsr
    613           * Description: UART TX interrupt handler. Called in interrupt context.
    614           * Parameters: [IN]: UartNumber - the UART peripheral number
    615           * Return: -
    616           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    617          static void UartTransmitterIsr 
    618          (
    619              uint8_t UartNumber
    620          )
    621          {	/*************************
   \                     UartTransmitterIsr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    622          	 ******** UART_1 *********
    623          	 *************************/
    624          	
    625          #if (gUart1_Enabled_d == TRUE)
    626          
    627              if(gUart1_c == UartNumber)
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xF040 0x80FD      BNE.W    ??UartTransmitterIsr_0
    628              {
    629                  volatile uint8_t dummy;
    630                          
    631          #if gUART_USE_TX_FIFO_d
    632                  
    633                  if((mUartModule[gUart1_c].UartTxFifoSize > 1) && (mUartModule[gUart1_c].UartRegs->PFIFO & gUART_TX_FIFO_EN_BIT_c))
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000012   0xF890 0x0065      LDRB     R0,[R0, #+101]
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xF2C0 0x808B      BLT.W    ??UartTransmitterIsr_1
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000020   0x6B80             LDR      R0,[R0, #+56]
   \   00000022   0x7C00             LDRB     R0,[R0, #+16]
   \   00000024   0x0600             LSLS     R0,R0,#+24
   \   00000026   0xF140 0x8084      BPL.W    ??UartTransmitterIsr_1
    634                  {
    635                  	if(mUartModule[gUart1_c].UartRegs->S1 & gUART_S1_TDRE_MASK_c)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000002E   0x6B80             LDR      R0,[R0, #+56]
   \   00000030   0x7900             LDRB     R0,[R0, #+4]
   \   00000032   0x0600             LSLS     R0,R0,#+24
   \   00000034   0xF140 0x80E6      BPL.W    ??UartTransmitterIsr_2
    636                  	{        		        	
    637                  		while(mUartModule[gUart1_c].UartTxFifoSize - mUartModule[gUart1_c].UartRegs->TCFIFO > 0)
   \                     ??UartTransmitterIsr_3: (+1)
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000003C   0xF890 0x0065      LDRB     R0,[R0, #+101]
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable8
   \   00000044   0x6B89             LDR      R1,[R1, #+56]
   \   00000046   0x7D09             LDRB     R1,[R1, #+20]
   \   00000048   0x1A40             SUBS     R0,R0,R1
   \   0000004A   0x2801             CMP      R0,#+1
   \   0000004C   0xDB6A             BLT.N    ??UartTransmitterIsr_4
    638                  		{
    639                  			if(FALSE == mUartModule[gUart1_c].UartWriteOnGoing)
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000052   0x6B40             LDR      R0,[R0, #+52]
   \   00000054   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD063             BEQ.N    ??UartTransmitterIsr_4
    640                  				break;
    641                  			
    642                  			/* Write a byte. */
    643                  			mUartModule[gUart1_c].UartRegs->D = maSci1TxBufRefTable[mSci1TxBufRefTrailingIndex].pBuf[mSci1TxCurIndex];        	
   \                     ??UartTransmitterIsr_5: (+1)
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   00000064   0x7809             LDRB     R1,[R1, #+0]
   \   00000066   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   0000006E   0x7809             LDRB     R1,[R1, #+0]
   \   00000070   0x5C08             LDRB     R0,[R1, R0]
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable8
   \   00000076   0x6B89             LDR      R1,[R1, #+56]
   \   00000078   0x71C8             STRB     R0,[R1, #+7]
    644          
    645                  			/* Finished with this buffer? */
    646                  			if (++mSci1TxCurIndex >= maSci1TxBufLenTable[mSci1TxBufRefTrailingIndex]) 
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   0000007E   0x7800             LDRB     R0,[R0, #+0]
   \   00000080   0x1C40             ADDS     R0,R0,#+1
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   00000086   0x7008             STRB     R0,[R1, #+0]
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   0000008C   0x7800             LDRB     R0,[R0, #+0]
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000092   0x.... 0x....      LDR.W    R2,??DataTable10_2
   \   00000096   0x7812             LDRB     R2,[R2, #+0]
   \   00000098   0x5C51             LDRB     R1,[R2, R1]
   \   0000009A   0x4288             CMP      R0,R1
   \   0000009C   0xD3CC             BCC.N    ??UartTransmitterIsr_3
    647                  			{
    648          
    649                  				/* Mark this one as done */
    650                  				maSci1TxBufLenTable[mSci1TxBufRefTrailingIndex] = 0;                
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable11
   \   000000A4   0x.... 0x....      LDR.W    R2,??DataTable10_2
   \   000000A8   0x7812             LDRB     R2,[R2, #+0]
   \   000000AA   0x5450             STRB     R0,[R2, R1]
    651                  				if ( maSci1TxBufRefTable[mSci1TxBufRefTrailingIndex].pfCallBack) 
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   000000B4   0x7809             LDRB     R1,[R1, #+0]
   \   000000B6   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   000000BA   0x6840             LDR      R0,[R0, #+4]
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD002             BEQ.N    ??UartTransmitterIsr_6
    652                  				{
    653                                                          UartExecPendingCallbacks(gUart1_c);
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0x.... 0x....      BL       UartExecPendingCallbacks
    654                  				}                
    655          
    656                  				/* Reset the current buffer index */
    657                  				mSci1TxCurIndex = 0;
   \                     ??UartTransmitterIsr_6: (+1)
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   000000CC   0x7008             STRB     R0,[R1, #+0]
    658          
    659                  				/* Increment to the next buffer. */
    660                  				if (++mSci1TxBufRefTrailingIndex >= NumberOfElements(maSci1TxBufRefTable)) 
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   000000D2   0x7800             LDRB     R0,[R0, #+0]
   \   000000D4   0x1C40             ADDS     R0,R0,#+1
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   000000DA   0x7008             STRB     R0,[R1, #+0]
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   000000E0   0x7800             LDRB     R0,[R0, #+0]
   \   000000E2   0x2803             CMP      R0,#+3
   \   000000E4   0xD303             BCC.N    ??UartTransmitterIsr_7
    661                  				{
    662                  					mSci1TxBufRefTrailingIndex = 0;
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   000000EC   0x7008             STRB     R0,[R1, #+0]
    663                  				}
    664          
    665                  				/* If there is no more data to send, turn off the transmit interrupt. */
    666                  				if (!maSci1TxBufLenTable[mSci1TxBufRefTrailingIndex]) 
   \                     ??UartTransmitterIsr_7: (+1)
   \   000000EE   0x.... 0x....      LDR.W    R0,??DataTable11
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   000000F6   0x7809             LDRB     R1,[R1, #+0]
   \   000000F8   0x5C08             LDRB     R0,[R1, R0]
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xD19C             BNE.N    ??UartTransmitterIsr_3
    667                  				{
    668                  					mUartModule[gUart1_c].UartRegs->C2 &= ~(gUART_TIE_BIT_c);
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000102   0x6B80             LDR      R0,[R0, #+56]
   \   00000104   0x78C0             LDRB     R0,[R0, #+3]
   \   00000106   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   0000010A   0x.... 0x....      LDR.W    R1,??DataTable8
   \   0000010E   0x6B89             LDR      R1,[R1, #+56]
   \   00000110   0x70C8             STRB     R0,[R1, #+3]
    669                  					/* clear the write ongoing flag */
    670                  					mUartModule[gUart1_c].UartWriteOnGoing = FALSE;
   \   00000112   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000116   0x6B40             LDR      R0,[R0, #+52]
   \   00000118   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000011C   0x.... 0x....      LDR.W    R1,??DataTable8
   \   00000120   0x6348             STR      R0,[R1, #+52]
   \   00000122   0xE789             B.N      ??UartTransmitterIsr_3
    671                  				}
    672                  			} 
    673                  		}
    674                  		
    675                  		/* this read will clear the TDRE flag */
    676                  		dummy = mUartModule[gUart1_c].UartRegs->S1;
   \                     ??UartTransmitterIsr_4: (+1)
   \   00000124   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000128   0x6B80             LDR      R0,[R0, #+56]
   \   0000012A   0x7900             LDRB     R0,[R0, #+4]
   \   0000012C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000130   0xE068             B.N      ??UartTransmitterIsr_2
    677                  	}
    678                  }
    679                  else
    680          #endif
    681                  {
    682          #if gUart1_Hw_Sw_FlowControl_d
    683                  	if(Uart1_FlowConflict())
    684                  	{
    685                  		/* Disable the TX interrupt */
    686                  		mUartModule[gUart1_c].UartRegs->C2 &= ~(gUART_TIE_BIT_c);
    687                  		bUart1FlowConflict = TRUE;
    688                  	}
    689                  	else
    690          #endif	
    691                  	{
    692                  		/* Dummy read - required before write to data register. */
    693                  		dummy = mUartModule[gUart1_c].UartRegs->S1;
   \                     ??UartTransmitterIsr_1: (+1)
   \   00000132   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000136   0x6B80             LDR      R0,[R0, #+56]
   \   00000138   0x7900             LDRB     R0,[R0, #+4]
   \   0000013A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    694          
    695                  		/* Write a byte. */
    696                  		mUartModule[gUart1_c].UartRegs->D = maSci1TxBufRefTable[mSci1TxBufRefTrailingIndex].pBuf[mSci1TxCurIndex];        	
   \   0000013E   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000142   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   00000146   0x7809             LDRB     R1,[R1, #+0]
   \   00000148   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   0000014C   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   00000150   0x7809             LDRB     R1,[R1, #+0]
   \   00000152   0x5C08             LDRB     R0,[R1, R0]
   \   00000154   0x.... 0x....      LDR.W    R1,??DataTable8
   \   00000158   0x6B89             LDR      R1,[R1, #+56]
   \   0000015A   0x71C8             STRB     R0,[R1, #+7]
    697          
    698                  		/* Finished with this buffer? */
    699                  		if (++mSci1TxCurIndex >= maSci1TxBufLenTable[mSci1TxBufRefTrailingIndex]) 
   \   0000015C   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   00000160   0x7800             LDRB     R0,[R0, #+0]
   \   00000162   0x1C40             ADDS     R0,R0,#+1
   \   00000164   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   00000168   0x7008             STRB     R0,[R1, #+0]
   \   0000016A   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   0000016E   0x7800             LDRB     R0,[R0, #+0]
   \   00000170   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000174   0x.... 0x....      LDR.W    R2,??DataTable10_2
   \   00000178   0x7812             LDRB     R2,[R2, #+0]
   \   0000017A   0x5C51             LDRB     R1,[R2, R1]
   \   0000017C   0x4288             CMP      R0,R1
   \   0000017E   0xD341             BCC.N    ??UartTransmitterIsr_2
    700                  		{
    701          
    702                  			/* Mark this one as done */
    703                  			maSci1TxBufLenTable[mSci1TxBufRefTrailingIndex] = 0;                
   \   00000180   0x2000             MOVS     R0,#+0
   \   00000182   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000186   0x.... 0x....      LDR.W    R2,??DataTable10_2
   \   0000018A   0x7812             LDRB     R2,[R2, #+0]
   \   0000018C   0x5450             STRB     R0,[R2, R1]
    704                  			if ( maSci1TxBufRefTable[mSci1TxBufRefTrailingIndex].pfCallBack) 
   \   0000018E   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000192   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   00000196   0x7809             LDRB     R1,[R1, #+0]
   \   00000198   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   0000019C   0x6840             LDR      R0,[R0, #+4]
   \   0000019E   0x2800             CMP      R0,#+0
   \   000001A0   0xD002             BEQ.N    ??UartTransmitterIsr_8
    705                  			{
    706                                                  UartExecPendingCallbacks(gUart1_c);                  
   \   000001A2   0x2001             MOVS     R0,#+1
   \   000001A4   0x.... 0x....      BL       UartExecPendingCallbacks
    707                  			}                
    708          
    709                  			/* Reset the current buffer index */
    710                  			mSci1TxCurIndex = 0;
   \                     ??UartTransmitterIsr_8: (+1)
   \   000001A8   0x2000             MOVS     R0,#+0
   \   000001AA   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   000001AE   0x7008             STRB     R0,[R1, #+0]
    711          
    712                  			/* Increment to the next buffer. */
    713                  			if (++mSci1TxBufRefTrailingIndex >= NumberOfElements(maSci1TxBufRefTable)) 
   \   000001B0   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   000001B4   0x7800             LDRB     R0,[R0, #+0]
   \   000001B6   0x1C40             ADDS     R0,R0,#+1
   \   000001B8   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   000001BC   0x7008             STRB     R0,[R1, #+0]
   \   000001BE   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   000001C2   0x7800             LDRB     R0,[R0, #+0]
   \   000001C4   0x2803             CMP      R0,#+3
   \   000001C6   0xD303             BCC.N    ??UartTransmitterIsr_9
    714                  			{
    715                  				mSci1TxBufRefTrailingIndex = 0;
   \   000001C8   0x2000             MOVS     R0,#+0
   \   000001CA   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   000001CE   0x7008             STRB     R0,[R1, #+0]
    716                  			}
    717          
    718                  			/* If there is no more data to send, turn off the transmit interrupt. */
    719                  			if (!maSci1TxBufLenTable[mSci1TxBufRefTrailingIndex]) 
   \                     ??UartTransmitterIsr_9: (+1)
   \   000001D0   0x.... 0x....      LDR.W    R0,??DataTable11
   \   000001D4   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   000001D8   0x7809             LDRB     R1,[R1, #+0]
   \   000001DA   0x5C08             LDRB     R0,[R1, R0]
   \   000001DC   0x2800             CMP      R0,#+0
   \   000001DE   0xD111             BNE.N    ??UartTransmitterIsr_2
    720                  			{
    721                  				mUartModule[gUart1_c].UartRegs->C2 &= ~(gUART_TIE_BIT_c);
   \   000001E0   0x.... 0x....      LDR.W    R0,??DataTable8
   \   000001E4   0x6B80             LDR      R0,[R0, #+56]
   \   000001E6   0x78C0             LDRB     R0,[R0, #+3]
   \   000001E8   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   000001EC   0x.... 0x....      LDR.W    R1,??DataTable8
   \   000001F0   0x6B89             LDR      R1,[R1, #+56]
   \   000001F2   0x70C8             STRB     R0,[R1, #+3]
    722                  				/* clear the write ongoing flag */
    723                  				mUartModule[gUart1_c].UartWriteOnGoing = FALSE;
   \   000001F4   0x.... 0x....      LDR.W    R0,??DataTable8
   \   000001F8   0x6B40             LDR      R0,[R0, #+52]
   \   000001FA   0xF030 0x0002      BICS     R0,R0,#0x2
   \   000001FE   0x.... 0x....      LDR.W    R1,??DataTable8
   \   00000202   0x6348             STR      R0,[R1, #+52]
    724                  			}
    725                  		} 
    726                  	}
    727                 	
    728                  }
    729                  (void)dummy;
   \                     ??UartTransmitterIsr_2: (+1)
   \   00000204   0xF89D 0x0000      LDRB     R0,[SP, #+0]
    730              }   
    731          #endif // gUart1_Enabled_d   
    732              
    733              /*************************
    734               ******** UART_2 *********
    735               *************************/
    736              
    737          #if (gUart2_Enabled_d == TRUE)
    738          
    739              if(gUart2_c == UartNumber)
    740              {
    741                  volatile uint8_t dummy;
    742                          
    743          #if gUART_USE_TX_FIFO_d
    744                  
    745                  if((mUartModule[gUart2_c].UartTxFifoSize > 1) && (mUartModule[gUart2_c].UartRegs->PFIFO & gUART_TX_FIFO_EN_BIT_c))
    746                  {
    747                  	if(mUartModule[gUart2_c].UartRegs->S1 & gUART_S1_TDRE_MASK_c)
    748                  	{        		        	
    749                  		while(mUartModule[gUart2_c].UartTxFifoSize - mUartModule[gUart2_c].UartRegs->TCFIFO > 0)
    750                  		{
    751                  			if(FALSE == mUartModule[gUart2_c].UartWriteOnGoing)
    752                  				break;
    753                  			
    754                  			/* Write a byte. */
    755                  			mUartModule[gUart2_c].UartRegs->D = maSci2TxBufRefTable[mSci2TxBufRefTrailingIndex].pBuf[mSci2TxCurIndex];        	
    756          
    757                  			/* Finished with this buffer? */
    758                  			if (++mSci2TxCurIndex >= maSci2TxBufLenTable[mSci2TxBufRefTrailingIndex]) 
    759                  			{
    760          
    761                  				/* Mark this one as done */
    762                  				maSci2TxBufLenTable[mSci2TxBufRefTrailingIndex] = 0;                
    763                  				if ( maSci2TxBufRefTable[mSci2TxBufRefTrailingIndex].pfCallBack) 
    764                  				{
    765                                                          UartExecPendingCallbacks(gUart2_c);
    766                  				}                
    767          
    768                  				/* Reset the current buffer index */
    769                  				mSci2TxCurIndex = 0;
    770          
    771                  				/* Increment to the next buffer. */
    772                  				if (++mSci2TxBufRefTrailingIndex >= NumberOfElements(maSci2TxBufRefTable)) 
    773                  				{
    774                  					mSci2TxBufRefTrailingIndex = 0;
    775                  				}
    776          
    777                  				/* If there is no more data to send, turn off the transmit interrupt. */
    778                  				if (!maSci2TxBufLenTable[mSci2TxBufRefTrailingIndex]) 
    779                  				{
    780                  					mUartModule[gUart2_c].UartRegs->C2 &= ~(gUART_TIE_BIT_c);
    781                  					/* clear the write ongoing flag */
    782                  					mUartModule[gUart2_c].UartWriteOnGoing = FALSE;
    783                  				}
    784                  			} 
    785                  		}
    786                  		
    787                  		/* this read will clear the TDRE flag */
    788                  		dummy = mUartModule[gUart2_c].UartRegs->S1;
    789                  	}
    790                  }
    791                  else
    792          #endif
    793                  {
    794          #if gUart2_Hw_Sw_FlowControl_d
    795                  	if(Uart2_FlowConflict())
    796                  	{
    797                  		/* Disable the TX interrupt */
    798                  		mUartModule[gUart2_c].UartRegs->C2 &= ~(gUART_TIE_BIT_c);
    799                  		bUart2FlowConflict = TRUE;
    800                  	}
    801                  	else
    802          #endif
    803                  	{
    804                  		/* Dummy read - required before write to data register. */
    805                  		dummy = mUartModule[gUart2_c].UartRegs->S1;
    806          
    807                  		/* Write a byte. */
    808                  		mUartModule[gUart2_c].UartRegs->D = maSci2TxBufRefTable[mSci2TxBufRefTrailingIndex].pBuf[mSci2TxCurIndex];        	
    809          
    810                  		/* Finished with this buffer? */
    811                  		if (++mSci2TxCurIndex >= maSci2TxBufLenTable[mSci2TxBufRefTrailingIndex]) 
    812                  		{
    813          
    814                  			/* Mark this one as done */
    815                  			maSci2TxBufLenTable[mSci2TxBufRefTrailingIndex] = 0;                
    816                  			if ( maSci2TxBufRefTable[mSci2TxBufRefTrailingIndex].pfCallBack) 
    817                  			{
    818                                                  UartExecPendingCallbacks(gUart2_c); 
    819                  			}                
    820          
    821                  			/* Reset the current buffer index */
    822                  			mSci2TxCurIndex = 0;
    823          
    824                  			/* Increment to the next buffer. */
    825                  			if (++mSci2TxBufRefTrailingIndex >= NumberOfElements(maSci2TxBufRefTable)) 
    826                  			{
    827                  				mSci2TxBufRefTrailingIndex = 0;
    828                  			}
    829          
    830                  			/* If there is no more data to send, turn off the transmit interrupt. */
    831                  			if (!maSci2TxBufLenTable[mSci2TxBufRefTrailingIndex]) 
    832                  			{
    833                  				mUartModule[gUart2_c].UartRegs->C2 &= ~(gUART_TIE_BIT_c);
    834                  				/* clear the write ongoing flag */
    835                  				mUartModule[gUart2_c].UartWriteOnGoing = FALSE;
    836                  			}
    837                  		} 
    838                  	}       	
    839                  }
    840              }   
    841          #endif // gUart2_Enabled_d  }    
    842          }
   \                     ??UartTransmitterIsr_0: (+1)
   \   00000208   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    843          
    844          /******************************************************************************
    845           * Name: UartReadComplete
    846           * Description: UART read complete function.
    847           * Parameters: [IN]: UartNumber - the UART peripheral number
    848           * Return: -
    849           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    850          static void UartReadComplete
    851          (
    852              uint8_t UartNumber
    853          )
    854          {    
   \                     UartReadComplete: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    855          	/* Reset the internal write flag because the reception is over */
    856          	mUartModule[UartNumber].UartReadOnGoing = FALSE;
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2134             MOVS     R1,#+52
   \   0000000C   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable8
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2234             MOVS     R2,#+52
   \   0000001E   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000022   0x6008             STR      R0,[R1, #+0]
    857          	
    858          	/* Disable RX interrupt */ 
    859          	mUartModule[UartNumber].UartRegs->C2 &= ~(gUART_RIE_BIT_c);
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x2134             MOVS     R1,#+52
   \   0000002C   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000030   0x6840             LDR      R0,[R0, #+4]
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable8
   \   00000036   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   0x2234             MOVS     R2,#+52
   \   0000003A   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000003E   0x6849             LDR      R1,[R1, #+4]
   \   00000040   0x78C9             LDRB     R1,[R1, #+3]
   \   00000042   0xF011 0x01DF      ANDS     R1,R1,#0xDF
   \   00000046   0x70C1             STRB     R1,[R0, #+3]
    860             
    861              /* Call to the read pCallback function */
    862                  if (UartNumber == gUart1_c)
   \   00000048   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004A   0x2C01             CMP      R4,#+1
   \   0000004C   0xD108             BNE.N    ??UartReadComplete_0
    863                  {
    864                    #if (TRUE == gUart1_Enabled_d)
    865                            if(pfSci1RxCallBack != NULL)
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD003             BEQ.N    ??UartReadComplete_0
    866                            {
    867                              pfSci1RxCallBack();
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable10
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x4780             BLX      R0
    868                            }
    869                    #endif
    870                  }
    871                  else
    872                  {
    873                    #if (TRUE == gUart2_Enabled_d)
    874                          if(pfSci2RxCallBack != NULL)
    875                          {
    876                            pfSci2RxCallBack();
    877                          } 
    878                    #endif    
    879                  }
    880          }
   \                     ??UartReadComplete_0: (+1)
   \   00000060   0xBD10             POP      {R4,PC}          ;; return
    881          
    882          /******************************************************************************
    883           * Name: UartDivide
    884           * Description: Integer division by repeated substractions.
    885           * Parameters: [IN]: Number - the number to be divided
    886           *             [IN]: Divisor - the number to divide to
    887           * Return: the result of the division operation
    888           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    889          static uint16_t UartDivide
    890          (
    891              int32_t Number, 
    892              uint32_t Divisor
    893          )
    894          {
   \                     UartDivide: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    895              /* Variable to store result of the operation */
    896              uint16_t Result=0;
   \   00000002   0x2000             MOVS     R0,#+0
    897          
    898              while(1)
    899              {    
    900                  Number-=Divisor;
   \                     ??UartDivide_0: (+1)
   \   00000004   0x1A52             SUBS     R2,R2,R1
    901                  if(Number<0) 
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD501             BPL.N    ??UartDivide_1
    902                  {
    903                      return Result;
   \   0000000A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000C   0xE001             B.N      ??UartDivide_2
    904                  }
    905                  Result++;
   \                     ??UartDivide_1: (+1)
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \   00000010   0xE7F8             B.N      ??UartDivide_0
    906              }
   \                     ??UartDivide_2: (+1)
   \   00000012   0x4770             BX       LR               ;; return
    907          }
    908          
    909          /******************************************************************************
    910           * Name: UartOpen
    911           * Description: Open the specified UART port
    912           * Parameters: [IN]: UartNumber - the UART port number to be opened
    913           *             [IN]: PlatformClock - The platform clock in KHz
    914           * Return: see definition of UartErr_t
    915           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    916          static UartErr_t UartOpen
    917          (
    918              uint8_t UartNumber, 
    919              uint32_t PlatformClock
    920          )
    921          {
   \                     UartOpen: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
    922             
    923              /* Variable used to clear the UART status register */
    924              register uint32_t dummy;
    925          
    926              /* Check if the first parameter received is valid  */
    927              if (UartNumber >= gUART_HW_MODULES_AVAILABLE_c)
   \   00000004   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000006   0x2A04             CMP      R2,#+4
   \   00000008   0xDB01             BLT.N    ??UartOpen_0
    928              {
    929                  return gUartErrWrongUartNumber_c;
   \   0000000A   0x200D             MOVS     R0,#+13
   \   0000000C   0xE0B9             B.N      ??UartOpen_1
    930              }
    931          
    932              /* Check if UART is open */
    933              if (mUartModule[UartNumber].UartIsOpen)
   \                     ??UartOpen_0: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000012   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000014   0x2434             MOVS     R4,#+52
   \   00000016   0xFB04 0x0002      MLA      R0,R4,R2,R0
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x07C0             LSLS     R0,R0,#+31
   \   0000001E   0xD501             BPL.N    ??UartOpen_2
    934              {
    935                  return gUartErrUartAlreadyOpen_c;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE0AE             B.N      ??UartOpen_1
    936              }
    937          
    938              if(NULL == mUartModule[UartNumber].UartRegs)
   \                     ??UartOpen_2: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000028   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002A   0x2434             MOVS     R4,#+52
   \   0000002C   0xFB04 0x0002      MLA      R0,R4,R2,R0
   \   00000030   0x6840             LDR      R0,[R0, #+4]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD101             BNE.N    ??UartOpen_3
    939              {
    940                  return gUartErrNullPointer_c;
   \   00000036   0x2006             MOVS     R0,#+6
   \   00000038   0xE0A3             B.N      ??UartOpen_1
    941              }
    942          
    943              /* Disable transceiver */
    944              mUartModule[UartNumber].UartRegs->C2 &= ~(gUART_TX_EN_BIT_c | gUART_RX_EN_BIT_c);
   \                     ??UartOpen_3: (+1)
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000003E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000040   0x2434             MOVS     R4,#+52
   \   00000042   0xFB04 0x0002      MLA      R0,R4,R2,R0
   \   00000046   0x6840             LDR      R0,[R0, #+4]
   \   00000048   0x.... 0x....      LDR.W    R4,??DataTable8
   \   0000004C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000004E   0x2534             MOVS     R5,#+52
   \   00000050   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   00000054   0x6864             LDR      R4,[R4, #+4]
   \   00000056   0x78E4             LDRB     R4,[R4, #+3]
   \   00000058   0xF014 0x04F3      ANDS     R4,R4,#0xF3
   \   0000005C   0x70C4             STRB     R4,[R0, #+3]
    945          
    946              /* Clear all bits in control registers; disable RX and TX interrupts */
    947              mUartModule[UartNumber].UartRegs->C1 = 0x00;
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000062   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000064   0x2434             MOVS     R4,#+52
   \   00000066   0xFB04 0x0002      MLA      R0,R4,R2,R0
   \   0000006A   0x6840             LDR      R0,[R0, #+4]
   \   0000006C   0x2400             MOVS     R4,#+0
   \   0000006E   0x7084             STRB     R4,[R0, #+2]
    948              mUartModule[UartNumber].UartRegs->C2 &= ~(gUART_TIE_BIT_c | gUART_RIE_BIT_c); 
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000074   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000076   0x2434             MOVS     R4,#+52
   \   00000078   0xFB04 0x0002      MLA      R0,R4,R2,R0
   \   0000007C   0x6840             LDR      R0,[R0, #+4]
   \   0000007E   0x.... 0x....      LDR.W    R4,??DataTable8
   \   00000082   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000084   0x2534             MOVS     R5,#+52
   \   00000086   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   0000008A   0x6864             LDR      R4,[R4, #+4]
   \   0000008C   0x78E4             LDRB     R4,[R4, #+3]
   \   0000008E   0xF014 0x049F      ANDS     R4,R4,#0x9F
   \   00000092   0x70C4             STRB     R4,[R0, #+3]
    949              mUartModule[UartNumber].UartRegs->C3 = 0x00;
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000098   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000009A   0x2434             MOVS     R4,#+52
   \   0000009C   0xFB04 0x0002      MLA      R0,R4,R2,R0
   \   000000A0   0x6840             LDR      R0,[R0, #+4]
   \   000000A2   0x2400             MOVS     R4,#+0
   \   000000A4   0x7184             STRB     R4,[R0, #+6]
    950              mUartModule[UartNumber].UartRegs->C4 = 0x00;
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable8
   \   000000AA   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000AC   0x2434             MOVS     R4,#+52
   \   000000AE   0xFB04 0x0002      MLA      R0,R4,R2,R0
   \   000000B2   0x6840             LDR      R0,[R0, #+4]
   \   000000B4   0x2400             MOVS     R4,#+0
   \   000000B6   0x7284             STRB     R4,[R0, #+10]
    951              mUartModule[UartNumber].UartRegs->C5 = 0x00;
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable8
   \   000000BC   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000BE   0x2434             MOVS     R4,#+52
   \   000000C0   0xFB04 0x0002      MLA      R0,R4,R2,R0
   \   000000C4   0x6840             LDR      R0,[R0, #+4]
   \   000000C6   0x2400             MOVS     R4,#+0
   \   000000C8   0x72C4             STRB     R4,[R0, #+11]
    952          
    953              /* Initialize the internal variables */
    954              mUartModule[UartNumber].UartIsOpen = TRUE;
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable8
   \   000000CE   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000D0   0x2434             MOVS     R4,#+52
   \   000000D2   0xFB04 0x0002      MLA      R0,R4,R2,R0
   \   000000D6   0x6800             LDR      R0,[R0, #+0]
   \   000000D8   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000DC   0x.... 0x....      LDR.W    R4,??DataTable8
   \   000000E0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000E2   0x2534             MOVS     R5,#+52
   \   000000E4   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   000000E8   0x6020             STR      R0,[R4, #+0]
    955              mUartModule[UartNumber].UartReadOnGoing = FALSE;
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable8
   \   000000EE   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000F0   0x2434             MOVS     R4,#+52
   \   000000F2   0xFB04 0x0002      MLA      R0,R4,R2,R0
   \   000000F6   0x6800             LDR      R0,[R0, #+0]
   \   000000F8   0xF030 0x0004      BICS     R0,R0,#0x4
   \   000000FC   0x.... 0x....      LDR.W    R4,??DataTable8
   \   00000100   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000102   0x2534             MOVS     R5,#+52
   \   00000104   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   00000108   0x6020             STR      R0,[R4, #+0]
    956              mUartModule[UartNumber].UartWriteOnGoing = FALSE;
   \   0000010A   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000010E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000110   0x2434             MOVS     R4,#+52
   \   00000112   0xFB04 0x0002      MLA      R0,R4,R2,R0
   \   00000116   0x6800             LDR      R0,[R0, #+0]
   \   00000118   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000011C   0x.... 0x....      LDR.W    R4,??DataTable8
   \   00000120   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000122   0x2534             MOVS     R5,#+52
   \   00000124   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   00000128   0x6020             STR      R0,[R4, #+0]
    957              mUartModule[UartNumber].UartPlatformClock = PlatformClock;    
   \   0000012A   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000012E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000130   0x2434             MOVS     R4,#+52
   \   00000132   0xFB04 0x0002      MLA      R0,R4,R2,R0
   \   00000136   0x6201             STR      R1,[R0, #+32]
    958          
    959              /* Read status registers in order to clear error bits and interrupt receive bits */
    960              dummy = mUartModule[UartNumber].UartRegs->S1;   
   \   00000138   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000013C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000013E   0x2434             MOVS     R4,#+52
   \   00000140   0xFB04 0x0002      MLA      R0,R4,R2,R0
   \   00000144   0x6840             LDR      R0,[R0, #+4]
   \   00000146   0x7900             LDRB     R0,[R0, #+4]
   \   00000148   0x0003             MOVS     R3,R0
    961              (void)dummy;
    962              dummy = mUartModule[UartNumber].UartRegs->S2;
   \   0000014A   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000014E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000150   0x2434             MOVS     R4,#+52
   \   00000152   0xFB04 0x0002      MLA      R0,R4,R2,R0
   \   00000156   0x6840             LDR      R0,[R0, #+4]
   \   00000158   0x7940             LDRB     R0,[R0, #+5]
   \   0000015A   0x0003             MOVS     R3,R0
    963              (void)dummy;
    964          
    965              /* Enable transceiver */
    966              mUartModule[UartNumber].UartRegs->C2 |=  (gUART_TX_EN_BIT_c | gUART_RX_EN_BIT_c);
   \   0000015C   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000160   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000162   0x2434             MOVS     R4,#+52
   \   00000164   0xFB04 0x0002      MLA      R0,R4,R2,R0
   \   00000168   0x6840             LDR      R0,[R0, #+4]
   \   0000016A   0x.... 0x....      LDR.W    R4,??DataTable8
   \   0000016E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000170   0x2534             MOVS     R5,#+52
   \   00000172   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   00000176   0x6864             LDR      R4,[R4, #+4]
   \   00000178   0x78E4             LDRB     R4,[R4, #+3]
   \   0000017A   0xF054 0x040C      ORRS     R4,R4,#0xC
   \   0000017E   0x70C4             STRB     R4,[R0, #+3]
    967          
    968              /* Exit without error */
    969              return gUartErrNoError_c;
   \   00000180   0x2000             MOVS     R0,#+0
   \                     ??UartOpen_1: (+1)
   \   00000182   0xBC30             POP      {R4,R5}
   \   00000184   0x4770             BX       LR               ;; return
    970          }
    971          
    972          /******************************************************************************
    973           * Name: UartSetConfig
    974           * Description: configure the specified UART port
    975           * Parameters: [IN]: UartNumber - the UART port number to be configured
    976           *             [IN]: pConfig - pointer to UART configuration data structure
    977           * Return: see definition of UartErr_t
    978           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    979          static UartErr_t UartSetConfig
    980          (
    981              uint8_t UartNumber, 
    982              UartConfig_t* pConfig
    983          )
    984          {/* variables used for temporary store values for INC and MOD UART registers */
   \                     UartSetConfig: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    985              register uint16_t mUartSBR;
    986              register uint32_t mUartBRDF;
    987              register uint8_t mUartBRFA;    
    988          
    989              /* check if the first parameter received is valid */
    990              if (UartNumber >= gUART_HW_MODULES_AVAILABLE_c)    
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2C04             CMP      R4,#+4
   \   0000000C   0xDB01             BLT.N    ??UartSetConfig_0
    991                  return gUartErrWrongUartNumber_c;
   \   0000000E   0x200D             MOVS     R0,#+13
   \   00000010   0xE245             B.N      ??UartSetConfig_1
    992          
    993              /* check if the second parameter received is valid */
    994              if (NULL == pConfig)    
   \                     ??UartSetConfig_0: (+1)
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD101             BNE.N    ??UartSetConfig_2
    995                  return gUartErrNullPointer_c;
   \   00000016   0x2006             MOVS     R0,#+6
   \   00000018   0xE241             B.N      ??UartSetConfig_1
    996          
    997              /* check if UART has been opened */
    998              if (!mUartModule[UartNumber].UartIsOpen)    
   \                     ??UartSetConfig_2: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x2134             MOVS     R1,#+52
   \   00000022   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x07C0             LSLS     R0,R0,#+31
   \   0000002A   0xD401             BMI.N    ??UartSetConfig_3
    999                  return gUartErrUartNotOpen_c;
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xE236             B.N      ??UartSetConfig_1
   1000          
   1001              /* check the possibility to set the specified baudrate considering the platform clock  (platform clock/baudrate >=8) */
   1002              if ((((mUartModule[UartNumber].UartPlatformClock * 1000) >>3) < pConfig->UartBaudRate))    
   \                     ??UartSetConfig_3: (+1)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000034   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000036   0x2134             MOVS     R1,#+52
   \   00000038   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000003C   0x6A00             LDR      R0,[R0, #+32]
   \   0000003E   0xF44F 0x717A      MOV      R1,#+1000
   \   00000042   0x4348             MULS     R0,R1,R0
   \   00000044   0x08C0             LSRS     R0,R0,#+3
   \   00000046   0x6829             LDR      R1,[R5, #+0]
   \   00000048   0x4288             CMP      R0,R1
   \   0000004A   0xD201             BCS.N    ??UartSetConfig_4
   1003                  return gUartErrInvalidBaudrate_c;
   \   0000004C   0x2008             MOVS     R0,#+8
   \   0000004E   0xE226             B.N      ??UartSetConfig_1
   1004          
   1005              /* check if the read operation is ongoing */
   1006              if (mUartModule[UartNumber].UartReadOnGoing)    
   \                     ??UartSetConfig_4: (+1)
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000054   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000056   0x2134             MOVS     R1,#+52
   \   00000058   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD001             BEQ.N    ??UartSetConfig_5
   1007                  return gUartErrReadOngoing_c;
   \   00000066   0x2003             MOVS     R0,#+3
   \   00000068   0xE219             B.N      ??UartSetConfig_1
   1008          
   1009              /* check if the write operation is ongoing */
   1010              if (mUartModule[UartNumber].UartWriteOnGoing)
   \                     ??UartSetConfig_5: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000006E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000070   0x2134             MOVS     R1,#+52
   \   00000072   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD001             BEQ.N    ??UartSetConfig_6
   1011                  return gUartErrWriteOngoing_c;
   \   00000080   0x2004             MOVS     R0,#+4
   \   00000082   0xE20C             B.N      ??UartSetConfig_1
   1012          
   1013              /* set parity - set/reset PE and PT bits from UARTx_C2 */
   1014              switch(pConfig->UartParity)
   \                     ??UartSetConfig_6: (+1)
   \   00000084   0x7928             LDRB     R0,[R5, #+4]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD003             BEQ.N    ??UartSetConfig_7
   \   0000008A   0x2802             CMP      R0,#+2
   \   0000008C   0xD039             BEQ.N    ??UartSetConfig_8
   \   0000008E   0xD313             BCC.N    ??UartSetConfig_9
   \   00000090   0xE05C             B.N      ??UartSetConfig_10
   1015              {
   1016              case gUartParityNone_c:
   1017                  /* reset the PE (parity enable) bit */
   1018                  mUartModule[UartNumber].UartRegs->C1 &= ~gUART_PARITY_EN_BIT_c;
   \                     ??UartSetConfig_7: (+1)
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000096   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000098   0x2134             MOVS     R1,#+52
   \   0000009A   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000009E   0x6840             LDR      R0,[R0, #+4]
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable8
   \   000000A4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A6   0x2234             MOVS     R2,#+52
   \   000000A8   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000AC   0x6849             LDR      R1,[R1, #+4]
   \   000000AE   0x7889             LDRB     R1,[R1, #+2]
   \   000000B0   0xF011 0x01FD      ANDS     R1,R1,#0xFD
   \   000000B4   0x7081             STRB     R1,[R0, #+2]
   1019                  break;
   \   000000B6   0xE04B             B.N      ??UartSetConfig_11
   1020              case gUartParityEven_c:
   1021                  /* set the PE (parity enable) bit */
   1022                  mUartModule[UartNumber].UartRegs->C1 |= gUART_PARITY_EN_BIT_c;
   \                     ??UartSetConfig_9: (+1)
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable8
   \   000000BC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BE   0x2134             MOVS     R1,#+52
   \   000000C0   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000000C4   0x6840             LDR      R0,[R0, #+4]
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable8
   \   000000CA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000CC   0x2234             MOVS     R2,#+52
   \   000000CE   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000D2   0x6849             LDR      R1,[R1, #+4]
   \   000000D4   0x7889             LDRB     R1,[R1, #+2]
   \   000000D6   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   000000DA   0x7081             STRB     R1,[R0, #+2]
   1023                  /* reset the PT (parity type) bit */
   1024                  mUartModule[UartNumber].UartRegs->C1 &= ~gUART_PARITY_EVEN_BIT_c;
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable8
   \   000000E0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000E2   0x2134             MOVS     R1,#+52
   \   000000E4   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000000E8   0x6840             LDR      R0,[R0, #+4]
   \   000000EA   0x.... 0x....      LDR.W    R1,??DataTable8
   \   000000EE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F0   0x2234             MOVS     R2,#+52
   \   000000F2   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000F6   0x6849             LDR      R1,[R1, #+4]
   \   000000F8   0x7889             LDRB     R1,[R1, #+2]
   \   000000FA   0xF011 0x01FE      ANDS     R1,R1,#0xFE
   \   000000FE   0x7081             STRB     R1,[R0, #+2]
   1025                  break;
   \   00000100   0xE026             B.N      ??UartSetConfig_11
   1026              case gUartParityOdd_c:
   1027                  /* set the PE (parity enable) bit */
   1028                  mUartModule[UartNumber].UartRegs->C1 |=  gUART_PARITY_EN_BIT_c;
   \                     ??UartSetConfig_8: (+1)
   \   00000102   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000106   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000108   0x2134             MOVS     R1,#+52
   \   0000010A   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000010E   0x6840             LDR      R0,[R0, #+4]
   \   00000110   0x.... 0x....      LDR.W    R1,??DataTable8
   \   00000114   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000116   0x2234             MOVS     R2,#+52
   \   00000118   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000011C   0x6849             LDR      R1,[R1, #+4]
   \   0000011E   0x7889             LDRB     R1,[R1, #+2]
   \   00000120   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   00000124   0x7081             STRB     R1,[R0, #+2]
   1029                  /* set the PT (parity type) bit */
   1030                  mUartModule[UartNumber].UartRegs->C1 |= gUART_PARITY_EVEN_BIT_c;
   \   00000126   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000012A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000012C   0x2134             MOVS     R1,#+52
   \   0000012E   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000132   0x6840             LDR      R0,[R0, #+4]
   \   00000134   0x.... 0x....      LDR.W    R1,??DataTable8
   \   00000138   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000013A   0x2234             MOVS     R2,#+52
   \   0000013C   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000140   0x6849             LDR      R1,[R1, #+4]
   \   00000142   0x7889             LDRB     R1,[R1, #+2]
   \   00000144   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000148   0x7081             STRB     R1,[R0, #+2]
   1031                  break;
   \   0000014A   0xE001             B.N      ??UartSetConfig_11
   1032              default:
   1033                  /* on default case, return error */
   1034                  return gUartErrInvalidParity_c;
   \                     ??UartSetConfig_10: (+1)
   \   0000014C   0x2009             MOVS     R0,#+9
   \   0000014E   0xE1A6             B.N      ??UartSetConfig_1
   1035              }
   1036          
   1037              /* set the number of data bits - set/reset M bit from UARTx_C1 register */
   1038              switch(pConfig->UartDataBits)
   \                     ??UartSetConfig_11: (+1)
   \   00000150   0x7968             LDRB     R0,[R5, #+5]
   \   00000152   0x2800             CMP      R0,#+0
   \   00000154   0xD002             BEQ.N    ??UartSetConfig_12
   \   00000156   0x2801             CMP      R0,#+1
   \   00000158   0xD013             BEQ.N    ??UartSetConfig_13
   \   0000015A   0xE025             B.N      ??UartSetConfig_14
   1039              {
   1040              case gUart_8bits_c:
   1041                  /* M = 0 (8 bits) */
   1042                  mUartModule[UartNumber].UartRegs->C1 &= ~gUART_DATA_BITS_BIT_c;
   \                     ??UartSetConfig_12: (+1)
   \   0000015C   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000160   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000162   0x2134             MOVS     R1,#+52
   \   00000164   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000168   0x6840             LDR      R0,[R0, #+4]
   \   0000016A   0x.... 0x....      LDR.W    R1,??DataTable8
   \   0000016E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000170   0x2234             MOVS     R2,#+52
   \   00000172   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000176   0x6849             LDR      R1,[R1, #+4]
   \   00000178   0x7889             LDRB     R1,[R1, #+2]
   \   0000017A   0xF011 0x01F7      ANDS     R1,R1,#0xF7
   \   0000017E   0x7081             STRB     R1,[R0, #+2]
   1043                  break;
   \   00000180   0xE014             B.N      ??UartSetConfig_15
   1044              case gUart_9bits_c:
   1045                  /* M = 1 (9 bits) */
   1046                  mUartModule[UartNumber].UartRegs->C1 |=  gUART_DATA_BITS_BIT_c;
   \                     ??UartSetConfig_13: (+1)
   \   00000182   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000186   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000188   0x2134             MOVS     R1,#+52
   \   0000018A   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000018E   0x6840             LDR      R0,[R0, #+4]
   \   00000190   0x.... 0x....      LDR.W    R1,??DataTable8
   \   00000194   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000196   0x2234             MOVS     R2,#+52
   \   00000198   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000019C   0x6849             LDR      R1,[R1, #+4]
   \   0000019E   0x7889             LDRB     R1,[R1, #+2]
   \   000001A0   0xF051 0x0108      ORRS     R1,R1,#0x8
   \   000001A4   0x7081             STRB     R1,[R0, #+2]
   1047                  break;
   \   000001A6   0xE001             B.N      ??UartSetConfig_15
   1048              default:
   1049                  /* on default case, return error */
   1050                  return gUartErrInvalidStop_c;
   \                     ??UartSetConfig_14: (+1)
   \   000001A8   0x200A             MOVS     R0,#+10
   \   000001AA   0xE178             B.N      ??UartSetConfig_1
   1051              }
   1052          
   1053              /* configure the HW flow control, if enabled */
   1054              if(gFlowEnabled_c == pConfig->UartHWFlowCtrl)
   \                     ??UartSetConfig_15: (+1)
   \   000001AC   0x79A8             LDRB     R0,[R5, #+6]
   \   000001AE   0x2801             CMP      R0,#+1
   \   000001B0   0xD167             BNE.N    ??UartSetConfig_16
   1055              {
   1056              	
   1057              	if(gUart1_c == UartNumber)
   \   000001B2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001B4   0x2C01             CMP      R4,#+1
   \   000001B6   0xD10A             BNE.N    ??UartSetConfig_17
   1058              	{
   1059              		/* Setup Port Control Register (PCR) for RTS pin */
   1060              		gUART_1_RTS_PCR_c = PORT_PCR_MUX(gUART_1_MUX_c);
   \   000001B8   0xF44F 0x7040      MOV      R0,#+768
   \   000001BC   0x.... 0x....      LDR.W    R1,??DataTable22  ;; 0x4004d00c
   \   000001C0   0x6008             STR      R0,[R1, #+0]
   1061              		/* Setup Port Control Register (PCR) for CTS pin */
   1062              		gUART_1_CTS_PCR_c = PORT_PCR_MUX(gUART_1_MUX_c);
   \   000001C2   0xF44F 0x7040      MOV      R0,#+768
   \   000001C6   0x.... 0x....      LDR.W    R1,??DataTable22_1  ;; 0x4004d008
   \   000001CA   0x6008             STR      R0,[R1, #+0]
   \   000001CC   0xE00C             B.N      ??UartSetConfig_18
   1063              	} else if(gUart2_c == UartNumber)
   \                     ??UartSetConfig_17: (+1)
   \   000001CE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001D0   0x2C02             CMP      R4,#+2
   \   000001D2   0xD109             BNE.N    ??UartSetConfig_18
   1064              	{
   1065              		/* Setup Port Control Register (PCR) for RTS pin */
   1066              		gUART_2_RTS_PCR_c = PORT_PCR_MUX(gUART_2_MUX_c);
   \   000001D4   0xF44F 0x7040      MOV      R0,#+768
   \   000001D8   0x.... 0x....      LDR.W    R1,??DataTable22_2  ;; 0x4004d04c
   \   000001DC   0x6008             STR      R0,[R1, #+0]
   1067              		/* Setup Port Control Register (PCR) for CTS pin */
   1068              		gUART_2_CTS_PCR_c = PORT_PCR_MUX(gUART_2_MUX_c);
   \   000001DE   0xF44F 0x7040      MOV      R0,#+768
   \   000001E2   0x.... 0x....      LDR.W    R1,??DataTable23  ;; 0x4004d048
   \   000001E6   0x6008             STR      R0,[R1, #+0]
   1069              	}
   1070              	    	
   1071                  /* set the transmitter RTS polarity */
   1072                  if(gRtsActiveHi_c == pConfig->UartRTSActiveState) {
   \                     ??UartSetConfig_18: (+1)
   \   000001E8   0x79E8             LDRB     R0,[R5, #+7]
   \   000001EA   0x2801             CMP      R0,#+1
   \   000001EC   0xD112             BNE.N    ??UartSetConfig_19
   1073                      /* TXRTSPOL = 1 */
   1074                      mUartModule[UartNumber].UartRegs->MODEM |= gUART_TXRTSPOL_BIT_c;
   \   000001EE   0x.... 0x....      LDR.W    R0,??DataTable8
   \   000001F2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001F4   0x2134             MOVS     R1,#+52
   \   000001F6   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000001FA   0x6840             LDR      R0,[R0, #+4]
   \   000001FC   0x.... 0x....      LDR.W    R1,??DataTable8
   \   00000200   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000202   0x2234             MOVS     R2,#+52
   \   00000204   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000208   0x6849             LDR      R1,[R1, #+4]
   \   0000020A   0x7B49             LDRB     R1,[R1, #+13]
   \   0000020C   0xF051 0x0104      ORRS     R1,R1,#0x4
   \   00000210   0x7341             STRB     R1,[R0, #+13]
   \   00000212   0xE011             B.N      ??UartSetConfig_20
   1075                  } else {
   1076                      /* TXRTSPOL = 0 */
   1077                      mUartModule[UartNumber].UartRegs->MODEM &= ~gUART_TXRTSPOL_BIT_c;
   \                     ??UartSetConfig_19: (+1)
   \   00000214   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000218   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000021A   0x2134             MOVS     R1,#+52
   \   0000021C   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000220   0x6840             LDR      R0,[R0, #+4]
   \   00000222   0x.... 0x....      LDR.W    R1,??DataTable8
   \   00000226   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000228   0x2234             MOVS     R2,#+52
   \   0000022A   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000022E   0x6849             LDR      R1,[R1, #+4]
   \   00000230   0x7B49             LDRB     R1,[R1, #+13]
   \   00000232   0xF011 0x01FB      ANDS     R1,R1,#0xFB
   \   00000236   0x7341             STRB     R1,[R0, #+13]
   1078                  }
   1079          
   1080                  /* set the receiver RTS bit */
   1081                  mUartModule[UartNumber].UartRegs->MODEM |= gUART_RXRTSE_BIT_c;
   \                     ??UartSetConfig_20: (+1)
   \   00000238   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000023C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000023E   0x2134             MOVS     R1,#+52
   \   00000240   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000244   0x6840             LDR      R0,[R0, #+4]
   \   00000246   0x.... 0x....      LDR.W    R1,??DataTable8
   \   0000024A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000024C   0x2234             MOVS     R2,#+52
   \   0000024E   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000252   0x6849             LDR      R1,[R1, #+4]
   \   00000254   0x7B49             LDRB     R1,[R1, #+13]
   \   00000256   0xF051 0x0108      ORRS     R1,R1,#0x8
   \   0000025A   0x7341             STRB     R1,[R0, #+13]
   1082          
   1083                  /* set the transmitter CTS bit */
   1084                  mUartModule[UartNumber].UartRegs->MODEM |= gUART_TXCTSE_BIT_c;     
   \   0000025C   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000260   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000262   0x2134             MOVS     R1,#+52
   \   00000264   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000268   0x6840             LDR      R0,[R0, #+4]
   \   0000026A   0x.... 0x....      LDR.W    R1,??DataTable8
   \   0000026E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000270   0x2234             MOVS     R2,#+52
   \   00000272   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000276   0x6849             LDR      R1,[R1, #+4]
   \   00000278   0x7B49             LDRB     R1,[R1, #+13]
   \   0000027A   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   0000027E   0x7341             STRB     R1,[R0, #+13]
   \   00000280   0xE011             B.N      ??UartSetConfig_21
   1085              } 
   1086              else 
   1087              {
   1088                  /* HW flow control is disabled */
   1089                  mUartModule[UartNumber].UartRegs->MODEM &= ~(gUART_RXRTSE_BIT_c | gUART_TXRTSPOL_BIT_c | gUART_TXCTSE_BIT_c);
   \                     ??UartSetConfig_16: (+1)
   \   00000282   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000286   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000288   0x2134             MOVS     R1,#+52
   \   0000028A   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000028E   0x6840             LDR      R0,[R0, #+4]
   \   00000290   0x.... 0x....      LDR.W    R1,??DataTable8
   \   00000294   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000296   0x2234             MOVS     R2,#+52
   \   00000298   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000029C   0x6849             LDR      R1,[R1, #+4]
   \   0000029E   0x7B49             LDRB     R1,[R1, #+13]
   \   000002A0   0xF011 0x01F2      ANDS     R1,R1,#0xF2
   \   000002A4   0x7341             STRB     R1,[R0, #+13]
   1090              }
   1091              
   1092              /* default FIFO sizes */
   1093              mUartModule[UartNumber].UartRxFifoSize = 1;
   \                     ??UartSetConfig_21: (+1)
   \   000002A6   0x2001             MOVS     R0,#+1
   \   000002A8   0x.... 0x....      LDR.W    R1,??DataTable8
   \   000002AC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002AE   0x2234             MOVS     R2,#+52
   \   000002B0   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000002B4   0xF881 0x0030      STRB     R0,[R1, #+48]
   1094              mUartModule[UartNumber].UartTxFifoSize = 1;
   \   000002B8   0x2001             MOVS     R0,#+1
   \   000002BA   0x.... 0x....      LDR.W    R1,??DataTable8
   \   000002BE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002C0   0x2234             MOVS     R2,#+52
   \   000002C2   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000002C6   0xF881 0x0031      STRB     R0,[R1, #+49]
   1095              
   1096          #if (gUART_USE_RX_FIFO_d == TRUE)    
   1097              /* get RX FIFO size */
   1098              {
   1099              	register uint8_t fifoSz = (uint8_t)(mUartModule[UartNumber].UartRegs->PFIFO & gUART_RX_FIFO_MASK_c);    	
   \   000002CA   0x.... 0x....      LDR.W    R0,??DataTable8
   \   000002CE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002D0   0x2134             MOVS     R1,#+52
   \   000002D2   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000002D6   0x6840             LDR      R0,[R0, #+4]
   \   000002D8   0x7C00             LDRB     R0,[R0, #+16]
   \   000002DA   0xF010 0x0007      ANDS     R0,R0,#0x7
   1100              	fifoSz+=1;
   \   000002DE   0x1C40             ADDS     R0,R0,#+1
   1101              	
   1102              	while(fifoSz-->0)
   \                     ??UartSetConfig_22: (+1)
   \   000002E0   0x0001             MOVS     R1,R0
   \   000002E2   0x1E48             SUBS     R0,R1,#+1
   \   000002E4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002E6   0x2900             CMP      R1,#+0
   \   000002E8   0xD011             BEQ.N    ??UartSetConfig_23
   1103              	{
   1104              		mUartModule[UartNumber].UartRxFifoSize = mUartModule[UartNumber].UartRxFifoSize << 1;    		
   \   000002EA   0x.... 0x....      LDR.W    R1,??DataTable8
   \   000002EE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002F0   0x2234             MOVS     R2,#+52
   \   000002F2   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000002F6   0xF891 0x1030      LDRB     R1,[R1, #+48]
   \   000002FA   0x0049             LSLS     R1,R1,#+1
   \   000002FC   0x.... 0x....      LDR.W    R2,??DataTable8
   \   00000300   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000302   0x2334             MOVS     R3,#+52
   \   00000304   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   00000308   0xF882 0x1030      STRB     R1,[R2, #+48]
   \   0000030C   0xE7E8             B.N      ??UartSetConfig_22
   1105              	};    	
   1106              }
   1107                  
   1108              /* enable RX FIFO and set RX threshold, if FIFO is implemented by hardware */
   1109              if(mUartModule[UartNumber].UartRxFifoSize > 1)
   \                     ??UartSetConfig_23: (+1)
   \   0000030E   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000312   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000314   0x2134             MOVS     R1,#+52
   \   00000316   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000031A   0xF890 0x0030      LDRB     R0,[R0, #+48]
   \   0000031E   0x2802             CMP      R0,#+2
   \   00000320   0xDB04             BLT.N    ??UartSetConfig_24
   1110              {
   1111              	UartSetReceiverThreshold(UartNumber, gUART_RX_THRESHOLD_c);    	
   \   00000322   0x2101             MOVS     R1,#+1
   \   00000324   0x0020             MOVS     R0,R4
   \   00000326   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000328   0x.... 0x....      BL       UartSetReceiverThreshold
   1112              }
   1113          #endif
   1114              
   1115          #if (gUART_USE_TX_FIFO_d == TRUE)
   1116              /* get TX FIFO size */
   1117              {
   1118              	register uint8_t fifoSz = (uint8_t)((mUartModule[UartNumber].UartRegs->PFIFO >> 4 ) & gUART_RX_FIFO_MASK_c);    	
   \                     ??UartSetConfig_24: (+1)
   \   0000032C   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000330   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000332   0x2134             MOVS     R1,#+52
   \   00000334   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000338   0x6840             LDR      R0,[R0, #+4]
   \   0000033A   0x7C00             LDRB     R0,[R0, #+16]
   \   0000033C   0xF3C0 0x1002      UBFX     R0,R0,#+4,#+3
   1119              	fifoSz+=1;
   \   00000340   0x1C40             ADDS     R0,R0,#+1
   1120          
   1121              	while(fifoSz-->0)
   \                     ??UartSetConfig_25: (+1)
   \   00000342   0x0001             MOVS     R1,R0
   \   00000344   0x1E48             SUBS     R0,R1,#+1
   \   00000346   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000348   0x2900             CMP      R1,#+0
   \   0000034A   0xD011             BEQ.N    ??UartSetConfig_26
   1122              	{
   1123              		mUartModule[UartNumber].UartTxFifoSize = mUartModule[UartNumber].UartTxFifoSize << 1;    		
   \   0000034C   0x.... 0x....      LDR.W    R1,??DataTable8
   \   00000350   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000352   0x2234             MOVS     R2,#+52
   \   00000354   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000358   0xF891 0x1031      LDRB     R1,[R1, #+49]
   \   0000035C   0x0049             LSLS     R1,R1,#+1
   \   0000035E   0x.... 0x....      LDR.W    R2,??DataTable8
   \   00000362   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000364   0x2334             MOVS     R3,#+52
   \   00000366   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   0000036A   0xF882 0x1031      STRB     R1,[R2, #+49]
   \   0000036E   0xE7E8             B.N      ??UartSetConfig_25
   1124              	};    	
   1125              }    
   1126              
   1127              /* enable TX FIFO and set TX threshold, if FIFO is implemented by hardware */
   1128              if(mUartModule[UartNumber].UartTxFifoSize > 1)
   \                     ??UartSetConfig_26: (+1)
   \   00000370   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000374   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000376   0x2134             MOVS     R1,#+52
   \   00000378   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000037C   0xF890 0x0031      LDRB     R0,[R0, #+49]
   \   00000380   0x2802             CMP      R0,#+2
   \   00000382   0xDB04             BLT.N    ??UartSetConfig_27
   1129              {
   1130              	UartSetTransmitterThreshold(UartNumber, gUART_TX_THRESHOLD_c);    	
   \   00000384   0x2104             MOVS     R1,#+4
   \   00000386   0x0020             MOVS     R0,R4
   \   00000388   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000038A   0x.... 0x....      BL       UartSetTransmitterThreshold
   1131              }    
   1132          #endif
   1133          
   1134              /* setup the baud rate registers */
   1135              if(0 != pConfig->UartBaudRate) {
   \                     ??UartSetConfig_27: (+1)
   \   0000038E   0x6828             LDR      R0,[R5, #+0]
   \   00000390   0x2800             CMP      R0,#+0
   \   00000392   0xD05F             BEQ.N    ??UartSetConfig_28
   1136          
   1137                  mUartSBR = UartDivide( (mUartModule[UartNumber].UartPlatformClock * 1000), pConfig->UartBaudRate << 4);
   \   00000394   0x6828             LDR      R0,[R5, #+0]
   \   00000396   0x0101             LSLS     R1,R0,#+4
   \   00000398   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000039C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000039E   0x2234             MOVS     R2,#+52
   \   000003A0   0xFB02 0x0004      MLA      R0,R2,R4,R0
   \   000003A4   0x6A00             LDR      R0,[R0, #+32]
   \   000003A6   0xF44F 0x727A      MOV      R2,#+1000
   \   000003AA   0x4350             MULS     R0,R2,R0
   \   000003AC   0x.... 0x....      BL       UartDivide
   \   000003B0   0x0006             MOVS     R6,R0
   1138                  /* setup the baud rate registers BDH and BDL */
   1139                  mUartModule[UartNumber].UartRegs->BDH = 0x00;
   \   000003B2   0x2000             MOVS     R0,#+0
   \   000003B4   0x.... 0x....      LDR.W    R1,??DataTable8
   \   000003B8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000003BA   0x2234             MOVS     R2,#+52
   \   000003BC   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000003C0   0x6849             LDR      R1,[R1, #+4]
   \   000003C2   0x7008             STRB     R0,[R1, #+0]
   1140                  mUartModule[UartNumber].UartRegs->BDH |= (uint8_t)((mUartSBR >> 8) & gUART_BDH_MASK_c);
   \   000003C4   0x.... 0x....      LDR.W    R0,??DataTable8
   \   000003C8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000003CA   0x2134             MOVS     R1,#+52
   \   000003CC   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000003D0   0x6840             LDR      R0,[R0, #+4]
   \   000003D2   0x7800             LDRB     R0,[R0, #+0]
   \   000003D4   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000003D6   0x0A31             LSRS     R1,R6,#+8
   \   000003D8   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000003DC   0x4308             ORRS     R0,R1,R0
   \   000003DE   0x.... 0x....      LDR.W    R1,??DataTable8
   \   000003E2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000003E4   0x2234             MOVS     R2,#+52
   \   000003E6   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000003EA   0x6849             LDR      R1,[R1, #+4]
   \   000003EC   0x7008             STRB     R0,[R1, #+0]
   1141                  mUartModule[UartNumber].UartRegs->BDL = (uint8_t) (mUartSBR & gUART_BDL_MASK_c);
   \   000003EE   0x.... 0x....      LDR.W    R0,??DataTable8
   \   000003F2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000003F4   0x2134             MOVS     R1,#+52
   \   000003F6   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000003FA   0x6840             LDR      R0,[R0, #+4]
   \   000003FC   0x7046             STRB     R6,[R0, #+1]
   1142                  /* setup the baud rate fine adjust registers */
   1143                  mUartBRDF = UartDivide((mUartModule[UartNumber].UartPlatformClock * 100000), (pConfig->UartBaudRate<<4)) - (mUartSBR * 100);        
   \   000003FE   0x6828             LDR      R0,[R5, #+0]
   \   00000400   0x0101             LSLS     R1,R0,#+4
   \   00000402   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000406   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000408   0x2234             MOVS     R2,#+52
   \   0000040A   0xFB02 0x0004      MLA      R0,R2,R4,R0
   \   0000040E   0x6A00             LDR      R0,[R0, #+32]
   \   00000410   0x.... 0x....      LDR.W    R2,??DataTable28  ;; 0x186a0
   \   00000414   0x4350             MULS     R0,R2,R0
   \   00000416   0x.... 0x....      BL       UartDivide
   \   0000041A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000041C   0x2164             MOVS     R1,#+100
   \   0000041E   0xFB01 0x0016      MLS      R0,R1,R6,R0
   \   00000422   0x0007             MOVS     R7,R0
   1144                  mUartBRFA = UartDivide((mUartBRDF << 5), 100);
   \   00000424   0x2164             MOVS     R1,#+100
   \   00000426   0x0178             LSLS     R0,R7,#+5
   \   00000428   0x.... 0x....      BL       UartDivide
   \   0000042C   0x4680             MOV      R8,R0
   1145                  mUartModule[UartNumber].UartRegs->C4 |= (uint8_t)(mUartBRFA & gUART_BRFA_MASK_c); 
   \   0000042E   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000432   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000434   0x2134             MOVS     R1,#+52
   \   00000436   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000043A   0x6840             LDR      R0,[R0, #+4]
   \   0000043C   0x.... 0x....      LDR.W    R1,??DataTable8
   \   00000440   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000442   0x2234             MOVS     R2,#+52
   \   00000444   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000448   0x6849             LDR      R1,[R1, #+4]
   \   0000044A   0x7A89             LDRB     R1,[R1, #+10]
   \   0000044C   0xF018 0x021F      ANDS     R2,R8,#0x1F
   \   00000450   0x4311             ORRS     R1,R2,R1
   \   00000452   0x7281             STRB     R1,[R0, #+10]
   1146              }
   1147          
   1148              /* enable UART error(s) interrupts */
   1149              mUartModule[UartNumber].UartRegs->C3 |= (gUART_PARITY_ERROR_FLAG_c | gUART_FRAME_ERROR_FLAG_c | gUART_NOISE_FLAG_c | gUART_OVERRUN_FLAG_c);
   \                     ??UartSetConfig_28: (+1)
   \   00000454   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000458   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000045A   0x2134             MOVS     R1,#+52
   \   0000045C   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000460   0x6840             LDR      R0,[R0, #+4]
   \   00000462   0x.... 0x....      LDR.W    R1,??DataTable8
   \   00000466   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000468   0x2234             MOVS     R2,#+52
   \   0000046A   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000046E   0x6849             LDR      R1,[R1, #+4]
   \   00000470   0x7989             LDRB     R1,[R1, #+6]
   \   00000472   0xF051 0x010F      ORRS     R1,R1,#0xF
   \   00000476   0x7181             STRB     R1,[R0, #+6]
   1150          
   1151              /* enable UART transceiver */
   1152              mUartModule[UartNumber].UartRegs->C2 |=  (gUART_TX_EN_BIT_c | gUART_RX_EN_BIT_c);
   \   00000478   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000047C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000047E   0x2134             MOVS     R1,#+52
   \   00000480   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000484   0x6840             LDR      R0,[R0, #+4]
   \   00000486   0x.... 0x....      LDR.W    R1,??DataTable8
   \   0000048A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000048C   0x2234             MOVS     R2,#+52
   \   0000048E   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000492   0x6849             LDR      R1,[R1, #+4]
   \   00000494   0x78C9             LDRB     R1,[R1, #+3]
   \   00000496   0xF051 0x010C      ORRS     R1,R1,#0xC
   \   0000049A   0x70C1             STRB     R1,[R0, #+3]
   1153          
   1154              /* exit function without error */
   1155              return gUartErrNoError_c;
   \   0000049C   0x2000             MOVS     R0,#+0
   \                     ??UartSetConfig_1: (+1)
   \   0000049E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1156          }
   1157          
   1158          /******************************************************************************
   1159           * Name: UartGetConfig
   1160           * Description: get the configuration of the specified UART port
   1161           * Parameters: [IN]:  UartNumber - the UART port number to read the 
   1162           *                               configuration from
   1163           *             [OUT]: pConfig - pointer to UART configuration structure where
   1164           *                            the configuration data shall be placed                  
   1165           * Return: see definition of UartErr_t
   1166           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1167          static UartErr_t UartGetConfig
   1168          (
   1169              uint8_t UartNumber, 
   1170              UartConfig_t* pConfig
   1171          )
   1172          {
   \                     UartGetConfig: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   1173              /* check if the first parameter received is valid */
   1174              if (UartNumber >= gUART_HW_MODULES_AVAILABLE_c)
   \   00000002   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000004   0x2A04             CMP      R2,#+4
   \   00000006   0xDB01             BLT.N    ??UartGetConfig_0
   1175                  return gUartErrWrongUartNumber_c;
   \   00000008   0x200D             MOVS     R0,#+13
   \   0000000A   0xE059             B.N      ??UartGetConfig_1
   1176              /* check if the second parameter received is valid */
   1177              if (NULL == pConfig)
   \                     ??UartGetConfig_0: (+1)
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD101             BNE.N    ??UartGetConfig_2
   1178                  return gUartErrNullPointer_c;
   \   00000010   0x2006             MOVS     R0,#+6
   \   00000012   0xE055             B.N      ??UartGetConfig_1
   1179              /* check if UART has been opened */
   1180              if (!mUartModule[UartNumber].UartIsOpen)
   \                     ??UartGetConfig_2: (+1)
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000018   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001A   0x2334             MOVS     R3,#+52
   \   0000001C   0xFB03 0x0002      MLA      R0,R3,R2,R0
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x07C0             LSLS     R0,R0,#+31
   \   00000024   0xD401             BMI.N    ??UartGetConfig_3
   1181                  return gUartErrUartNotOpen_c;
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xE04A             B.N      ??UartGetConfig_1
   1182          
   1183              /* get parity - look for the PE and PT bits in UARTx_C1 register */
   1184              if (!(mUartModule[UartNumber].UartRegs->C1 & gUART_PARITY_EN_BIT_c))
   \                     ??UartGetConfig_3: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000002E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000030   0x2334             MOVS     R3,#+52
   \   00000032   0xFB03 0x0002      MLA      R0,R3,R2,R0
   \   00000036   0x6840             LDR      R0,[R0, #+4]
   \   00000038   0x7880             LDRB     R0,[R0, #+2]
   \   0000003A   0x0780             LSLS     R0,R0,#+30
   \   0000003C   0xD402             BMI.N    ??UartGetConfig_4
   1185              {
   1186                  pConfig->UartParity=gUartParityNone_c;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x7108             STRB     R0,[R1, #+4]
   \   00000042   0xE00E             B.N      ??UartGetConfig_5
   1187              }
   1188              else
   1189              {
   1190                  if (mUartModule[UartNumber].UartRegs->C1 & gUART_PARITY_EVEN_BIT_c)
   \                     ??UartGetConfig_4: (+1)
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000048   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000004A   0x2334             MOVS     R3,#+52
   \   0000004C   0xFB03 0x0002      MLA      R0,R3,R2,R0
   \   00000050   0x6840             LDR      R0,[R0, #+4]
   \   00000052   0x7880             LDRB     R0,[R0, #+2]
   \   00000054   0x07C0             LSLS     R0,R0,#+31
   \   00000056   0xD502             BPL.N    ??UartGetConfig_6
   1191                  {
   1192                      pConfig->UartParity=gUartParityEven_c;
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x7108             STRB     R0,[R1, #+4]
   \   0000005C   0xE001             B.N      ??UartGetConfig_5
   1193                  }
   1194                  else
   1195                  {
   1196                      pConfig->UartParity=gUartParityOdd_c;
   \                     ??UartGetConfig_6: (+1)
   \   0000005E   0x2002             MOVS     R0,#+2
   \   00000060   0x7108             STRB     R0,[R1, #+4]
   1197                  }       
   1198              }
   1199          
   1200              /* get the number of data bits - look for M bit in UARTx_C1 register */
   1201              if (mUartModule[UartNumber].UartRegs->C1 & gUART_DATA_BITS_BIT_c)
   \                     ??UartGetConfig_5: (+1)
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000066   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000068   0x2334             MOVS     R3,#+52
   \   0000006A   0xFB03 0x0002      MLA      R0,R3,R2,R0
   \   0000006E   0x6840             LDR      R0,[R0, #+4]
   \   00000070   0x7880             LDRB     R0,[R0, #+2]
   \   00000072   0x0700             LSLS     R0,R0,#+28
   \   00000074   0xD502             BPL.N    ??UartGetConfig_7
   1202                  pConfig->UartDataBits=gUart_9bits_c;
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x7148             STRB     R0,[R1, #+5]
   \   0000007A   0xE001             B.N      ??UartGetConfig_8
   1203              else
   1204                  pConfig->UartDataBits=gUart_8bits_c;
   \                     ??UartGetConfig_7: (+1)
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x7148             STRB     R0,[R1, #+5]
   1205          
   1206              /* get the flow control */
   1207              if((mUartModule[UartNumber].UartRegs->MODEM & (gUART_RXRTSE_BIT_c | gUART_TXCTSE_BIT_c)))
   \                     ??UartGetConfig_8: (+1)
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000084   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000086   0x2334             MOVS     R3,#+52
   \   00000088   0xFB03 0x0002      MLA      R0,R3,R2,R0
   \   0000008C   0x6840             LDR      R0,[R0, #+4]
   \   0000008E   0x7B40             LDRB     R0,[R0, #+13]
   \   00000090   0x2309             MOVS     R3,#+9
   \   00000092   0x4218             TST      R0,R3
   \   00000094   0xD011             BEQ.N    ??UartGetConfig_9
   1208              {
   1209                  pConfig->UartHWFlowCtrl = gFlowEnabled_c; /* HW flow control enabled */
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0x7188             STRB     R0,[R1, #+6]
   1210          
   1211                  if(mUartModule[UartNumber].UartRegs->MODEM & gUART_TXRTSPOL_BIT_c) 
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000009E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000A0   0x2334             MOVS     R3,#+52
   \   000000A2   0xFB03 0x0002      MLA      R0,R3,R2,R0
   \   000000A6   0x6840             LDR      R0,[R0, #+4]
   \   000000A8   0x7B40             LDRB     R0,[R0, #+13]
   \   000000AA   0x0740             LSLS     R0,R0,#+29
   \   000000AC   0xD502             BPL.N    ??UartGetConfig_10
   1212                  {
   1213                      pConfig->UartRTSActiveState = gRtsActiveHi_c;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0x71C8             STRB     R0,[R1, #+7]
   \   000000B2   0xE004             B.N      ??UartGetConfig_11
   1214                  } else 
   1215                  {
   1216                      pConfig->UartRTSActiveState = gRtsActiveLow_c;
   \                     ??UartGetConfig_10: (+1)
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x71C8             STRB     R0,[R1, #+7]
   \   000000B8   0xE001             B.N      ??UartGetConfig_11
   1217                  }       
   1218              }
   1219              else 
   1220              {
   1221                  pConfig->UartHWFlowCtrl = gNoFlowControl_c;  /* HW flow control disabled */
   \                     ??UartGetConfig_9: (+1)
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x7188             STRB     R0,[R1, #+6]
   1222              }
   1223          
   1224              /* exit function without error */
   1225              return gUartErrNoError_c;    
   \                     ??UartGetConfig_11: (+1)
   \   000000BE   0x2000             MOVS     R0,#+0
   \                     ??UartGetConfig_1: (+1)
   \   000000C0   0x4770             BX       LR               ;; return
   1226          }
   1227          
   1228          /******************************************************************************
   1229           * Name: UartSetReceiverThreshold
   1230           * Description: sets the receiver threshold
   1231           * Parameters: [IN]: UartNumber - the UART port number
   1232           *             [IN]: Threshold - the desired threshold
   1233           * Return: see definition of UartErr_t
   1234           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1235          static UartErr_t UartSetReceiverThreshold
   1236          (
   1237              uint8_t UartNumber,
   1238              uint8_t Threshold
   1239          )
   1240          {	
   \                     UartSetReceiverThreshold: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1241          #if (gUART_USE_RX_FIFO_d == FALSE)
   1242          	(void)UartNumber;
   1243          	(void)Threshold;
   1244              return gUartRXFIFONotInUse_c;
   1245          #else
   1246          
   1247              UartConfig_t UartCfg;
   1248          
   1249              UartGetConfig(UartNumber, &UartCfg);
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x.... 0x....      BL       UartGetConfig
   1250          
   1251              if (UartNumber >= gUART_HW_MODULES_AVAILABLE_c)
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2C04             CMP      R4,#+4
   \   00000016   0xDB01             BLT.N    ??UartSetReceiverThreshold_0
   1252                  return gUartErrWrongUartNumber_c;
   \   00000018   0x200D             MOVS     R0,#+13
   \   0000001A   0xE07B             B.N      ??UartSetReceiverThreshold_1
   1253               
   1254              if (Threshold > mUartModule[UartNumber].UartRxFifoSize)
   \                     ??UartSetReceiverThreshold_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x2134             MOVS     R1,#+52
   \   00000024   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000028   0xF890 0x0030      LDRB     R0,[R0, #+48]
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x42A8             CMP      R0,R5
   \   00000030   0xD201             BCS.N    ??UartSetReceiverThreshold_2
   1255                  return gUartErrInvalidThreshold_c;
   \   00000032   0x200C             MOVS     R0,#+12
   \   00000034   0xE06E             B.N      ??UartSetReceiverThreshold_1
   1256              
   1257              if (!mUartModule[UartNumber].UartIsOpen)
   \                     ??UartSetReceiverThreshold_2: (+1)
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000003A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003C   0x2134             MOVS     R1,#+52
   \   0000003E   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000042   0x7800             LDRB     R0,[R0, #+0]
   \   00000044   0x07C0             LSLS     R0,R0,#+31
   \   00000046   0xD401             BMI.N    ??UartSetReceiverThreshold_3
   1258                  return gUartErrUartNotOpen_c;
   \   00000048   0x2002             MOVS     R0,#+2
   \   0000004A   0xE063             B.N      ??UartSetReceiverThreshold_1
   1259              
   1260              if (mUartModule[UartNumber].UartReadOnGoing)
   \                     ??UartSetReceiverThreshold_3: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000050   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000052   0x2134             MOVS     R1,#+52
   \   00000054   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD001             BEQ.N    ??UartSetReceiverThreshold_4
   1261                  return gUartErrReadOngoing_c;
   \   00000062   0x2003             MOVS     R0,#+3
   \   00000064   0xE056             B.N      ??UartSetReceiverThreshold_1
   1262          
   1263              /* disable transceiver*/
   1264              mUartModule[UartNumber].UartRegs->C2 &= ~(gUART_TX_EN_BIT_c | gUART_RX_EN_BIT_c);     
   \                     ??UartSetReceiverThreshold_4: (+1)
   \   00000066   0x....             LDR.N    R0,??DataTable8
   \   00000068   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006A   0x2134             MOVS     R1,#+52
   \   0000006C   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000070   0x6840             LDR      R0,[R0, #+4]
   \   00000072   0x....             LDR.N    R1,??DataTable8
   \   00000074   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000076   0x2234             MOVS     R2,#+52
   \   00000078   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000007C   0x6849             LDR      R1,[R1, #+4]
   \   0000007E   0x78C9             LDRB     R1,[R1, #+3]
   \   00000080   0xF011 0x01F3      ANDS     R1,R1,#0xF3
   \   00000084   0x70C1             STRB     R1,[R0, #+3]
   1265              
   1266              /* enable RX FIFO */
   1267              mUartModule[UartNumber].UartRegs->PFIFO |= gUART_RX_FIFO_EN_BIT_c;
   \   00000086   0x....             LDR.N    R0,??DataTable8
   \   00000088   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000008A   0x2134             MOVS     R1,#+52
   \   0000008C   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000090   0x6840             LDR      R0,[R0, #+4]
   \   00000092   0x....             LDR.N    R1,??DataTable8
   \   00000094   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000096   0x2234             MOVS     R2,#+52
   \   00000098   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000009C   0x6849             LDR      R1,[R1, #+4]
   \   0000009E   0x7C09             LDRB     R1,[R1, #+16]
   \   000000A0   0xF051 0x0108      ORRS     R1,R1,#0x8
   \   000000A4   0x7401             STRB     R1,[R0, #+16]
   1268              
   1269              /* write the threshold to UART FIFO Receive Water-mark register */
   1270              mUartModule[UartNumber].UartRegs->RWFIFO = Threshold;
   \   000000A6   0x....             LDR.N    R0,??DataTable8
   \   000000A8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000AA   0x2134             MOVS     R1,#+52
   \   000000AC   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000000B0   0x6840             LDR      R0,[R0, #+4]
   \   000000B2   0x7545             STRB     R5,[R0, #+21]
   1271              
   1272              /* Flush the FIFOs */
   1273              mUartModule[UartNumber].UartRegs->CFIFO |= (gUART_TX_FIFO_FLUSH_c | gUART_RX_FIFO_FLUSH_c);
   \   000000B4   0x....             LDR.N    R0,??DataTable8
   \   000000B6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B8   0x2134             MOVS     R1,#+52
   \   000000BA   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000000BE   0x6840             LDR      R0,[R0, #+4]
   \   000000C0   0x....             LDR.N    R1,??DataTable8
   \   000000C2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C4   0x2234             MOVS     R2,#+52
   \   000000C6   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000CA   0x6849             LDR      R1,[R1, #+4]
   \   000000CC   0x7C49             LDRB     R1,[R1, #+17]
   \   000000CE   0xF051 0x01C0      ORRS     R1,R1,#0xC0
   \   000000D2   0x7441             STRB     R1,[R0, #+17]
   1274          
   1275              /* enable transceiver */    
   1276              mUartModule[UartNumber].UartRegs->C2 |= (gUART_TX_EN_BIT_c | gUART_RX_EN_BIT_c);
   \   000000D4   0x....             LDR.N    R0,??DataTable8
   \   000000D6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000D8   0x2134             MOVS     R1,#+52
   \   000000DA   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000000DE   0x6840             LDR      R0,[R0, #+4]
   \   000000E0   0x....             LDR.N    R1,??DataTable8
   \   000000E2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000E4   0x2234             MOVS     R2,#+52
   \   000000E6   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000EA   0x6849             LDR      R1,[R1, #+4]
   \   000000EC   0x78C9             LDRB     R1,[R1, #+3]
   \   000000EE   0xF051 0x010C      ORRS     R1,R1,#0xC
   \   000000F2   0x70C1             STRB     R1,[R0, #+3]
   1277          
   1278              /* memorize internally the value of the threshold */     
   1279              mUartModule[UartNumber].UartRxThreshold = Threshold;
   \   000000F4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000F6   0x....             LDR.N    R0,??DataTable8
   \   000000F8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000FA   0x2134             MOVS     R1,#+52
   \   000000FC   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000100   0x6800             LDR      R0,[R0, #+0]
   \   00000102   0xF365 0x200F      BFI      R0,R5,#+8,#+8
   \   00000106   0x....             LDR.N    R1,??DataTable8
   \   00000108   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000010A   0x2234             MOVS     R2,#+52
   \   0000010C   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000110   0x6008             STR      R0,[R1, #+0]
   1280          
   1281              /* exit function without error */
   1282              return gUartErrNoError_c;
   \   00000112   0x2000             MOVS     R0,#+0
   \                     ??UartSetReceiverThreshold_1: (+1)
   \   00000114   0xBD3E             POP      {R1-R5,PC}       ;; return
   1283          #endif
   1284          }
   1285          
   1286          /******************************************************************************
   1287           * Name: UartSetTransmitterThreshold
   1288           * Description: sets the transmitter threshold
   1289           * Parameters: [IN]: UartNumber - the UART port number
   1290           *             [IN]: Threshold - the desired threshold
   1291           * Return: see definition of UartErr_t
   1292           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1293          static UartErr_t UartSetTransmitterThreshold
   1294          (
   1295              uint8_t UartNumber,
   1296              uint8_t Threshold
   1297          )
   1298          {
   \                     UartSetTransmitterThreshold: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1299          #if (gUART_USE_TX_FIFO_d == FALSE)      
   1300              (void)UartNumber;
   1301              (void)Threshold;
   1302              return gUartTXFIFONotInUse_c;
   1303          #else
   1304          
   1305              UartConfig_t UartCfg;
   1306          
   1307              UartGetConfig(UartNumber, &UartCfg);
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x.... 0x....      BL       UartGetConfig
   1308              
   1309              if (UartNumber >= gUART_HW_MODULES_AVAILABLE_c) 
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2C04             CMP      R4,#+4
   \   00000016   0xDB01             BLT.N    ??UartSetTransmitterThreshold_0
   1310                  return gUartErrWrongUartNumber_c;
   \   00000018   0x200D             MOVS     R0,#+13
   \   0000001A   0xE078             B.N      ??UartSetTransmitterThreshold_1
   1311                  
   1312              if (Threshold > mUartModule[UartNumber].UartTxFifoSize)
   \                     ??UartSetTransmitterThreshold_0: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable8
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x2134             MOVS     R1,#+52
   \   00000022   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000026   0xF890 0x0031      LDRB     R0,[R0, #+49]
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x42A8             CMP      R0,R5
   \   0000002E   0xD201             BCS.N    ??UartSetTransmitterThreshold_2
   1313                  return gUartErrInvalidThreshold_c;
   \   00000030   0x200C             MOVS     R0,#+12
   \   00000032   0xE06C             B.N      ??UartSetTransmitterThreshold_1
   1314              
   1315              if (!mUartModule[UartNumber].UartIsOpen)
   \                     ??UartSetTransmitterThreshold_2: (+1)
   \   00000034   0x....             LDR.N    R0,??DataTable8
   \   00000036   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   0x2134             MOVS     R1,#+52
   \   0000003A   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000003E   0x7800             LDRB     R0,[R0, #+0]
   \   00000040   0x07C0             LSLS     R0,R0,#+31
   \   00000042   0xD401             BMI.N    ??UartSetTransmitterThreshold_3
   1316                  return gUartErrUartNotOpen_c;
   \   00000044   0x2002             MOVS     R0,#+2
   \   00000046   0xE062             B.N      ??UartSetTransmitterThreshold_1
   1317              
   1318              if (mUartModule[UartNumber].UartWriteOnGoing)
   \                     ??UartSetTransmitterThreshold_3: (+1)
   \   00000048   0x....             LDR.N    R0,??DataTable8
   \   0000004A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004C   0x2134             MOVS     R1,#+52
   \   0000004E   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD001             BEQ.N    ??UartSetTransmitterThreshold_4
   1319                  return gUartErrWriteOngoing_c;
   \   0000005C   0x2004             MOVS     R0,#+4
   \   0000005E   0xE056             B.N      ??UartSetTransmitterThreshold_1
   1320          
   1321              /* disable transceiver*/
   1322              mUartModule[UartNumber].UartRegs->C2 &= ~(gUART_TX_EN_BIT_c | gUART_RX_EN_BIT_c);   
   \                     ??UartSetTransmitterThreshold_4: (+1)
   \   00000060   0x....             LDR.N    R0,??DataTable8
   \   00000062   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000064   0x2134             MOVS     R1,#+52
   \   00000066   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000006A   0x6840             LDR      R0,[R0, #+4]
   \   0000006C   0x....             LDR.N    R1,??DataTable8
   \   0000006E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000070   0x2234             MOVS     R2,#+52
   \   00000072   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000076   0x6849             LDR      R1,[R1, #+4]
   \   00000078   0x78C9             LDRB     R1,[R1, #+3]
   \   0000007A   0xF011 0x01F3      ANDS     R1,R1,#0xF3
   \   0000007E   0x70C1             STRB     R1,[R0, #+3]
   1323              
   1324              /* enable TX FIFO */
   1325              mUartModule[UartNumber].UartRegs->PFIFO |= gUART_TX_FIFO_EN_BIT_c;
   \   00000080   0x....             LDR.N    R0,??DataTable8
   \   00000082   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000084   0x2134             MOVS     R1,#+52
   \   00000086   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000008A   0x6840             LDR      R0,[R0, #+4]
   \   0000008C   0x....             LDR.N    R1,??DataTable8
   \   0000008E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000090   0x2234             MOVS     R2,#+52
   \   00000092   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000096   0x6849             LDR      R1,[R1, #+4]
   \   00000098   0x7C09             LDRB     R1,[R1, #+16]
   \   0000009A   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   0000009E   0x7401             STRB     R1,[R0, #+16]
   1326          
   1327              /* write the threshold to UART FIFO Transmit Water-mark register */
   1328              mUartModule[UartNumber].UartRegs->TWFIFO = Threshold;
   \   000000A0   0x....             LDR.N    R0,??DataTable8
   \   000000A2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A4   0x2134             MOVS     R1,#+52
   \   000000A6   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000000AA   0x6840             LDR      R0,[R0, #+4]
   \   000000AC   0x74C5             STRB     R5,[R0, #+19]
   1329              
   1330              /* Flush the FIFOs */
   1331              mUartModule[UartNumber].UartRegs->CFIFO |= (gUART_TX_FIFO_FLUSH_c | gUART_RX_FIFO_FLUSH_c);
   \   000000AE   0x....             LDR.N    R0,??DataTable8
   \   000000B0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B2   0x2134             MOVS     R1,#+52
   \   000000B4   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000000B8   0x6840             LDR      R0,[R0, #+4]
   \   000000BA   0x....             LDR.N    R1,??DataTable8
   \   000000BC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BE   0x2234             MOVS     R2,#+52
   \   000000C0   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000C4   0x6849             LDR      R1,[R1, #+4]
   \   000000C6   0x7C49             LDRB     R1,[R1, #+17]
   \   000000C8   0xF051 0x01C0      ORRS     R1,R1,#0xC0
   \   000000CC   0x7441             STRB     R1,[R0, #+17]
   1332          
   1333              /* enable transceiver */
   1334              mUartModule[UartNumber].UartRegs->C2 |=  (gUART_TX_EN_BIT_c | gUART_RX_EN_BIT_c);
   \   000000CE   0x....             LDR.N    R0,??DataTable8
   \   000000D0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000D2   0x2134             MOVS     R1,#+52
   \   000000D4   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000000D8   0x6840             LDR      R0,[R0, #+4]
   \   000000DA   0x....             LDR.N    R1,??DataTable8
   \   000000DC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000DE   0x2234             MOVS     R2,#+52
   \   000000E0   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000E4   0x6849             LDR      R1,[R1, #+4]
   \   000000E6   0x78C9             LDRB     R1,[R1, #+3]
   \   000000E8   0xF051 0x010C      ORRS     R1,R1,#0xC
   \   000000EC   0x70C1             STRB     R1,[R0, #+3]
   1335          
   1336              /* memorize internally the value of the threshold */
   1337              mUartModule[UartNumber].UartTxThreshold = Threshold;
   \   000000EE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000F0   0x....             LDR.N    R0,??DataTable8
   \   000000F2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F4   0x2134             MOVS     R1,#+52
   \   000000F6   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000000FA   0x6800             LDR      R0,[R0, #+0]
   \   000000FC   0xF365 0x4017      BFI      R0,R5,#+16,#+8
   \   00000100   0x....             LDR.N    R1,??DataTable8
   \   00000102   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000104   0x2234             MOVS     R2,#+52
   \   00000106   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000010A   0x6008             STR      R0,[R1, #+0]
   1338          
   1339              /* exit function without error */
   1340              return gUartErrNoError_c;
   \   0000010C   0x2000             MOVS     R0,#+0
   \                     ??UartSetTransmitterThreshold_1: (+1)
   \   0000010E   0xBD3E             POP      {R1-R5,PC}       ;; return
   1341          #endif  
   1342          }
   1343          
   1344          /******************************************************************************
   1345           * Name: UartReadData
   1346           * Description: read data from the specified UART port
   1347           * Parameters: [IN]: UartNumber - the UART port number
   1348           *             [OUT]: pBuf - pointer to the buffer where the read data shall be 
   1349           *                         placed 
   1350           *             [IN]: NumberBytes - number of bytes to be read 
   1351           * Return: see definition of UartErr_t
   1352           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1353          static UartErr_t UartReadData
   1354          (
   1355              uint8_t UartNumber, 
   1356              uint8_t* pBuf,
   1357              uint16_t NumberBytes
   1358          )
   1359          {
   \                     UartReadData: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0003             MOVS     R3,R0
   1360              /* Variable used for clear the Rx hardware FIFO */
   1361              register uint8_t dummy;
   1362          
   1363              /* Check if the first parameter received is valid */ 
   1364              if (UartNumber >= gUART_HW_MODULES_AVAILABLE_c) 
   \   00000004   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000006   0x2B04             CMP      R3,#+4
   \   00000008   0xDB01             BLT.N    ??UartReadData_0
   1365                  return gUartErrWrongUartNumber_c;
   \   0000000A   0x200D             MOVS     R0,#+13
   \   0000000C   0xE0DE             B.N      ??UartReadData_1
   1366              
   1367              /* Check if the pointer received is not null */
   1368              if (NULL == pBuf)   
   \                     ??UartReadData_0: (+1)
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD101             BNE.N    ??UartReadData_2
   1369                  return gUartErrNullPointer_c;
   \   00000012   0x2006             MOVS     R0,#+6
   \   00000014   0xE0DA             B.N      ??UartReadData_1
   1370              
   1371              /* Check if the buffer length is not zero */
   1372              if (NumberBytes==0) 
   \                     ??UartReadData_2: (+1)
   \   00000016   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000018   0x2A00             CMP      R2,#+0
   \   0000001A   0xD101             BNE.N    ??UartReadData_3
   1373                  return gUartErrInvalidNrBytes_c;
   \   0000001C   0x2007             MOVS     R0,#+7
   \   0000001E   0xE0D5             B.N      ??UartReadData_1
   1374              
   1375              /* Check if UART has been opened */
   1376              if (!mUartModule[UartNumber].UartIsOpen)    
   \                     ??UartReadData_3: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000024   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000026   0x2534             MOVS     R5,#+52
   \   00000028   0xFB05 0x0003      MLA      R0,R5,R3,R0
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x07C0             LSLS     R0,R0,#+31
   \   00000030   0xD401             BMI.N    ??UartReadData_4
   1377                  return gUartErrUartNotOpen_c;
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0xE0CA             B.N      ??UartReadData_1
   1378              
   1379              /* Check if the read operation is ongoing  */
   1380              if (mUartModule[UartNumber].UartReadOnGoing)    
   \                     ??UartReadData_4: (+1)
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000003A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000003C   0x2534             MOVS     R5,#+52
   \   0000003E   0xFB05 0x0003      MLA      R0,R5,R3,R0
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD001             BEQ.N    ??UartReadData_5
   1381                  return gUartErrReadOngoing_c;
   \   0000004C   0x2003             MOVS     R0,#+3
   \   0000004E   0xE0BD             B.N      ??UartReadData_1
   1382              
   1383          
   1384              /* Set the read status */
   1385              mUartModule[UartNumber].UartRxStatus.UartReadStatus = gUartReadStatusComplete_c;
   \                     ??UartReadData_5: (+1)
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x.... 0x....      LDR.W    R5,??DataTable32
   \   00000056   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000058   0x2634             MOVS     R6,#+52
   \   0000005A   0xFB06 0x5503      MLA      R5,R6,R3,R5
   \   0000005E   0x7228             STRB     R0,[R5, #+8]
   1386              mUartModule[UartNumber].UartRxStatus.UartNumberBytesReceived = 0;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x.... 0x....      LDR.W    R5,??DataTable32
   \   00000066   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000068   0x2634             MOVS     R6,#+52
   \   0000006A   0xFB06 0x5503      MLA      R5,R6,R3,R5
   \   0000006E   0x8168             STRH     R0,[R5, #+10]
   1387              
   1388              /* Set the read error flags to false */
   1389              mUartModule[UartNumber].UartRxStatus.UartReadError.UartRecvOverrunError = FALSE;
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000074   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000076   0x2534             MOVS     R5,#+52
   \   00000078   0xFB05 0x0003      MLA      R0,R5,R3,R0
   \   0000007C   0x68C0             LDR      R0,[R0, #+12]
   \   0000007E   0x0840             LSRS     R0,R0,#+1
   \   00000080   0x0040             LSLS     R0,R0,#+1
   \   00000082   0x.... 0x....      LDR.W    R5,??DataTable32
   \   00000086   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000088   0x2634             MOVS     R6,#+52
   \   0000008A   0xFB06 0x5503      MLA      R5,R6,R3,R5
   \   0000008E   0x60E8             STR      R0,[R5, #+12]
   1390              mUartModule[UartNumber].UartRxStatus.UartReadError.UartParityError = FALSE;
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000094   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000096   0x2534             MOVS     R5,#+52
   \   00000098   0xFB05 0x0003      MLA      R0,R5,R3,R0
   \   0000009C   0x68C0             LDR      R0,[R0, #+12]
   \   0000009E   0xF030 0x0002      BICS     R0,R0,#0x2
   \   000000A2   0x.... 0x....      LDR.W    R5,??DataTable32
   \   000000A6   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000A8   0x2634             MOVS     R6,#+52
   \   000000AA   0xFB06 0x5503      MLA      R5,R6,R3,R5
   \   000000AE   0x60E8             STR      R0,[R5, #+12]
   1391              mUartModule[UartNumber].UartRxStatus.UartReadError.UartFrameError = FALSE;
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable32
   \   000000B4   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000B6   0x2534             MOVS     R5,#+52
   \   000000B8   0xFB05 0x0003      MLA      R0,R5,R3,R0
   \   000000BC   0x68C0             LDR      R0,[R0, #+12]
   \   000000BE   0xF030 0x0004      BICS     R0,R0,#0x4
   \   000000C2   0x.... 0x....      LDR.W    R5,??DataTable32
   \   000000C6   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000C8   0x2634             MOVS     R6,#+52
   \   000000CA   0xFB06 0x5503      MLA      R5,R6,R3,R5
   \   000000CE   0x60E8             STR      R0,[R5, #+12]
   1392              mUartModule[UartNumber].UartRxStatus.UartReadError.UartNoiseError = FALSE;
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable32
   \   000000D4   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000D6   0x2534             MOVS     R5,#+52
   \   000000D8   0xFB05 0x0003      MLA      R0,R5,R3,R0
   \   000000DC   0x68C0             LDR      R0,[R0, #+12]
   \   000000DE   0xF030 0x0008      BICS     R0,R0,#0x8
   \   000000E2   0x.... 0x....      LDR.W    R5,??DataTable32
   \   000000E6   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000E8   0x2634             MOVS     R6,#+52
   \   000000EA   0xFB06 0x5503      MLA      R5,R6,R3,R5
   \   000000EE   0x60E8             STR      R0,[R5, #+12]
   1393              
   1394              /* Set the internal variables */
   1395              mUartModule[UartNumber].pUartRxBuffer = pBuf;
   \   000000F0   0x.... 0x....      LDR.W    R0,??DataTable32
   \   000000F4   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000F6   0x2534             MOVS     R5,#+52
   \   000000F8   0xFB05 0x0003      MLA      R0,R5,R3,R0
   \   000000FC   0x6101             STR      R1,[R0, #+16]
   1396              mUartModule[UartNumber].UartNumberCharsToReceive = NumberBytes;
   \   000000FE   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000100   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000104   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000106   0x2534             MOVS     R5,#+52
   \   00000108   0xFB05 0x0003      MLA      R0,R5,R3,R0
   \   0000010C   0x6142             STR      R2,[R0, #+20]
   1397              
   1398              /* read ongoing */
   1399              mUartModule[UartNumber].UartReadOnGoing = TRUE; 
   \   0000010E   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000112   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000114   0x2534             MOVS     R5,#+52
   \   00000116   0xFB05 0x0003      MLA      R0,R5,R3,R0
   \   0000011A   0x6800             LDR      R0,[R0, #+0]
   \   0000011C   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000120   0x.... 0x....      LDR.W    R5,??DataTable32
   \   00000124   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000126   0x2634             MOVS     R6,#+52
   \   00000128   0xFB06 0x5503      MLA      R5,R6,R3,R5
   \   0000012C   0x6028             STR      R0,[R5, #+0]
   1400          
   1401              /* Read the status registers in order to clear the error flags */
   1402              dummy = mUartModule[UartNumber].UartRegs->S1;
   \   0000012E   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000132   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000134   0x2534             MOVS     R5,#+52
   \   00000136   0xFB05 0x0003      MLA      R0,R5,R3,R0
   \   0000013A   0x6840             LDR      R0,[R0, #+4]
   \   0000013C   0x7900             LDRB     R0,[R0, #+4]
   \   0000013E   0x0004             MOVS     R4,R0
   1403              dummy = mUartModule[UartNumber].UartRegs->D;    
   \   00000140   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000144   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000146   0x2534             MOVS     R5,#+52
   \   00000148   0xFB05 0x0003      MLA      R0,R5,R3,R0
   \   0000014C   0x6840             LDR      R0,[R0, #+4]
   \   0000014E   0x79C0             LDRB     R0,[R0, #+7]
   \   00000150   0x0004             MOVS     R4,R0
   1404              (void)dummy;
   1405          
   1406          #if gUART_USE_RX_FIFO_d     
   1407              /* flush the RX FIFO */
   1408              mUartModule[UartNumber].UartRegs->CFIFO |= gUART_RX_FIFO_FLUSH_c;  
   \   00000152   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000156   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000158   0x2534             MOVS     R5,#+52
   \   0000015A   0xFB05 0x0003      MLA      R0,R5,R3,R0
   \   0000015E   0x6840             LDR      R0,[R0, #+4]
   \   00000160   0x.... 0x....      LDR.W    R5,??DataTable32
   \   00000164   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000166   0x2634             MOVS     R6,#+52
   \   00000168   0xFB06 0x5503      MLA      R5,R6,R3,R5
   \   0000016C   0x686D             LDR      R5,[R5, #+4]
   \   0000016E   0x7C6D             LDRB     R5,[R5, #+17]
   \   00000170   0xF055 0x0540      ORRS     R5,R5,#0x40
   \   00000174   0x7445             STRB     R5,[R0, #+17]
   1409          #endif
   1410          
   1411              mUartModule[UartNumber].UartBufferLeadIndex = 0;
   \   00000176   0x2000             MOVS     R0,#+0
   \   00000178   0x.... 0x....      LDR.W    R5,??DataTable32
   \   0000017C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000017E   0x2634             MOVS     R6,#+52
   \   00000180   0xFB06 0x5503      MLA      R5,R6,R3,R5
   \   00000184   0x6268             STR      R0,[R5, #+36]
   1412              mUartModule[UartNumber].UartBufferTrailIndex = 0;
   \   00000186   0x2000             MOVS     R0,#+0
   \   00000188   0x.... 0x....      LDR.W    R5,??DataTable32
   \   0000018C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000018E   0x2634             MOVS     R6,#+52
   \   00000190   0xFB06 0x5503      MLA      R5,R6,R3,R5
   \   00000194   0x62A8             STR      R0,[R5, #+40]
   1413              mUartModule[UartNumber].UartUnreadBytesNumber = 0;
   \   00000196   0x2000             MOVS     R0,#+0
   \   00000198   0x.... 0x....      LDR.W    R5,??DataTable32
   \   0000019C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000019E   0x2634             MOVS     R6,#+52
   \   000001A0   0xFB06 0x5503      MLA      R5,R6,R3,R5
   \   000001A4   0x62E8             STR      R0,[R5, #+44]
   1414          
   1415              /* Enable the RX interrupt */
   1416              mUartModule[UartNumber].UartRegs->C2 |= gUART_RIE_BIT_c;
   \   000001A6   0x.... 0x....      LDR.W    R0,??DataTable32
   \   000001AA   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000001AC   0x2534             MOVS     R5,#+52
   \   000001AE   0xFB05 0x0003      MLA      R0,R5,R3,R0
   \   000001B2   0x6840             LDR      R0,[R0, #+4]
   \   000001B4   0x.... 0x....      LDR.W    R5,??DataTable32
   \   000001B8   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000001BA   0x2634             MOVS     R6,#+52
   \   000001BC   0xFB06 0x5503      MLA      R5,R6,R3,R5
   \   000001C0   0x686D             LDR      R5,[R5, #+4]
   \   000001C2   0x78ED             LDRB     R5,[R5, #+3]
   \   000001C4   0xF055 0x0520      ORRS     R5,R5,#0x20
   \   000001C8   0x70C5             STRB     R5,[R0, #+3]
   1417          
   1418              /* Exit function without error */
   1419              return gUartErrNoError_c;
   \   000001CA   0x2000             MOVS     R0,#+0
   \                     ??UartReadData_1: (+1)
   \   000001CC   0xBC70             POP      {R4-R6}
   \   000001CE   0x4770             BX       LR               ;; return
   1420          }
   1421          
   1422          /******************************************************************************
   1423           * Name: UartCancelReadData
   1424           * Description: cancels the read data operation
   1425           * Parameters: [IN]: UartNumber - the UART port number
   1426           * Return: see definition of UartErr_t
   1427           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1428          static UartErr_t UartCancelReadData
   1429          (
   1430              uint8_t UartNumber
   1431          )
   1432          {
   \                     UartCancelReadData: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1433               /*Check if the first parameter received is valid*/ 
   1434              if (UartNumber >= gUART_HW_MODULES_AVAILABLE_c) 
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C04             CMP      R4,#+4
   \   00000008   0xDB01             BLT.N    ??UartCancelReadData_0
   1435                  return gUartErrWrongUartNumber_c;
   \   0000000A   0x200D             MOVS     R0,#+13
   \   0000000C   0xE024             B.N      ??UartCancelReadData_1
   1436              
   1437              /* Check if UART has been opened */
   1438              if (!mUartModule[UartNumber].UartIsOpen)    
   \                     ??UartCancelReadData_0: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2134             MOVS     R1,#+52
   \   00000016   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x07C0             LSLS     R0,R0,#+31
   \   0000001E   0xD401             BMI.N    ??UartCancelReadData_2
   1439                  return gUartErrUartNotOpen_c;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xE019             B.N      ??UartCancelReadData_1
   1440              
   1441              /* Check if the read operation is ongoing  */
   1442              if (!mUartModule[UartNumber].UartReadOnGoing)   
   \                     ??UartCancelReadData_2: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x2134             MOVS     R1,#+52
   \   0000002C   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD101             BNE.N    ??UartCancelReadData_3
   1443                  return gUartErrNoError_c;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE00C             B.N      ??UartCancelReadData_1
   1444              
   1445              /* Set the status operation to canceled */
   1446              mUartModule[UartNumber].UartRxStatus.UartReadStatus = gUartReadStatusCanceled_c;
   \                     ??UartCancelReadData_3: (+1)
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable32
   \   00000044   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000046   0x2234             MOVS     R2,#+52
   \   00000048   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000004C   0x7208             STRB     R0,[R1, #+8]
   1447              
   1448              /*Call UartReadComplete */
   1449              UartReadComplete(UartNumber); 
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0x.... 0x....      BL       UartReadComplete
   1450              
   1451              /* Exit function without error */
   1452              return gUartErrNoError_c;
   \   00000056   0x2000             MOVS     R0,#+0
   \                     ??UartCancelReadData_1: (+1)
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
   1453          }
   1454          
   1455          /******************************************************************************
   1456           * Name: UartCancelWriteData
   1457           * Description: cancels the write data operation
   1458           * Parameters: [IN]: UartNumber - the UART port number
   1459           * Return: see definition of UartErr_t
   1460           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1461          static UartErr_t UartCancelWriteData
   1462          (
   1463              uint8_t UartNumber
   1464          )
   1465          {
   \                     UartCancelWriteData: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1466              /* check if the first parameter received is valid */ 
   1467              if (UartNumber >= gUART_HW_MODULES_AVAILABLE_c) 
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2904             CMP      R1,#+4
   \   00000006   0xDB01             BLT.N    ??UartCancelWriteData_0
   1468                  return gUartErrWrongUartNumber_c;
   \   00000008   0x200D             MOVS     R0,#+13
   \   0000000A   0xE021             B.N      ??UartCancelWriteData_1
   1469              
   1470              /* Check if UART has been opened */
   1471              if (!mUartModule[UartNumber].UartIsOpen)    
   \                     ??UartCancelWriteData_0: (+1)
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x2234             MOVS     R2,#+52
   \   00000014   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x07C0             LSLS     R0,R0,#+31
   \   0000001C   0xD401             BMI.N    ??UartCancelWriteData_2
   1472                  return gUartErrUartNotOpen_c;
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0xE016             B.N      ??UartCancelWriteData_1
   1473              
   1474              /* Check if the read operation is ongoing */ 
   1475              if (!mUartModule[UartNumber].UartWriteOnGoing)  
   \                     ??UartCancelWriteData_2: (+1)
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000026   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000028   0x2234             MOVS     R2,#+52
   \   0000002A   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD101             BNE.N    ??UartCancelWriteData_3
   1476                  return gUartErrNoError_c;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xE009             B.N      ??UartCancelWriteData_1
   1477              
   1478              /* set TX FIFO threshold to 0 in order for the next TX interrupt to be 
   1479              triggered when all the characters in FIFO had been sent*/
   1480              mUartModule[UartNumber].UartRegs->TWFIFO = 0;
   \                     ??UartCancelWriteData_3: (+1)
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000040   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000042   0x2234             MOVS     R2,#+52
   \   00000044   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000048   0x6840             LDR      R0,[R0, #+4]
   \   0000004A   0x2200             MOVS     R2,#+0
   \   0000004C   0x74C2             STRB     R2,[R0, #+19]
   1481                  
   1482              /* Exit function without error*/
   1483              return gUartErrNoError_c;
   \   0000004E   0x2000             MOVS     R0,#+0
   \                     ??UartCancelWriteData_1: (+1)
   \   00000050   0x4770             BX       LR               ;; return
   1484          }
   1485          
   1486          /******************************************************************************
   1487           * Name: UartGetStatus
   1488           * Description: gets the status of the specified UART port
   1489           * Parameters: [IN]: UartNumber - the UART port number
   1490           * Return: see definition of UartErr_t
   1491           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1492          static UartErr_t UartGetStatus
   1493          (
   1494              uint8_t UartNumber
   1495          )
   1496          {
   \                     UartGetStatus: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1497                  /* Check if the parameter received is valid  */
   1498              if (UartNumber >= gUART_HW_MODULES_AVAILABLE_c)     
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2904             CMP      R1,#+4
   \   00000006   0xDB01             BLT.N    ??UartGetStatus_0
   1499                  return gUartErrWrongUartNumber_c;
   \   00000008   0x200D             MOVS     R0,#+13
   \   0000000A   0xE025             B.N      ??UartGetStatus_1
   1500              
   1501              /* Check if UART has been opened */ 
   1502              if (!mUartModule[UartNumber].UartIsOpen)    
   \                     ??UartGetStatus_0: (+1)
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x2234             MOVS     R2,#+52
   \   00000014   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x07C0             LSLS     R0,R0,#+31
   \   0000001C   0xD401             BMI.N    ??UartGetStatus_2
   1503                  return gUartErrUartNotOpen_c;
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0xE01A             B.N      ??UartGetStatus_1
   1504              
   1505              /* Verify if the read is ongoing */
   1506              if(mUartModule[UartNumber].UartReadOnGoing) 
   \                     ??UartGetStatus_2: (+1)
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000026   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000028   0x2234             MOVS     R2,#+52
   \   0000002A   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD001             BEQ.N    ??UartGetStatus_3
   1507                  return gUartErrReadOngoing_c;
   \   00000038   0x2003             MOVS     R0,#+3
   \   0000003A   0xE00D             B.N      ??UartGetStatus_1
   1508              
   1509              /* Verify if the write is ongoing */ 
   1510              if(mUartModule[UartNumber].UartWriteOnGoing)    
   \                     ??UartGetStatus_3: (+1)
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000040   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000042   0x2234             MOVS     R2,#+52
   \   00000044   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD001             BEQ.N    ??UartGetStatus_4
   1511                  return gUartErrWriteOngoing_c;
   \   00000052   0x2004             MOVS     R0,#+4
   \   00000054   0xE000             B.N      ??UartGetStatus_1
   1512              
   1513              /* no error  */
   1514              return gUartErrNoError_c;
   \                     ??UartGetStatus_4: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \                     ??UartGetStatus_1: (+1)
   \   00000058   0x4770             BX       LR               ;; return
   1515          }
   1516          
   1517          /******************************************************************************
   1518           * Name: UartClose
   1519           * Description: closes the specified UART port
   1520           * Parameters: [IN] UartNumber - the UART port number
   1521           * Return: see definition of UartErr_t
   1522           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1523          static UartErr_t UartClose
   1524          (
   1525              uint8_t UartNumber
   1526          )
   1527          {
   \                     UartClose: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1528              /* Check if the parameter received is valid */ 
   1529              if (UartNumber >= gUART_HW_MODULES_AVAILABLE_c) 
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2904             CMP      R1,#+4
   \   00000006   0xDB01             BLT.N    ??UartClose_0
   1530                  return gUartErrWrongUartNumber_c;
   \   00000008   0x200D             MOVS     R0,#+13
   \   0000000A   0xE059             B.N      ??UartClose_1
   1531              
   1532              /* Check if UART has been opened */
   1533              if (mUartModule[UartNumber].UartIsOpen==FALSE)  
   \                     ??UartClose_0: (+1)
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x2234             MOVS     R2,#+52
   \   00000014   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x07C0             LSLS     R0,R0,#+31
   \   0000001C   0xD401             BMI.N    ??UartClose_2
   1534                  return gUartErrNoError_c;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE04E             B.N      ??UartClose_1
   1535              
   1536              /* Verify if the read is ongoing */ 
   1537              if(TRUE == mUartModule[UartNumber].UartReadOnGoing) 
   \                     ??UartClose_2: (+1)
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000026   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000028   0x2234             MOVS     R2,#+52
   \   0000002A   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD001             BEQ.N    ??UartClose_3
   1538                  return gUartErrReadOngoing_c;
   \   00000038   0x2003             MOVS     R0,#+3
   \   0000003A   0xE041             B.N      ??UartClose_1
   1539              
   1540              /* Verify if the write is ongoing */ 
   1541              if(mUartModule[UartNumber].UartWriteOnGoing)    
   \                     ??UartClose_3: (+1)
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000040   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000042   0x2234             MOVS     R2,#+52
   \   00000044   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD001             BEQ.N    ??UartClose_4
   1542                  return gUartErrWriteOngoing_c;
   \   00000052   0x2004             MOVS     R0,#+4
   \   00000054   0xE034             B.N      ??UartClose_1
   1543              
   1544              /* Disable UART interrupt enable flags */
   1545              mUartModule[UartNumber].UartRegs->C2 &= ~(gUART_TIE_BIT_c | gUART_RIE_BIT_c);
   \                     ??UartClose_4: (+1)
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000005A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000005C   0x2234             MOVS     R2,#+52
   \   0000005E   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000062   0x6840             LDR      R0,[R0, #+4]
   \   00000064   0x.... 0x....      LDR.W    R2,??DataTable32
   \   00000068   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006A   0x2334             MOVS     R3,#+52
   \   0000006C   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000070   0x6852             LDR      R2,[R2, #+4]
   \   00000072   0x78D2             LDRB     R2,[R2, #+3]
   \   00000074   0xF012 0x029F      ANDS     R2,R2,#0x9F
   \   00000078   0x70C2             STRB     R2,[R0, #+3]
   1546              /* Disable transceiver*/
   1547              mUartModule[UartNumber].UartRegs->C2 &= ~(gUART_TX_EN_BIT_c | gUART_RX_EN_BIT_c) ;
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000007E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000080   0x2234             MOVS     R2,#+52
   \   00000082   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000086   0x6840             LDR      R0,[R0, #+4]
   \   00000088   0x.... 0x....      LDR.W    R2,??DataTable32
   \   0000008C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008E   0x2334             MOVS     R3,#+52
   \   00000090   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000094   0x6852             LDR      R2,[R2, #+4]
   \   00000096   0x78D2             LDRB     R2,[R2, #+3]
   \   00000098   0xF012 0x02F3      ANDS     R2,R2,#0xF3
   \   0000009C   0x70C2             STRB     R2,[R0, #+3]
   1548              /* Clear the internal variable */ 
   1549              mUartModule[UartNumber].UartIsOpen = FALSE;
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable32
   \   000000A2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A4   0x2234             MOVS     R2,#+52
   \   000000A6   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0x0840             LSRS     R0,R0,#+1
   \   000000AE   0x0040             LSLS     R0,R0,#+1
   \   000000B0   0x.... 0x....      LDR.W    R2,??DataTable32
   \   000000B4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B6   0x2334             MOVS     R3,#+52
   \   000000B8   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   000000BC   0x6010             STR      R0,[R2, #+0]
   1550              /* Exit function with no error status */
   1551              return gUartErrNoError_c;
   \   000000BE   0x2000             MOVS     R0,#+0
   \                     ??UartClose_1: (+1)
   \   000000C0   0x4770             BX       LR               ;; return
   1552          }
   1553          
   1554          /******************************************************************************
   1555           * Name: UartGetByteFromRxBuffer
   1556           * Description: gets a byte from the HW RX buffer and appends it to RAM buffer
   1557           * Parameters: [IN] UartNumber - the UART port number
   1558           *             [OUT] pDst - pointer to the RAM buffer
   1559           * Return: TRUE/FALSE
   1560           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1561          static bool_t UartGetByteFromRxBuffer
   1562          (
   1563              uint8_t UartNumber, 
   1564              uint8_t *pDst
   1565          )
   1566          {
   \                     UartGetByteFromRxBuffer: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
   1567             UartModule_t *Module = &mUartModule[UartNumber];
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000008   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000A   0x2334             MOVS     R3,#+52
   \   0000000C   0xFB03 0x0302      MLA      R3,R3,R2,R0
   1568              
   1569              if(0 == Module->UartUnreadBytesNumber)
   \   00000010   0x6AD8             LDR      R0,[R3, #+44]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD101             BNE.N    ??UartGetByteFromRxBuffer_0
   1570              {
   1571                  return FALSE;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE06A             B.N      ??UartGetByteFromRxBuffer_1
   1572              }
   1573          
   1574              /* Disable the RX interrupt while the counter is updated */    
   1575              mUartModule[UartNumber].UartRegs->C2 &= ~gUART_RIE_BIT_c;
   \                     ??UartGetByteFromRxBuffer_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000001E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000020   0x2434             MOVS     R4,#+52
   \   00000022   0xFB04 0x0002      MLA      R0,R4,R2,R0
   \   00000026   0x6840             LDR      R0,[R0, #+4]
   \   00000028   0x.... 0x....      LDR.W    R4,??DataTable32
   \   0000002C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002E   0x2534             MOVS     R5,#+52
   \   00000030   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   00000034   0x6864             LDR      R4,[R4, #+4]
   \   00000036   0x78E4             LDRB     R4,[R4, #+3]
   \   00000038   0xF014 0x04DF      ANDS     R4,R4,#0xDF
   \   0000003C   0x70C4             STRB     R4,[R0, #+3]
   1576          
   1577              *pDst = mUartModule[UartNumber].pUartRxBuffer[mUartModule[UartNumber].UartBufferTrailIndex];
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000042   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000044   0x2434             MOVS     R4,#+52
   \   00000046   0xFB04 0x0002      MLA      R0,R4,R2,R0
   \   0000004A   0x6900             LDR      R0,[R0, #+16]
   \   0000004C   0x.... 0x....      LDR.W    R4,??DataTable32
   \   00000050   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000052   0x2534             MOVS     R5,#+52
   \   00000054   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   00000058   0x6AA4             LDR      R4,[R4, #+40]
   \   0000005A   0x5C20             LDRB     R0,[R4, R0]
   \   0000005C   0x7008             STRB     R0,[R1, #+0]
   1578              if (++mUartModule[UartNumber].UartBufferTrailIndex >= mUartModule[UartNumber].UartNumberCharsToReceive) 
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000062   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000064   0x2434             MOVS     R4,#+52
   \   00000066   0xFB04 0x0002      MLA      R0,R4,R2,R0
   \   0000006A   0x6A80             LDR      R0,[R0, #+40]
   \   0000006C   0x1C40             ADDS     R0,R0,#+1
   \   0000006E   0x.... 0x....      LDR.W    R4,??DataTable32
   \   00000072   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000074   0x2534             MOVS     R5,#+52
   \   00000076   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   0000007A   0x62A0             STR      R0,[R4, #+40]
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000080   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000082   0x2434             MOVS     R4,#+52
   \   00000084   0xFB04 0x0002      MLA      R0,R4,R2,R0
   \   00000088   0x6A80             LDR      R0,[R0, #+40]
   \   0000008A   0x.... 0x....      LDR.W    R4,??DataTable32
   \   0000008E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000090   0x2534             MOVS     R5,#+52
   \   00000092   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   00000096   0x6964             LDR      R4,[R4, #+20]
   \   00000098   0x42A0             CMP      R0,R4
   \   0000009A   0xD307             BCC.N    ??UartGetByteFromRxBuffer_2
   1579              {
   1580                  mUartModule[UartNumber].UartBufferTrailIndex = 0;
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x.... 0x....      LDR.W    R4,??DataTable32
   \   000000A2   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000A4   0x2534             MOVS     R5,#+52
   \   000000A6   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   000000AA   0x62A0             STR      R0,[R4, #+40]
   1581              }
   1582              --mUartModule[UartNumber].UartUnreadBytesNumber;  
   \                     ??UartGetByteFromRxBuffer_2: (+1)
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable32
   \   000000B0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000B2   0x2434             MOVS     R4,#+52
   \   000000B4   0xFB04 0x0002      MLA      R0,R4,R2,R0
   \   000000B8   0x6AC0             LDR      R0,[R0, #+44]
   \   000000BA   0x1E40             SUBS     R0,R0,#+1
   \   000000BC   0x.... 0x....      LDR.W    R4,??DataTable32
   \   000000C0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000C2   0x2534             MOVS     R5,#+52
   \   000000C4   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   000000C8   0x62E0             STR      R0,[R4, #+44]
   1583              
   1584          #if gUart1_Hw_Sw_FlowControl_d
   1585              if(gUart1_c == UartNumber)
   1586              {
   1587                  if (mUartModule[UartNumber].UartUnreadBytesNumber <= gUart1_RxFlowControlResume_d) 
   1588                  {
   1589                      Uart1_EnableFlow();
   1590                  } 
   1591              }
   1592          #endif
   1593          
   1594          #if gUart2_Hw_Sw_FlowControl_d
   1595              if(gUart2_c == UartNumber)
   1596              {
   1597                  if (mUartModule[UartNumber].UartUnreadBytesNumber <= gUart2_RxFlowControlResume_d) 
   1598                  {
   1599                      Uart2_EnableFlow();
   1600                  } 
   1601              }
   1602          #endif  
   1603                 
   1604              /* Enable the RX interrupt */   
   1605              mUartModule[UartNumber].UartRegs->C2 |= gUART_RIE_BIT_c;
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable32
   \   000000CE   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000D0   0x2434             MOVS     R4,#+52
   \   000000D2   0xFB04 0x0002      MLA      R0,R4,R2,R0
   \   000000D6   0x6840             LDR      R0,[R0, #+4]
   \   000000D8   0x.... 0x....      LDR.W    R4,??DataTable32
   \   000000DC   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000DE   0x2534             MOVS     R5,#+52
   \   000000E0   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   000000E4   0x6864             LDR      R4,[R4, #+4]
   \   000000E6   0x78E4             LDRB     R4,[R4, #+3]
   \   000000E8   0xF054 0x0420      ORRS     R4,R4,#0x20
   \   000000EC   0x70C4             STRB     R4,[R0, #+3]
   1606          
   1607              return TRUE;
   \   000000EE   0x2001             MOVS     R0,#+1
   \                     ??UartGetByteFromRxBuffer_1: (+1)
   \   000000F0   0xBC30             POP      {R4,R5}
   \   000000F2   0x4770             BX       LR               ;; return
   1608          }
   1609          
   1610          /******************************************************************************
   1611           * Name: UartOpenCloseTransceiver
   1612           * Description: opens or closes the UART transceiver
   1613           * Parameters: [IN] UartNumber - the UART port number
   1614           *             [IN] Pin - the bit in the control register that 
   1615           *                  enables/disables the transmiter and the receiver
   1616           *             [IN] Open - if TRUE, it opens the receiver/trasmitter; if FALSE
   1617           *                         it closes the receiver/transmiter
   1618           * Return: -
   1619           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1620          static void UartOpenCloseTransceiver
   1621          (
   1622              uint8_t UartNumber, 
   1623              uint8_t Pin, 
   1624              bool_t Open
   1625          )
   1626          {  
   \                     UartOpenCloseTransceiver: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   1627              if (Open)
   \   00000002   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD011             BEQ.N    ??UartOpenCloseTransceiver_0
   1628              {
   1629                  mUartModule[UartNumber].UartRegs->C2 |= Pin;
   \   00000008   0x.... 0x....      LDR.W    R3,??DataTable32
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2434             MOVS     R4,#+52
   \   00000010   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   00000014   0x685B             LDR      R3,[R3, #+4]
   \   00000016   0x.... 0x....      LDR.W    R4,??DataTable32
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x2534             MOVS     R5,#+52
   \   0000001E   0xFB05 0x4400      MLA      R4,R5,R0,R4
   \   00000022   0x6864             LDR      R4,[R4, #+4]
   \   00000024   0x78E4             LDRB     R4,[R4, #+3]
   \   00000026   0x430C             ORRS     R4,R1,R4
   \   00000028   0x70DC             STRB     R4,[R3, #+3]
   \   0000002A   0xE010             B.N      ??UartOpenCloseTransceiver_1
   1630              }
   1631              else
   1632              {
   1633                  mUartModule[UartNumber].UartRegs->C2 &= ~(uint32_t)Pin;
   \                     ??UartOpenCloseTransceiver_0: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R3,??DataTable32
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x2434             MOVS     R4,#+52
   \   00000034   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   00000038   0x685B             LDR      R3,[R3, #+4]
   \   0000003A   0x.... 0x....      LDR.W    R4,??DataTable32
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0x2534             MOVS     R5,#+52
   \   00000042   0xFB05 0x4400      MLA      R4,R5,R0,R4
   \   00000046   0x6864             LDR      R4,[R4, #+4]
   \   00000048   0x78E4             LDRB     R4,[R4, #+3]
   \   0000004A   0x438C             BICS     R4,R4,R1
   \   0000004C   0x70DC             STRB     R4,[R3, #+3]
   1634              }
   1635          }
   \                     ??UartOpenCloseTransceiver_1: (+1)
   \   0000004E   0xBC30             POP      {R4,R5}
   \   00000050   0x4770             BX       LR               ;; return
   1636          
   1637          /******************************************************************************
   1638           * Name: UartClearErrors
   1639           * Description: clears the UART receive errors
   1640           * Parameters: [IN] UartNumber - the UART port number
   1641           * Return: -
   1642           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1643          static void UartClearErrors
   1644          (
   1645              uint8_t UartNumber
   1646          )
   1647          {  
   \                     UartClearErrors: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1648              register uint8_t status;
   1649              status = mUartModule[UartNumber].UartRegs->S1;
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable32
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x2334             MOVS     R3,#+52
   \   0000000A   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000000E   0x6852             LDR      R2,[R2, #+4]
   \   00000010   0x7912             LDRB     R2,[R2, #+4]
   \   00000012   0x0011             MOVS     R1,R2
   1650              /* Check for errors */
   1651              if(status & (gUART_PARITY_ERROR_FLAG_c | gUART_FRAME_ERROR_FLAG_c | gUART_NOISE_FLAG_c | gUART_OVERRUN_FLAG_c))
   \   00000014   0x220F             MOVS     R2,#+15
   \   00000016   0x4211             TST      R1,R2
   \   00000018   0xD02C             BEQ.N    ??UartClearErrors_0
   1652              {
   1653                  /* dummy read to clear UART errors */
   1654                  status = mUartModule[UartNumber].UartRegs->D;
   \   0000001A   0x.... 0x....      LDR.W    R2,??DataTable32
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x2334             MOVS     R3,#+52
   \   00000022   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000026   0x6852             LDR      R2,[R2, #+4]
   \   00000028   0x79D2             LDRB     R2,[R2, #+7]
   \   0000002A   0x0011             MOVS     R1,R2
   1655                  
   1656          #if gUART_USE_RX_FIFO_d     
   1657              /* flush the RX FIFO */
   1658              mUartModule[UartNumber].UartRegs->CFIFO |= gUART_RX_FIFO_FLUSH_c;  
   \   0000002C   0x.... 0x....      LDR.W    R2,??DataTable32
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x2334             MOVS     R3,#+52
   \   00000034   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000038   0x6852             LDR      R2,[R2, #+4]
   \   0000003A   0x.... 0x....      LDR.W    R3,??DataTable32
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0x2434             MOVS     R4,#+52
   \   00000042   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   00000046   0x685B             LDR      R3,[R3, #+4]
   \   00000048   0x7C5B             LDRB     R3,[R3, #+17]
   \   0000004A   0xF053 0x0340      ORRS     R3,R3,#0x40
   \   0000004E   0x7453             STRB     R3,[R2, #+17]
   1659          #endif
   1660              
   1661          #if gUART_USE_TX_FIFO_d     
   1662              /* flush the TX FIFO */
   1663              mUartModule[UartNumber].UartRegs->CFIFO |= gUART_TX_FIFO_FLUSH_c;  
   \   00000050   0x.... 0x....      LDR.W    R2,??DataTable32
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0x2334             MOVS     R3,#+52
   \   00000058   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000005C   0x6852             LDR      R2,[R2, #+4]
   \   0000005E   0x.... 0x....      LDR.W    R3,??DataTable32
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000064   0x2434             MOVS     R4,#+52
   \   00000066   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   0000006A   0x685B             LDR      R3,[R3, #+4]
   \   0000006C   0x7C5B             LDRB     R3,[R3, #+17]
   \   0000006E   0xF053 0x0380      ORRS     R3,R3,#0x80
   \   00000072   0x7453             STRB     R3,[R2, #+17]
   1664          #endif
   1665              }
   1666          }
   \                     ??UartClearErrors_0: (+1)
   \   00000074   0xBC10             POP      {R4}
   \   00000076   0x4770             BX       LR               ;; return
   1667          
   1668          /******************************************************************************
   1669           * Name: UartExecPendingCallbacks
   1670           * Description: execute any pending UART transmit callbacks
   1671           * Parameters: [IN] UartNumber - the UART port number
   1672           * Return: -
   1673           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1674          static void UartExecPendingCallbacks
   1675          (
   1676                  uint8_t UartNumber
   1677          )
   1678          {   
   \                     UartExecPendingCallbacks: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1679          
   1680              uint8_t loopCnt;
   1681              
   1682          #if (gUart1_Enabled_d == TRUE)
   1683              if(UartNumber == gUart1_c)
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD127             BNE.N    ??UartExecPendingCallbacks_0
   1684              {
   1685                  for(loopCnt = 0; loopCnt < NumberOfElements(maSci1TxBufRefTable); loopCnt++ )
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0005             MOVS     R5,R0
   \                     ??UartExecPendingCallbacks_1: (+1)
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x2D03             CMP      R5,#+3
   \   00000012   0xD222             BCS.N    ??UartExecPendingCallbacks_0
   1686                  {
   1687                      if(maSci1TxBufLenTable[loopCnt] == 0 && (NULL != maSci1TxBufRefTable[loopCnt].pfCallBack) )
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x5C28             LDRB     R0,[R5, R0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD11A             BNE.N    ??UartExecPendingCallbacks_2
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable32_2
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   0000002A   0x6840             LDR      R0,[R0, #+4]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD012             BEQ.N    ??UartExecPendingCallbacks_2
   1688                      {
   1689                          /* Call callback with buffer info as parameter */
   1690                          (maSci1TxBufRefTable[loopCnt].pfCallBack)(maSci1TxBufRefTable[loopCnt].pBuf);
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable32_2
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0xF850 0x0035      LDR      R0,[R0, R5, LSL #+3]
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable32_2
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0xEB11 0x01C5      ADDS     R1,R1,R5, LSL #+3
   \   00000044   0x6849             LDR      R1,[R1, #+4]
   \   00000046   0x4788             BLX      R1
   1691                          /* reset the callback */
   1692                          maSci1TxBufRefTable[loopCnt].pfCallBack = NULL;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable32_2
   \   0000004E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000050   0xEB11 0x01C5      ADDS     R1,R1,R5, LSL #+3
   \   00000054   0x6048             STR      R0,[R1, #+4]
   1693                      }
   1694                  }
   \                     ??UartExecPendingCallbacks_2: (+1)
   \   00000056   0x1C6D             ADDS     R5,R5,#+1
   \   00000058   0xE7D9             B.N      ??UartExecPendingCallbacks_1
   1695              }
   1696          #endif //gUart1_Enabled_d
   1697              
   1698          #if (gUart2_Enabled_d == TRUE)        
   1699              if (UartNumber == gUart2_c)
   1700              {
   1701                  for(loopCnt = 0; loopCnt < NumberOfElements(maSci2TxBufRefTable); loopCnt++ )
   1702                  {
   1703                      if(maSci2TxBufLenTable[loopCnt] == 0 && (NULL != maSci2TxBufRefTable[loopCnt].pfCallBack) )
   1704                      {
   1705                          /*Call callback with buffer info as parameter*/
   1706                          (maSci2TxBufRefTable[loopCnt].pfCallBack)(maSci2TxBufRefTable[loopCnt].pBuf);
   1707                          /* reset the callback */
   1708                          maSci2TxBufRefTable[loopCnt].pfCallBack = NULL;
   1709                      }
   1710                  }
   1711              }
   1712          #endif //gUart2_Enabled_d
   1713          }
   \                     ??UartExecPendingCallbacks_0: (+1)
   \   0000005A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1714           
   1715          /*****************************************************************************
   1716          ******************************************************************************
   1717          * Public functions
   1718          ******************************************************************************
   1719          *****************************************************************************/
   1720          
   1721          /******************************************************************************
   1722           * Name: Uart_ModuleInit
   1723           * Description: Initialize the serial port(s) and module internal variables
   1724           * Parameters: -
   1725           * Return: -
   1726           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1727          void Uart_ModuleInit
   1728          (
   1729              void
   1730          ) 
   1731          {
   \                     Uart_ModuleInit: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   1732             uint8_t res, loopCnt;
   1733             UartConfig_t pConfig;    
   1734          
   1735          
   1736          /************************
   1737           ******** UART_1 ********
   1738           ************************/
   1739          #if gUart1_Enabled_d
   1740              
   1741              /* Initialize the UART peripheral base address */
   1742              mUartModule[gUart1_c].UartRegs = (UART_MemMapPtr)UartBaseAddress_c[gUart1_c];
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable32_3
   \   00000008   0x6840             LDR      R0,[R0, #+4]
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable32
   \   0000000E   0x6388             STR      R0,[R1, #+56]
   1743              
   1744              if(NULL == mUartModule[gUart1_c].UartRegs)
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000014   0x6B80             LDR      R0,[R0, #+56]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD056             BEQ.N    ??Uart_ModuleInit_0
   1745              	return;
   1746              
   1747              /* Enable system clock gating for UART_1 */
   1748              gUART_1_SIM_SCG_c |= (1 << gUART_1_SIM_SCG_BIT_c);
   \                     ??Uart_ModuleInit_1: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable32_4  ;; 0x40048034
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable32_4  ;; 0x40048034
   \   00000028   0x6008             STR      R0,[R1, #+0]
   1749                  
   1750              /* Enable clock gating for UART port in use */
   1751              gUART_1_PORT_SIM_SCG_c |= gUART_1_PORT_SIM_SGC_BIT_c;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable32_5  ;; 0x40048038
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable32_5  ;; 0x40048038
   \   00000038   0x6008             STR      R0,[R1, #+0]
   1752              /* Setup Port Control Register (PCR) for RX pin */
   1753              gUART_1_RX_PCR_c = PORT_PCR_MUX(gUART_1_MUX_c);
   \   0000003A   0xF44F 0x7040      MOV      R0,#+768
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable32_6  ;; 0x4004d004
   \   00000042   0x6008             STR      R0,[R1, #+0]
   1754              /* Setup Port Control Register (PCR) for TX pin */
   1755              gUART_1_TX_PCR_c = PORT_PCR_MUX(gUART_1_MUX_c);
   \   00000044   0xF44F 0x7040      MOV      R0,#+768
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable32_7  ;; 0x4004d000
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   1756          
   1757          #if (gUart1_Hw_Sw_FlowControl_d == TRUE)
   1758              /* Enable clock gating of the port used by CTS pin */
   1759              gUART_1_SW_CTS_SIM_SCG_c |= (1<<gUART_1_SW_CTS_SIM_SCG_BIT_c);
   1760              /* Setup Port Control Register (PCR) for CTS pin*/
   1761              gUART_1_SW_CTS_PCR_c = PORT_PCR_MUX(gUART_1_SW_CTS_MUX_c);  
   1762              
   1763              /* Enable clock gating of the port used by RTS pin */
   1764              gUART_1_SW_RTS_SIM_SCG_c |= (1<<gUART_1_SW_RTS_SIM_SCG_BIT_c);
   1765              /* Setup Port Control Register (PCR) for CTS pin*/
   1766              gUART_1_SW_RTS_PCR_c = PORT_PCR_MUX(gUART_1_SW_RTS_MUX_c);
   1767              
   1768              /* CTS set as input pin */
   1769              gUART_1_SW_CTS_PDDR_c &= ~gUART_1_SW_CTS_PIN_c;     
   1770              /* RTS set as output pin */
   1771              gUART_1_SW_RTS_PDDR_c |= gUART_1_SW_RTS_PIN_c; 
   1772          #endif
   1773              
   1774              /* Open the UART_1 port */               
   1775              res =  UartOpen(gUart1_c, gSystemClock_c * gMhzToKHzConvert_c);
   \   0000004E   0xF64B 0x3180      MOVW     R1,#+48000
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x.... 0x....      BL       UartOpen
   \   00000058   0x0004             MOVS     R4,R0
   1776              
   1777              /* Set UART_1 communication parameters */ 
   1778              pConfig.UartParity = gUART1_Parity_c;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1779              pConfig.UartDataBits = gUART1_DataBits_c;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xF88D 0x0005      STRB     R0,[SP, #+5]
   1780              pConfig.UartBaudRate = gUART1_Baudrate_c;
   \   00000066   0xF45F 0x30E1      MOVS     R0,#+115200
   \   0000006A   0x9000             STR      R0,[SP, #+0]
   1781              pConfig.UartHWFlowCtrl = gUart1_EnableHWFlowControl_c;   
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF88D 0x0006      STRB     R0,[SP, #+6]
   1782              pConfig.UartRTSActiveState = gUart1_RTS_ActiveState_c;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xF88D 0x0007      STRB     R0,[SP, #+7]
   1783              
   1784              /* Apply UART_1 configuration */    
   1785              res |= UartSetConfig(gUart1_c, &pConfig);  
   \   00000078   0xA900             ADD      R1,SP,#+0
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0x.... 0x....      BL       UartSetConfig
   \   00000080   0x4320             ORRS     R0,R0,R4
   \   00000082   0x0004             MOVS     R4,R0
   1786              
   1787              for(loopCnt = 0; loopCnt < gUart_TransmitBuffers_c; loopCnt++)
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x0005             MOVS     R5,R0
   \                     ??Uart_ModuleInit_2: (+1)
   \   00000088   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008A   0x2D03             CMP      R5,#+3
   \   0000008C   0xDA08             BGE.N    ??Uart_ModuleInit_3
   1788              {
   1789                  /* initialize TX callbacks to NULL */
   1790                  maSci1TxBufRefTable[loopCnt].pfCallBack = NULL;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x.... 0x....      LDR.W    R1,??DataTable32_2
   \   00000094   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000096   0xEB11 0x01C5      ADDS     R1,R1,R5, LSL #+3
   \   0000009A   0x6048             STR      R0,[R1, #+4]
   1791              }
   \   0000009C   0x1C6D             ADDS     R5,R5,#+1
   \   0000009E   0xE7F3             B.N      ??Uart_ModuleInit_2
   1792          
   1793              /* Enables the interrupts corresponding to UART_1 driver */      
   1794              NVIC_EnableIRQ(gUART_1_IRQ_NUM_c);
   \                     ??Uart_ModuleInit_3: (+1)
   \   000000A0   0x2021             MOVS     R0,#+33
   \   000000A2   0x.... 0x....      BL       NVIC_EnableIRQ
   1795              NVIC_SetPriority(gUART_1_IRQ_NUM_c, gUart1_InterruptPriority_c);
   \   000000A6   0x2109             MOVS     R1,#+9
   \   000000A8   0x2021             MOVS     R0,#+33
   \   000000AA   0x.... 0x....      BL       NVIC_SetPriority
   1796          
   1797              /* Enables the interrupts corresponding to UART_1 driver error */      
   1798              NVIC_EnableIRQ(gUART_1_ERR_IRQ_NUM_c);
   \   000000AE   0x2022             MOVS     R0,#+34
   \   000000B0   0x.... 0x....      BL       NVIC_EnableIRQ
   1799              NVIC_SetPriority(gUART_1_ERR_IRQ_NUM_c, gUart1_ErrInterruptPriority_c);
   \   000000B4   0x2108             MOVS     R1,#+8
   \   000000B6   0x2022             MOVS     R0,#+34
   \   000000B8   0x.... 0x....      BL       NVIC_SetPriority
   1800          
   1801              /* Enable reception */
   1802              UartReadData(gUart1_c, maSci1RxBuf, sizeof(maSci1RxBuf));
   \   000000BC   0x22FA             MOVS     R2,#+250
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable32_8
   \   000000C2   0x2001             MOVS     R0,#+1
   \   000000C4   0x.... 0x....      BL       UartReadData
   1803              
   1804          #endif /* gUart1_Enabled_d */
   1805              
   1806          
   1807          /************************
   1808           ******** UART_2 ********
   1809           ************************/
   1810          #if gUart2_Enabled_d
   1811              
   1812              /* Initialize the UART peripheral base address */
   1813              mUartModule[gUart2_c].UartRegs = UartBaseAddress_c[gUart2_c];
   1814              
   1815              if(NULL == mUartModule[gUart2_c].UartRegs)
   1816              	return;
   1817              
   1818              /* Enable system clock gating for UART_2 */
   1819              gUART_2_SIM_SCG_c |= (1 << gUART_2_SIM_SCG_BIT_c);       
   1820              
   1821              /* Enable clock gating for UART port in use */
   1822              gUART_2_PORT_SIM_SCG_c |= gUART_2_PORT_SIM_SGC_BIT_c;
   1823              /* Setup Port Control Register (PCR) for RX pin */
   1824              gUART_2_RX_PCR_c = PORT_PCR_MUX(gUART_2_MUX_c);
   1825              /* Setup Port Control Register (PCR) for TX pin*/
   1826              gUART_2_TX_PCR_c = PORT_PCR_MUX(gUART_2_MUX_c);
   1827              
   1828          #if (gUart2_Hw_Sw_FlowControl_d == TRUE)
   1829              /* Enable clock gating of the port used by CTS pin */
   1830              gUART_2_SW_CTS_SIM_SCG_c |= (1<<gUART_2_SW_CTS_SIM_SCG_BIT_c);
   1831              /* Setup Port Control Register (PCR) for CTS pin*/
   1832              gUART_2_SW_CTS_PCR_c = PORT_PCR_MUX(gUART_2_SW_CTS_MUX_c);  
   1833              
   1834              /* Enable clock gating of the port used by RTS pin */
   1835              gUART_2_SW_RTS_SIM_SCG_c |= (1<<gUART_2_SW_RTS_SIM_SCG_BIT_c);
   1836              /* Setup Port Control Register (PCR) for CTS pin*/
   1837              gUART_2_SW_RTS_PCR_c = PORT_PCR_MUX(gUART_2_SW_RTS_MUX_c);
   1838              
   1839              /* CTS set as input pin */
   1840              gUART_2_SW_CTS_PDDR_c &= ~gUART_2_SW_CTS_PIN_c;     
   1841              /* RTS set as output pin */
   1842              gUART_2_SW_RTS_PDDR_c |= gUART_2_SW_RTS_PIN_c;
   1843          #endif
   1844                      
   1845              /* Open the UART_2 port */            
   1846              res =  UartOpen(gUart2_c, gSystemClock_c * gMhzToKHzConvert_c);
   1847              
   1848              /* Set UART_2 communication parameters */ 
   1849              pConfig.UartParity = gUART2_Parity_c;
   1850              pConfig.UartDataBits = gUART2_DataBits_c;
   1851              pConfig.UartBaudRate = gUART2_Baudrate_c;
   1852              pConfig.UartHWFlowCtrl = gUart2_EnableHWFlowControl_c;   
   1853              pConfig.UartRTSActiveState = gUart2_RTS_ActiveState_c;
   1854              
   1855              /* Apply UART_2 configuration */ 
   1856              res |= UartSetConfig(gUart2_c, &pConfig);
   1857          
   1858              for(loopCnt = 0; loopCnt < gUart_TransmitBuffers_c; loopCnt++)
   1859              {
   1860                  /* initialize TX callbacks to NULL */
   1861                  maSci2TxBufRefTable[loopCnt].pfCallBack = NULL;
   1862              }
   1863          
   1864              /* Enables the interrupts corresponding to UART_2 driver */      
   1865              NVIC_EnableIRQ(gUART_2_IRQ_NUM_c);
   1866              NVIC_SetPriority(gUART_2_IRQ_NUM_c, gUart2_InterruptPriority_c);
   1867          
   1868              /* Enables the interrupts corresponding to UART_2 driver error */      
   1869              NVIC_EnableIRQ(gUART_2_ERR_IRQ_NUM_c);
   1870              NVIC_SetPriority(gUART_2_ERR_IRQ_NUM_c, gUart2_ErrInterruptPriority_c);
   1871          
   1872              UartReadData(gUart2_c, maSci2RxBuf, sizeof(maSci2RxBuf));    
   1873          #endif /* gUart2_Enabled_d */
   1874          
   1875              /* Initialize the UART task */
   1876             // gUartTaskId = TS_CreateTask(gTsUartTaskPriority_c, Uart_Task);
   1877              
   1878              (void)res;
   1879          }
   \                     ??Uart_ModuleInit_0: (+1)
   \   000000C8   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
   1880          
   1881          /******************************************************************************
   1882           * Name: Uart_ModuleUninit
   1883           * Description: Shut down the serial port(s)
   1884           * Parameters: -
   1885           * Return: -
   1886           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1887          void Uart_ModuleUninit
   1888          (
   1889              void
   1890          )
   1891          {
   \                     Uart_ModuleUninit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1892          #if gUart1_Enabled_d
   1893              UartClose(gUart1_c);
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       UartClose
   1894          #endif /* gUart1_Enabled_d */
   1895          
   1896          #if gUart2_Enabled_d
   1897              UartClose(gUart2_c);
   1898          #endif /* gUart2_Enabled_d */
   1899          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   1900          
   1901          
   1902          /******************************************************************************
   1903           * Name: Uart_ClearErrors
   1904           * Description: Clear any error flags seen by the UART driver. In rare 
   1905           *              conditions, an error flag can be set without triggering an 
   1906           *              error interrupt, and will prevent Rx and/or Tx interrupts 
   1907           *              from occuring. The most likely cause is a breakpoint set 
   1908           *              during debugging, when a UART port is active.
   1909           *              Calling this function occasionaly allows the UART code 
   1910           *              to recover from these errors.
   1911           * Parameters: -
   1912           * Return: -
   1913           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1914          void Uart_ClearErrors
   1915          (
   1916              void
   1917          )
   1918          {
   \                     Uart_ClearErrors: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1919          #if gUart1_Enabled_d
   1920              UartClearErrors(gUart1_c);
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       UartClearErrors
   1921          #endif
   1922          
   1923          #if gUart2_Enabled_d
   1924              UartClearErrors(gUart2_c);
   1925          #endif
   1926          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   1927          
   1928          /******************************************************************************
   1929           * Name: Uart1_GetByteFromRxBuffer
   1930           * Description: Retrieve a byte from the driver's UART1 Rx buffer and store 
   1931           *              it at *pDst
   1932           * Parameters: [OUT] pDst - destination pointer
   1933           * Return: TRUE if a byte was retrieved / FALSE if the Rx buffer is empty
   1934           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1935          bool_t Uart1_GetByteFromRxBuffer
   1936          (
   1937              unsigned char *pDst
   1938          ) 
   1939          {
   \                     Uart1_GetByteFromRxBuffer: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1940          #if !gUart1_Enabled_d
   1941              (void) pDst;
   1942              return FALSE;
   1943          #else  
   1944              if (uart1_ungetFlag) 
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable32_9
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD009             BEQ.N    ??Uart1_GetByteFromRxBuffer_0
   1945              {
   1946                  uart1_ungetFlag = FALSE;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable32_9
   \   00000014   0x7008             STRB     R0,[R1, #+0]
   1947                  *pDst = uart1_ungetByte;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable32_10
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x7020             STRB     R0,[R4, #+0]
   1948                  return TRUE;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE003             B.N      ??Uart1_GetByteFromRxBuffer_1
   1949              } 
   1950              else
   1951              {  
   1952                  return UartGetByteFromRxBuffer(gUart1_c, pDst);
   \                     ??Uart1_GetByteFromRxBuffer_0: (+1)
   \   00000022   0x0021             MOVS     R1,R4
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x.... 0x....      BL       UartGetByteFromRxBuffer
   \                     ??Uart1_GetByteFromRxBuffer_1: (+1)
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
   1953              }
   1954          #endif
   1955          }
   1956          
   1957          /******************************************************************************
   1958           * Name: Uart2_GetByteFromRxBuffer
   1959           * Description: Retrieve a byte from the driver's UART2 Rx buffer and store 
   1960           *              it at *pDst
   1961           * Parameters: [OUT] pDst - destination pointer
   1962           * Return: TRUE if a byte was retrieved / FALSE if the Rx buffer is empty
   1963           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1964          bool_t Uart2_GetByteFromRxBuffer
   1965          (
   1966              unsigned char *pDst
   1967          ) 
   1968          {
   \                     Uart2_GetByteFromRxBuffer: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1969          #if !gUart2_Enabled_d
   1970              (void) pDst;
   1971              return 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
   1972          #else
   1973              if (uart2_ungetFlag)
   1974              {
   1975                  uart2_ungetFlag = FALSE;
   1976                  *pDst = uart2_ungetByte;
   1977                  return TRUE;
   1978              }
   1979              else
   1980              {
   1981                  return UartGetByteFromRxBuffer(gUart2_c, pDst);
   1982              }
   1983          #endif
   1984          }
   1985          
   1986          /******************************************************************************
   1987           * Name: Uart1_IsTxActive
   1988           * Description: checks if UART_1 trasmitter is active
   1989           * Parameters: -
   1990           * Return: TRUE if there is data still not sent
   1991           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1992          bool_t Uart1_IsTxActive
   1993          (
   1994              void
   1995          ) 
   1996          {
   1997          #if !gUart1_Enabled_d
   1998              return FALSE;
   1999          #else
   2000              
   2001          #if gUart1_Hw_Sw_FlowControl_d
   2002              bool_t status;
   2003          
   2004              status = (maSci1TxBufLenTable[mSci1TxBufRefTrailingIndex] != 0) || 
   2005              (!(mUartModule[gUart1_c].UartRegs->S1 & 0x40));
   2006          
   2007              if(TRUE == bUart1FlowConflict)
   2008              {
   2009              	pfSci1RxCallBack();
   2010              	if(0 == Uart1_FlowConflict())
   2011              	{
   2012              		bUart1FlowConflict = FALSE;
   2013              		if(status)
   2014              		{
   2015              			mUartModule[gUart1_c].UartRegs->C2 |= (gUART_TIE_BIT_c);
   2016              		}
   2017              	}
   2018              }
   2019              return status ;
   2020          #else     
   2021              return (maSci1TxBufLenTable[mSci1TxBufRefTrailingIndex] != 0) || 
   2022              (!(mUartModule[gUart1_c].UartRegs->S1 & 0x40));
   \                     Uart1_IsTxActive: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable32_11
   \   00000008   0x7809             LDRB     R1,[R1, #+0]
   \   0000000A   0x5C08             LDRB     R0,[R1, R0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD10A             BNE.N    ??Uart1_IsTxActive_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000014   0x6B80             LDR      R0,[R0, #+56]
   \   00000016   0x7900             LDRB     R0,[R0, #+4]
   \   00000018   0xF3C0 0x1080      UBFX     R0,R0,#+6,#+1
   \   0000001C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000020   0xF090 0x0001      EORS     R0,R0,#0x1
   \   00000024   0xE000             B.N      ??Uart1_IsTxActive_1
   \                     ??Uart1_IsTxActive_0: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \                     ??Uart1_IsTxActive_1: (+1)
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x4770             BX       LR               ;; return
   2023          #endif
   2024          #endif
   2025          }
   2026          
   2027          /******************************************************************************
   2028           * Name: Uart2_IsTxActive
   2029           * Description: checks if UART_1 trasmitter is active
   2030           * Parameters: -
   2031           * Return: TRUE if there is data still not sent
   2032           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2033          bool_t Uart2_IsTxActive
   2034          (
   2035              void
   2036          ) 
   2037          {
   2038          #if !gUart2_Enabled_d
   2039              return FALSE;
   \                     Uart2_IsTxActive: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
   2040          #else   
   2041          
   2042          #if gUart2_Hw_Sw_FlowControl_d
   2043              bool_t status;
   2044          
   2045              status = (maSci2TxBufLenTable[mSci2TxBufRefTrailingIndex] != 0) || 
   2046              (!(mUartModule[gUart2_c].UartRegs->S1 & 0x40));
   2047          
   2048              if(TRUE == bUart2FlowConflict)
   2049              {
   2050                  pfSci2RxCallBack();
   2051                  if(0 == Uart2_FlowConflict())
   2052                  {
   2053                      bUart2FlowConflict = FALSE;
   2054                      if(status)
   2055                      {
   2056                          mUartModule[gUart2_c].UartRegs->C2 |= (gUART_TIE_BIT_c);
   2057                      }
   2058                  }
   2059              }
   2060              return status ;
   2061          #else    
   2062              return (maSci2TxBufLenTable[mSci2TxBufRefTrailingIndex] != 0) || 
   2063              (!(mUartModule[gUart2_c].UartRegs->S1 & 0x40));
   2064          #endif
   2065          #endif
   2066          }
   2067          
   2068          /******************************************************************************
   2069           * Name: Uart_ModuleEnableLowPowerWakeup
   2070           * Description: Enables the Receive input active edge, RXEDGIF, to generate interrupt requests.
   2071           *              The receive input active edge detect circuit is still active on low power modes
   2072           *              (wait and stop). An active edge on the receive input brings the CPU out of low 
   2073           *              power mode if the interrupt is not masked.
   2074           * Parameters: -
   2075           * Return: -
   2076           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2077          void Uart_ModuleEnableLowPowerWakeup
   2078          (
   2079              void
   2080          )
   2081          {
   2082          #if (gUart1_Enabled_d == FALSE)
   2083          #else
   2084            mUartModule[gUart1_c].UartRegs->BDH   &= ~(UART_BDH_RXEDGIE_MASK);
   \                     Uart_ModuleEnableLowPowerWakeup: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000004   0x6B80             LDR      R0,[R0, #+56]
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable32
   \   00000010   0x6B89             LDR      R1,[R1, #+56]
   \   00000012   0x7008             STRB     R0,[R1, #+0]
   2085            mUartModule[gUart1_c].UartRegs->S2    &= ~(UART_S2_RXINV_MASK);
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000018   0x6B80             LDR      R0,[R0, #+56]
   \   0000001A   0x7940             LDRB     R0,[R0, #+5]
   \   0000001C   0xF010 0x00EF      ANDS     R0,R0,#0xEF
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable32
   \   00000024   0x6B89             LDR      R1,[R1, #+56]
   \   00000026   0x7148             STRB     R0,[R1, #+5]
   2086            mUartModule[gUart1_c].UartRegs->S2    |= UART_S2_RXEDGIF_MASK;
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000002C   0x6B80             LDR      R0,[R0, #+56]
   \   0000002E   0x7940             LDRB     R0,[R0, #+5]
   \   00000030   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable32
   \   00000038   0x6B89             LDR      R1,[R1, #+56]
   \   0000003A   0x7148             STRB     R0,[R1, #+5]
   2087            mUartModule[gUart1_c].UartRegs->BDH   |= UART_BDH_RXEDGIE_MASK;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000040   0x6B80             LDR      R0,[R0, #+56]
   \   00000042   0x7800             LDRB     R0,[R0, #+0]
   \   00000044   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable32
   \   0000004C   0x6B89             LDR      R1,[R1, #+56]
   \   0000004E   0x7008             STRB     R0,[R1, #+0]
   2088          #endif
   2089            
   2090          #if (gUart2_Enabled_d == FALSE)
   2091          #else
   2092            mUartModule[gUart2_c].UartRegs->BDH   &= ~(UART_BDH_RXEDGIE_MASK);
   2093            mUartModule[gUart2_c].UartRegs->S2    &= ~(UART_S2_RXINV_MASK);
   2094            mUartModule[gUart2_c].UartRegs->S2    |= UART_S2_RXEDGIF_MASK;
   2095            mUartModule[gUart2_c].UartRegs->BDH   |= UART_BDH_RXEDGIE_MASK;
   2096          #endif
   2097          }
   \   00000050   0x4770             BX       LR               ;; return
   2098          
   2099          /******************************************************************************
   2100           * Name: Uart_ModuleDisableLowPowerWakeup
   2101           * Description: Disables the Receive input active edge, RXEDGIF, to generate interrupt requests.
   2102           * Parameters: -
   2103           * Return: -
   2104           *****************************************************************************/
   2105          

   \                                 In section .text, align 2, keep-with-next
   2106          void Uart_ModuleDisableLowPowerWakeup
   2107          (
   2108              void
   2109          )
   2110          {
   2111          #if (gUart1_Enabled_d == FALSE)
   2112          #else
   2113            mUartModule[gUart1_c].UartRegs->BDH   &= ~(UART_BDH_RXEDGIE_MASK);
   \                     Uart_ModuleDisableLowPowerWakeup: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000004   0x6B80             LDR      R0,[R0, #+56]
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable32
   \   00000010   0x6B89             LDR      R1,[R1, #+56]
   \   00000012   0x7008             STRB     R0,[R1, #+0]
   2114            mUartModule[gUart1_c].UartRegs->S2    |= UART_S2_RXEDGIF_MASK;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000018   0x6B80             LDR      R0,[R0, #+56]
   \   0000001A   0x7940             LDRB     R0,[R0, #+5]
   \   0000001C   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable32
   \   00000024   0x6B89             LDR      R1,[R1, #+56]
   \   00000026   0x7148             STRB     R0,[R1, #+5]
   2115          #endif
   2116            
   2117          #if (gUart2_Enabled_d == FALSE)
   2118          #else
   2119            mUartModule[gUart2_c].UartRegs->BDH   &= ~(UART_BDH_RXEDGIE_MASK);
   2120            mUartModule[gUart2_c].UartRegs->S2    |= UART_S2_RXEDGIF_MASK;
   2121          #endif
   2122          }
   \   00000028   0x4770             BX       LR               ;; return
   2123          
   2124          /******************************************************************************
   2125           * Name: Uart_IsWakeUpSource
   2126           * Description: -
   2127           * Parameters: -
   2128           * Return: -
   2129           *****************************************************************************/
   2130          

   \                                 In section .text, align 2, keep-with-next
   2131          bool_t Uart_IsWakeUpSource
   2132          (
   2133              void
   2134          )
   2135          {
   \                     Uart_IsWakeUpSource: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   2136            bool_t res = FALSE;
   \   00000002   0x2400             MOVS     R4,#+0
   2137            uint32_t irqMaskRegister;
   2138            irqMaskRegister = IntDisableAll();
   \   00000004   0x.... 0x....      BL       IntDisableAll
   \   00000008   0x0005             MOVS     R5,R0
   2139            
   2140          #if (gUart1_Enabled_d == FALSE)
   2141          #else
   2142            if( ( mUartModule[gUart1_c].UartRegs->S2 & UART_S2_RXEDGIF_MASK ) == UART_S2_RXEDGIF_MASK )
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000000E   0x6B80             LDR      R0,[R0, #+56]
   \   00000010   0x7940             LDRB     R0,[R0, #+5]
   \   00000012   0x0640             LSLS     R0,R0,#+25
   \   00000014   0xD50B             BPL.N    ??Uart_IsWakeUpSource_0
   2143            {
   2144              mUartModule[gUart1_c].UartRegs->S2 |= UART_S2_RXEDGIF_MASK;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000001A   0x6B80             LDR      R0,[R0, #+56]
   \   0000001C   0x7940             LDRB     R0,[R0, #+5]
   \   0000001E   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable32
   \   00000026   0x6B89             LDR      R1,[R1, #+56]
   \   00000028   0x7148             STRB     R0,[R1, #+5]
   2145              res = TRUE;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x0004             MOVS     R4,R0
   2146            }
   2147          #endif
   2148            
   2149          #if (gUart2_Enabled_d == FALSE)
   2150          #else
   2151            if( ( mUartModule[gUart2_c].UartRegs->S2 & UART_S2_RXEDGIF_MASK ) == UART_S2_RXEDGIF_MASK )
   2152            {
   2153              mUartModule[gUart2_c].UartRegs->S2 |= UART_S2_RXEDGIF_MASK;
   2154              res = TRUE;
   2155            }
   2156          #endif
   2157            
   2158            IntRestoreAll(irqMaskRegister);
   \                     ??Uart_IsWakeUpSource_0: (+1)
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0x.... 0x....      BL       IntRestoreAll
   2159            return res;
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2160          }
   2161          
   2162          /******************************************************************************
   2163           * Name: Uart1_SetRxCallBack
   2164           * Description: Set the receive side callback function. This function will 
   2165           *              be called whenever a byte is received by the driver. 
   2166           *              The callback's bytesWaiting parameter is the number of bytes 
   2167           *              available in the driver's Rx buffer.
   2168           *              The callback function will be called in interrupt context, 
   2169           *              so it should be kept very short.
   2170           *              If the callback pointer is set to NULL, the Rx interrupt will 
   2171           *              be turned off, and all data in the driver's Rx buffer will be 
   2172           *              discarded.
   2173           * Parameters: [IN] pfCallBack - pointer to callback function
   2174           * Return: -
   2175           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2176          void Uart1_SetRxCallBack
   2177          (
   2178              void (*pfCallBack)(void)
   2179          )
   2180          {
   \                     Uart1_SetRxCallBack: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2181          #if (gUart1_Enabled_d == FALSE)
   2182              (void) pfCallBack;
   2183          #else
   2184              pfSci1RxCallBack = pfCallBack;
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable32_12
   \   00000008   0x6004             STR      R4,[R0, #+0]
   2185              UartOpenCloseTransceiver(gUart1_c, gUART_RX_EN_BIT_c, NULL != pfSci1RxCallBack);  
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable32_12
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD001             BEQ.N    ??Uart1_SetRxCallBack_0
   \   00000014   0x2201             MOVS     R2,#+1
   \   00000016   0xE000             B.N      ??Uart1_SetRxCallBack_1
   \                     ??Uart1_SetRxCallBack_0: (+1)
   \   00000018   0x2200             MOVS     R2,#+0
   \                     ??Uart1_SetRxCallBack_1: (+1)
   \   0000001A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001C   0x2104             MOVS     R1,#+4
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x.... 0x....      BL       UartOpenCloseTransceiver
   2186          #endif
   2187          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
   2188          
   2189          /******************************************************************************
   2190           * Name: Uart2_SetRxCallBack
   2191           * Description: Set the receive side callback function. This function will 
   2192           *              be called whenever a byte is received by the driver. 
   2193           *              The callback's bytesWaiting parameter is the number of bytes 
   2194           *              available in the driver's Rx buffer.
   2195           *              The callback function will be called in interrupt context, 
   2196           *              so it should be kept very short.
   2197           *              If the callback pointer is set to NULL, the Rx interrupt will 
   2198           *              be turned off, and all data in the driver's Rx buffer will be 
   2199           *              discarded.
   2200           * Parameters: [IN] pfCallBack - pointer to callback function
   2201           * Return: -
   2202           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2203          void Uart2_SetRxCallBack
   2204          (
   2205              void (*pfCallBack)(void)
   2206          ) 
   2207          {
   2208          #if (gUart2_Enabled_d == FALSE)
   2209              (void) pfCallBack;
   2210          #else
   2211              pfSci2RxCallBack = pfCallBack;  
   2212              UartOpenCloseTransceiver(gUart2_c, gUART_RX_EN_BIT_c, NULL != pfSci2RxCallBack);  
   2213          #endif
   2214          }
   \                     Uart2_SetRxCallBack: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2215          
   2216          /******************************************************************************
   2217           * Name: Uart1_SetBaud
   2218           * Description: Sets the UART_1 baud rate
   2219           * Parameters: [IN] baudRate - baudrate value (bps)
   2220           * Return: -
   2221           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2222          void Uart1_SetBaud
   2223          (
   2224              uint32_t baudRate
   2225          ) 
   2226          {  
   \                     Uart1_SetBaud: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   2227          #if (gUart1_Enabled_d == FALSE)
   2228              (void) baudRate;
   2229          #else  
   2230              UartConfig_t Cfg;
   2231              bool_t readStopped = FALSE;
   \   00000006   0x2500             MOVS     R5,#+0
   2232              register uint32_t i;
   2233              UartErr_t err;
   2234          
   2235              err = UartGetStatus(gUart1_c);  
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x.... 0x....      BL       UartGetStatus
   \   0000000E   0x0007             MOVS     R7,R0
   2236              if(err != gUartErrUartNotOpen_c)
   \   00000010   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000012   0x2F02             CMP      R7,#+2
   \   00000014   0xD01A             BEQ.N    ??Uart1_SetBaud_0
   2237              {  
   2238                  for (i = 0; i < 2; i++)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x0006             MOVS     R6,R0
   \                     ??Uart1_SetBaud_1: (+1)
   \   0000001A   0x2E02             CMP      R6,#+2
   \   0000001C   0xD216             BCS.N    ??Uart1_SetBaud_0
   2239                  {  
   2240                      if(err == gUartErrReadOngoing_c) 
   \   0000001E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000020   0x2F03             CMP      R7,#+3
   \   00000022   0xD105             BNE.N    ??Uart1_SetBaud_2
   2241                      {  
   2242                          UartCancelReadData(gUart1_c);
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x.... 0x....      BL       UartCancelReadData
   2243                          readStopped = TRUE;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x0005             MOVS     R5,R0
   \   0000002E   0xE007             B.N      ??Uart1_SetBaud_3
   2244                      }
   2245                      else
   2246                      {  
   2247                          if(err == gUartErrWriteOngoing_c)
   \                     ??Uart1_SetBaud_2: (+1)
   \   00000030   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000032   0x2F04             CMP      R7,#+4
   \   00000034   0xD103             BNE.N    ??Uart1_SetBaud_4
   2248                          {  
   2249                              UartCancelWriteData(gUart1_c);
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x.... 0x....      BL       UartCancelWriteData
   \   0000003C   0xE000             B.N      ??Uart1_SetBaud_3
   2250                          }  
   2251                          else
   2252                          {
   2253                              break;
   \                     ??Uart1_SetBaud_4: (+1)
   \   0000003E   0xE005             B.N      ??Uart1_SetBaud_0
   2254                          }
   2255                      }
   2256                      /* UartGetStatus is returning one error code at a time. Read back the status to check again */
   2257                      err = UartGetStatus(gUart1_c);
   \                     ??Uart1_SetBaud_3: (+1)
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x.... 0x....      BL       UartGetStatus
   \   00000046   0x0007             MOVS     R7,R0
   2258                  }
   \   00000048   0x1C76             ADDS     R6,R6,#+1
   \   0000004A   0xE7E6             B.N      ??Uart1_SetBaud_1
   2259              }
   2260              
   2261              UartGetConfig(gUart1_c, &Cfg);
   \                     ??Uart1_SetBaud_0: (+1)
   \   0000004C   0xA900             ADD      R1,SP,#+0
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0x.... 0x....      BL       UartGetConfig
   2262              Cfg.UartBaudRate = baudRate;
   \   00000054   0x9400             STR      R4,[SP, #+0]
   2263              UartSetConfig(gUart1_c, &Cfg);
   \   00000056   0xA900             ADD      R1,SP,#+0
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x.... 0x....      BL       UartSetConfig
   2264          
   2265              if(TRUE == readStopped)
   \   0000005E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000060   0x2D01             CMP      R5,#+1
   \   00000062   0xD104             BNE.N    ??Uart1_SetBaud_5
   2266              {
   2267                  UartReadData(gUart1_c, maSci1RxBuf, sizeof(maSci1RxBuf));
   \   00000064   0x22FA             MOVS     R2,#+250
   \   00000066   0x....             LDR.N    R1,??DataTable32_8
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0x.... 0x....      BL       UartReadData
   2268              }    
   2269          #endif
   2270          }
   \                     ??Uart1_SetBaud_5: (+1)
   \   0000006E   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
   2271          
   2272          /******************************************************************************
   2273           * Name: Uart2_SetBaud
   2274           * Description: Sets the UART_1 baud rate
   2275           * Parameters: [IN] baudRate - baudrate value (bps)
   2276           * Return: -
   2277           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2278          void Uart2_SetBaud
   2279          (
   2280              uint32_t baudRate
   2281          ) 
   2282          {
   2283          #if (gUart2_Enabled_d == FALSE)
   2284              (void) baudRate;
   2285          #else
   2286              UartConfig_t Cfg;
   2287              bool_t readStopped = FALSE;
   2288              register uint32_t i;
   2289          
   2290              UartErr_t err = UartGetStatus(gUart2_c);  
   2291              if(err != gUartErrUartNotOpen_c)
   2292              {  
   2293                  for (i = 0; i < 2; i++)
   2294                  {  
   2295                      if(err == gUartErrReadOngoing_c) 
   2296                      {  
   2297                          UartCancelReadData(gUart2_c);
   2298                          readStopped = TRUE;
   2299                      }
   2300                      else
   2301                      {  
   2302                          if(err == gUartErrWriteOngoing_c)
   2303                          {  
   2304                              UartCancelWriteData(gUart2_c);
   2305                          }  
   2306                          else
   2307                          {
   2308                              break;
   2309                          }
   2310                      }
   2311                      /* UartGetStatus is returning one error code at a time. Read back the status to check again */
   2312                      err = UartGetStatus(gUart2_c);
   2313                  }
   2314              }
   2315              
   2316          	UartGetConfig(gUart2_c, &Cfg);
   2317          	Cfg.UartBaudRate = baudRate;
   2318          	UartSetConfig(gUart2_c, &Cfg);
   2319          
   2320              if(TRUE == readStopped)
   2321              {
   2322                  UartReadData(gUart2_c, maSci2RxBuf, sizeof(maSci2RxBuf));
   2323              } 
   2324          #endif
   2325          }
   \                     Uart2_SetBaud: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2326          
   2327          /******************************************************************************
   2328           * Name: Uart1_Transmit
   2329           * Description: Transmit bufLen bytes of data from pBuffer over UART_1 port. 
   2330           *              It calls *pfCallBack() when the entire buffer has been sent. 
   2331           *              Returns FALSE if there are no more available Tx buffer slots, 
   2332           *              TRUE otherwise. The caller must ensure that the buffer remains
   2333           *              available until the call back function is called.
   2334           *              pfCallBack must not be NULL.
   2335           *              The callback function will be called in interrupt context, 
   2336           *              so it should be kept very short.
   2337           * Parameters: [IN] pBuf - pointer to the buffer to be transmitted
   2338           *             [IN] bufLen - buffer length
   2339           *             [IN] pfCallBack - pointer to the callback function
   2340           * Return: Returns FALSE if there are no more slots in the buffer reference 
   2341           *         table
   2342           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2343          bool_t Uart1_Transmit
   2344          (
   2345              unsigned char const *pBuf, 
   2346              index_t bufLen, 
   2347              void (*pfCallBack)(unsigned char const *pBuf)
   2348          ) 
   2349          {
   \                     Uart1_Transmit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   2350          #if (gUart1_Enabled_d == FALSE)
   2351              (void) pBuf;
   2352              (void) bufLen;
   2353              (void) pfCallBack;
   2354              return FALSE;
   2355          #else
   2356              /* Handle empty buffers */
   2357              if (!bufLen) 
   \   00000008   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD106             BNE.N    ??Uart1_Transmit_0
   2358              {
   2359              	if(pfCallBack)
   \   0000000E   0x0030             MOVS     R0,R6
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD001             BEQ.N    ??Uart1_Transmit_1
   2360              		(*pfCallBack)(pBuf);    		 
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x47B0             BLX      R6
   2361              	
   2362              	return TRUE;
   \                     ??Uart1_Transmit_1: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE045             B.N      ??Uart1_Transmit_2
   2363              }
   2364              
   2365              if (maSci1TxBufLenTable[mSci1TxBufRefLeadingIndex])
   \                     ??Uart1_Transmit_0: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable32_1
   \   0000001E   0x....             LDR.N    R1,??DataTable32_13
   \   00000020   0x7809             LDRB     R1,[R1, #+0]
   \   00000022   0x5C08             LDRB     R0,[R1, R0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD001             BEQ.N    ??Uart1_Transmit_3
   2366              	return FALSE;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE03D             B.N      ??Uart1_Transmit_2
   2367              
   2368              /* Room for one more */
   2369              
   2370              /* Handle the case when a previous message was transmitted but the callback was not yet executed. 
   2371               * The buffer length of the new message must be stored before executing the callback because
   2372               * the transmit function (this function) can be called again from that callback */
   2373                
   2374              maSci1TxBufLenTable[mSci1TxBufRefLeadingIndex] = bufLen;
   \                     ??Uart1_Transmit_3: (+1)
   \   0000002C   0x....             LDR.N    R0,??DataTable32_1
   \   0000002E   0x....             LDR.N    R1,??DataTable32_13
   \   00000030   0x7809             LDRB     R1,[R1, #+0]
   \   00000032   0x540D             STRB     R5,[R1, R0]
   2375              
   2376              if(maSci1TxBufRefTable[mSci1TxBufRefLeadingIndex].pfCallBack)
   \   00000034   0x....             LDR.N    R0,??DataTable32_2
   \   00000036   0x....             LDR.N    R1,??DataTable32_13
   \   00000038   0x7809             LDRB     R1,[R1, #+0]
   \   0000003A   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   0000003E   0x6840             LDR      R0,[R0, #+4]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD00B             BEQ.N    ??Uart1_Transmit_4
   2377              	maSci1TxBufRefTable[mSci1TxBufRefLeadingIndex].pfCallBack(maSci1TxBufRefTable[mSci1TxBufRefLeadingIndex].pBuf);
   \   00000044   0x....             LDR.N    R0,??DataTable32_2
   \   00000046   0x....             LDR.N    R1,??DataTable32_13
   \   00000048   0x7809             LDRB     R1,[R1, #+0]
   \   0000004A   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   0000004E   0x....             LDR.N    R1,??DataTable32_2
   \   00000050   0x....             LDR.N    R2,??DataTable32_13
   \   00000052   0x7812             LDRB     R2,[R2, #+0]
   \   00000054   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000058   0x6849             LDR      R1,[R1, #+4]
   \   0000005A   0x4788             BLX      R1
   2378          
   2379              /* store the new message to be transmitted */
   2380              maSci1TxBufRefTable[mSci1TxBufRefLeadingIndex].pBuf = pBuf;
   \                     ??Uart1_Transmit_4: (+1)
   \   0000005C   0x....             LDR.N    R0,??DataTable32_2
   \   0000005E   0x....             LDR.N    R1,??DataTable32_13
   \   00000060   0x7809             LDRB     R1,[R1, #+0]
   \   00000062   0xF840 0x4031      STR      R4,[R0, R1, LSL #+3]
   2381              maSci1TxBufRefTable[mSci1TxBufRefLeadingIndex].pfCallBack = pfCallBack;     
   \   00000066   0x....             LDR.N    R0,??DataTable32_2
   \   00000068   0x....             LDR.N    R1,??DataTable32_13
   \   0000006A   0x7809             LDRB     R1,[R1, #+0]
   \   0000006C   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000070   0x6046             STR      R6,[R0, #+4]
   2382              
   2383              if (++mSci1TxBufRefLeadingIndex >= NumberOfElements(maSci1TxBufRefTable)) 
   \   00000072   0x....             LDR.N    R0,??DataTable32_13
   \   00000074   0x7800             LDRB     R0,[R0, #+0]
   \   00000076   0x1C40             ADDS     R0,R0,#+1
   \   00000078   0x....             LDR.N    R1,??DataTable32_13
   \   0000007A   0x7008             STRB     R0,[R1, #+0]
   \   0000007C   0x....             LDR.N    R0,??DataTable32_13
   \   0000007E   0x7800             LDRB     R0,[R0, #+0]
   \   00000080   0x2803             CMP      R0,#+3
   \   00000082   0xD302             BCC.N    ??Uart1_Transmit_5
   2384              {
   2385              	mSci1TxBufRefLeadingIndex = 0;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x....             LDR.N    R1,??DataTable32_13
   \   00000088   0x7008             STRB     R0,[R1, #+0]
   2386              }
   2387          
   2388              /* Set the write ongoing flag */
   2389              mUartModule[gUart1_c].UartWriteOnGoing = TRUE;
   \                     ??Uart1_Transmit_5: (+1)
   \   0000008A   0x....             LDR.N    R0,??DataTable32
   \   0000008C   0x6B40             LDR      R0,[R0, #+52]
   \   0000008E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000092   0x....             LDR.N    R1,??DataTable32
   \   00000094   0x6348             STR      R0,[R1, #+52]
   2390              
   2391              /* 
   2392               * Enable the transmit interrupt. 
   2393               * Harmless if the interrupt is already enabled. 
   2394               */
   2395              mUartModule[gUart1_c].UartRegs->C2 |= gUART_TIE_BIT_c;
   \   00000096   0x....             LDR.N    R0,??DataTable32
   \   00000098   0x6B80             LDR      R0,[R0, #+56]
   \   0000009A   0x78C0             LDRB     R0,[R0, #+3]
   \   0000009C   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   000000A0   0x....             LDR.N    R1,??DataTable32
   \   000000A2   0x6B89             LDR      R1,[R1, #+56]
   \   000000A4   0x70C8             STRB     R0,[R1, #+3]
   2396                     
   2397              return TRUE;
   \   000000A6   0x2001             MOVS     R0,#+1
   \                     ??Uart1_Transmit_2: (+1)
   \   000000A8   0xBD70             POP      {R4-R6,PC}       ;; return
   2398          #endif /* gUart1_Enabled_d */
   2399          }
   2400          
   2401          /******************************************************************************
   2402           * Name: Uart2_Transmit
   2403           * Description: Transmit bufLen bytes of data from pBuffer over UART_2 port. 
   2404           *              It calls *pfCallBack() when the entire buffer has been sent. 
   2405           *              Returns FALSE if there are no more available Tx buffer slots, 
   2406           *              TRUE otherwise. The caller must ensure that the buffer remains
   2407           *              available until the call back function is called.
   2408           *              pfCallBack must not be NULL.
   2409           *              The callback function will be called in interrupt context, 
   2410           *              so it should be kept very short.
   2411           * Parameters: [IN] pBuf - pointer to the buffer to be transmitted
   2412           *             [IN] bufLen - buffer length
   2413           *             [IN] pfCallBack - pointer to the callback function
   2414           * Return: Returns FALSE if there are no more slots in the buffer reference 
   2415           *         table
   2416           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2417          bool_t Uart2_Transmit
   2418          (
   2419              unsigned char const *pBuf, 
   2420              index_t bufLen, 
   2421              void (*pfCallBack)(unsigned char const *pBuf)
   2422          )
   2423          {
   \                     Uart2_Transmit: (+1)
   \   00000000   0x0003             MOVS     R3,R0
   2424          #if (gUart2_Enabled_d == FALSE)
   2425              (void) pBuf;
   2426              (void) bufLen;
   2427              (void) pfCallBack;
   2428              return FALSE;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
   2429          #else
   2430          
   2431              /* Handle empty buffers */
   2432              if (!bufLen) 
   2433              {
   2434              	if(pfCallBack)    	
   2435              		(*pfCallBack)(pBuf);
   2436              		
   2437              	return TRUE;
   2438              }
   2439              
   2440              if (maSci2TxBufLenTable[mSci2TxBufRefLeadingIndex])
   2441              	return FALSE;
   2442              
   2443              /* Room for one more */
   2444              
   2445              /* Handle the case when a previous message was transmitted but the callback was not yet executed. 
   2446               * The buffer length of the new message must be stored before executing the callback because
   2447               * the transmit function (this function) can be called again from that callback */
   2448              
   2449              maSci2TxBufLenTable[mSci2TxBufRefLeadingIndex] = bufLen;
   2450                  
   2451              if(maSci2TxBufRefTable[mSci2TxBufRefLeadingIndex].pfCallBack)
   2452              	maSci2TxBufRefTable[mSci2TxBufRefLeadingIndex].pfCallBack(maSci2TxBufRefTable[mSci2TxBufRefLeadingIndex].pBuf);
   2453          
   2454              /* store the new message to be transmitted */
   2455              maSci2TxBufRefTable[mSci2TxBufRefLeadingIndex].pBuf = pBuf;
   2456              maSci2TxBufRefTable[mSci2TxBufRefLeadingIndex].pfCallBack = pfCallBack;     
   2457              
   2458          
   2459              if (++mSci2TxBufRefLeadingIndex >= NumberOfElements(maSci2TxBufRefTable)) 
   2460              {
   2461              	mSci2TxBufRefLeadingIndex = 0;
   2462              }
   2463          
   2464              /* Set the write ongoing flag */
   2465              mUartModule[gUart2_c].UartWriteOnGoing = TRUE;
   2466          
   2467              /* 
   2468               * Enable the transmit interrupt. 
   2469               * Harmless if the interrupt is already enabled. 
   2470               */
   2471              mUartModule[gUart2_c].UartRegs->C2 |= gUART_TIE_BIT_c; 
   2472             
   2473              return TRUE;
   2474          #endif  /* gUart2_Enabled_d */
   2475          }                                      
   2476          
   2477          /******************************************************************************
   2478           * Name: Uart1_UngetByte
   2479           * Description: Unget a byte: store the byte so that it will be returned by 
   2480           *              the next call to the get byte function. 
   2481           *              Also call the Rx callback
   2482           * Parameters: [IN] byte - the byte to be stored
   2483           * Return: -
   2484           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2485          void Uart1_UngetByte
   2486          (
   2487              unsigned char byte
   2488          ) 
   2489          {
   \                     Uart1_UngetByte: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2490          #if (gUart1_Enabled_d == FALSE)
   2491              (void) byte;
   2492          #else
   2493              uart1_ungetFlag = TRUE;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x....             LDR.N    R1,??DataTable32_9
   \   00000008   0x7008             STRB     R0,[R1, #+0]
   2494              uart1_ungetByte = byte;
   \   0000000A   0x....             LDR.N    R0,??DataTable32_10
   \   0000000C   0x7004             STRB     R4,[R0, #+0]
   2495          
   2496              /* Likewise, it is the caller's responsibility to not call this function */
   2497              /* if the callback pointer is not valid. */
   2498              if(pfSci1RxCallBack != NULL)
   \   0000000E   0x....             LDR.N    R0,??DataTable32_12
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD002             BEQ.N    ??Uart1_UngetByte_0
   2499              {  
   2500                  pfSci1RxCallBack();
   \   00000016   0x....             LDR.N    R0,??DataTable32_12
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x4780             BLX      R0
   2501              } 
   2502          #endif /* gUart1_Enabled_d */
   2503          }
   \                     ??Uart1_UngetByte_0: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
   2504          
   2505          
   2506          /******************************************************************************
   2507           * Name: Uart2_UngetByte
   2508           * Description: Unget a byte: store the byte so that it will be returned by 
   2509           *              the next call to the get byte function. 
   2510           *              Also call the Rx callback
   2511           * Parameters: [IN] byte - the byte to be stored
   2512           * Return: -
   2513           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2514          void Uart2_UngetByte
   2515          (
   2516              unsigned char byte
   2517          ) 
   2518          {
   2519          #if (gUart2_Enabled_d == FALSE)
   2520              (void) byte;
   2521          #else
   2522              uart2_ungetFlag = TRUE;
   2523              uart2_ungetByte = byte;
   2524          
   2525              /* Likewise, it is the caller's responsibility to not call this function */
   2526              /* if the callback pointer is not valid. */
   2527              if(pfSci2RxCallBack != NULL)
   2528              {  
   2529                  pfSci2RxCallBack();
   2530              } 
   2531          #endif  /* gUart2_Enabled_d */
   2532          }
   \                     Uart2_UngetByte: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2533          
   2534          /******************************************************************************
   2535           * Name: Uart1_RxBufferByteCount
   2536           * Description: Return unread bytes number from UART_1 buffer
   2537           * Parameters: -
   2538           * Return: the number of unread bytes 
   2539           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2540          uint32_t Uart1_RxBufferByteCount
   2541          (
   2542              void
   2543          ) 
   2544          {
   2545              return mUartModule[gUart1_c].UartUnreadBytesNumber;
   \                     Uart1_RxBufferByteCount: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable32
   \   00000002   0x6E00             LDR      R0,[R0, #+96]
   \   00000004   0x4770             BX       LR               ;; return
   2546          }
   2547          
   2548          /******************************************************************************
   2549           * Name: Uart2_RxBufferByteCount
   2550           * Description: Return unread bytes number from UART_2 buffer
   2551           * Parameters: -
   2552           * Return: the number of unread bytes 
   2553           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2554          uint32_t Uart2_RxBufferByteCount
   2555          (
   2556              void
   2557          ) 
   2558          {
   2559              	return mUartModule[gUart2_c].UartUnreadBytesNumber;
   \                     Uart2_RxBufferByteCount: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable32
   \   00000002   0xF8D0 0x0094      LDR      R0,[R0, #+148]
   \   00000006   0x4770             BX       LR               ;; return
   2560          }
   2561          
   2562          /******************************************************************************
   2563           * Name: Uart1Isr
   2564           * Description: UART_1 Interrupt Service Routine
   2565           * Parameters: -
   2566           * Return: -
   2567           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2568          void Uart1Isr
   2569          (
   2570              void
   2571          )
   2572          {
   \                     Uart1Isr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2573               /* Store the status register in an internal variable, because a read of this register clears all the error and interrupt flags */
   2574              mUartModule[gUart1_c].UartUstatRegister1 = mUartModule[gUart1_c].UartRegs->S1;
   \   00000002   0x....             LDR.N    R0,??DataTable32
   \   00000004   0x6B80             LDR      R0,[R0, #+56]
   \   00000006   0x7900             LDRB     R0,[R0, #+4]
   \   00000008   0x....             LDR.N    R1,??DataTable32
   \   0000000A   0x64C8             STR      R0,[R1, #+76]
   2575              mUartModule[gUart1_c].UartUstatRegister2 = mUartModule[gUart1_c].UartRegs->S2;
   \   0000000C   0x....             LDR.N    R0,??DataTable32
   \   0000000E   0x6B80             LDR      R0,[R0, #+56]
   \   00000010   0x7940             LDRB     R0,[R0, #+5]
   \   00000012   0x....             LDR.N    R1,??DataTable32
   \   00000014   0x6508             STR      R0,[R1, #+80]
   2576              if( (mUartModule[gUart1_c].UartUstatRegister2 & UART_S2_RXEDGIF_MASK) &&
   2577                  (mUartModule[gUart1_c].UartRegs->BDH & UART_BDH_RXEDGIE_MASK) )
   \   00000016   0x....             LDR.N    R0,??DataTable32
   \   00000018   0xF890 0x0050      LDRB     R0,[R0, #+80]
   \   0000001C   0x0640             LSLS     R0,R0,#+25
   \   0000001E   0xD50C             BPL.N    ??Uart1Isr_0
   \   00000020   0x....             LDR.N    R0,??DataTable32
   \   00000022   0x6B80             LDR      R0,[R0, #+56]
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x0640             LSLS     R0,R0,#+25
   \   00000028   0xD507             BPL.N    ??Uart1Isr_0
   2578              {
   2579                mUartModule[gUart1_c].UartRegs->S2 |= UART_S2_RXEDGIF_MASK;
   \   0000002A   0x....             LDR.N    R0,??DataTable32
   \   0000002C   0x6B80             LDR      R0,[R0, #+56]
   \   0000002E   0x7940             LDRB     R0,[R0, #+5]
   \   00000030   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000034   0x....             LDR.N    R1,??DataTable32
   \   00000036   0x6B89             LDR      R1,[R1, #+56]
   \   00000038   0x7148             STRB     R0,[R1, #+5]
   2580              }
   2581          
   2582              /*If Rx module is enabled and Rx interrupt pending flag is set and Rx interrupt is enabled */
   2583              if((mUartModule[gUart1_c].UartRegs->C2 & gUART_RX_EN_BIT_c) &&
   2584                      (mUartModule[gUart1_c].UartUstatRegister1 & gUART_RX_INT_BIT_c)  && 
   2585                      (mUartModule[gUart1_c].UartRegs->C2 & gUART_RIE_BIT_c))
   \                     ??Uart1Isr_0: (+1)
   \   0000003A   0x....             LDR.N    R0,??DataTable32
   \   0000003C   0x6B80             LDR      R0,[R0, #+56]
   \   0000003E   0x78C0             LDRB     R0,[R0, #+3]
   \   00000040   0x0740             LSLS     R0,R0,#+29
   \   00000042   0xD50C             BPL.N    ??Uart1Isr_1
   \   00000044   0x....             LDR.N    R0,??DataTable32
   \   00000046   0xF890 0x004C      LDRB     R0,[R0, #+76]
   \   0000004A   0x0680             LSLS     R0,R0,#+26
   \   0000004C   0xD507             BPL.N    ??Uart1Isr_1
   \   0000004E   0x....             LDR.N    R0,??DataTable32
   \   00000050   0x6B80             LDR      R0,[R0, #+56]
   \   00000052   0x78C0             LDRB     R0,[R0, #+3]
   \   00000054   0x0680             LSLS     R0,R0,#+26
   \   00000056   0xD502             BPL.N    ??Uart1Isr_1
   2586              {
   2587                  UartReceiverIsr(gUart1_c);
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x.... 0x....      BL       UartReceiverIsr
   2588              }
   2589              /*If Tx module is enabled and Tx interrupt pending flag is set and Tx interrupt is enabled */
   2590              if((mUartModule[gUart1_c].UartRegs->C2 & gUART_TX_EN_BIT_c) &&
   2591                      (mUartModule[gUart1_c].UartUstatRegister1 & gUART_TX_INT_BIT_c)  &&
   2592                      (mUartModule[gUart1_c].UartRegs->C2 & gUART_TIE_BIT_c))
   \                     ??Uart1Isr_1: (+1)
   \   0000005E   0x....             LDR.N    R0,??DataTable32
   \   00000060   0x6B80             LDR      R0,[R0, #+56]
   \   00000062   0x78C0             LDRB     R0,[R0, #+3]
   \   00000064   0x0700             LSLS     R0,R0,#+28
   \   00000066   0xD50C             BPL.N    ??Uart1Isr_2
   \   00000068   0x....             LDR.N    R0,??DataTable32
   \   0000006A   0xF890 0x004C      LDRB     R0,[R0, #+76]
   \   0000006E   0x0600             LSLS     R0,R0,#+24
   \   00000070   0xD507             BPL.N    ??Uart1Isr_2
   \   00000072   0x....             LDR.N    R0,??DataTable32
   \   00000074   0x6B80             LDR      R0,[R0, #+56]
   \   00000076   0x78C0             LDRB     R0,[R0, #+3]
   \   00000078   0x0640             LSLS     R0,R0,#+25
   \   0000007A   0xD502             BPL.N    ??Uart1Isr_2
   2593              {
   2594                  UartTransmitterIsr(gUart1_c);
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0x.... 0x....      BL       UartTransmitterIsr
   2595              }
   2596          }
   \                     ??Uart1Isr_2: (+1)
   \   00000082   0xBD01             POP      {R0,PC}          ;; return
   2597          
   2598          /******************************************************************************
   2599           * Name: Uart2Isr
   2600           * Description: UART_2 Interrupt Service Routine
   2601           * Parameters: -
   2602           * Return: -
   2603           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2604          void Uart2Isr
   2605          (
   2606              void
   2607          )
   2608          {
   \                     Uart2Isr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2609               /* Store the status register in an internal variable, because a read of this register clears all the error and interrupt flags */
   2610              mUartModule[gUart2_c].UartUstatRegister1 = mUartModule[gUart2_c].UartRegs->S1;
   \   00000002   0x....             LDR.N    R0,??DataTable32
   \   00000004   0x6EC0             LDR      R0,[R0, #+108]
   \   00000006   0x7900             LDRB     R0,[R0, #+4]
   \   00000008   0x....             LDR.N    R1,??DataTable32
   \   0000000A   0xF8C1 0x0080      STR      R0,[R1, #+128]
   2611              mUartModule[gUart2_c].UartUstatRegister2 = mUartModule[gUart2_c].UartRegs->S2;
   \   0000000E   0x....             LDR.N    R0,??DataTable32
   \   00000010   0x6EC0             LDR      R0,[R0, #+108]
   \   00000012   0x7940             LDRB     R0,[R0, #+5]
   \   00000014   0x....             LDR.N    R1,??DataTable32
   \   00000016   0xF8C1 0x0084      STR      R0,[R1, #+132]
   2612              if( (mUartModule[gUart2_c].UartUstatRegister2 & UART_S2_RXEDGIF_MASK) &&
   2613                  (mUartModule[gUart2_c].UartRegs->BDH & UART_BDH_RXEDGIE_MASK) )
   \   0000001A   0x....             LDR.N    R0,??DataTable32
   \   0000001C   0xF890 0x0084      LDRB     R0,[R0, #+132]
   \   00000020   0x0640             LSLS     R0,R0,#+25
   \   00000022   0xD50C             BPL.N    ??Uart2Isr_0
   \   00000024   0x....             LDR.N    R0,??DataTable32
   \   00000026   0x6EC0             LDR      R0,[R0, #+108]
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x0640             LSLS     R0,R0,#+25
   \   0000002C   0xD507             BPL.N    ??Uart2Isr_0
   2614              {
   2615                mUartModule[gUart2_c].UartRegs->S2 |= UART_S2_RXEDGIF_MASK;
   \   0000002E   0x....             LDR.N    R0,??DataTable32
   \   00000030   0x6EC0             LDR      R0,[R0, #+108]
   \   00000032   0x7940             LDRB     R0,[R0, #+5]
   \   00000034   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000038   0x....             LDR.N    R1,??DataTable32
   \   0000003A   0x6EC9             LDR      R1,[R1, #+108]
   \   0000003C   0x7148             STRB     R0,[R1, #+5]
   2616              }
   2617          
   2618              /* If Rx module is enabled and Rx interrupt pending flag is set and Rx interrupt is enabled */
   2619              if((mUartModule[gUart2_c].UartRegs->C2 & gUART_RX_EN_BIT_c) &&
   2620                      (mUartModule[gUart2_c].UartUstatRegister1 & gUART_RX_INT_BIT_c) && 
   2621                      (mUartModule[gUart2_c].UartRegs->C2 & gUART_RIE_BIT_c))
   \                     ??Uart2Isr_0: (+1)
   \   0000003E   0x....             LDR.N    R0,??DataTable32
   \   00000040   0x6EC0             LDR      R0,[R0, #+108]
   \   00000042   0x78C0             LDRB     R0,[R0, #+3]
   \   00000044   0x0740             LSLS     R0,R0,#+29
   \   00000046   0xD50C             BPL.N    ??Uart2Isr_1
   \   00000048   0x....             LDR.N    R0,??DataTable32
   \   0000004A   0xF890 0x0080      LDRB     R0,[R0, #+128]
   \   0000004E   0x0680             LSLS     R0,R0,#+26
   \   00000050   0xD507             BPL.N    ??Uart2Isr_1
   \   00000052   0x....             LDR.N    R0,??DataTable32
   \   00000054   0x6EC0             LDR      R0,[R0, #+108]
   \   00000056   0x78C0             LDRB     R0,[R0, #+3]
   \   00000058   0x0680             LSLS     R0,R0,#+26
   \   0000005A   0xD502             BPL.N    ??Uart2Isr_1
   2622              {                    
   2623                  UartReceiverIsr(gUart2_c);
   \   0000005C   0x2002             MOVS     R0,#+2
   \   0000005E   0x.... 0x....      BL       UartReceiverIsr
   2624              }
   2625              /* If Tx module is enabled and Tx interrupt pending flag is set and Tx interrupt is enabled*/
   2626              if((mUartModule[gUart2_c].UartRegs->C2 & gUART_TX_EN_BIT_c) &&
   2627                      (mUartModule[gUart2_c].UartUstatRegister1 & gUART_TX_INT_BIT_c) &&
   2628                      (mUartModule[gUart2_c].UartRegs->C2 & gUART_TIE_BIT_c))
   \                     ??Uart2Isr_1: (+1)
   \   00000062   0x....             LDR.N    R0,??DataTable32
   \   00000064   0x6EC0             LDR      R0,[R0, #+108]
   \   00000066   0x78C0             LDRB     R0,[R0, #+3]
   \   00000068   0x0700             LSLS     R0,R0,#+28
   \   0000006A   0xD50C             BPL.N    ??Uart2Isr_2
   \   0000006C   0x....             LDR.N    R0,??DataTable32
   \   0000006E   0xF890 0x0080      LDRB     R0,[R0, #+128]
   \   00000072   0x0600             LSLS     R0,R0,#+24
   \   00000074   0xD507             BPL.N    ??Uart2Isr_2
   \   00000076   0x....             LDR.N    R0,??DataTable32
   \   00000078   0x6EC0             LDR      R0,[R0, #+108]
   \   0000007A   0x78C0             LDRB     R0,[R0, #+3]
   \   0000007C   0x0640             LSLS     R0,R0,#+25
   \   0000007E   0xD502             BPL.N    ??Uart2Isr_2
   2629              {
   2630                  UartTransmitterIsr(gUart2_c);
   \   00000080   0x2002             MOVS     R0,#+2
   \   00000082   0x.... 0x....      BL       UartTransmitterIsr
   2631              }
   2632          }
   \                     ??Uart2Isr_2: (+1)
   \   00000086   0xBD01             POP      {R0,PC}          ;; return
   2633          
   2634          /******************************************************************************
   2635           * Name: Uart1ErrorIsr
   2636           * Description: Clear enabled UART_1 errors
   2637           * Parameters: -
   2638           * Return: -
   2639           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2640          void Uart1ErrorIsr
   2641          (
   2642              void
   2643          ) 
   2644          {
   2645          	/* Since the flag checking mechanism will clear any flags in a register
   2646          	 * that are set, we have to save the value of the status register
   2647          	 * and then check against the saved value to be able to detect all of
   2648          	 * the flags that were set (if you read the status register over and 
   2649          	 * over again, then you'll only capture the first one that was set.
   2650          	 */
   2651          
   2652          	uint8_t status, dummy;
   2653          
   2654          	status = mUartModule[gUart1_c].UartRegs->S1;
   \                     Uart1ErrorIsr: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable32
   \   00000002   0x6B92             LDR      R2,[R2, #+56]
   \   00000004   0x7912             LDRB     R2,[R2, #+4]
   \   00000006   0x0010             MOVS     R0,R2
   2655          
   2656          	if(status & (gUART_PARITY_ERROR_FLAG_c | gUART_FRAME_ERROR_FLAG_c | gUART_NOISE_FLAG_c | gUART_OVERRUN_FLAG_c))
   \   00000008   0x220F             MOVS     R2,#+15
   \   0000000A   0x4210             TST      R0,R2
   \   0000000C   0xD003             BEQ.N    ??Uart1ErrorIsr_0
   2657          	{
   2658          		/* dummy read to clear UART errors */
   2659          		dummy = mUartModule[gUart1_c].UartRegs->D;
   \   0000000E   0x....             LDR.N    R2,??DataTable32
   \   00000010   0x6B92             LDR      R2,[R2, #+56]
   \   00000012   0x79D2             LDRB     R2,[R2, #+7]
   \   00000014   0x0011             MOVS     R1,R2
   2660          	}
   2661          
   2662          	if (mUartModule[gUart1_c].UartRegs->SFIFO & (UART_SFIFO_TXOF_MASK))
   \                     ??Uart1ErrorIsr_0: (+1)
   \   00000016   0x....             LDR.N    R2,??DataTable32
   \   00000018   0x6B92             LDR      R2,[R2, #+56]
   \   0000001A   0x7C92             LDRB     R2,[R2, #+18]
   \   0000001C   0x0792             LSLS     R2,R2,#+30
   \   0000001E   0xD507             BPL.N    ??Uart1ErrorIsr_1
   2663          	{
   2664          		mUartModule[gUart1_c].UartRegs->SFIFO |= UART_SFIFO_TXOF_MASK;
   \   00000020   0x....             LDR.N    R2,??DataTable32
   \   00000022   0x6B92             LDR      R2,[R2, #+56]
   \   00000024   0x7C92             LDRB     R2,[R2, #+18]
   \   00000026   0xF052 0x0202      ORRS     R2,R2,#0x2
   \   0000002A   0x....             LDR.N    R3,??DataTable32
   \   0000002C   0x6B9B             LDR      R3,[R3, #+56]
   \   0000002E   0x749A             STRB     R2,[R3, #+18]
   2665          	}
   2666          
   2667          	if (mUartModule[gUart1_c].UartRegs->SFIFO & (UART_SFIFO_RXUF_MASK))
   \                     ??Uart1ErrorIsr_1: (+1)
   \   00000030   0x....             LDR.N    R2,??DataTable32
   \   00000032   0x6B92             LDR      R2,[R2, #+56]
   \   00000034   0x7C92             LDRB     R2,[R2, #+18]
   \   00000036   0x07D2             LSLS     R2,R2,#+31
   \   00000038   0xD507             BPL.N    ??Uart1ErrorIsr_2
   2668          	{    	
   2669          		mUartModule[gUart1_c].UartRegs->SFIFO |= UART_SFIFO_RXUF_MASK;    	
   \   0000003A   0x....             LDR.N    R2,??DataTable32
   \   0000003C   0x6B92             LDR      R2,[R2, #+56]
   \   0000003E   0x7C92             LDRB     R2,[R2, #+18]
   \   00000040   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   00000044   0x....             LDR.N    R3,??DataTable32
   \   00000046   0x6B9B             LDR      R3,[R3, #+56]
   \   00000048   0x749A             STRB     R2,[R3, #+18]
   2670          	}
   2671          	
   2672          #if gUART_USE_RX_FIFO_d     
   2673              /* flush the RX FIFO */
   2674              mUartModule[gUart1_c].UartRegs->CFIFO |= gUART_RX_FIFO_FLUSH_c;  
   \                     ??Uart1ErrorIsr_2: (+1)
   \   0000004A   0x....             LDR.N    R2,??DataTable32
   \   0000004C   0x6B92             LDR      R2,[R2, #+56]
   \   0000004E   0x7C52             LDRB     R2,[R2, #+17]
   \   00000050   0xF052 0x0240      ORRS     R2,R2,#0x40
   \   00000054   0x....             LDR.N    R3,??DataTable32
   \   00000056   0x6B9B             LDR      R3,[R3, #+56]
   \   00000058   0x745A             STRB     R2,[R3, #+17]
   2675          #endif
   2676              
   2677          #if gUART_USE_TX_FIFO_d     
   2678              /* flush the TX FIFO */
   2679              mUartModule[gUart1_c].UartRegs->CFIFO |= gUART_TX_FIFO_FLUSH_c;  
   \   0000005A   0x....             LDR.N    R2,??DataTable32
   \   0000005C   0x6B92             LDR      R2,[R2, #+56]
   \   0000005E   0x7C52             LDRB     R2,[R2, #+17]
   \   00000060   0xF052 0x0280      ORRS     R2,R2,#0x80
   \   00000064   0x....             LDR.N    R3,??DataTable32
   \   00000066   0x6B9B             LDR      R3,[R3, #+56]
   \   00000068   0x745A             STRB     R2,[R3, #+17]
   2680          #endif
   2681                  
   2682              (void)dummy;
   2683          }
   \   0000006A   0x4770             BX       LR               ;; return
   2684          
   2685          /******************************************************************************
   2686           * Name: Uart2ErrorIsr
   2687           * Description: Clear enabled UART_2 errors
   2688           * Parameters: -
   2689           * Return: -
   2690           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2691          void Uart2ErrorIsr
   2692          (
   2693              void
   2694          ) 
   2695          {	
   2696          	/* Since the flag checking mechanism will clear any flags in a register
   2697          	 * that are set, we have to save the value of the status register
   2698          	 * and then check against the saved value to be able to detect all of
   2699          	 * the flags that were set (if you read the status register over and 
   2700          	 * over again, then you'll only capture the first one that was set.
   2701          	 */
   2702              
   2703          	uint8_t status, dummy;
   2704          
   2705              status = mUartModule[gUart2_c].UartRegs->S1;
   \                     Uart2ErrorIsr: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable32
   \   00000002   0x6ED2             LDR      R2,[R2, #+108]
   \   00000004   0x7912             LDRB     R2,[R2, #+4]
   \   00000006   0x0010             MOVS     R0,R2
   2706             
   2707              if(status & (gUART_PARITY_ERROR_FLAG_c | gUART_FRAME_ERROR_FLAG_c | gUART_NOISE_FLAG_c | gUART_OVERRUN_FLAG_c))
   \   00000008   0x220F             MOVS     R2,#+15
   \   0000000A   0x4210             TST      R0,R2
   \   0000000C   0xD003             BEQ.N    ??Uart2ErrorIsr_0
   2708              {
   2709                  /* dummy read to clear UART errors */
   2710              	dummy = mUartModule[gUart2_c].UartRegs->D;
   \   0000000E   0x....             LDR.N    R2,??DataTable32
   \   00000010   0x6ED2             LDR      R2,[R2, #+108]
   \   00000012   0x79D2             LDRB     R2,[R2, #+7]
   \   00000014   0x0011             MOVS     R1,R2
   2711              }
   2712                      
   2713              if (mUartModule[gUart2_c].UartRegs->SFIFO & (UART_SFIFO_TXOF_MASK))
   \                     ??Uart2ErrorIsr_0: (+1)
   \   00000016   0x....             LDR.N    R2,??DataTable32
   \   00000018   0x6ED2             LDR      R2,[R2, #+108]
   \   0000001A   0x7C92             LDRB     R2,[R2, #+18]
   \   0000001C   0x0792             LSLS     R2,R2,#+30
   \   0000001E   0xD507             BPL.N    ??Uart2ErrorIsr_1
   2714              {
   2715              	mUartModule[gUart2_c].UartRegs->SFIFO |= UART_SFIFO_TXOF_MASK;
   \   00000020   0x....             LDR.N    R2,??DataTable32
   \   00000022   0x6ED2             LDR      R2,[R2, #+108]
   \   00000024   0x7C92             LDRB     R2,[R2, #+18]
   \   00000026   0xF052 0x0202      ORRS     R2,R2,#0x2
   \   0000002A   0x....             LDR.N    R3,??DataTable32
   \   0000002C   0x6EDB             LDR      R3,[R3, #+108]
   \   0000002E   0x749A             STRB     R2,[R3, #+18]
   2716              }
   2717              
   2718              if (mUartModule[gUart2_c].UartRegs->SFIFO & (UART_SFIFO_RXUF_MASK))
   \                     ??Uart2ErrorIsr_1: (+1)
   \   00000030   0x....             LDR.N    R2,??DataTable32
   \   00000032   0x6ED2             LDR      R2,[R2, #+108]
   \   00000034   0x7C92             LDRB     R2,[R2, #+18]
   \   00000036   0x07D2             LSLS     R2,R2,#+31
   \   00000038   0xD507             BPL.N    ??Uart2ErrorIsr_2
   2719              {    	
   2720              	mUartModule[gUart2_c].UartRegs->SFIFO |= UART_SFIFO_RXUF_MASK;    	
   \   0000003A   0x....             LDR.N    R2,??DataTable32
   \   0000003C   0x6ED2             LDR      R2,[R2, #+108]
   \   0000003E   0x7C92             LDRB     R2,[R2, #+18]
   \   00000040   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   00000044   0x....             LDR.N    R3,??DataTable32
   \   00000046   0x6EDB             LDR      R3,[R3, #+108]
   \   00000048   0x749A             STRB     R2,[R3, #+18]
   2721              }
   2722              
   2723          #if gUART_USE_RX_FIFO_d     
   2724              /* flush the RX FIFO */
   2725              mUartModule[gUart2_c].UartRegs->CFIFO |= gUART_RX_FIFO_FLUSH_c;  
   \                     ??Uart2ErrorIsr_2: (+1)
   \   0000004A   0x....             LDR.N    R2,??DataTable32
   \   0000004C   0x6ED2             LDR      R2,[R2, #+108]
   \   0000004E   0x7C52             LDRB     R2,[R2, #+17]
   \   00000050   0xF052 0x0240      ORRS     R2,R2,#0x40
   \   00000054   0x....             LDR.N    R3,??DataTable32
   \   00000056   0x6EDB             LDR      R3,[R3, #+108]
   \   00000058   0x745A             STRB     R2,[R3, #+17]
   2726          #endif
   2727              
   2728          #if gUART_USE_TX_FIFO_d     
   2729              /* flush the TX FIFO */
   2730              mUartModule[gUart2_c].UartRegs->CFIFO |= gUART_TX_FIFO_FLUSH_c;  
   \   0000005A   0x....             LDR.N    R2,??DataTable32
   \   0000005C   0x6ED2             LDR      R2,[R2, #+108]
   \   0000005E   0x7C52             LDRB     R2,[R2, #+17]
   \   00000060   0xF052 0x0280      ORRS     R2,R2,#0x80
   \   00000064   0x....             LDR.N    R3,??DataTable32
   \   00000066   0x6EDB             LDR      R3,[R3, #+108]
   \   00000068   0x745A             STRB     R2,[R3, #+17]
   2731          #endif
   2732              
   2733              (void)dummy;
   2734          }
   \   0000006A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     mUartModule

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     pfSci1RxCallBack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     maSci1TxBufRefTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     mSci1TxBufRefTrailingIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     mSci1TxCurIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     maSci1TxBufLenTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0x4004D00C         DC32     0x4004d00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \   00000000   0x4004D008         DC32     0x4004d008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \   00000000   0x4004D04C         DC32     0x4004d04c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x4004D048         DC32     0x4004d048

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0x000186A0         DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \   00000000   0x........         DC32     mUartModule

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_1:
   \   00000000   0x........         DC32     maSci1TxBufLenTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_2:
   \   00000000   0x........         DC32     maSci1TxBufRefTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_3:
   \   00000000   0x........         DC32     UartBaseAddress_c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_4:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_5:
   \   00000000   0x40048038         DC32     0x40048038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_6:
   \   00000000   0x4004D004         DC32     0x4004d004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_7:
   \   00000000   0x4004D000         DC32     0x4004d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_8:
   \   00000000   0x........         DC32     maSci1RxBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_9:
   \   00000000   0x........         DC32     uart1_ungetFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_10:
   \   00000000   0x........         DC32     uart1_ungetByte

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_11:
   \   00000000   0x........         DC32     mSci1TxBufRefTrailingIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_12:
   \   00000000   0x........         DC32     pfSci1RxCallBack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_13:
   \   00000000   0x........         DC32     mSci1TxBufRefLeadingIndex
   2735          
   2736          #endif /* gUart1_Enabled_d || gUart2_Enabled_d */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   Uart1ErrorIsr
       8   Uart1Isr
         8   -> UartReceiverIsr
         8   -> UartTransmitterIsr
       8   Uart1_GetByteFromRxBuffer
         8   -> UartGetByteFromRxBuffer
       0   Uart1_IsTxActive
       0   Uart1_RxBufferByteCount
      32   Uart1_SetBaud
        32   -> UartCancelReadData
        32   -> UartCancelWriteData
        32   -> UartGetConfig
        32   -> UartGetStatus
        32   -> UartReadData
        32   -> UartSetConfig
       8   Uart1_SetRxCallBack
         8   -> UartOpenCloseTransceiver
      16   Uart1_Transmit
        16   -- Indirect call
       8   Uart1_UngetByte
         8   -- Indirect call
       0   Uart2ErrorIsr
       8   Uart2Isr
         8   -> UartReceiverIsr
         8   -> UartTransmitterIsr
       0   Uart2_GetByteFromRxBuffer
       0   Uart2_IsTxActive
       0   Uart2_RxBufferByteCount
       0   Uart2_SetBaud
       0   Uart2_SetRxCallBack
       0   Uart2_Transmit
       0   Uart2_UngetByte
       8   UartCancelReadData
         8   -> UartReadComplete
       0   UartCancelWriteData
       4   UartClearErrors
       0   UartClose
       0   UartDivide
      16   UartExecPendingCallbacks
        16   -- Indirect call
       8   UartGetByteFromRxBuffer
       0   UartGetConfig
       0   UartGetStatus
       8   UartOpen
       8   UartOpenCloseTransceiver
       8   UartReadComplete
         8   -- Indirect call
      12   UartReadData
      16   UartReceiverIsr
        16   -- Indirect call
      24   UartSetConfig
        24   -> UartDivide
        24   -> UartSetReceiverThreshold
        24   -> UartSetTransmitterThreshold
      24   UartSetReceiverThreshold
        24   -> UartGetConfig
      24   UartSetTransmitterThreshold
        24   -> UartGetConfig
      16   UartTransmitterIsr
        16   -> UartExecPendingCallbacks
       8   Uart_ClearErrors
         8   -> UartClearErrors
      16   Uart_IsWakeUpSource
        16   -> IntDisableAll
        16   -> IntRestoreAll
       0   Uart_ModuleDisableLowPowerWakeup
       0   Uart_ModuleEnableLowPowerWakeup
      24   Uart_ModuleInit
        24   -> NVIC_EnableIRQ
        24   -> NVIC_SetPriority
        24   -> UartOpen
        24   -> UartReadData
        24   -> UartSetConfig
       8   Uart_ModuleUninit
         8   -> UartClose


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable11
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable23
       4  ??DataTable28
       4  ??DataTable32
       4  ??DataTable32_1
       4  ??DataTable32_10
       4  ??DataTable32_11
       4  ??DataTable32_12
       4  ??DataTable32_13
       4  ??DataTable32_2
       4  ??DataTable32_3
       4  ??DataTable32_4
       4  ??DataTable32_5
       4  ??DataTable32_6
       4  ??DataTable32_7
       4  ??DataTable32_8
       4  ??DataTable32_9
       4  ??DataTable8
     108  Uart1ErrorIsr
     132  Uart1Isr
      44  Uart1_GetByteFromRxBuffer
      44  Uart1_IsTxActive
       6  Uart1_RxBufferByteCount
     112  Uart1_SetBaud
      38  Uart1_SetRxCallBack
     170  Uart1_Transmit
      30  Uart1_UngetByte
     108  Uart2ErrorIsr
     136  Uart2Isr
       6  Uart2_GetByteFromRxBuffer
       4  Uart2_IsTxActive
       8  Uart2_RxBufferByteCount
       2  Uart2_SetBaud
       2  Uart2_SetRxCallBack
       6  Uart2_Transmit
       2  Uart2_UngetByte
      16  UartBaseAddress_c
      90  UartCancelReadData
      82  UartCancelWriteData
     120  UartClearErrors
     194  UartClose
      20  UartDivide
      92  UartExecPendingCallbacks
     244  UartGetByteFromRxBuffer
     194  UartGetConfig
      90  UartGetStatus
     390  UartOpen
      82  UartOpenCloseTransceiver
      98  UartReadComplete
     464  UartReadData
     104  UartReceiverIsr
    1186  UartSetConfig
     278  UartSetReceiverThreshold
     272  UartSetTransmitterThreshold
     522  UartTransmitterIsr
      10  Uart_ClearErrors
      58  Uart_IsWakeUpSource
      42  Uart_ModuleDisableLowPowerWakeup
      82  Uart_ModuleEnableLowPowerWakeup
     202  Uart_ModuleInit
      10  Uart_ModuleUninit
       1  mSci1TxBufRefLeadingIndex
       1  mSci1TxBufRefTrailingIndex
       1  mSci1TxCurIndex
     208  mUartModule
     252  maSci1RxBuf
       4  maSci1TxBufLenTable
      24  maSci1TxBufRefTable
       4  pfSci1RxCallBack
       1  uart1_ungetByte
       1  uart1_ungetFlag

 
   497 bytes in section .bss
    16 bytes in section .rodata
 5 984 bytes in section .text
 
 5 984 bytes of CODE  memory
    16 bytes of CONST memory
   497 bytes of DATA  memory

Errors: none
Warnings: none
