///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM       02/Sep/2018  14:19:41
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\PWRLib.c
//    Command line =  
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\LPM\PWRLib.c" -D IAR --preprocess "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\List\" -lC "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\List\" -lB "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\List\" --diag_suppress
//        Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\Obj\" --no_cse --no_unroll
//        --no_inline --no_code_motion --no_tbaa --no_clustering
//        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\APP\CDC\" -I "F:\Guardrail Work\Sensor Code\Git
//        Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\USB\APP\Descriptor\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Class\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Sys Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
//    List file    =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\PWRLib.s
//
///////////////////////////////////////////////////////////////////////////////

        #define SHT_PROGBITS 0x1

        EXTERN IntDisableAll
        EXTERN IntRestoreAll
        EXTERN MC1324xDrv_DirectAccessSPIRead
        EXTERN MC1324xDrv_DirectAccessSPIWrite
        EXTERN NVIC_EnableIRQ
        EXTERN TMR_AllocateTimer
        EXTERN TMR_FreeTimer
        EXTERN TMR_StartTimer

        PUBLIC PWRLib_DelayMs
        PUBLIC PWRLib_GetSystemResetStatus
        PUBLIC PWRLib_Init
        PUBLIC PWRLib_LLWU_IsGPIOWakeUpSource
        PUBLIC PWRLib_LLWU_IsLPTMRWakeUpSource
        PUBLIC PWRLib_LLWU_IsRTCWakeUpSource
        PUBLIC PWRLib_LLWU_IsTSIWakeUpSource
        PUBLIC PWRLib_LLWU_Isr
        PUBLIC PWRLib_LLWU_WakeupModuleDisable
        PUBLIC PWRLib_LLWU_WakeupModuleEnable
        PUBLIC PWRLib_LLWU_WakeupPinDisable
        PUBLIC PWRLib_LLWU_WakeupPinEnable
        PUBLIC PWRLib_LPTMR_ClockCheck
        PUBLIC PWRLib_LPTMR_ClockStart
        PUBLIC PWRLib_LPTMR_ClockStop
        PUBLIC PWRLib_LPTMR_Isr
        PUBLIC PWRLib_LPTMR_ResetTicks
        PUBLIC PWRLib_LVD_CollectLevel
        PUBLIC PWRLib_MCU_Enter_LLS
        PUBLIC PWRLib_MCU_Enter_STOP
        PUBLIC PWRLib_MCU_Enter_VLLS0
        PUBLIC PWRLib_MCU_Enter_VLLS1
        PUBLIC PWRLib_MCU_Enter_VLLS2
        PUBLIC PWRLib_MCU_Enter_VLLS3
        PUBLIC PWRLib_MCU_Enter_VLPS
        PUBLIC PWRLib_MCU_Enter_WAIT
        PUBLIC PWRLib_MCU_WakeupReason
        PUBLIC PWRLib_RTC_ClockCheck
        PUBLIC PWRLib_RTC_ClockStart
        PUBLIC PWRLib_RTC_ClockStop
        PUBLIC PWRLib_RTC_Init
        PUBLIC PWRLib_RTC_IsOscStarted
        PUBLIC PWRLib_RTC_Isr
        PUBLIC PWRLib_RTC_ResetTicks
        PUBLIC PWRLib_Radio_Enter_AutoDoze
        PUBLIC PWRLib_Radio_Enter_Doze
        PUBLIC PWRLib_Radio_Enter_Hibernate
        PUBLIC PWRLib_Radio_Enter_Idle
        PUBLIC PWRLib_Reset
        PUBLIC PWRLib_StackPS

// F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\PWRLib.c
//    1 /************************************************************************************
//    2 *
//    3 * (c) Copyright 2012, Freescale, Inc.  All rights reserved.
//    4 *
//    5 * No part of this document may be reproduced in any form - including copied,
//    6 * transcribed, printed or by any electronic means - without specific written
//    7 * permission from Freescale Semiconductor.
//    8 *
//    9 ************************************************************************************/
//   10 /*****************************************************************************
//   11  *                               INCLUDED HEADERS                            *
//   12  *---------------------------------------------------------------------------*
//   13  * Add to this section all the headers that this module needs to include.    *
//   14  *---------------------------------------------------------------------------*
//   15  *****************************************************************************/
//   16 #include "EmbeddedTypes.h"
//   17 #include "PortConfig.h"
//   18 #include "Interrupt.h"
//   19 #include "PWRLib.h"
//   20 #include "PWR_Configuration.h"
//   21 #include "TMR_Interface.h"
//   22 #include "Keyboard.h"
//   23 #include "TransceiverDrv.h"
//   24 #include "TransceiverReg.h"
//   25 
//   26 /*****************************************************************************
//   27  *                               PRIVATE VARIABLES                           *
//   28  *---------------------------------------------------------------------------*
//   29  * Add to this section all the variables and constants that have local       *
//   30  * (file) scope.                                                             *
//   31  * Each of this declarations shall be preceded by the 'static' keyword.      *
//   32  * These variables / constants cannot be accessed outside this module.       *
//   33  *---------------------------------------------------------------------------*
//   34  *****************************************************************************/
//   35 
//   36 
//   37 
//   38 /* LPTMR/RTC variables */
//   39 #if (cPWR_UsePowerDownMode==1)

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   40 static uint32_t mPWRLib_RTIRemainingTicks;
mPWRLib_RTIRemainingTicks:
        DS8 4
//   41 #endif /* #if (cPWR_UsePowerDownMode==1) */
//   42 
//   43 #if (cPWR_UsePowerDownMode==1)
//   44 /* RTC variables*/
//   45 #if gTMR_Enabled_d

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   46 static tmrTimerID_t mPWRLib_RTC_OscInitTmrID;
mPWRLib_RTC_OscInitTmrID:
        DS8 1
//   47 #endif
//   48 #endif /* #if (cPWR_UsePowerDownMode==1) */
//   49 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   50 static volatile bool_t mPWRLib_RTC_IsOscStarted = FALSE;
mPWRLib_RTC_IsOscStarted:
        DS8 1
//   51 
//   52 /* For LVD function */ 
//   53 #if ((cPWR_LVD_Enable == 1) || (cPWR_LVD_Enable == 2))
//   54   #if (cPWR_LVD_Enable == 2)
//   55     uint16_t                   PWRLib_LVD_CollectCounter;
//   56     tmrTimerID_t               PWRLib_LVD_PollIntervalTmrID;
//   57   #endif  /* #if (cPWR_LVD_Enable == 2) */
//   58   PWRLib_LVD_VoltageLevel_t    PWRLib_LVD_SavedLevel;
//   59 #endif /* #if ((cPWR_LVD_Enable == 1) || (cPWR_LVD_Enable == 2)) */
//   60 
//   61 
//   62 
//   63 /*****************************************************************************
//   64  *                               PUBLIC VARIABLES                            *
//   65  *---------------------------------------------------------------------------*
//   66  * Add to this section all the variables and constants that have global      *
//   67  * (project) scope.                                                          *
//   68  * These variables / constants can be accessed outside this module.          *
//   69  * These variables / constants shall be preceded by the 'extern' keyword in  *
//   70  * the interface header.                                                     *
//   71  *---------------------------------------------------------------------------*
//   72  *****************************************************************************/
//   73 
//   74 /* Zigbee STACK status */ 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   75   PWRLib_StackPS_t PWRLib_StackPS;
PWRLib_StackPS:
        DS8 1
//   76   
//   77   /*--- Chip status ---*/
//   78 #if (cPWR_UseMCUStatus)
//   79   PWRLib_MCUStatus_t PWRLib_MCUStatus;
//   80 #endif  /* #if (cPWR_UseMCUStatus) */
//   81   
//   82 #if (cPWR_UseRADIOStatus)
//   83   PWRLib_RADIOStatus_t PWRLib_RADIOStatus;
//   84 #endif  /* #if (cPWR_UseRADIOStatus) */
//   85 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   86 volatile PWRLib_WakeupReason_t PWRLib_MCU_WakeupReason;
PWRLib_MCU_WakeupReason:
        DS8 4
//   87 
//   88 #if (cPWR_UsePowerDownMode==1)
//   89 
//   90 /*****************************************************************************
//   91  *                           PRIVATE FUNCTIONS PROTOTYPES                    *
//   92  *---------------------------------------------------------------------------*
//   93  * Add to this section all the functions prototypes that have local (file)   *
//   94  * scope.                                                                    *
//   95  * These functions cannot be accessed outside this module.                   *
//   96  * These declarations shall be preceded by the 'static' keyword.             *
//   97  *---------------------------------------------------------------------------*
//   98  *****************************************************************************/
//   99 
//  100 /******************************************************************************
//  101  * Name: PWRLib_RTC_OscInitCallback
//  102  * Description:
//  103  *
//  104  * Parameter(s): -
//  105  * Return: -
//  106  ******************************************************************************/
//  107 #if gTMR_Enabled_d
//  108 static void PWRLib_RTC_OscInitCallback
//  109 (
//  110  tmrTimerID_t tmrID
//  111 );
//  112 #endif
//  113 
//  114 void PWRLib_DelayMs
//  115 (
//  116   uint16_t val
//  117 );
//  118 
//  119 /*****************************************************************************
//  120  *                                PRIVATE FUNCTIONS                          *
//  121  *---------------------------------------------------------------------------*
//  122  * Add to this section all the functions that have local (file) scope.       *
//  123  * These functions cannot be accessed outside this module.                   *
//  124  * These definitions shall be preceded by the 'static' keyword.              *
//  125  *---------------------------------------------------------------------------*
//  126 *****************************************************************************/
//  127 
//  128 /*****************************************************************************
//  129  *                             PUBLIC FUNCTIONS                              *
//  130  *---------------------------------------------------------------------------*
//  131  * Add to this section all the functions that have global (project) scope.   *
//  132  * These functions can be accessed outside this module.                      *
//  133  * These functions shall have their declarations (prototypes) within the     *
//  134  * interface header file and shall be preceded by the 'extern' keyword.      *
//  135  *---------------------------------------------------------------------------*
//  136  *****************************************************************************/
//  137 
//  138 /*---------------------------------------------------------------------------
//  139  * Name: PWRLib_MCU_Enter_WAIT
//  140  * Description: WAIT mode entry routine. Puts the processor into wait mode.
//  141  *              In this mode the core clock is disabled (no code executing), but 
//  142  *              bus clocks are enabled (peripheral modules are operational). 
//  143  * Parameters: -
//  144  * Return: -
//  145  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(2)
        THUMB
//  146  void PWRLib_MCU_Enter_WAIT
//  147 (
//  148   void
//  149 )
//  150 {
//  151   /* Clear the SLEEPDEEP bit to enable cortex M4 WAIT (sleep) mode */
//  152   SCB_SCR &= ~SCB_SCR_SLEEPDEEP_MASK;
PWRLib_MCU_Enter_WAIT:
        LDR.W    R0,??DataTable29  ;; 0xe000ed10
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0x4
        LDR.W    R1,??DataTable29  ;; 0xe000ed10
        STR      R0,[R1, #+0]
//  153   /* WFI instruction will start entry into WAIT (sleep) mode */
//  154   asm("WFI");
        WFI
//  155 }
        BX       LR               ;; return
//  156    
//  157 
//  158 /*---------------------------------------------------------------------------
//  159  * Name: PWRLib_MCUEnter_STOP
//  160  * Description: Puts the processor into normal stop mode.
//  161 
//  162                 Places chip in static state. Lowest power mode that retains all 
//  163                 registers while maintaining LVD protection. NVIC is disabled;
//  164                 AWIC is used to wake up from interrupt; peripheral clocks are stopped.
//  165 
//  166                 Mode of operation details:
//  167                  - ARM core enters DeepSleep Mode
//  168                  - ARM core is clock gated (HCLK = OFF)
//  169                  - NVIC is disable (FCLK = OFF)
//  170                  - WIC is used to wake up from interruptions
//  171                  - Platform and peripheral clock are stopped
//  172                  - MCG module can be configured to leave reference clocks running
//  173                  - All SRAM is operating (content retained and I/O states held)
//  174 
//  175                 STOP mode is exited into RUN mode using any enabled interrupt or RESET.
//  176 
//  177  * Parameters: -
//  178  * Return: -
//  179  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(2)
        THUMB
//  180 void PWRLib_MCU_Enter_STOP
//  181 (
//  182   void
//  183 )
//  184 {
//  185   /*  Set the LPLLSM to 0b000, normal sop mode */
//  186 #if (MCU_MK60N512VMD100 == 1)
//  187   MC_PMCTRL = (MC_PMCTRL & (MC_PMCTRL_RUNM_MASK | MC_PMCTRL_LPWUI_MASK)) |
//  188                MC_PMCTRL_LPLLSM(0x0) ;
//  189 #elif ((MCU_MK60D10 == 1) || (MCU_MK21DN512 == 1) || (MCU_MK21DX256 == 1))
//  190   SMC_PMCTRL = (SMC_PMCTRL & (SMC_PMCTRL_RUNM_MASK | SMC_PMCTRL_LPWUI_MASK)) |
//  191                SMC_PMCTRL_STOPM(0x0) ;
PWRLib_MCU_Enter_STOP:
        LDR.W    R0,??DataTable29_1  ;; 0x4007e001
        LDRB     R0,[R0, #+0]
        ANDS     R0,R0,#0xE0
        LDR.W    R1,??DataTable29_1  ;; 0x4007e001
        STRB     R0,[R1, #+0]
//  192 #endif
//  193   
//  194   /* Set the SLEEPDEEP bit to enable CORTEX M4 deep sleep mode */
//  195   SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;	
        LDR.W    R0,??DataTable29  ;; 0xe000ed10
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x4
        LDR.W    R1,??DataTable29  ;; 0xe000ed10
        STR      R0,[R1, #+0]
//  196 
//  197   /* WFI instruction will start entry into deep sleep mode */
//  198   asm("WFI");
        WFI
//  199 }
        BX       LR               ;; return
//  200 
//  201 /*---------------------------------------------------------------------------
//  202  * Name: PWRLib_MCUEnter_VLPS
//  203  * Description: Puts the processor into VLPS (Very Low Power Stop).
//  204 
//  205                 Mode of operation details:
//  206                  - ARM core enters DeepSleep Mode
//  207                  - ARM core is clock gated (HCLK = OFF)
//  208                  - NVIC is disable (FCLK = OFF)
//  209                  - WIC is used to wake up from interruptions
//  210                  - Platform and peripheral clock are stopped
//  211                  - MCG module can be configured to leave reference clocks running
//  212                  - On chip voltage regulator is in a mode that supplies only enough
//  213                    power to run the MCU in a reduced frequency
//  214                  - All SRAM is operating (content retained and I/O states held)
//  215 
//  216                 VLPS mode is exited into RUN mode using any enabled interrupt (with LPWUI =1) or RESET.
//  217                 
//  218                 The AVLP must be set to 0b1 in MC_PMPROT register in order to allow VPLS mode.
//  219 
//  220  * Parameters: -
//  221  * Return: -
//  222  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(2)
        THUMB
//  223 void PWRLib_MCU_Enter_VLPS
//  224 (
//  225   void
//  226 )
//  227 {
//  228   /*  Set the LPLLSM to 0b000, very low power stop (VLPS) */
//  229   /*  Set the LPWUI to 0b1, The voltage regulator exits stop regulation on an interrupt*/
//  230 #if (MCU_MK60N512VMD100 == 1)
//  231   MC_PMCTRL = (MC_PMCTRL & (MC_PMCTRL_RUNM_MASK | MC_PMCTRL_LPWUI_MASK)) |
//  232                MC_PMCTRL_LPLLSM(0x2) | 
//  233                MC_PMCTRL_LPWUI_MASK ;
//  234 #elif ((MCU_MK60D10 == 1) || (MCU_MK21DN512 == 1) || (MCU_MK21DX256 == 1))
//  235   SMC_PMCTRL = (SMC_PMCTRL & (SMC_PMCTRL_RUNM_MASK | SMC_PMCTRL_LPWUI_MASK)) |
//  236                SMC_PMCTRL_STOPM(0x2) | 
//  237                SMC_PMCTRL_LPWUI_MASK ;
PWRLib_MCU_Enter_VLPS:
        LDR.W    R0,??DataTable29_1  ;; 0x4007e001
        LDRB     R0,[R0, #+0]
        ANDS     R0,R0,#0xE0
        ORRS     R0,R0,#0x82
        LDR.W    R1,??DataTable29_1  ;; 0x4007e001
        STRB     R0,[R1, #+0]
//  238 #endif
//  239   
//  240   /* Set the SLEEPDEEP bit to enable CORTEX M4 deep sleep mode */
//  241   SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;	
        LDR.W    R0,??DataTable29  ;; 0xe000ed10
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x4
        LDR.W    R1,??DataTable29  ;; 0xe000ed10
        STR      R0,[R1, #+0]
//  242 
//  243   /* WFI instruction will start entry into deep sleep mode */
//  244   asm("WFI");
        WFI
//  245 }
        BX       LR               ;; return
//  246 
//  247 /*---------------------------------------------------------------------------
//  248  * Name: PWRLib_MCUEnter_LLS
//  249  * Description: Puts the processor into LLS (Low Leakage Stop).
//  250 
//  251                 Mode of operation details:
//  252                  - ARM core enters Deep Sleep Mode
//  253                  - ARM core is clock gated (HCLK = OFF)
//  254                  - NVIC is disable (FCLK = OFF)
//  255                  - LLWU is used to wake up from interruptions
//  256                  - Platform and peripheral clock are stopped
//  257                  - MCG module can be configured to leave reference clocks running
//  258                  - On chip voltage regulator is in a mode that supplies only enough 
//  259                    power to run the MCU in a reduced frequency
//  260                  - All SRAM is operating (content retained and I/O states held)
//  261                  - Most of peripherals are in state retention mode (cannot operate)
//  262 
//  263                 LLS mode is exited into RUN mode using LLWU module or RESET.
//  264 
//  265                 The ALLP must be set to 0b1 in MC_PMPROT register in order to allow LLS mode.
//  266 
//  267  * Parameters: -
//  268  * Return: -
//  269  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(2)
        THUMB
//  270 void PWRLib_MCU_Enter_LLS
//  271 (
//  272   void
//  273 )
//  274 {
//  275 
//  276   /* Set the LPLLSM field to 0b011 for LLS mode  */
//  277 #if (MCU_MK60N512VMD100 == 1)
//  278   MC_PMCTRL = (MC_PMCTRL & (MC_PMCTRL_RUNM_MASK | MC_PMCTRL_LPWUI_MASK)) |
//  279                MC_PMCTRL_LPLLSM(0x3) ;
//  280 #elif ((MCU_MK60D10 == 1) || (MCU_MK21DN512 == 1) || (MCU_MK21DX256 == 1))
//  281   SMC_PMCTRL = (SMC_PMCTRL & (SMC_PMCTRL_RUNM_MASK | SMC_PMCTRL_LPWUI_MASK)) |
//  282                SMC_PMCTRL_STOPM(0x3) ;  
PWRLib_MCU_Enter_LLS:
        LDR.W    R0,??DataTable29_1  ;; 0x4007e001
        LDRB     R0,[R0, #+0]
        ANDS     R0,R0,#0xE0
        ORRS     R0,R0,#0x3
        LDR.W    R1,??DataTable29_1  ;; 0x4007e001
        STRB     R0,[R1, #+0]
//  283 #endif
//  284 
//  285   /* Set the SLEEPDEEP bit to enable CORTEX M4 deep sleep mode */
//  286   SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;	
        LDR.W    R0,??DataTable29  ;; 0xe000ed10
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x4
        LDR.W    R1,??DataTable29  ;; 0xe000ed10
        STR      R0,[R1, #+0]
//  287   
//  288   /* WFI instruction will start entry into deep sleep mode */
//  289   asm("WFI");
        WFI
//  290 }
        BX       LR               ;; return
//  291 
//  292 /*---------------------------------------------------------------------------
//  293  * Name: PWRLib_MCUEnter_VLLS3
//  294  * Description: Puts the processor into VLLS3 (Very Low Leakage Stop3).
//  295 
//  296                 Mode of operation details:
//  297                  - ARM core enters SleepDeep Mode
//  298                  - ARM core is clock gated (HCLK = OFF)
//  299                  - NVIC is disable (FCLK = OFF)
//  300                  - LLWU should configure by user to enable the desire wake up source
//  301                  - Platform and peripheral clock are stopped
//  302                  - MCG module can be configured to leave reference clocks running
//  303                  - On chip voltage regulator is in a mode that supplies only enough
//  304                    power to run the MCU in a reduced frequency
//  305                  - All SRAM is operating (content retained and I/O states held)
//  306                  - Most modules are disabled
//  307 
//  308                 VLLS3 mode is exited into RUN mode using LLWU module or RESET.
//  309                 All wakeup goes through Reset sequence.
//  310 
//  311                 The AVLLS3 must be set to 0b1 in MC_PMPROT register in order to allow VLLS3 mode.
//  312 
//  313  * Parameters: -
//  314  * Return: -
//  315  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(2)
        THUMB
//  316 void PWRLib_MCU_Enter_VLLS3
//  317 (
//  318   void
//  319 )
//  320 {
//  321   /* Set the LPLLSM field to 0b101 for VLLS3 mode */
//  322 #if (MCU_MK60N512VMD100 == 1)
//  323   MC_PMCTRL = (MC_PMCTRL & (MC_PMCTRL_RUNM_MASK | MC_PMCTRL_LPWUI_MASK)) |
//  324                MC_PMCTRL_LPLLSM(0x5) ;
//  325 #elif ((MCU_MK60D10 == 1)  || (MCU_MK21DN512 == 1) || (MCU_MK21DX256 == 1))
//  326   SMC_PMCTRL = (SMC_PMCTRL & (SMC_PMCTRL_RUNM_MASK | SMC_PMCTRL_LPWUI_MASK)) |
//  327                SMC_PMCTRL_STOPM(0x4) ;
PWRLib_MCU_Enter_VLLS3:
        LDR.W    R0,??DataTable29_1  ;; 0x4007e001
        LDRB     R0,[R0, #+0]
        ANDS     R0,R0,#0xE0
        ORRS     R0,R0,#0x4
        LDR.W    R1,??DataTable29_1  ;; 0x4007e001
        STRB     R0,[R1, #+0]
//  328   SMC_VLLSCTRL = SMC_VLLSCTRL_VLLSM(0x3);
        MOVS     R0,#+3
        LDR.W    R1,??DataTable29_2  ;; 0x4007e002
        STRB     R0,[R1, #+0]
//  329 #endif
//  330   
//  331   /* Set the SLEEPDEEP bit to enable CORTEX M4 deep sleep mode */
//  332   SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;	
        LDR.W    R0,??DataTable29  ;; 0xe000ed10
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x4
        LDR.W    R1,??DataTable29  ;; 0xe000ed10
        STR      R0,[R1, #+0]
//  333   
//  334   /* WFI instruction will start entry into deep sleep mode */
//  335   asm("WFI");
        WFI
//  336 }
        BX       LR               ;; return
//  337 
//  338 /*---------------------------------------------------------------------------
//  339  * Name: PWRLib_MCUEnter_VLLS2
//  340  * Description: Puts the processor into VLLS2 (Very Low Leakage Stop2).
//  341 
//  342                 Mode of operation details:
//  343                  - ARM core enters SleepDeep Mode
//  344                  - ARM core is clock gated (HCLK = OFF)
//  345                  - NVIC is disable (FCLK = OFF)
//  346                  - LLWU should configure by user to enable the desire wake up source
//  347                  - Platform and peripheral clock are stopped
//  348                  - MCG module can be configured to leave reference clocks running
//  349                  - On chip voltage regulator is in a mode that supplies only enough
//  350                    power to run the MCU in a reduced frequency
//  351                  - SRAM_L is powered off. A portion of SRAM_U remains powered on (content retained and I/O state held).
//  352                  - Most modules are disabled
//  353 
//  354                 VLLS2 mode is exited into RUN mode using LLWU module or RESET.
//  355                 All wakeup goes through Reset sequence.
//  356 
//  357                 The AVLLS2 must be set to 0b1 in MC_PMPROT register in order to allow VLLS2 mode.
//  358 
//  359  * Parameters: -
//  360  * Return: -
//  361  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(2)
        THUMB
//  362 void PWRLib_MCU_Enter_VLLS2
//  363 (
//  364   void
//  365 )
//  366 {
//  367   /* Set the LPLLSM field to 0b110 for VLLS2 mode */
//  368 #if (MCU_MK60N512VMD100 == 1)
//  369   MC_PMCTRL = (MC_PMCTRL & (MC_PMCTRL_RUNM_MASK | MC_PMCTRL_LPWUI_MASK)) |
//  370                MC_PMCTRL_LPLLSM(0x6) ;
//  371 #elif ((MCU_MK60D10 == 1)  || (MCU_MK21DN512 == 1) || (MCU_MK21DX256 == 1))
//  372   SMC_PMCTRL = (SMC_PMCTRL & (SMC_PMCTRL_RUNM_MASK | SMC_PMCTRL_LPWUI_MASK)) |
//  373                SMC_PMCTRL_STOPM(0x4) ;
PWRLib_MCU_Enter_VLLS2:
        LDR.W    R0,??DataTable29_1  ;; 0x4007e001
        LDRB     R0,[R0, #+0]
        ANDS     R0,R0,#0xE0
        ORRS     R0,R0,#0x4
        LDR.W    R1,??DataTable29_1  ;; 0x4007e001
        STRB     R0,[R1, #+0]
//  374   SMC_VLLSCTRL = (SMC_VLLSCTRL_VLLSM(0x2) | cPWR_RAM2PowerOption );
        MOVS     R0,#+2
        LDR.W    R1,??DataTable29_2  ;; 0x4007e002
        STRB     R0,[R1, #+0]
//  375 #endif
//  376   
//  377   /* Set the SLEEPDEEP bit to enable CORTEX M4 deep sleep mode */
//  378   SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;	
        LDR.W    R0,??DataTable29  ;; 0xe000ed10
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x4
        LDR.W    R1,??DataTable29  ;; 0xe000ed10
        STR      R0,[R1, #+0]
//  379   
//  380   /* WFI instruction will start entry into deep sleep mode */
//  381   asm("WFI");
        WFI
//  382 }
        BX       LR               ;; return
//  383 
//  384 /*---------------------------------------------------------------------------
//  385  * Name: PWRLib_MCUEnter_VLLS1
//  386  * Description: Puts the processor into VLLS1 (Very Low Leakage Stop2).
//  387 
//  388                 Mode of operation details:
//  389                  - ARM core enters SleepDeep Mode
//  390                  - ARM core is clock gated (HCLK = OFF)
//  391                  - NVIC is disable (FCLK = OFF)
//  392                  - LLWU should configure by user to enable the desire wake up source
//  393                  - Platform and peripheral clock are stopped
//  394                  - MCG module can be configured to leave reference clocks running
//  395                  - On chip voltage regulator is in a mode that supplies only enough
//  396                    power to run the MCU in a reduced frequency
//  397                  - SRAM_L and SRAM_H is powered off.
//  398                  - Most modules are disabled
//  399 
//  400                 VLLS1 mode is exited into RUN mode using LLWU module or RESET.
//  401                 All wakeup goes through Reset sequence.
//  402 
//  403                 The AVLLS1 must be set to 0b1 in MC_PMPROT register in order to allow VLLS2 mode.
//  404 
//  405  * Parameters: -
//  406  * Return: -
//  407  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(2)
        THUMB
//  408 void PWRLib_MCU_Enter_VLLS1
//  409 (
//  410   void
//  411 )
//  412 {
//  413   /* Set the LPLLSM field to 0b110 for VLLS1 mode */
//  414 #if (MCU_MK60N512VMD100 == 1)
//  415   MC_PMCTRL = (MC_PMCTRL & (MC_PMCTRL_RUNM_MASK | MC_PMCTRL_LPWUI_MASK)) |
//  416                MC_PMCTRL_LPLLSM(0x7) ;
//  417 #elif ((MCU_MK60D10 == 1)  || (MCU_MK21DN512 == 1) || (MCU_MK21DX256 == 1))
//  418   SMC_PMCTRL = (SMC_PMCTRL & (SMC_PMCTRL_RUNM_MASK | SMC_PMCTRL_LPWUI_MASK)) |
//  419                SMC_PMCTRL_STOPM(0x4) ;
PWRLib_MCU_Enter_VLLS1:
        LDR.W    R0,??DataTable29_1  ;; 0x4007e001
        LDRB     R0,[R0, #+0]
        ANDS     R0,R0,#0xE0
        ORRS     R0,R0,#0x4
        LDR.W    R1,??DataTable29_1  ;; 0x4007e001
        STRB     R0,[R1, #+0]
//  420   SMC_VLLSCTRL = SMC_VLLSCTRL_VLLSM(0x1);
        MOVS     R0,#+1
        LDR.W    R1,??DataTable29_2  ;; 0x4007e002
        STRB     R0,[R1, #+0]
//  421 #endif
//  422   
//  423   /* Set the SLEEPDEEP bit to enable CORTEX M4 deep sleep mode */
//  424   SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;	
        LDR.W    R0,??DataTable29  ;; 0xe000ed10
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x4
        LDR.W    R1,??DataTable29  ;; 0xe000ed10
        STR      R0,[R1, #+0]
//  425   
//  426   /* WFI instruction will start entry into deep sleep mode */
//  427   asm("WFI");
        WFI
//  428 }
        BX       LR               ;; return
//  429 
//  430 /*---------------------------------------------------------------------------
//  431  * Name: PWRLib_MCUEnter_VLLS0
//  432  * Description: Puts the processor into VLLS0 (Very Low Leakage Stop0).
//  433 
//  434                 Mode of operation details:
//  435                  - ARM core enters SleepDeep Mode
//  436                  - ARM core is clock gated (HCLK = OFF)
//  437                  - NVIC is disable (FCLK = OFF)
//  438                  - LLWU should configure by user to enable the desire wake up source
//  439                  - Platform and peripheral clock are stopped
//  440                  - MCG module can be configured to leave reference clocks running
//  441                  - On chip voltage regulator is in a mode that supplies only enough
//  442                    power to run the MCU in a reduced frequency
//  443                  - SRAM_L and SRAM_H is powered off.
//  444                  - Most modules are disabled
//  445 
//  446                 VLLS1 mode is exited into RUN mode using LLWU module or RESET.
//  447                 All wakeup goes through Reset sequence.
//  448 
//  449                 The AVLLS1 must be set to 0b1 in MC_PMPROT register in order to allow VLLS2 mode.
//  450 
//  451  * Parameters: -
//  452  * Return: -
//  453  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(2)
        THUMB
//  454 void PWRLib_MCU_Enter_VLLS0
//  455 (
//  456   void
//  457 )
//  458 {
//  459   /* Set the LPLLSM field to 0b110 for VLLS0 mode */
//  460 #if (MCU_MK60N512VMD100 == 1)
//  461   MC_PMCTRL = (MC_PMCTRL & (MC_PMCTRL_RUNM_MASK | MC_PMCTRL_LPWUI_MASK)) |
//  462                MC_PMCTRL_LPLLSM(0x8) ;
//  463 #elif ((MCU_MK60D10 == 1)  || (MCU_MK21DN512 == 1) || (MCU_MK21DX256 == 1))
//  464   SMC_PMCTRL = (SMC_PMCTRL & (SMC_PMCTRL_RUNM_MASK | SMC_PMCTRL_LPWUI_MASK)) |
//  465                SMC_PMCTRL_STOPM(0x4) ;
PWRLib_MCU_Enter_VLLS0:
        LDR.W    R0,??DataTable29_1  ;; 0x4007e001
        LDRB     R0,[R0, #+0]
        ANDS     R0,R0,#0xE0
        ORRS     R0,R0,#0x4
        LDR.W    R1,??DataTable29_1  ;; 0x4007e001
        STRB     R0,[R1, #+0]
//  466   SMC_VLLSCTRL = SMC_VLLSCTRL_VLLSM(0x0) ;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable29_2  ;; 0x4007e002
        STRB     R0,[R1, #+0]
//  467 #endif
//  468   
//  469   /* Set the SLEEPDEEP bit to enable CORTEX M4 deep sleep mode */
//  470   SCB_SCR |=( SCB_SCR_SLEEPDEEP_MASK | 0x20 );	
        LDR.W    R0,??DataTable29  ;; 0xe000ed10
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x24
        LDR.W    R1,??DataTable29  ;; 0xe000ed10
        STR      R0,[R1, #+0]
//  471   
//  472   /* WFI instruction will start entry into deep sleep mode */
//  473   asm("WFI");
        WFI
//  474 }
        BX       LR               ;; return
//  475 
//  476 /*---------------------------------------------------------------------------
//  477  * Name: PWRLib_Radio_Enter_Doze
//  478  * Description: -
//  479  * Parameters: -
//  480  * Return: -
//  481  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  482 void PWRLib_Radio_Enter_Doze
//  483 (
//  484   void
//  485 )
//  486 {
PWRLib_Radio_Enter_Doze:
        PUSH     {R3-R7,LR}
//  487   uint32_t irqMaskRegister;
//  488   uint8_t phyCtrl1Reg, irqSts1Reg, pwrModesReg;
//  489   irqMaskRegister = IntDisableAll();
        BL       IntDisableAll
        MOVS     R4,R0
//  490 
//  491   pwrModesReg = MC1324xDrv_DirectAccessSPIRead( (uint8_t) PWR_MODES);
        MOVS     R0,#+61
        BL       MC1324xDrv_DirectAccessSPIRead
        MOVS     R7,R0
//  492   /* disable autodoze mode. sets PMC in low-power mode */
//  493   pwrModesReg &= (uint8_t) ~( cPWR_MODES_AUTODOZE | cPWR_MODES_PMC_MODE );
        ANDS     R7,R7,#0xFC
//  494   /* check if 32 MHz crystal oscillator is enabled (current state is hibernate mode) */
//  495   if( (pwrModesReg & cPWR_MODES_XTALEN ) != cPWR_MODES_XTALEN )
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LSLS     R0,R7,#+27
        BMI.N    ??PWRLib_Radio_Enter_Doze_0
//  496   {
//  497     /* enable 32 MHz crystal oscillator */
//  498     pwrModesReg |= (uint8_t) cPWR_MODES_XTALEN;
        ORRS     R7,R7,#0x10
//  499     MC1324xDrv_DirectAccessSPIWrite( (uint8_t) PWR_MODES, pwrModesReg);
        MOVS     R1,R7
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,#+61
        BL       MC1324xDrv_DirectAccessSPIWrite
//  500     /* wait for crystal oscillator to complet its warmup */
//  501     while( ( MC1324xDrv_DirectAccessSPIRead( (uint8_t) PWR_MODES) & cPWR_MODES_XTAL_READY ) != cPWR_MODES_XTAL_READY);
??PWRLib_Radio_Enter_Doze_1:
        MOVS     R0,#+61
        BL       MC1324xDrv_DirectAccessSPIRead
        LSLS     R0,R0,#+26
        BPL.N    ??PWRLib_Radio_Enter_Doze_1
//  502     /* wait for radio wakeup from hibernate interrupt */
//  503     while( ( MC1324xDrv_DirectAccessSPIRead( (uint8_t) IRQSTS2) & (cIRQSTS2_WAKE_IRQ | cIRQSTS2_TMRSTATUS) ) != (cIRQSTS2_WAKE_IRQ | cIRQSTS2_TMRSTATUS) );
??PWRLib_Radio_Enter_Doze_2:
        MOVS     R0,#+1
        BL       MC1324xDrv_DirectAccessSPIRead
        ANDS     R0,R0,#0x9
        CMP      R0,#+9
        BNE.N    ??PWRLib_Radio_Enter_Doze_2
//  504     MC1324xDrv_DirectAccessSPIWrite((uint8_t) IRQSTS2, (uint8_t) (cIRQSTS2_WAKE_IRQ));
        MOVS     R1,#+1
        MOVS     R0,#+1
        BL       MC1324xDrv_DirectAccessSPIWrite
        B.N      ??PWRLib_Radio_Enter_Doze_3
//  505   }
//  506   else
//  507   {
//  508     /* checks if packet processor is in idle state. otherwise abort any ongoing sequence */
//  509     phyCtrl1Reg = MC1324xDrv_DirectAccessSPIRead( (uint8_t) PHY_CTRL1 );
??PWRLib_Radio_Enter_Doze_0:
        MOVS     R0,#+3
        BL       MC1324xDrv_DirectAccessSPIRead
        MOVS     R5,R0
//  510     if( (phyCtrl1Reg & cPHY_CTRL1_XCVSEQ) != 0x00 )
        MOVS     R0,#+7
        TST      R5,R0
        BEQ.N    ??PWRLib_Radio_Enter_Doze_4
//  511     {
//  512       /* abort any ongoing sequence */
//  513       /* make sure that we abort in HW only if the sequence was actually started (tmr triggered) */
//  514       if( ( 0 != ( MC1324xDrv_DirectAccessSPIRead( (uint8_t) PHY_CTRL1) & cPHY_CTRL1_XCVSEQ ) ) && ((MC1324xDrv_DirectAccessSPIRead(SEQ_STATE)&0x1F) != 0))
        MOVS     R0,#+3
        BL       MC1324xDrv_DirectAccessSPIRead
        MOVS     R1,#+7
        TST      R0,R1
        BEQ.N    ??PWRLib_Radio_Enter_Doze_5
        MOVS     R0,#+36
        BL       MC1324xDrv_DirectAccessSPIRead
        MOVS     R1,#+31
        TST      R0,R1
        BEQ.N    ??PWRLib_Radio_Enter_Doze_5
//  515       {
//  516         phyCtrl1Reg &= (uint8_t) ~(cPHY_CTRL1_XCVSEQ);
        ANDS     R5,R5,#0xF8
//  517         MC1324xDrv_DirectAccessSPIWrite(PHY_CTRL1, phyCtrl1Reg);
        MOVS     R1,R5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,#+3
        BL       MC1324xDrv_DirectAccessSPIWrite
//  518         while ((MC1324xDrv_DirectAccessSPIRead(SEQ_STATE) & 0x1F) != 0);
??PWRLib_Radio_Enter_Doze_6:
        MOVS     R0,#+36
        BL       MC1324xDrv_DirectAccessSPIRead
        MOVS     R1,#+31
        TST      R0,R1
        BNE.N    ??PWRLib_Radio_Enter_Doze_6
//  519       }
//  520       /* clear sequence-end interrupt */ 
//  521       irqSts1Reg = MC1324xDrv_DirectAccessSPIRead( (uint8_t) IRQSTS1);
??PWRLib_Radio_Enter_Doze_5:
        MOVS     R0,#+0
        BL       MC1324xDrv_DirectAccessSPIRead
        MOVS     R6,R0
//  522       irqSts1Reg |= (uint8_t) cIRQSTS1_SEQIRQ;
        ORRS     R6,R6,#0x1
//  523       MC1324xDrv_DirectAccessSPIWrite( (uint8_t) IRQSTS1, irqSts1Reg);
        MOVS     R1,R6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,#+0
        BL       MC1324xDrv_DirectAccessSPIWrite
//  524     }
//  525     MC1324xDrv_DirectAccessSPIWrite( (uint8_t) PWR_MODES, pwrModesReg);
??PWRLib_Radio_Enter_Doze_4:
        MOVS     R1,R7
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,#+61
        BL       MC1324xDrv_DirectAccessSPIWrite
//  526   }
//  527   
//  528   IntRestoreAll(irqMaskRegister);
??PWRLib_Radio_Enter_Doze_3:
        MOVS     R0,R4
        BL       IntRestoreAll
//  529 }
        POP      {R0,R4-R7,PC}    ;; return
//  530 
//  531 /*---------------------------------------------------------------------------
//  532  * Name: PWRLib_Radio_Enter_AutoDoze
//  533  * Description: -
//  534  * Parameters: -
//  535  * Return: -
//  536  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  537 void PWRLib_Radio_Enter_AutoDoze
//  538 (
//  539   void
//  540 )
//  541 {
PWRLib_Radio_Enter_AutoDoze:
        PUSH     {R3-R5,LR}
//  542   uint32_t irqMaskRegister;
//  543   uint8_t pwrModesReg;
//  544   irqMaskRegister = IntDisableAll();
        BL       IntDisableAll
        MOVS     R4,R0
//  545 
//  546   pwrModesReg = MC1324xDrv_DirectAccessSPIRead( (uint8_t) PWR_MODES);
        MOVS     R0,#+61
        BL       MC1324xDrv_DirectAccessSPIRead
        MOVS     R5,R0
//  547   /* enable autodoze mode. */
//  548   pwrModesReg |= (uint8_t) cPWR_MODES_AUTODOZE;
        ORRS     R5,R5,#0x2
//  549   /* check if 32 MHz crystal oscillator is enabled (current state is hibernate mode) */
//  550   if( (pwrModesReg & cPWR_MODES_XTALEN ) != cPWR_MODES_XTALEN )
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        LSLS     R0,R5,#+27
        BMI.N    ??PWRLib_Radio_Enter_AutoDoze_0
//  551   {
//  552     /* enable 32 MHz crystal oscillator */
//  553     pwrModesReg |= (uint8_t) cPWR_MODES_XTALEN;
        ORRS     R5,R5,#0x10
//  554     MC1324xDrv_DirectAccessSPIWrite( (uint8_t) PWR_MODES, pwrModesReg);
        MOVS     R1,R5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,#+61
        BL       MC1324xDrv_DirectAccessSPIWrite
//  555     /* wait for crystal oscillator to complet its warmup */
//  556     while( ( MC1324xDrv_DirectAccessSPIRead( (uint8_t) PWR_MODES) & cPWR_MODES_XTAL_READY ) != cPWR_MODES_XTAL_READY);
??PWRLib_Radio_Enter_AutoDoze_1:
        MOVS     R0,#+61
        BL       MC1324xDrv_DirectAccessSPIRead
        LSLS     R0,R0,#+26
        BPL.N    ??PWRLib_Radio_Enter_AutoDoze_1
//  557     /* wait for radio wakeup from hibernate interrupt */
//  558     while( ( MC1324xDrv_DirectAccessSPIRead( (uint8_t) IRQSTS2) & (cIRQSTS2_WAKE_IRQ | cIRQSTS2_TMRSTATUS) ) != (cIRQSTS2_WAKE_IRQ | cIRQSTS2_TMRSTATUS) );
??PWRLib_Radio_Enter_AutoDoze_2:
        MOVS     R0,#+1
        BL       MC1324xDrv_DirectAccessSPIRead
        ANDS     R0,R0,#0x9
        CMP      R0,#+9
        BNE.N    ??PWRLib_Radio_Enter_AutoDoze_2
//  559     MC1324xDrv_DirectAccessSPIWrite((uint8_t) IRQSTS2, (uint8_t) (cIRQSTS2_WAKE_IRQ));
        MOVS     R1,#+1
        MOVS     R0,#+1
        BL       MC1324xDrv_DirectAccessSPIWrite
        B.N      ??PWRLib_Radio_Enter_AutoDoze_3
//  560   }
//  561   else
//  562   {
//  563     MC1324xDrv_DirectAccessSPIWrite( (uint8_t) PWR_MODES, pwrModesReg);
??PWRLib_Radio_Enter_AutoDoze_0:
        MOVS     R1,R5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,#+61
        BL       MC1324xDrv_DirectAccessSPIWrite
//  564   }
//  565   
//  566   IntRestoreAll(irqMaskRegister);
??PWRLib_Radio_Enter_AutoDoze_3:
        MOVS     R0,R4
        BL       IntRestoreAll
//  567 }
        POP      {R0,R4,R5,PC}    ;; return
//  568 
//  569 /*---------------------------------------------------------------------------
//  570  * Name: PWRLib_Radio_Enter_Idle
//  571  * Description: -
//  572  * Parameters: -
//  573  * Return: -
//  574  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  575 void PWRLib_Radio_Enter_Idle
//  576 (
//  577   void
//  578 )
//  579 {
PWRLib_Radio_Enter_Idle:
        PUSH     {R3-R7,LR}
//  580   uint32_t irqMaskRegister;
//  581   uint8_t phyCtrl1Reg, irqSts1Reg, pwrModesReg;
//  582   irqMaskRegister = IntDisableAll();
        BL       IntDisableAll
        MOVS     R4,R0
//  583 
//  584   pwrModesReg = MC1324xDrv_DirectAccessSPIRead( (uint8_t) PWR_MODES);
        MOVS     R0,#+61
        BL       MC1324xDrv_DirectAccessSPIRead
        MOVS     R7,R0
//  585   /* disable autodoze mode. sets PMC in high-power mode */
//  586   pwrModesReg &= (uint8_t) ~( cPWR_MODES_AUTODOZE );
        ANDS     R7,R7,#0xFD
//  587   pwrModesReg |= (uint8_t) cPWR_MODES_PMC_MODE;
        ORRS     R7,R7,#0x1
//  588   /* check if 32 MHz crystal oscillator is enabled (current state is hibernate mode) */
//  589   if( (pwrModesReg & cPWR_MODES_XTALEN ) != cPWR_MODES_XTALEN )
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LSLS     R0,R7,#+27
        BMI.N    ??PWRLib_Radio_Enter_Idle_0
//  590   {
//  591     /* enable 32 MHz crystal oscillator */
//  592     pwrModesReg |= (uint8_t) cPWR_MODES_XTALEN;
        ORRS     R7,R7,#0x10
//  593     MC1324xDrv_DirectAccessSPIWrite( (uint8_t) PWR_MODES, pwrModesReg);
        MOVS     R1,R7
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,#+61
        BL       MC1324xDrv_DirectAccessSPIWrite
//  594     /* wait for crystal oscillator to complet its warmup */
//  595     while( ( MC1324xDrv_DirectAccessSPIRead( (uint8_t) PWR_MODES) & cPWR_MODES_XTAL_READY ) != cPWR_MODES_XTAL_READY);
??PWRLib_Radio_Enter_Idle_1:
        MOVS     R0,#+61
        BL       MC1324xDrv_DirectAccessSPIRead
        LSLS     R0,R0,#+26
        BPL.N    ??PWRLib_Radio_Enter_Idle_1
//  596     /* wait for radio wakeup from hibernate interrupt */
//  597     while( ( MC1324xDrv_DirectAccessSPIRead( (uint8_t) IRQSTS2) & (cIRQSTS2_WAKE_IRQ | cIRQSTS2_TMRSTATUS) ) != (cIRQSTS2_WAKE_IRQ | cIRQSTS2_TMRSTATUS) );
??PWRLib_Radio_Enter_Idle_2:
        MOVS     R0,#+1
        BL       MC1324xDrv_DirectAccessSPIRead
        ANDS     R0,R0,#0x9
        CMP      R0,#+9
        BNE.N    ??PWRLib_Radio_Enter_Idle_2
//  598     MC1324xDrv_DirectAccessSPIWrite((uint8_t) IRQSTS2, (uint8_t) (cIRQSTS2_WAKE_IRQ));
        MOVS     R1,#+1
        MOVS     R0,#+1
        BL       MC1324xDrv_DirectAccessSPIWrite
        B.N      ??PWRLib_Radio_Enter_Idle_3
//  599   }
//  600   else
//  601   {
//  602     /* checks if packet processor is in idle state. otherwise abort any ongoing sequence */
//  603     phyCtrl1Reg = MC1324xDrv_DirectAccessSPIRead( (uint8_t) PHY_CTRL1 );
??PWRLib_Radio_Enter_Idle_0:
        MOVS     R0,#+3
        BL       MC1324xDrv_DirectAccessSPIRead
        MOVS     R5,R0
//  604     if( (phyCtrl1Reg & cPHY_CTRL1_XCVSEQ) != 0x00 )
        MOVS     R0,#+7
        TST      R5,R0
        BEQ.N    ??PWRLib_Radio_Enter_Idle_4
//  605     {
//  606       /* abort any ongoing sequence */
//  607       /* make sure that we abort in HW only if the sequence was actually started (tmr triggered) */
//  608       if( ( 0 != ( MC1324xDrv_DirectAccessSPIRead( (uint8_t) PHY_CTRL1) & cPHY_CTRL1_XCVSEQ ) ) && ((MC1324xDrv_DirectAccessSPIRead(SEQ_STATE)&0x1F) != 0))
        MOVS     R0,#+3
        BL       MC1324xDrv_DirectAccessSPIRead
        MOVS     R1,#+7
        TST      R0,R1
        BEQ.N    ??PWRLib_Radio_Enter_Idle_5
        MOVS     R0,#+36
        BL       MC1324xDrv_DirectAccessSPIRead
        MOVS     R1,#+31
        TST      R0,R1
        BEQ.N    ??PWRLib_Radio_Enter_Idle_5
//  609       {
//  610         phyCtrl1Reg &= (uint8_t) ~(cPHY_CTRL1_XCVSEQ);
        ANDS     R5,R5,#0xF8
//  611         MC1324xDrv_DirectAccessSPIWrite(PHY_CTRL1, phyCtrl1Reg);
        MOVS     R1,R5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,#+3
        BL       MC1324xDrv_DirectAccessSPIWrite
//  612         while ((MC1324xDrv_DirectAccessSPIRead(SEQ_STATE) & 0x1F) != 0);
??PWRLib_Radio_Enter_Idle_6:
        MOVS     R0,#+36
        BL       MC1324xDrv_DirectAccessSPIRead
        MOVS     R1,#+31
        TST      R0,R1
        BNE.N    ??PWRLib_Radio_Enter_Idle_6
//  613       }
//  614       /* clear sequence-end interrupt */ 
//  615       irqSts1Reg = MC1324xDrv_DirectAccessSPIRead( (uint8_t) IRQSTS1);
??PWRLib_Radio_Enter_Idle_5:
        MOVS     R0,#+0
        BL       MC1324xDrv_DirectAccessSPIRead
        MOVS     R6,R0
//  616       irqSts1Reg |= (uint8_t) cIRQSTS1_SEQIRQ;
        ORRS     R6,R6,#0x1
//  617       MC1324xDrv_DirectAccessSPIWrite( (uint8_t) IRQSTS1, irqSts1Reg);
        MOVS     R1,R6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,#+0
        BL       MC1324xDrv_DirectAccessSPIWrite
//  618     }
//  619     MC1324xDrv_DirectAccessSPIWrite( (uint8_t) PWR_MODES, pwrModesReg);
??PWRLib_Radio_Enter_Idle_4:
        MOVS     R1,R7
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,#+61
        BL       MC1324xDrv_DirectAccessSPIWrite
//  620   }
//  621   
//  622   IntRestoreAll(irqMaskRegister);
??PWRLib_Radio_Enter_Idle_3:
        MOVS     R0,R4
        BL       IntRestoreAll
//  623 }
        POP      {R0,R4-R7,PC}    ;; return
//  624 
//  625 /*---------------------------------------------------------------------------
//  626  * Name: PWRLib_Radio_Enter_Hibernate
//  627  * Description: -
//  628  * Parameters: -
//  629  * Return: -
//  630  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  631 void PWRLib_Radio_Enter_Hibernate
//  632 (
//  633   void
//  634 )
//  635 {
PWRLib_Radio_Enter_Hibernate:
        PUSH     {R3-R7,LR}
//  636   uint32_t irqMaskRegister;
//  637   uint8_t phyCtrl1Reg, irqSts1Reg, pwrModesReg;
//  638   irqMaskRegister = IntDisableAll();
        BL       IntDisableAll
        MOVS     R4,R0
//  639   
//  640   /* checks if packet processor is in idle state. otherwise abort any ongoing sequence */
//  641   phyCtrl1Reg = MC1324xDrv_DirectAccessSPIRead( (uint8_t) PHY_CTRL1 );
        MOVS     R0,#+3
        BL       MC1324xDrv_DirectAccessSPIRead
        MOVS     R5,R0
//  642   if( (phyCtrl1Reg & cPHY_CTRL1_XCVSEQ) != 0x00 )
        MOVS     R0,#+7
        TST      R5,R0
        BEQ.N    ??PWRLib_Radio_Enter_Hibernate_0
//  643   {
//  644       /* abort any ongoing sequence */
//  645       /* make sure that we abort in HW only if the sequence was actually started (tmr triggered) */
//  646       if( ( 0 != ( MC1324xDrv_DirectAccessSPIRead( (uint8_t) PHY_CTRL1) & cPHY_CTRL1_XCVSEQ ) ) && ((MC1324xDrv_DirectAccessSPIRead(SEQ_STATE)&0x1F) != 0))
        MOVS     R0,#+3
        BL       MC1324xDrv_DirectAccessSPIRead
        MOVS     R1,#+7
        TST      R0,R1
        BEQ.N    ??PWRLib_Radio_Enter_Hibernate_1
        MOVS     R0,#+36
        BL       MC1324xDrv_DirectAccessSPIRead
        MOVS     R1,#+31
        TST      R0,R1
        BEQ.N    ??PWRLib_Radio_Enter_Hibernate_1
//  647       {
//  648         phyCtrl1Reg &= (uint8_t) ~(cPHY_CTRL1_XCVSEQ);
        ANDS     R5,R5,#0xF8
//  649         MC1324xDrv_DirectAccessSPIWrite(PHY_CTRL1, phyCtrl1Reg);
        MOVS     R1,R5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,#+3
        BL       MC1324xDrv_DirectAccessSPIWrite
//  650         while ((MC1324xDrv_DirectAccessSPIRead(SEQ_STATE) & 0x1F) != 0);
??PWRLib_Radio_Enter_Hibernate_2:
        MOVS     R0,#+36
        BL       MC1324xDrv_DirectAccessSPIRead
        MOVS     R1,#+31
        TST      R0,R1
        BNE.N    ??PWRLib_Radio_Enter_Hibernate_2
//  651       }
//  652       /* clear sequence-end interrupt */ 
//  653       irqSts1Reg = MC1324xDrv_DirectAccessSPIRead( (uint8_t) IRQSTS1);
??PWRLib_Radio_Enter_Hibernate_1:
        MOVS     R0,#+0
        BL       MC1324xDrv_DirectAccessSPIRead
        MOVS     R6,R0
//  654       irqSts1Reg |= (uint8_t) cIRQSTS1_SEQIRQ;
        ORRS     R6,R6,#0x1
//  655       MC1324xDrv_DirectAccessSPIWrite( (uint8_t) IRQSTS1, irqSts1Reg);
        MOVS     R1,R6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,#+0
        BL       MC1324xDrv_DirectAccessSPIWrite
//  656   }
//  657   
//  658   pwrModesReg = MC1324xDrv_DirectAccessSPIRead( (uint8_t) PWR_MODES);
??PWRLib_Radio_Enter_Hibernate_0:
        MOVS     R0,#+61
        BL       MC1324xDrv_DirectAccessSPIRead
        MOVS     R7,R0
//  659   /* disable autodoze mode. disable 32 MHz crystal oscillator. sets PMC in low-power mode */
//  660   pwrModesReg &= (uint8_t) ~( cPWR_MODES_AUTODOZE | cPWR_MODES_XTALEN | cPWR_MODES_PMC_MODE );
        ANDS     R7,R7,#0xEC
//  661 
//  662   MC1324xDrv_DirectAccessSPIWrite( (uint8_t) PWR_MODES, pwrModesReg);
        MOVS     R1,R7
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,#+61
        BL       MC1324xDrv_DirectAccessSPIWrite
//  663   
//  664   IntRestoreAll(irqMaskRegister);
        MOVS     R0,R4
        BL       IntRestoreAll
//  665 }
        POP      {R0,R4-R7,PC}    ;; return
//  666 
//  667 /*---------------------------------------------------------------------------
//  668  * Name: PWRLib_LLWU_WakeupPinEnable
//  669  * Description: -
//  670  * Parameters: -
//  671  * Return: -
//  672  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  673 void PWRLib_LLWU_WakeupPinEnable
//  674 (
//  675   PWRLib_LLWU_WakeupPin_t       wakeupPin,
//  676   PWRLib_LLWU_WakeupPinConfig_t edgeDetection
//  677 )
//  678 {
PWRLib_LLWU_WakeupPinEnable:
        PUSH     {R4-R6}
//  679   volatile uint8_t * pinEnableRegBase = (volatile uint8_t *) &LLWU_PE1;
        LDR.W    R2,??DataTable29_3  ;; 0x4007c000
//  680   uint8_t regIdx, pinIdx;
//  681   
//  682   regIdx = (uint8_t)((uint8_t) wakeupPin >> 2);
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LSRS     R5,R0,#+2
        MOVS     R3,R5
//  683   pinIdx = (uint8_t)(((uint8_t) wakeupPin & 3) << 1);
        ANDS     R5,R0,#0x3
        LSLS     R5,R5,#+1
        MOVS     R4,R5
//  684   
//  685   pinEnableRegBase[regIdx] &= (uint8_t) ~(0x03 << pinIdx);
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        LDRB     R5,[R3, R2]
        MOVS     R6,#+3
        LSLS     R6,R6,R4
        BICS     R5,R5,R6
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        STRB     R5,[R3, R2]
//  686   pinEnableRegBase[regIdx] |= (uint8_t) ((uint8_t) edgeDetection << pinIdx);
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        LDRB     R5,[R3, R2]
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LSLS     R6,R1,R4
        ORRS     R5,R6,R5
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        STRB     R5,[R3, R2]
//  687   
//  688 }
        POP      {R4-R6}
        BX       LR               ;; return
//  689   
//  690 /*---------------------------------------------------------------------------
//  691  * Name: PWRLib_LLWU_WakeupModuleEnable
//  692  * Description: -
//  693  * Parameters: -
//  694  * Return: -
//  695  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  696 void PWRLib_LLWU_WakeupModuleEnable
//  697 (
//  698   PWRLib_LLWU_WakeupModule_t wakeupModule
//  699 )
//  700 {
//  701   LLWU_ME |= (uint8_t)(0x01 << (uint8_t) wakeupModule);
PWRLib_LLWU_WakeupModuleEnable:
        LDR.W    R1,??DataTable29_4  ;; 0x4007c004
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+1
        LSLS     R2,R2,R0
        ORRS     R1,R2,R1
        LDR.W    R2,??DataTable29_4  ;; 0x4007c004
        STRB     R1,[R2, #+0]
//  702 }
        BX       LR               ;; return
//  703 
//  704 /*---------------------------------------------------------------------------
//  705  * Name: PWRLib_LLWU_WakeupPinDisable
//  706  * Description: -
//  707  * Parameters: -
//  708  * Return: -
//  709  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  710 void PWRLib_LLWU_WakeupPinDisable
//  711 (
//  712   PWRLib_LLWU_WakeupPin_t wakeupPin
//  713 )
//  714 {
PWRLib_LLWU_WakeupPinDisable:
        PUSH     {R4,R5}
//  715   volatile uint8_t * pinEnableRegBase = (volatile uint8_t *) &LLWU_PE1;
        LDR.W    R1,??DataTable29_3  ;; 0x4007c000
//  716   uint8_t regIdx, pinIdx;
//  717   
//  718   regIdx = (uint8_t)((uint8_t) wakeupPin >> 2);
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LSRS     R4,R0,#+2
        MOVS     R2,R4
//  719   pinIdx = (uint8_t)(((uint8_t) wakeupPin & 3) << 1);
        ANDS     R4,R0,#0x3
        LSLS     R4,R4,#+1
        MOVS     R3,R4
//  720   
//  721   pinEnableRegBase[regIdx] &= (uint8_t) ~(0x03 << pinIdx); 
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        LDRB     R4,[R2, R1]
        MOVS     R5,#+3
        LSLS     R5,R5,R3
        BICS     R4,R4,R5
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        STRB     R4,[R2, R1]
//  722 }
        POP      {R4,R5}
        BX       LR               ;; return
//  723 
//  724 /*---------------------------------------------------------------------------
//  725  * Name: PWRLib_LLWU_WakeupModuleDisable
//  726  * Description: -
//  727  * Parameters: -
//  728  * Return: -
//  729  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  730 void PWRLib_LLWU_WakeupModuleDisable
//  731 (
//  732   PWRLib_LLWU_WakeupModule_t wakeupModule
//  733 )
//  734 {
//  735   LLWU_ME &= (uint8_t) ~(0x01 << (uint8_t) wakeupModule);
PWRLib_LLWU_WakeupModuleDisable:
        LDR.W    R1,??DataTable29_4  ;; 0x4007c004
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+1
        LSLS     R2,R2,R0
        BICS     R1,R1,R2
        LDR.W    R2,??DataTable29_4  ;; 0x4007c004
        STRB     R1,[R2, #+0]
//  736 }
        BX       LR               ;; return
//  737 
//  738 /*---------------------------------------------------------------------------
//  739  * Name: PWRLib_LLWU_IsLPTMRWakeUpSource
//  740  * Description: -
//  741  * Parameters: -
//  742  * Return: -
//  743  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  744 bool_t PWRLib_LLWU_IsLPTMRWakeUpSource
//  745 (
//  746   void
//  747 )
//  748 {
//  749   /* low power timer wakeup */
//  750   if( (LLWU_ME & ( (uint8_t) (1 << gPWRLib_LLWU_WakeupModule_LPTMR_c ) )) == ( (uint8_t) (1 << gPWRLib_LLWU_WakeupModule_LPTMR_c ) ) )
PWRLib_LLWU_IsLPTMRWakeUpSource:
        LDR.W    R0,??DataTable29_4  ;; 0x4007c004
        LDRB     R0,[R0, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LSLS     R0,R0,#+31
        BPL.N    ??PWRLib_LLWU_IsLPTMRWakeUpSource_0
//  751   {
//  752     if( (LLWU_F3 & ( (uint8_t) (1 << gPWRLib_LLWU_WakeupModule_LPTMR_c ) )) == ( (uint8_t) (1 << gPWRLib_LLWU_WakeupModule_LPTMR_c ) ) )
        LDR.W    R0,??DataTable29_5  ;; 0x4007c007
        LDRB     R0,[R0, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LSLS     R0,R0,#+31
        BPL.N    ??PWRLib_LLWU_IsLPTMRWakeUpSource_0
//  753     {
//  754       return TRUE;
        MOVS     R0,#+1
        B.N      ??PWRLib_LLWU_IsLPTMRWakeUpSource_1
//  755     }
//  756   }
//  757   return FALSE;
??PWRLib_LLWU_IsLPTMRWakeUpSource_0:
        MOVS     R0,#+0
??PWRLib_LLWU_IsLPTMRWakeUpSource_1:
        BX       LR               ;; return
//  758 }
//  759 
//  760 /*---------------------------------------------------------------------------
//  761  * Name: PWRLib_LLWU_IsRTCWakeUpSource
//  762  * Description: -
//  763  * Parameters: -
//  764  * Return: -
//  765  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  766 bool_t PWRLib_LLWU_IsRTCWakeUpSource
//  767 (
//  768   void
//  769 )
//  770 {
//  771   /* real time counter wakeup */
//  772   if( (LLWU_ME & ( (uint8_t) (1 << gPWRLib_LLWU_WakeupModule_RTC_Alarm_c ) )) == ( (uint8_t) (1 << gPWRLib_LLWU_WakeupModule_RTC_Alarm_c ) ) )
PWRLib_LLWU_IsRTCWakeUpSource:
        LDR.W    R0,??DataTable29_4  ;; 0x4007c004
        LDRB     R0,[R0, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LSLS     R0,R0,#+26
        BPL.N    ??PWRLib_LLWU_IsRTCWakeUpSource_0
//  773   {
//  774     if( (LLWU_F3 & ( (uint8_t) (1 << gPWRLib_LLWU_WakeupModule_RTC_Alarm_c ) )) == ( (uint8_t) (1 << gPWRLib_LLWU_WakeupModule_RTC_Alarm_c ) ) )
        LDR.W    R0,??DataTable29_5  ;; 0x4007c007
        LDRB     R0,[R0, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LSLS     R0,R0,#+26
        BPL.N    ??PWRLib_LLWU_IsRTCWakeUpSource_0
//  775     {
//  776       return TRUE;
        MOVS     R0,#+1
        B.N      ??PWRLib_LLWU_IsRTCWakeUpSource_1
//  777     }
//  778   }
//  779   return FALSE;
??PWRLib_LLWU_IsRTCWakeUpSource_0:
        MOVS     R0,#+0
??PWRLib_LLWU_IsRTCWakeUpSource_1:
        BX       LR               ;; return
//  780 }
//  781 
//  782 /*---------------------------------------------------------------------------
//  783  * Name: PWRLib_LLWU_IsTSIWakeUpSource
//  784  * Description: -
//  785  * Parameters: -
//  786  * Return: -
//  787  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  788 bool_t PWRLib_LLWU_IsTSIWakeUpSource
//  789 (
//  790   void
//  791 )
//  792 {
//  793 #if (MCU_MK60D10 == 1) || (MCU_MK20D5 == 1) || (MCU_MK60N512VMD100 == 1)
//  794   /* TSI wakeup */
//  795   if( (LLWU_ME & ( (uint8_t) (1 << gPWRLib_LLWU_WakeupModule_TSI_c ) )) == ( (uint8_t) (1 << gPWRLib_LLWU_WakeupModule_TSI_c ) ) )
//  796   {
//  797     if( (LLWU_F3 & ( (uint8_t) (1 << gPWRLib_LLWU_WakeupModule_TSI_c ) )) == ( (uint8_t) (1 << gPWRLib_LLWU_WakeupModule_TSI_c ) ) )
//  798     {
//  799       return TRUE;
//  800     }
//  801   }
//  802 #endif
//  803   return FALSE;
PWRLib_LLWU_IsTSIWakeUpSource:
        MOVS     R0,#+0
        BX       LR               ;; return
//  804 }
//  805 
//  806 /*---------------------------------------------------------------------------
//  807  * Name: PWRLib_LLWU_IsGPIOWakeUpSource
//  808  * Description: -
//  809  * Parameters: -
//  810  * Return: -
//  811  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  812 bool_t PWRLib_LLWU_IsGPIOWakeUpSource
//  813 (
//  814   uint8_t pinNumber
//  815 )
//  816 {
PWRLib_LLWU_IsGPIOWakeUpSource:
        PUSH     {R4}
        MOVS     R1,R0
//  817   uint32_t llwuPinEnableReg;
//  818   uint16_t llwuFlagReg;
//  819 
//  820   llwuPinEnableReg = (uint32_t) (LLWU_PE1 << 0);
        LDR.W    R0,??DataTable29_3  ;; 0x4007c000
        LDRB     R0,[R0, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R2,R0
//  821   llwuPinEnableReg |= (uint32_t) (LLWU_PE2 << 8);
        LDR.W    R0,??DataTable29_6  ;; 0x4007c001
        LDRB     R0,[R0, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ORRS     R2,R2,R0, LSL #+8
//  822   llwuPinEnableReg |= (uint32_t) (LLWU_PE3 << 16);
        LDR.W    R0,??DataTable29_7  ;; 0x4007c002
        LDRB     R0,[R0, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ORRS     R2,R2,R0, LSL #+16
//  823   llwuPinEnableReg |= (uint32_t) (LLWU_PE4 << 24);
        LDR.W    R0,??DataTable29_8  ;; 0x4007c003
        LDRB     R0,[R0, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ORRS     R2,R2,R0, LSL #+24
//  824 
//  825   llwuFlagReg = (uint32_t) (LLWU_F1 << 0);
        LDR.W    R0,??DataTable29_9  ;; 0x4007c005
        LDRB     R0,[R0, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,R0
//  826   llwuFlagReg |= (uint32_t) (LLWU_F2 << 8);
        LDR.W    R0,??DataTable29_10  ;; 0x4007c006
        LDRB     R0,[R0, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ORRS     R3,R3,R0, LSL #+8
//  827   if( ( llwuPinEnableReg & (uint32_t) (0x3 << ( pinNumber << 1 ) ) ) != 0)
        MOVS     R0,#+3
        LSLS     R4,R1,#+1
        LSLS     R0,R0,R4
        TST      R2,R0
        BEQ.N    ??PWRLib_LLWU_IsGPIOWakeUpSource_0
//  828   {
//  829     if( (llwuFlagReg & (uint16_t) (1 << pinNumber) ) != 0)
        MOVS     R0,#+1
        LSLS     R0,R0,R1
        MOVS     R4,R3
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        TST      R4,R0
        BEQ.N    ??PWRLib_LLWU_IsGPIOWakeUpSource_0
//  830     {
//  831        return TRUE;
        MOVS     R0,#+1
        B.N      ??PWRLib_LLWU_IsGPIOWakeUpSource_1
//  832     }
//  833   }
//  834   return FALSE;
??PWRLib_LLWU_IsGPIOWakeUpSource_0:
        MOVS     R0,#+0
??PWRLib_LLWU_IsGPIOWakeUpSource_1:
        POP      {R4}
        BX       LR               ;; return
//  835 }
//  836 
//  837 
//  838 /*---------------------------------------------------------------------------
//  839  * Name: PWRLib_LPTMR_ClockStart
//  840  * Description: -
//  841  * Parameters: -
//  842  * Return: -
//  843  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  844 void PWRLib_LPTMR_ClockStart
//  845 (
//  846   uint8_t  ClkMode,
//  847   uint32_t Ticks
//  848 )
//  849 {
PWRLib_LPTMR_ClockStart:
        PUSH     {R4-R6,LR}
        MOVS     R4,R0
        MOVS     R5,R1
//  850   uint32_t irqMaskRegister;
//  851   
//  852   irqMaskRegister = IntDisableAll();
        BL       IntDisableAll
        MOVS     R6,R0
//  853   /* Turn on clock to LPTMR module */
//  854   SIM_SCGC5 |= SIM_SCGC5_LPTIMER_MASK;
        LDR.W    R0,??DataTable29_11  ;; 0x40048038
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x1
        LDR.W    R1,??DataTable29_11  ;; 0x40048038
        STR      R0,[R1, #+0]
//  855   
//  856   /* Disable LPTMR */
//  857   LPTMR0_CSR &= ~(LPTMR_CSR_TEN_MASK);
        LDR.W    R0,??DataTable29_12  ;; 0x40040000
        LDR      R0,[R0, #+0]
        LSRS     R0,R0,#+1
        LSLS     R0,R0,#+1
        LDR.W    R1,??DataTable29_12  ;; 0x40040000
        STR      R0,[R1, #+0]
//  858   
//  859   /* Set compare value */
//  860   if(Ticks != 0)
        CMP      R5,#+0
        BEQ.N    ??PWRLib_LPTMR_ClockStart_0
//  861   {
//  862     LPTMR0_CMR = (uint16_t) (Ticks - 1);
        MOVS     R0,R5
        SUBS     R0,R0,#+1
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        LDR.W    R1,??DataTable29_13  ;; 0x40040008
        STR      R0,[R1, #+0]
        B.N      ??PWRLib_LPTMR_ClockStart_1
//  863   }
//  864   else
//  865   {
//  866     LPTMR0_CMR = (uint16_t) Ticks;
??PWRLib_LPTMR_ClockStart_0:
        MOVS     R0,R5
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        LDR.W    R1,??DataTable29_13  ;; 0x40040008
        STR      R0,[R1, #+0]
//  867   }
//  868   
//  869   /* Use specified tick count */
//  870   mPWRLib_RTIRemainingTicks = Ticks;
??PWRLib_LPTMR_ClockStart_1:
        LDR.W    R0,??DataTable29_14
        STR      R5,[R0, #+0]
//  871   
//  872   /* Configure prescaler, bypass prescaler and clck source */
//  873   LPTMR0_PSR = (ClkMode | cPWR_LPTMRClockSource);
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        ORRS     R0,R4,#0x1
        LDR.W    R1,??DataTable29_15  ;; 0x40040004
        STR      R0,[R1, #+0]
//  874   
//  875   /* Start counting */
//  876   LPTMR0_CSR = ( LPTMR_CSR_TCF_MASK |
//  877                  LPTMR_CSR_TIE_MASK | 
//  878                  LPTMR_CSR_TFC_MASK);
        MOVS     R0,#+196
        LDR.W    R1,??DataTable29_12  ;; 0x40040000
        STR      R0,[R1, #+0]
//  879   LPTMR0_CSR |= LPTMR_CSR_TEN_MASK;
        LDR.W    R0,??DataTable29_12  ;; 0x40040000
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x1
        LDR.W    R1,??DataTable29_12  ;; 0x40040000
        STR      R0,[R1, #+0]
//  880   
//  881   IntRestoreAll(irqMaskRegister);
        MOVS     R0,R6
        BL       IntRestoreAll
//  882 }
        POP      {R4-R6,PC}       ;; return
//  883 
//  884 /*---------------------------------------------------------------------------
//  885  * Name: PWRLib_LPTMR_ClockCheck
//  886  * Description: -
//  887  * Parameters: -
//  888  * Return: -
//  889  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  890 uint32_t PWRLib_LPTMR_ClockCheck
//  891 (
//  892   void
//  893 )
//  894 {
PWRLib_LPTMR_ClockCheck:
        PUSH     {R3-R5,LR}
//  895   uint32_t irqMaskRegister;
//  896   uint32_t remTicks;
//  897   
//  898   irqMaskRegister = IntDisableAll();
        BL       IntDisableAll
        MOVS     R4,R0
//  899   
//  900   remTicks = mPWRLib_RTIRemainingTicks;
        LDR.W    R0,??DataTable29_14
        LDR      R0,[R0, #+0]
        MOVS     R5,R0
//  901   
//  902   /* LPTMR is still running */
//  903   if(LPTMR0_CSR & LPTMR_CSR_TEN_MASK)
        LDR.W    R0,??DataTable29_12  ;; 0x40040000
        LDR      R0,[R0, #+0]
        LSLS     R0,R0,#+31
        BPL.N    ??PWRLib_LPTMR_ClockCheck_0
//  904   {
//  905     /* timer compare flag is set */
//  906     if(LPTMR0_CSR & LPTMR_CSR_TCF_MASK)
        LDR.W    R0,??DataTable29_12  ;; 0x40040000
        LDR      R0,[R0, #+0]
        LSLS     R0,R0,#+24
        BPL.N    ??PWRLib_LPTMR_ClockCheck_1
//  907     {
//  908       remTicks = 0;
        MOVS     R0,#+0
        MOVS     R5,R0
        B.N      ??PWRLib_LPTMR_ClockCheck_0
//  909     }
//  910     else
//  911     {
//  912       LPTMR0_CNR = LPTMR0_CNR;
??PWRLib_LPTMR_ClockCheck_1:
        LDR.W    R0,??DataTable29_16  ;; 0x4004000c
        LDR      R0,[R0, #+0]
        LDR.W    R1,??DataTable29_16  ;; 0x4004000c
        STR      R0,[R1, #+0]
//  913       remTicks = mPWRLib_RTIRemainingTicks - LPTMR0_CNR;
        LDR.N    R0,??DataTable29_14
        LDR      R0,[R0, #+0]
        LDR.W    R1,??DataTable29_16  ;; 0x4004000c
        LDR      R1,[R1, #+0]
        SUBS     R0,R0,R1
        MOVS     R5,R0
//  914     }
//  915   }
//  916  
//  917   IntRestoreAll(irqMaskRegister);
??PWRLib_LPTMR_ClockCheck_0:
        MOVS     R0,R4
        BL       IntRestoreAll
//  918   return remTicks;
        MOVS     R0,R5
        POP      {R1,R4,R5,PC}    ;; return
//  919 }
//  920 
//  921 /*---------------------------------------------------------------------------
//  922  * Name: PWRLib_LPTMR_ResetTicks
//  923  * Description: -
//  924  * Parameters: -
//  925  * Return: -
//  926  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  927 void PWRLib_LPTMR_ResetTicks
//  928 (
//  929   void
//  930 )
//  931 {
PWRLib_LPTMR_ResetTicks:
        PUSH     {R4,LR}
//  932   uint32_t irqMaskRegister;
//  933   irqMaskRegister = IntDisableAll();
        BL       IntDisableAll
        MOVS     R4,R0
//  934   mPWRLib_RTIRemainingTicks = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable29_14
        STR      R0,[R1, #+0]
//  935   IntRestoreAll(irqMaskRegister);
        MOVS     R0,R4
        BL       IntRestoreAll
//  936 }
        POP      {R4,PC}          ;; return
//  937 
//  938 /*---------------------------------------------------------------------------
//  939  * Name: PWRLib_LPTMR_ClockStop
//  940  * Description: -
//  941  * Parameters: -
//  942  * Return: -
//  943  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  944 void PWRLib_LPTMR_ClockStop
//  945 (
//  946   void
//  947 )
//  948 {
PWRLib_LPTMR_ClockStop:
        PUSH     {R4,LR}
//  949   uint32_t irqMaskRegister;
//  950   irqMaskRegister = IntDisableAll();
        BL       IntDisableAll
        MOVS     R4,R0
//  951   
//  952   /* LPTMR is still running */
//  953   if(LPTMR0_CSR & LPTMR_CSR_TEN_MASK)
        LDR.N    R0,??DataTable29_12  ;; 0x40040000
        LDR      R0,[R0, #+0]
        LSLS     R0,R0,#+31
        BPL.N    ??PWRLib_LPTMR_ClockStop_0
//  954   {
//  955     /* timer compare flag is set */
//  956     if(LPTMR0_CSR & LPTMR_CSR_TCF_MASK)
        LDR.N    R0,??DataTable29_12  ;; 0x40040000
        LDR      R0,[R0, #+0]
        LSLS     R0,R0,#+24
        BPL.N    ??PWRLib_LPTMR_ClockStop_1
//  957     {
//  958       mPWRLib_RTIRemainingTicks = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable29_14
        STR      R0,[R1, #+0]
        B.N      ??PWRLib_LPTMR_ClockStop_0
//  959     }
//  960     else
//  961     {
//  962       LPTMR0_CNR = LPTMR0_CNR;
??PWRLib_LPTMR_ClockStop_1:
        LDR.N    R0,??DataTable29_16  ;; 0x4004000c
        LDR      R0,[R0, #+0]
        LDR.N    R1,??DataTable29_16  ;; 0x4004000c
        STR      R0,[R1, #+0]
//  963       mPWRLib_RTIRemainingTicks = mPWRLib_RTIRemainingTicks - LPTMR0_CNR;
        LDR.N    R0,??DataTable29_14
        LDR      R0,[R0, #+0]
        LDR.N    R1,??DataTable29_16  ;; 0x4004000c
        LDR      R1,[R1, #+0]
        SUBS     R0,R0,R1
        LDR.N    R1,??DataTable29_14
        STR      R0,[R1, #+0]
//  964     }
//  965   }
//  966   /* Stop LPTMR */
//  967   LPTMR0_CSR &= ~(LPTMR_CSR_TEN_MASK);
??PWRLib_LPTMR_ClockStop_0:
        LDR.N    R0,??DataTable29_12  ;; 0x40040000
        LDR      R0,[R0, #+0]
        LSRS     R0,R0,#+1
        LSLS     R0,R0,#+1
        LDR.N    R1,??DataTable29_12  ;; 0x40040000
        STR      R0,[R1, #+0]
//  968   
//  969   IntRestoreAll(irqMaskRegister);
        MOVS     R0,R4
        BL       IntRestoreAll
//  970 }
        POP      {R4,PC}          ;; return
//  971 
//  972 /*---------------------------------------------------------------------------
//  973  * Name: PWRLib_RTC_Init
//  974  * Description: -
//  975  * Parameters: -
//  976  * Return: -
//  977  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  978 void PWRLib_RTC_Init
//  979 (
//  980  void
//  981 )
//  982 {
PWRLib_RTC_Init:
        PUSH     {R4,LR}
//  983   uint32_t irqMaskRegister;
//  984   
//  985   irqMaskRegister = IntDisableAll();
        BL       IntDisableAll
        MOVS     R4,R0
//  986   
//  987   /* Turn on clock to RTC module */
//  988   SIM_SCGC6 |= SIM_SCGC6_RTC_MASK;
        LDR.N    R0,??DataTable29_17  ;; 0x4004803c
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x20000000
        LDR.N    R1,??DataTable29_17  ;; 0x4004803c
        STR      R0,[R1, #+0]
//  989   /* Reset RTC register */
//  990   RTC_CR |= RTC_CR_SWR_MASK;
        LDR.N    R0,??DataTable29_18  ;; 0x4003d010
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x1
        LDR.N    R1,??DataTable29_18  ;; 0x4003d010
        STR      R0,[R1, #+0]
//  991   RTC_CR &= ~(RTC_CR_SWR_MASK);
        LDR.N    R0,??DataTable29_18  ;; 0x4003d010
        LDR      R0,[R0, #+0]
        LSRS     R0,R0,#+1
        LSLS     R0,R0,#+1
        LDR.N    R1,??DataTable29_18  ;; 0x4003d010
        STR      R0,[R1, #+0]
//  992   /* Disable RTC */
//  993   RTC_SR &=  ~(RTC_SR_TCE_MASK);
        LDR.N    R0,??DataTable29_19  ;; 0x4003d014
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0x10
        LDR.N    R1,??DataTable29_19  ;; 0x4003d014
        STR      R0,[R1, #+0]
//  994   /* Allow non-supervisor mode access*/
//  995   RTC_CR |= RTC_CR_SUP_MASK;
        LDR.N    R0,??DataTable29_18  ;; 0x4003d010
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x4
        LDR.N    R1,??DataTable29_18  ;; 0x4003d010
        STR      R0,[R1, #+0]
//  996   /* Clear all pending interrupts */
//  997   RTC_TAR = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable29_20  ;; 0x4003d008
        STR      R0,[R1, #+0]
//  998   RTC_TSR = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable29_21  ;; 0x4003d000
        STR      R0,[R1, #+0]
//  999   /* Disable all RTC interrupts */
// 1000   RTC_IER &= ~(RTC_IER_TAIE_MASK |
// 1001                RTC_IER_TSIE_MASK |
// 1002                RTC_IER_TOIE_MASK |
// 1003                RTC_IER_TIIE_SHIFT);
        LDR.N    R0,??DataTable29_22  ;; 0x4003d01c
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0x16
        LDR.N    R1,??DataTable29_22  ;; 0x4003d01c
        STR      R0,[R1, #+0]
// 1004   /* Enable 32 KHz oscillator */
// 1005   RTC_CR |= RTC_CR_OSCE_MASK;
        LDR.N    R0,??DataTable29_18  ;; 0x4003d010
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x100
        LDR.N    R1,??DataTable29_18  ;; 0x4003d010
        STR      R0,[R1, #+0]
// 1006   
// 1007   mPWRLib_RTC_IsOscStarted = FALSE;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable29_23
        STRB     R0,[R1, #+0]
// 1008 #if gTMR_Enabled_d
// 1009   /* Allocate a platform timer */
// 1010   mPWRLib_RTC_OscInitTmrID = TMR_AllocateTimer();	
        BL       TMR_AllocateTimer
        LDR.N    R1,??DataTable29_24
        STRB     R0,[R1, #+0]
// 1011   
// 1012   if(gTmrInvalidTimerID_c != mPWRLib_RTC_OscInitTmrID)
        LDR.N    R0,??DataTable29_24
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??PWRLib_RTC_Init_0
// 1013   {	
// 1014     TMR_StartTimer(mPWRLib_RTC_OscInitTmrID, gTmrSingleShotTimer_c, 1000, PWRLib_RTC_OscInitCallback);
        ADR.W    R3,PWRLib_RTC_OscInitCallback
        MOV      R2,#+1000
        MOVS     R1,#+1
        LDR.N    R0,??DataTable29_24
        LDRB     R0,[R0, #+0]
        BL       TMR_StartTimer
// 1015   }	
// 1016 //  else
// 1017 #else
// 1018   {
// 1019     /* Wait the oscilator startup time */
// 1020     PWRLib_DelayMs(cRTC_OSC_STARTUP_TIME);
// 1021     mPWRLib_RTC_IsOscStarted = TRUE;
// 1022   }
// 1023 #endif
// 1024     
// 1025   IntRestoreAll(irqMaskRegister);
??PWRLib_RTC_Init_0:
        MOVS     R0,R4
        BL       IntRestoreAll
// 1026 }
        POP      {R4,PC}          ;; return
// 1027 
// 1028 /*---------------------------------------------------------------------------
// 1029  * Name: PWRLib_RTC_IsOscStarted
// 1030  * Description: -
// 1031  * Parameters: -
// 1032  * Return: -
// 1033  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1034 bool_t PWRLib_RTC_IsOscStarted
// 1035 (
// 1036  void
// 1037 )
// 1038 {
PWRLib_RTC_IsOscStarted:
        PUSH     {R3-R5,LR}
// 1039   uint32_t irqMaskRegister;
// 1040   bool_t isOscStarted = FALSE;
        MOVS     R5,#+0
// 1041   
// 1042   irqMaskRegister = IntDisableAll();
        BL       IntDisableAll
        MOVS     R4,R0
// 1043   
// 1044   isOscStarted = mPWRLib_RTC_IsOscStarted;
        LDR.N    R0,??DataTable29_23
        LDRB     R0,[R0, #+0]
        MOVS     R5,R0
// 1045   
// 1046   IntRestoreAll(irqMaskRegister);
        MOVS     R0,R4
        BL       IntRestoreAll
// 1047   
// 1048   return isOscStarted;
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R1,R4,R5,PC}    ;; return
// 1049 }
// 1050 
// 1051 /*---------------------------------------------------------------------------
// 1052  * Name: PWRLib_RTC_ClockStart
// 1053  * Description: -
// 1054  * Parameters: -
// 1055  * Return: -
// 1056  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1057 void PWRLib_RTC_ClockStart
// 1058 (
// 1059   uint32_t Ticks
// 1060 )
// 1061 {
PWRLib_RTC_ClockStart:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
// 1062   uint32_t irqMaskRegister;
// 1063   
// 1064   irqMaskRegister = IntDisableAll();
        BL       IntDisableAll
        MOVS     R5,R0
// 1065 
// 1066   /* Disable RTC */
// 1067   RTC_SR &=  ~(RTC_SR_TCE_MASK);
        LDR.N    R0,??DataTable29_19  ;; 0x4003d014
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0x10
        LDR.N    R1,??DataTable29_19  ;; 0x4003d014
        STR      R0,[R1, #+0]
// 1068   
// 1069   /* Set compare value and clear alaram interrupt*/
// 1070   if(Ticks != 0)
        CMP      R4,#+0
        BEQ.N    ??PWRLib_RTC_ClockStart_0
// 1071   {
// 1072     RTC_TAR = Ticks - 1;
        SUBS     R0,R4,#+1
        LDR.N    R1,??DataTable29_20  ;; 0x4003d008
        STR      R0,[R1, #+0]
        B.N      ??PWRLib_RTC_ClockStart_1
// 1073   }
// 1074   else
// 1075   {
// 1076     RTC_TAR = Ticks;
??PWRLib_RTC_ClockStart_0:
        LDR.N    R0,??DataTable29_20  ;; 0x4003d008
        STR      R4,[R0, #+0]
// 1077   }
// 1078   
// 1079   RTC_TSR = 0;
??PWRLib_RTC_ClockStart_1:
        MOVS     R0,#+0
        LDR.N    R1,??DataTable29_21  ;; 0x4003d000
        STR      R0,[R1, #+0]
// 1080   
// 1081   /* Enable alarm interrupt*/
// 1082   RTC_IER |= RTC_IER_TAIE_MASK;
        LDR.N    R0,??DataTable29_22  ;; 0x4003d01c
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x4
        LDR.N    R1,??DataTable29_22  ;; 0x4003d01c
        STR      R0,[R1, #+0]
// 1083   /* Enable RTC */
// 1084   RTC_SR |=  RTC_SR_TCE_MASK;
        LDR.N    R0,??DataTable29_19  ;; 0x4003d014
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x10
        LDR.N    R1,??DataTable29_19  ;; 0x4003d014
        STR      R0,[R1, #+0]
// 1085   
// 1086   IntRestoreAll(irqMaskRegister);
        MOVS     R0,R5
        BL       IntRestoreAll
// 1087 }
        POP      {R0,R4,R5,PC}    ;; return
// 1088 
// 1089 /*---------------------------------------------------------------------------
// 1090  * Name: PWRLib_RTC_ClockCheck
// 1091  * Description: -
// 1092  * Parameters: -
// 1093  * Return: -
// 1094  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1095 uint32_t PWRLib_RTC_ClockCheck
// 1096 (
// 1097   void
// 1098 )
// 1099 {
PWRLib_RTC_ClockCheck:
        PUSH     {R3-R5,LR}
// 1100   uint32_t irqMaskRegister;
// 1101   uint32_t remTicks;
// 1102   
// 1103   irqMaskRegister = IntDisableAll();
        BL       IntDisableAll
        MOVS     R4,R0
// 1104   
// 1105   remTicks = mPWRLib_RTIRemainingTicks;
        LDR.N    R0,??DataTable29_14
        LDR      R0,[R0, #+0]
        MOVS     R5,R0
// 1106   
// 1107   /* RTC is still running */
// 1108   if(RTC_SR & RTC_SR_TCE_MASK)
        LDR.N    R0,??DataTable29_19  ;; 0x4003d014
        LDR      R0,[R0, #+0]
        LSLS     R0,R0,#+27
        BPL.N    ??PWRLib_RTC_ClockCheck_0
// 1109   {
// 1110     /* Time Alarm Flag */
// 1111     if(RTC_SR & RTC_SR_TAF_MASK)
        LDR.N    R0,??DataTable29_19  ;; 0x4003d014
        LDR      R0,[R0, #+0]
        LSLS     R0,R0,#+29
        BPL.N    ??PWRLib_RTC_ClockCheck_1
// 1112     {
// 1113       remTicks = 0;
        MOVS     R0,#+0
        MOVS     R5,R0
        B.N      ??PWRLib_RTC_ClockCheck_0
// 1114     }
// 1115     else
// 1116     {
// 1117       remTicks = mPWRLib_RTIRemainingTicks - RTC_TSR;
??PWRLib_RTC_ClockCheck_1:
        LDR.N    R0,??DataTable29_14
        LDR      R0,[R0, #+0]
        LDR.N    R1,??DataTable29_21  ;; 0x4003d000
        LDR      R1,[R1, #+0]
        SUBS     R0,R0,R1
        MOVS     R5,R0
// 1118     }
// 1119   }
// 1120   
// 1121   IntRestoreAll(irqMaskRegister);
??PWRLib_RTC_ClockCheck_0:
        MOVS     R0,R4
        BL       IntRestoreAll
// 1122   return remTicks;
        MOVS     R0,R5
        POP      {R1,R4,R5,PC}    ;; return
// 1123 }
// 1124 
// 1125 /*---------------------------------------------------------------------------
// 1126  * Name: PWRLib_RTC_ResetTicks
// 1127  * Description: -
// 1128  * Parameters: -
// 1129  * Return: -
// 1130  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1131 void PWRLib_RTC_ResetTicks
// 1132 (
// 1133   void
// 1134 )
// 1135 {
PWRLib_RTC_ResetTicks:
        PUSH     {R4,LR}
// 1136   uint32_t irqMaskRegister;
// 1137   irqMaskRegister = IntDisableAll();
        BL       IntDisableAll
        MOVS     R4,R0
// 1138   mPWRLib_RTIRemainingTicks = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable29_14
        STR      R0,[R1, #+0]
// 1139   IntRestoreAll(irqMaskRegister);
        MOVS     R0,R4
        BL       IntRestoreAll
// 1140 }
        POP      {R4,PC}          ;; return
// 1141 
// 1142 /*---------------------------------------------------------------------------
// 1143  * Name: PWRLib_RTC_ClockStop
// 1144  * Description: -
// 1145  * Parameters: -
// 1146  * Return: -
// 1147  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1148 void PWRLib_RTC_ClockStop
// 1149 (
// 1150   void
// 1151 )
// 1152 {
PWRLib_RTC_ClockStop:
        PUSH     {R4,LR}
// 1153   uint32_t irqMaskRegister;
// 1154   irqMaskRegister = IntDisableAll();
        BL       IntDisableAll
        MOVS     R4,R0
// 1155   
// 1156   /* RTC is still running */
// 1157   if(RTC_SR & RTC_SR_TCE_MASK)
        LDR.N    R0,??DataTable29_19  ;; 0x4003d014
        LDR      R0,[R0, #+0]
        LSLS     R0,R0,#+27
        BPL.N    ??PWRLib_RTC_ClockStop_0
// 1158   {
// 1159     /* Time Alarm Flag */
// 1160     if(RTC_SR & RTC_SR_TAF_MASK)
        LDR.N    R0,??DataTable29_19  ;; 0x4003d014
        LDR      R0,[R0, #+0]
        LSLS     R0,R0,#+29
        BPL.N    ??PWRLib_RTC_ClockStop_1
// 1161     {
// 1162       mPWRLib_RTIRemainingTicks = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable29_14
        STR      R0,[R1, #+0]
        B.N      ??PWRLib_RTC_ClockStop_0
// 1163     }
// 1164     else
// 1165     {
// 1166       mPWRLib_RTIRemainingTicks = mPWRLib_RTIRemainingTicks - RTC_TSR;
??PWRLib_RTC_ClockStop_1:
        LDR.N    R0,??DataTable29_14
        LDR      R0,[R0, #+0]
        LDR.N    R1,??DataTable29_21  ;; 0x4003d000
        LDR      R1,[R1, #+0]
        SUBS     R0,R0,R1
        LDR.N    R1,??DataTable29_14
        STR      R0,[R1, #+0]
// 1167     }
// 1168   }
// 1169   /* Stop RTC */
// 1170   RTC_SR &=  ~(RTC_SR_TCE_MASK);
??PWRLib_RTC_ClockStop_0:
        LDR.N    R0,??DataTable29_19  ;; 0x4003d014
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0x10
        LDR.N    R1,??DataTable29_19  ;; 0x4003d014
        STR      R0,[R1, #+0]
// 1171   /* Disable alarm interrupt*/
// 1172   RTC_IER &= ~(RTC_IER_TAIE_MASK);
        LDR.N    R0,??DataTable29_22  ;; 0x4003d01c
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0x4
        LDR.N    R1,??DataTable29_22  ;; 0x4003d01c
        STR      R0,[R1, #+0]
// 1173   /* Clear all pending interrupts */
// 1174   RTC_TAR = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable29_20  ;; 0x4003d008
        STR      R0,[R1, #+0]
// 1175   RTC_TSR = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable29_21  ;; 0x4003d000
        STR      R0,[R1, #+0]
// 1176   
// 1177   IntRestoreAll(irqMaskRegister);
        MOVS     R0,R4
        BL       IntRestoreAll
// 1178 }
        POP      {R4,PC}          ;; return
// 1179 
// 1180 /******************************************************************************
// 1181  * Name: PWRLib_RTC_OscInitCallback
// 1182  * Description:
// 1183  *
// 1184  * Parameter(s): -
// 1185  * Return: -
// 1186  ******************************************************************************/
// 1187 #if gTMR_Enabled_d

        SECTION `.text`:CODE:NOROOT(2)
        THUMB
// 1188 static void PWRLib_RTC_OscInitCallback
// 1189 (
// 1190  tmrTimerID_t tmrID
// 1191 )
// 1192 {
PWRLib_RTC_OscInitCallback:
        PUSH     {R4,LR}
        MOVS     R4,R0
// 1193   if(tmrID == mPWRLib_RTC_OscInitTmrID)
        LDR.N    R0,??DataTable29_24
        LDRB     R0,[R0, #+0]
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,R0
        BNE.N    ??PWRLib_RTC_OscInitCallback_0
// 1194   {
// 1195     /* RTC OSC is started */
// 1196     mPWRLib_RTC_IsOscStarted = TRUE;
        MOVS     R0,#+1
        LDR.N    R1,??DataTable29_23
        STRB     R0,[R1, #+0]
// 1197     
// 1198     /* free timer */
// 1199     TMR_FreeTimer(tmrID);			
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       TMR_FreeTimer
// 1200   }		
// 1201 }
??PWRLib_RTC_OscInitCallback_0:
        POP      {R4,PC}          ;; return
// 1202 #endif
// 1203 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1204 void PWRLib_DelayMs
// 1205 (
// 1206   uint16_t val
// 1207 )
// 1208 {
// 1209     /* Turn on clock to LPTMR module */
// 1210     SIM_SCGC5 |= SIM_SCGC5_LPTIMER_MASK;
PWRLib_DelayMs:
        LDR.N    R1,??DataTable29_11  ;; 0x40048038
        LDR      R1,[R1, #+0]
        ORRS     R1,R1,#0x1
        LDR.N    R2,??DataTable29_11  ;; 0x40048038
        STR      R1,[R2, #+0]
// 1211     
// 1212       /* Disable LPTMR */
// 1213     LPTMR0_CSR &= ~(LPTMR_CSR_TEN_MASK);
        LDR.N    R1,??DataTable29_12  ;; 0x40040000
        LDR      R1,[R1, #+0]
        LSRS     R1,R1,#+1
        LSLS     R1,R1,#+1
        LDR.N    R2,??DataTable29_12  ;; 0x40040000
        STR      R1,[R2, #+0]
// 1214     
// 1215     /* Set compare value */
// 1216     LPTMR0_CMR = val;
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        LDR.N    R1,??DataTable29_13  ;; 0x40040008
        STR      R0,[R1, #+0]
// 1217     
// 1218     /* Use 1Khz LPO clock and bypass prescaler */
// 1219     LPTMR0_PSR = LPTMR_PSR_PCS(1)|LPTMR_PSR_PBYP_MASK;
        MOVS     R1,#+5
        LDR.N    R2,??DataTable29_15  ;; 0x40040004
        STR      R1,[R2, #+0]
// 1220     
// 1221     /* Start counting */
// 1222     LPTMR0_CSR |= LPTMR_CSR_TEN_MASK;
        LDR.N    R1,??DataTable29_12  ;; 0x40040000
        LDR      R1,[R1, #+0]
        ORRS     R1,R1,#0x1
        LDR.N    R2,??DataTable29_12  ;; 0x40040000
        STR      R1,[R2, #+0]
// 1223     
// 1224     /* Wait for counter to reach compare value */
// 1225     while (!(LPTMR0_CSR & LPTMR_CSR_TCF_MASK)) {}
??PWRLib_DelayMs_0:
        LDR.N    R1,??DataTable29_12  ;; 0x40040000
        LDR      R1,[R1, #+0]
        LSLS     R1,R1,#+24
        BPL.N    ??PWRLib_DelayMs_0
// 1226     
// 1227     /* Clear Timer Compare Flag */
// 1228     LPTMR0_CSR &= ~LPTMR_CSR_TEN_MASK;
        LDR.N    R1,??DataTable29_12  ;; 0x40040000
        LDR      R1,[R1, #+0]
        LSRS     R1,R1,#+1
        LSLS     R1,R1,#+1
        LDR.N    R2,??DataTable29_12  ;; 0x40040000
        STR      R1,[R2, #+0]
// 1229     
// 1230     /* Turn off clock to LPTMR module */
// 1231     SIM_SCGC5 &= ~SIM_SCGC5_LPTIMER_MASK;	
        LDR.N    R1,??DataTable29_11  ;; 0x40048038
        LDR      R1,[R1, #+0]
        LSRS     R1,R1,#+1
        LSLS     R1,R1,#+1
        LDR.N    R2,??DataTable29_11  ;; 0x40048038
        STR      R1,[R2, #+0]
// 1232 }
        BX       LR               ;; return
// 1233 
// 1234 #if (cPWR_UsePowerModuleStandAlone == 0)
// 1235 
// 1236 /******************************************************************************
// 1237  * Name: PWRLib_GetMacStateReq
// 1238  * Description: Get status from MAC. Functions just as Asp_GetMacStateReq().
// 1239  *
// 1240  * Parameter(s): - none
// 1241  * Return: - gAspMacStateIdle_c     : MAC ready for Sleep or DeepSleep
// 1242  *           gAspMacStateBusy_c     : Don't sleep
// 1243  *           gAspMacStateNotEmpty_c : MAC allows Wait
// 1244  ******************************************************************************/
// 1245 uint8_t PWRLib_GetMacStateReq
// 1246 (
// 1247   void
// 1248 )
// 1249 {
// 1250   return Asp_GetMacStateReq();
// 1251 }
// 1252 
// 1253 #endif /* (cPWR_UsePowerModuleStandAlone == 0) */
// 1254 
// 1255 #endif /* #if (cPWR_UsePowerDownMode==1) */
// 1256 
// 1257 /*---------------------------------------------------------------------------
// 1258  * Name: PWRLib_LLWU_Isr
// 1259  * Description: -
// 1260  * Parameters: -
// 1261  * Return: -
// 1262  *---------------------------------------------------------------------------*/
// 1263 #if defined(__IAR_SYSTEMS_ICC__)
// 1264 #pragma location = ".isr_handler"
// 1265 #endif 

        SECTION `.isr_handler`:CODE:NOROOT(1)
        THUMB
// 1266 void PWRLib_LLWU_Isr
// 1267 (
// 1268   void
// 1269 )
// 1270 {
// 1271 
// 1272 #if (MCU_MK60N512VMD100 == 1)
// 1273   SIM_SCGC4 |= SIM_SCGC4_LLWU_MASK;
// 1274 #elif (MCU_MK60D10 == 1)
// 1275   SIM_SCGC4 |= (uint32_t) (1 << 28);
// 1276 #endif
// 1277 
// 1278 #if  (MCU_MK21DN512 == 1) || (MCU_MK21DX256 == 1)
// 1279   if (LLWU_F2 & LLWU_F2_WUF8_MASK)
PWRLib_LLWU_Isr:
        LDR.N    R0,??DataTable62  ;; 0x4007c006
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+31
        BPL.N    ??PWRLib_LLWU_Isr_0
// 1280   {
// 1281     PORTC_PCR4 |= PORT_PCR_ISF_MASK; //PTC4 
        LDR.N    R0,??DataTable62_1  ;; 0x4004b010
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x1000000
        LDR.N    R1,??DataTable62_1  ;; 0x4004b010
        STR      R0,[R1, #+0]
// 1282     LLWU_F2 |= LLWU_F2_WUF8_MASK;   // write one to clear the flag
        LDR.N    R0,??DataTable62  ;; 0x4007c006
        LDRB     R0,[R0, #+0]
        ORRS     R0,R0,#0x1
        LDR.N    R1,??DataTable62  ;; 0x4007c006
        STRB     R0,[R1, #+0]
// 1283         PWRLib_MCU_WakeupReason.Bits.FromKeyBoard = 1;
        LDR.N    R0,??DataTable62_2
        LDRB     R0,[R0, #+0]
        ORRS     R0,R0,#0x4
        LDR.N    R1,??DataTable62_2
        STRB     R0,[R1, #+0]
// 1284   }
// 1285   if (LLWU_F2 & LLWU_F2_WUF9_MASK)
??PWRLib_LLWU_Isr_0:
        LDR.N    R0,??DataTable62  ;; 0x4007c006
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+30
        BPL.N    ??PWRLib_LLWU_Isr_1
// 1286   {
// 1287     PORTC_PCR5 |= PORT_PCR_ISF_MASK;
        LDR.N    R0,??DataTable62_3  ;; 0x4004b014
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x1000000
        LDR.N    R1,??DataTable62_3  ;; 0x4004b014
        STR      R0,[R1, #+0]
// 1288     LLWU_F2 |= LLWU_F2_WUF9_MASK;   // write one to clear the flag
        LDR.N    R0,??DataTable62  ;; 0x4007c006
        LDRB     R0,[R0, #+0]
        ORRS     R0,R0,#0x2
        LDR.N    R1,??DataTable62  ;; 0x4007c006
        STRB     R0,[R1, #+0]
// 1289 	PWRLib_MCU_WakeupReason.Bits.FromKeyBoard = 1;
        LDR.N    R0,??DataTable62_2
        LDRB     R0,[R0, #+0]
        ORRS     R0,R0,#0x4
        LDR.N    R1,??DataTable62_2
        STRB     R0,[R1, #+0]
// 1290   }
// 1291   if (LLWU_F2 & LLWU_F2_WUF10_MASK)
??PWRLib_LLWU_Isr_1:
        LDR.N    R0,??DataTable62  ;; 0x4007c006
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+29
        BPL.N    ??PWRLib_LLWU_Isr_2
// 1292   {
// 1293     PORTC_PCR6 |= PORT_PCR_ISF_MASK;
        LDR.N    R0,??DataTable62_4  ;; 0x4004b018
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x1000000
        LDR.N    R1,??DataTable62_4  ;; 0x4004b018
        STR      R0,[R1, #+0]
// 1294     LLWU_F2 |= LLWU_F2_WUF10_MASK;   // write one to clear the flag
        LDR.N    R0,??DataTable62  ;; 0x4007c006
        LDRB     R0,[R0, #+0]
        ORRS     R0,R0,#0x4
        LDR.N    R1,??DataTable62  ;; 0x4007c006
        STRB     R0,[R1, #+0]
// 1295 	PWRLib_MCU_WakeupReason.Bits.FromKeyBoard = 1;
        LDR.N    R0,??DataTable62_2
        LDRB     R0,[R0, #+0]
        ORRS     R0,R0,#0x4
        LDR.N    R1,??DataTable62_2
        STRB     R0,[R1, #+0]
// 1296   }
// 1297 #endif
// 1298   
// 1299   /* Clear external pins wakeup interrupts */
// 1300   LLWU_F1 = LLWU_F1;
??PWRLib_LLWU_Isr_2:
        LDR.N    R0,??DataTable62_5  ;; 0x4007c005
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable62_5  ;; 0x4007c005
        STRB     R0,[R1, #+0]
// 1301   LLWU_F2 = LLWU_F2;
        LDR.N    R0,??DataTable62  ;; 0x4007c006
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable62  ;; 0x4007c006
        STRB     R0,[R1, #+0]
// 1302   
// 1303   /* Clear wakeup from error interrupt */
// 1304   LLWU_F3 |= LLWU_F3_MWUF7_MASK;
        LDR.N    R0,??DataTable62_6  ;; 0x4007c007
        LDRB     R0,[R0, #+0]
        ORRS     R0,R0,#0x80
        LDR.N    R1,??DataTable62_6  ;; 0x4007c007
        STRB     R0,[R1, #+0]
// 1305 
// 1306 #if (MCU_MK60D10 == 1) || (MCU_MK20D5 == 1) || (MCU_MK60N512VMD100 == 1)
// 1307   /* TSI is wakeup source */
// 1308   if(LLWU_F3 & LLWU_F3_MWUF4_MASK)
// 1309   {
// 1310     /* Clear OUT OF RANGE, END OF SCAN flags */
// 1311     //gTSI_GENCS_REG |= ( gTSI_OUT_OF_RANGE_MASK_c | gTSI_EOS_FLAG_MASK_c );
// 1312     TSI0_GENCS |= (TSI_GENCS_OUTRGF_MASK | TSI_GENCS_EOSF_MASK); 
// 1313     
// 1314     /* Clear touch sensing error flags */
// 1315 #if (MCU_MK60N512VMD100 == 1)
// 1316     TSI0_STATUS = 0xFFFFFFFF;
// 1317 #elif (MCU_MK60D10 == 1)
// 1318            
// 1319 #endif
// 1320     PWRLib_MCU_WakeupReason.Bits.FromKeyBoard = 1;
// 1321   }
// 1322 #endif
// 1323   
// 1324   /* LPTMR is wakeup source */
// 1325   if(LLWU_F3 & LLWU_F3_MWUF0_MASK)
        LDR.N    R0,??DataTable62_6  ;; 0x4007c007
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+31
        BPL.N    ??PWRLib_LLWU_Isr_3
// 1326   {
// 1327     /* Clear LPTMR interrupt */
// 1328     LPTMR0_CSR |= LPTMR_CSR_TCF_MASK;
        LDR.N    R0,??DataTable62_7  ;; 0x40040000
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x80
        LDR.N    R1,??DataTable62_7  ;; 0x40040000
        STR      R0,[R1, #+0]
// 1329     PWRLib_MCU_WakeupReason.Bits.FromLPTMR = 1;
        LDR.N    R0,??DataTable62_2
        LDRB     R0,[R0, #+0]
        ORRS     R0,R0,#0x8
        LDR.N    R1,??DataTable62_2
        STRB     R0,[R1, #+0]
// 1330   }
// 1331   
// 1332   /* RTC alarm is wakeup source */
// 1333   if(LLWU_F3 & LLWU_F3_MWUF5_MASK)
??PWRLib_LLWU_Isr_3:
        LDR.N    R0,??DataTable62_6  ;; 0x4007c007
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+26
        BPL.N    ??PWRLib_LLWU_Isr_4
// 1334   {
// 1335     /* Stop RTC */
// 1336     RTC_SR &=  ~(RTC_SR_TCE_MASK);
        LDR.N    R0,??DataTable62_8  ;; 0x4003d014
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0x10
        LDR.N    R1,??DataTable62_8  ;; 0x4003d014
        STR      R0,[R1, #+0]
// 1337     /* Disable alarm interrupt*/
// 1338     RTC_IER &= ~(RTC_IER_TAIE_MASK);
        LDR.N    R0,??DataTable62_9  ;; 0x4003d01c
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0x4
        LDR.N    R1,??DataTable62_9  ;; 0x4003d01c
        STR      R0,[R1, #+0]
// 1339     /* Clear all pending interrupts */
// 1340     RTC_TAR = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable62_10  ;; 0x4003d008
        STR      R0,[R1, #+0]
// 1341     RTC_TSR = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable62_11  ;; 0x4003d000
        STR      R0,[R1, #+0]
// 1342     PWRLib_MCU_WakeupReason.Bits.FromRTC = 1;
        LDR.N    R0,??DataTable62_2
        LDRB     R0,[R0, #+0]
        ORRS     R0,R0,#0x10
        LDR.N    R1,??DataTable62_2
        STRB     R0,[R1, #+0]
// 1343   }
// 1344   
// 1345 }
??PWRLib_LLWU_Isr_4:
        BX       LR               ;; return
// 1346 
// 1347 /*---------------------------------------------------------------------------
// 1348  * Name: PWRLib_LPTMR_Isr
// 1349  * Description: -
// 1350  * Parameters: -
// 1351  * Return: -
// 1352  *---------------------------------------------------------------------------*/
// 1353 #if defined(__IAR_SYSTEMS_ICC__)
// 1354 #pragma location = ".isr_handler"
// 1355 #endif

        SECTION `.isr_handler`:CODE:NOROOT(1)
        THUMB
// 1356  void PWRLib_LPTMR_Isr
// 1357 (
// 1358   void
// 1359 )
// 1360 {
// 1361   /* Stop LPTMR */
// 1362   LPTMR0_CSR &= ~(LPTMR_CSR_TEN_MASK);
PWRLib_LPTMR_Isr:
        LDR.N    R0,??DataTable62_7  ;; 0x40040000
        LDR      R0,[R0, #+0]
        LSRS     R0,R0,#+1
        LSLS     R0,R0,#+1
        LDR.N    R1,??DataTable62_7  ;; 0x40040000
        STR      R0,[R1, #+0]
// 1363   /* Clear LPTMR interrupt */
// 1364   LPTMR0_CSR |= LPTMR_CSR_TCF_MASK;
        LDR.N    R0,??DataTable62_7  ;; 0x40040000
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x80
        LDR.N    R1,??DataTable62_7  ;; 0x40040000
        STR      R0,[R1, #+0]
// 1365 #if (cPWR_UsePowerDownMode==1)  
// 1366   mPWRLib_RTIRemainingTicks = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable62_12
        STR      R0,[R1, #+0]
// 1367 #endif /* #if (cPWR_UsePowerDownMode==1) */
// 1368 }
        BX       LR               ;; return
// 1369 
// 1370 /*---------------------------------------------------------------------------
// 1371  * Name: PWRLib_LVD_CollectLevel
// 1372  * Description: -
// 1373  * Parameters: -
// 1374  * Return: -
// 1375  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1376 PWRLib_LVD_VoltageLevel_t PWRLib_LVD_CollectLevel
// 1377 (
// 1378   void
// 1379 )
// 1380 {
// 1381 #if ((cPWR_LVD_Enable == 1) || (cPWR_LVD_Enable == 2))
// 1382   
// 1383   /* Check low detect voltage 1.6V */
// 1384   PMC_LVDSC1 = PMC_LVDSC1_LVDV(0);
// 1385   PMC_LVDSC2 = PMC_LVDSC2_LVWV(0);
// 1386   PMC_LVDSC1 = PMC_LVDSC1_LVDACK_MASK;
// 1387   if(PMC_LVDSC1 & PMC_LVDSC1_LVDF_MASK)
// 1388   {
// 1389     /* Low detect voltage reached */
// 1390     PMC_LVDSC1 = PMC_LVDSC1_LVDACK_MASK;
// 1391     return(PWR_LEVEL_CRITICAL);
// 1392   }
// 1393   
// 1394   /* Check low trip voltage 1.8V */
// 1395   PMC_LVDSC1 = PMC_LVDSC1_LVDV(0);
// 1396   PMC_LVDSC2 = PMC_LVDSC2_LVWV(0);
// 1397   PMC_LVDSC2 |= PMC_LVDSC2_LVWACK_MASK;
// 1398   if(PMC_LVDSC2 & PMC_LVDSC2_LVWF_MASK)
// 1399   {
// 1400     /* Low trip voltage reached */
// 1401     PMC_LVDSC2 = PMC_LVDSC2_LVWACK_MASK; /* Clear flag (and set low trip voltage) */
// 1402     PMC_LVDSC1 = PMC_LVDSC1_LVDV(0); /* Set low trip voltage */
// 1403     return(PWR_BELOW_LEVEL_1_8V);
// 1404   }
// 1405   
// 1406   /* Check low trip voltage 1.9V */
// 1407   PMC_LVDSC1 = PMC_LVDSC1_LVDV(0);
// 1408   PMC_LVDSC2 = PMC_LVDSC2_LVWV(1);
// 1409   PMC_LVDSC2 |= PMC_LVDSC2_LVWACK_MASK;
// 1410   if(PMC_LVDSC2 & PMC_LVDSC2_LVWF_MASK)
// 1411   {
// 1412     /* Low trip voltage reached */
// 1413     PMC_LVDSC2 = PMC_LVDSC2_LVWACK_MASK; /* Clear flag (and set low trip voltage) */
// 1414     PMC_LVDSC1 = PMC_LVDSC1_LVDV(0); /* Set low trip voltage */
// 1415     return(PWR_BELOW_LEVEL_1_9V);
// 1416   }
// 1417   /* Check low trip voltage 2.0V */
// 1418   PMC_LVDSC1 = PMC_LVDSC1_LVDV(0);
// 1419   PMC_LVDSC2 = PMC_LVDSC2_LVWV(2);
// 1420   PMC_LVDSC2 |= PMC_LVDSC2_LVWACK_MASK;
// 1421   if(PMC_LVDSC2 & PMC_LVDSC2_LVWF_MASK)
// 1422   {
// 1423     /* Low trip voltage reached */
// 1424     PMC_LVDSC2 = PMC_LVDSC2_LVWACK_MASK; /* Clear flag (and set low trip voltage) */
// 1425     PMC_LVDSC1 = PMC_LVDSC1_LVDV(0); /* Set low trip voltage */
// 1426     return(PWR_BELOW_LEVEL_2_0V);
// 1427   }
// 1428   
// 1429   /* Check low trip voltage 2.1V */
// 1430   PMC_LVDSC1 = PMC_LVDSC1_LVDV(0);
// 1431   PMC_LVDSC2 = PMC_LVDSC2_LVWV(3);
// 1432   PMC_LVDSC2 |= PMC_LVDSC2_LVWACK_MASK;
// 1433   if(PMC_LVDSC2 & PMC_LVDSC2_LVWF_MASK)
// 1434   {
// 1435     /* Low trip voltage reached */
// 1436     PMC_LVDSC2 = PMC_LVDSC2_LVWACK_MASK; /* Clear flag (and set low trip voltage) */
// 1437     PMC_LVDSC1 = PMC_LVDSC1_LVDV(0); /* Set low trip voltage */
// 1438     return(PWR_BELOW_LEVEL_2_1V);
// 1439   }
// 1440   
// 1441   /* Check low detect voltage (high range) 2.56V */
// 1442   PMC_LVDSC1 = PMC_LVDSC1_LVDV(1); /* Set high trip voltage and clear warning flag */
// 1443   PMC_LVDSC2 = PMC_LVDSC2_LVWV(0);
// 1444   PMC_LVDSC1 |= PMC_LVDSC1_LVDACK_MASK;
// 1445   if(PMC_LVDSC1 & PMC_LVDSC1_LVDF_MASK)
// 1446   {
// 1447     /* Low detect voltage reached */
// 1448     PMC_LVDSC1 = PMC_LVDSC1_LVDACK_MASK; /* Set low trip voltage and clear warning flag */
// 1449     PMC_LVDSC1 = PMC_LVDSC1_LVDV(0); /* Set low trip voltage */
// 1450     return(PWR_BELOW_LEVEL_2_56V);
// 1451   }
// 1452   
// 1453   /* Check high trip voltage 2.7V */
// 1454   PMC_LVDSC1 = PMC_LVDSC1_LVDV(1);
// 1455   PMC_LVDSC2 = PMC_LVDSC2_LVWV(0);
// 1456   PMC_LVDSC2 |= PMC_LVDSC2_LVWACK_MASK;
// 1457   if(PMC_LVDSC2 & PMC_LVDSC2_LVWF_MASK)
// 1458   {
// 1459     /* Low trip voltage reached */
// 1460     PMC_LVDSC2 = PMC_LVDSC2_LVWACK_MASK; /* Clear flag (and set low trip voltage) */
// 1461     PMC_LVDSC1 = PMC_LVDSC1_LVDV(0); /* Set low trip voltage */
// 1462     return(PWR_BELOW_LEVEL_2_7V);
// 1463   }
// 1464   
// 1465   /* Check high trip voltage 2.8V */
// 1466   PMC_LVDSC1 = PMC_LVDSC1_LVDV(1);
// 1467   PMC_LVDSC2 = PMC_LVDSC2_LVWV(1);
// 1468   PMC_LVDSC2 |= PMC_LVDSC2_LVWACK_MASK;
// 1469   if(PMC_LVDSC2 & PMC_LVDSC2_LVWF_MASK)
// 1470   {
// 1471     /* Low trip voltage reached */
// 1472     PMC_LVDSC2 = PMC_LVDSC2_LVWACK_MASK; /* Clear flag (and set low trip voltage) */
// 1473     PMC_LVDSC1 = PMC_LVDSC1_LVDV(0); /* Set low trip voltage */
// 1474     return(PWR_BELOW_LEVEL_2_8V);
// 1475   }
// 1476   
// 1477   /* Check high trip voltage 2.9V */
// 1478   PMC_LVDSC1 = PMC_LVDSC1_LVDV(1);
// 1479   PMC_LVDSC2 = PMC_LVDSC2_LVWV(2);
// 1480   PMC_LVDSC2 |= PMC_LVDSC2_LVWACK_MASK;
// 1481   if(PMC_LVDSC2 & PMC_LVDSC2_LVWF_MASK)
// 1482   {
// 1483     /* Low trip voltage reached */
// 1484     PMC_LVDSC2 = PMC_LVDSC2_LVWACK_MASK; /* Clear flag (and set low trip voltage) */
// 1485     PMC_LVDSC1 = PMC_LVDSC1_LVDV(0); /* Set low trip voltage */
// 1486     return(PWR_BELOW_LEVEL_2_9V);
// 1487   }
// 1488   
// 1489   /* Check high trip voltage 3.0V */
// 1490   PMC_LVDSC1 = PMC_LVDSC1_LVDV(1);
// 1491   PMC_LVDSC2 = PMC_LVDSC2_LVWV(3);
// 1492   PMC_LVDSC2 |= PMC_LVDSC2_LVWACK_MASK;
// 1493   if(PMC_LVDSC2 & PMC_LVDSC2_LVWF_MASK)
// 1494   {
// 1495     /* Low trip voltage reached */
// 1496     PMC_LVDSC2 = PMC_LVDSC2_LVWACK_MASK; /* Clear flag (and set low trip voltage) */
// 1497     PMC_LVDSC1 = PMC_LVDSC1_LVDV(0); /* Set low trip voltage */
// 1498     return(PWR_BELOW_LEVEL_3_0V);
// 1499   }
// 1500   
// 1501   PMC_LVDSC2 = PMC_LVDSC2_LVWV(0);
// 1502   PMC_LVDSC1 = PMC_LVDSC1_LVDV(0); /* Set low trip voltage */
// 1503 #endif  /* #if ((cPWR_LVD_Enable == 1) || (cPWR_LVD_Enable == 2)) */
// 1504 
// 1505   /*--- Voltage level is okay > 3.0V */
// 1506   return(PWR_ABOVE_LEVEL_3_0V);
PWRLib_LVD_CollectLevel:
        MOVS     R0,#+0
        BX       LR               ;; return
// 1507 }
// 1508 
// 1509 /******************************************************************************
// 1510  * Name: PWRLib_LVD_PollIntervalCallback
// 1511  * Description:
// 1512  *
// 1513  * Parameter(s): -
// 1514  * Return: -
// 1515  ******************************************************************************/
// 1516 #if (cPWR_LVD_Enable == 2)
// 1517 static void PWRLib_LVD_PollIntervalCallback
// 1518 (
// 1519   tmrTimerID_t tmrID
// 1520 )
// 1521 {
// 1522   if(tmrID == PWRLib_LVD_PollIntervalTmrID)
// 1523   {
// 1524     PWRLib_LVD_SavedLevel = PWRLib_LVD_CollectLevel();
// 1525     /* re-start the timer */
// 1526     //TMR_StartMinuteTimer(PWRLib_LVD_PollIntervalTmrID, PWRLib_LVD_CollectCounter, PWRLib_LVD_PollIntervalCallback);
// 1527     TMR_StartLowPowerTimer(PWRLib_LVD_PollIntervalTmrID, gTmrLowPowerMinuteTimer_c, PWRLib_LVD_CollectCounter, PWRLib_LVD_PollIntervalCallback);
// 1528   }
// 1529 }
// 1530 #endif
// 1531 
// 1532 /*---------------------------------------------------------------------------
// 1533  * Name: PWRLib_RTC_Isr
// 1534  * Description: -
// 1535  * Parameters: -
// 1536  * Return: -
// 1537  *---------------------------------------------------------------------------*/
// 1538 #if defined(__IAR_SYSTEMS_ICC__)
// 1539 #pragma location = ".isr_handler"
// 1540 #endif 

        SECTION `.isr_handler`:CODE:NOROOT(1)
        THUMB
// 1541 void PWRLib_RTC_Isr
// 1542 (
// 1543   void
// 1544 )
// 1545 {
// 1546   /* Stop RTC */
// 1547   RTC_SR &=  ~(RTC_SR_TCE_MASK);
PWRLib_RTC_Isr:
        LDR.N    R0,??DataTable62_8  ;; 0x4003d014
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0x10
        LDR.N    R1,??DataTable62_8  ;; 0x4003d014
        STR      R0,[R1, #+0]
// 1548   /* Disable alarm interrupt*/
// 1549   RTC_IER &= ~(RTC_IER_TAIE_MASK);
        LDR.N    R0,??DataTable62_9  ;; 0x4003d01c
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0x4
        LDR.N    R1,??DataTable62_9  ;; 0x4003d01c
        STR      R0,[R1, #+0]
// 1550   /* Clear all pending interrupts */
// 1551   RTC_TAR = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable62_10  ;; 0x4003d008
        STR      R0,[R1, #+0]
// 1552   RTC_TSR = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable62_11  ;; 0x4003d000
        STR      R0,[R1, #+0]
// 1553 #if (cPWR_UsePowerDownMode==1)
// 1554   mPWRLib_RTIRemainingTicks = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable62_12
        STR      R0,[R1, #+0]
// 1555 #endif /* #if (cPWR_UsePowerDownMode==1) */
// 1556 }
        BX       LR               ;; return

        SECTION `.isr_handler`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable62:
        DC32     0x4007c006

        SECTION `.isr_handler`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable62_1:
        DC32     0x4004b010

        SECTION `.isr_handler`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable62_2:
        DC32     PWRLib_MCU_WakeupReason

        SECTION `.isr_handler`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable62_3:
        DC32     0x4004b014

        SECTION `.isr_handler`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable62_4:
        DC32     0x4004b018

        SECTION `.isr_handler`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable62_5:
        DC32     0x4007c005

        SECTION `.isr_handler`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable62_6:
        DC32     0x4007c007

        SECTION `.isr_handler`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable62_7:
        DC32     0x40040000

        SECTION `.isr_handler`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable62_8:
        DC32     0x4003d014

        SECTION `.isr_handler`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable62_9:
        DC32     0x4003d01c

        SECTION `.isr_handler`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable62_10:
        DC32     0x4003d008

        SECTION `.isr_handler`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable62_11:
        DC32     0x4003d000

        SECTION `.isr_handler`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable62_12:
        DC32     mPWRLib_RTIRemainingTicks
// 1557 
// 1558 /*---------------------------------------------------------------------------
// 1559  * Name: PWRLib_GetSystemResetStatus
// 1560  * Description: -
// 1561  * Parameters: -
// 1562  * Return: -
// 1563  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1564 uint16_t PWRLib_GetSystemResetStatus
// 1565 (
// 1566   void
// 1567 )
// 1568 {
// 1569   uint16_t resetStatus = 0;
PWRLib_GetSystemResetStatus:
        MOVS     R0,#+0
// 1570 #if (MCU_MK60N512VMD100 == 1)
// 1571   resetStatus = (uint16_t) (MC_SRSL);
// 1572   resetStatus |= (uint16_t)(MC_SRSH << 8);
// 1573 #elif ((MCU_MK60D10 == 1) || (MCU_MK20D5 == 1) || (MCU_MK21DN512 == 1) || (MCU_MK21DX256 == 1))
// 1574   resetStatus = (uint16_t) (RCM_SRS0);
        LDR.N    R1,??DataTable29_25  ;; 0x4007f000
        LDRB     R1,[R1, #+0]
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R1
// 1575   resetStatus |= (uint16_t)(RCM_SRS1 << 8);
        LDR.N    R1,??DataTable29_26  ;; 0x4007f001
        LDRB     R1,[R1, #+0]
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        ORRS     R0,R0,R1, LSL #+8
// 1576 #endif
// 1577   return resetStatus;
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        BX       LR               ;; return
// 1578 }
// 1579 
// 1580 /*---------------------------------------------------------------------------
// 1581  * Name: PWRLib_Init
// 1582  * Description: -
// 1583  * Parameters: -
// 1584  * Return: -
// 1585  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1586 void PWRLib_Init
// 1587 (
// 1588   void
// 1589 )
// 1590 {
PWRLib_Init:
        PUSH     {R7,LR}
// 1591 
// 1592 #if (cPWR_UsePowerDownMode == 1)
// 1593   /* enable clock to LLWU module */
// 1594 #if (MCU_MK60N512VMD100 == 1)	
// 1595   SIM_SCGC4 |= SIM_SCGC4_LLWU_MASK;
// 1596 #elif (MCU_MK60D10 == 1)
// 1597   SIM_SCGC4 |= (uint32_t) (1 << 28);
// 1598 #endif
// 1599 
// 1600 #if ( (cPWR_DeepSleepMode == 4) || (cPWR_DeepSleepMode == 7) || (cPWR_DeepSleepMode == 11) )
// 1601   PWRLib_RTC_Init();
// 1602   /* configure NVIC for RTC alarm Isr */
// 1603   NVIC_EnableIRQ(gRTC_IRQ_Number_c);
// 1604   /* enable RTC as wakeup source for LLWU module */
// 1605   PWRLib_LLWU_WakeupModuleEnable(gPWRLib_LLWU_WakeupModule_RTC_Alarm_c);
// 1606 #endif
// 1607 
// 1608 #if ( (cPWR_DeepSleepMode == 2) || (cPWR_DeepSleepMode == 3) || (cPWR_DeepSleepMode == 5) || (cPWR_DeepSleepMode == 6) || (cPWR_DeepSleepMode == 8) || (cPWR_DeepSleepMode == 9) || (cPWR_DeepSleepMode == 10) || (cPWR_DeepSleepMode == 12) )  
// 1609   /* configure NVIC for LPTMR Isr */
// 1610   //NVIC_EnableIRQ(gLPTMR_IRQ_Number_c);
// 1611   /* enable LPTMR as wakeup source for LLWU module */
// 1612   //PWRLib_LLWU_WakeupModuleEnable(gPWRLib_LLWU_WakeupModule_LPTMR_c);
// 1613 #endif
// 1614 
// 1615 #if ( (cPWR_DeepSleepMode != 0) && (cPWR_DeepSleepMode != 2) && (cPWR_DeepSleepMode != 3) && (cPWR_DeepSleepMode != 4) )
// 1616 
// 1617 #if ((MCU_MK21DN512 == 1) || (MCU_MK21DX256 == 1))
// 1618   /* enable GPIO as wakeup source for LLWU module */
// 1619   PWRLib_LLWU_WakeupPinEnable( (PWRLib_LLWU_WakeupPin_t) gLLWU_WakeUp_PIN_Number_c, gPWRLib_LLWU_WakeupPin_AnyEdge_c);
        MOVS     R1,#+3
        MOVS     R0,#+8
        BL       PWRLib_LLWU_WakeupPinEnable
// 1620 #elif (MCU_MK60D10 == 1)
// 1621   /* enable TSI as wakeup source for LLWU module */
// 1622   PWRLib_LLWU_WakeupModuleEnable(gPWRLib_LLWU_WakeupModule_TSI_c);
// 1623 #endif
// 1624 
// 1625 #endif
// 1626   
// 1627 #if ( (cPWR_DeepSleepMode != 0) && (cPWR_DeepSleepMode != 13) )
// 1628   /* configure NVIC for LLWU Isr */
// 1629   NVIC_EnableIRQ(gLLWU_IRQ_Number_c);
        MOVS     R0,#+21
        BL       NVIC_EnableIRQ
// 1630 #endif
// 1631   
// 1632 #if ( (cPWR_DeepSleepMode == 3) || (cPWR_DeepSleepMode == 6) || (cPWR_DeepSleepMode == 10) )
// 1633   
// 1634 #if (MCU_MK60N512VMD100 == 1)	
// 1635   SIM_SOPT1 |= SIM_SOPT1_OSC32KSEL_MASK;
// 1636 #elif ((MCU_MK60D10 == 1)  || (MCU_MK21DN512 == 1) || (MCU_MK21DX256 == 1))
// 1637   SIM_SOPT1 &= ~SIM_SOPT1_OSC32KSEL_MASK;
// 1638   SIM_SOPT1 |= SIM_SOPT1_OSC32KSEL(2);
// 1639 #endif // (MCU_MK60N512VMD100 == 1)	
// 1640   PWRLib_RTC_Init();
// 1641 
// 1642 #endif
// 1643 
// 1644 #endif /* #if (cPWR_UsePowerDownMode==1) */
// 1645     
// 1646   /* LVD_Init TODO */
// 1647 #if (cPWR_LVD_Enable == 0)
// 1648 //  PMC_LVDSC1 &= (uint32_t) ~( PMC_LVDSC1_LVDRE_MASK | PMC_LVDSC1_LVDIE_MASK );
// 1649   PMC_LVDSC1 &= (uint32_t) ~( PMC_LVDSC1_LVDIE_MASK );
        LDR.N    R0,??DataTable29_27  ;; 0x4007d000
        LDRB     R0,[R0, #+0]
        ANDS     R0,R0,#0xDF
        LDR.N    R1,??DataTable29_27  ;; 0x4007d000
        STRB     R0,[R1, #+0]
// 1650   PMC_LVDSC2 &= (uint32_t) ~( PMC_LVDSC2_LVWIE_MASK );
        LDR.N    R0,??DataTable29_28  ;; 0x4007d001
        LDRB     R0,[R0, #+0]
        ANDS     R0,R0,#0xDF
        LDR.N    R1,??DataTable29_28  ;; 0x4007d001
        STRB     R0,[R1, #+0]
// 1651 #elif ((cPWR_LVD_Enable == 1) || (cPWR_LVD_Enable == 2))
// 1652 //  PMC_LVDSC1 &= (uint32_t) ~( PMC_LVDSC1_LVDRE_MASK | PMC_LVDSC1_LVDIE_MASK );
// 1653   PMC_LVDSC1 &= (uint32_t) ~( PMC_LVDSC1_LVDIE_MASK );
// 1654   PMC_LVDSC2 &= (uint32_t) ~( PMC_LVDSC2_LVWIE_MASK );
// 1655 #elif (cPWR_LVD_Enable==3)
// 1656   PMC_LVDSC1 &= (uint32_t) ~( PMC_LVDSC1_LVDIE_MASK );
// 1657   PMC_LVDSC2 &= (uint32_t) ~( PMC_LVDSC2_LVWIE_MASK );
// 1658   PMC_LVDSC1 |= (uint32_t) ( PMC_LVDSC1_LVDRE_MASK );
// 1659 #endif /* #if (cPWR_LVD_Enable) */
// 1660   
// 1661 #if ((cPWR_LVD_Enable == 1) || (cPWR_LVD_Enable == 2))
// 1662   PWRLib_LVD_SavedLevel = PWR_ABOVE_LEVEL_3_0V;
// 1663 #endif  /* #if ((cPWR_LVD_Enable == 1) || (cPWR_LVD_Enable == 2)) */
// 1664 #if (cPWR_LVD_Enable == 2)
// 1665   PWRLib_LVD_CollectCounter = cPWR_LVD_Ticks;
// 1666 #endif  /* #if (cPWR_LVD_Enable==2) */
// 1667   
// 1668 #if (cPWR_LVD_Enable == 2)
// 1669   
// 1670   /* Allocate a platform timer */
// 1671   PWRLib_LVD_PollIntervalTmrID = TMR_AllocateTimer();	
// 1672   
// 1673   if(gTmrInvalidTimerID_c != PWRLib_LVD_PollIntervalTmrID)
// 1674   {	
// 1675     /* start the timer */
// 1676     TMR_StartLowPowerTimer(PWRLib_LVD_PollIntervalTmrID, gTmrLowPowerMinuteTimer_c, PWRLib_LVD_CollectCounter, PWRLib_LVD_PollIntervalCallback);
// 1677   }
// 1678 #endif  /* #if (cPWR_LVD_Enable==2) */
// 1679   
// 1680 }
        POP      {R0,PC}          ;; return
// 1681 
// 1682 /*---------------------------------------------------------------------------
// 1683  * Name: PWRLib_Reset
// 1684  * Description: -
// 1685  * Parameters: -
// 1686  * Return: -
// 1687  *---------------------------------------------------------------------------*/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1688 void PWRLib_Reset
// 1689 (
// 1690   void
// 1691 )
// 1692 {
// 1693   SCB_AIRCR = (uint32_t) (SCB_AIRCR_VECTKEY(0x5FA) | SCB_AIRCR_SYSRESETREQ_MASK);
PWRLib_Reset:
        LDR.N    R0,??DataTable29_29  ;; 0x5fa0004
        LDR.N    R1,??DataTable29_30  ;; 0xe000ed0c
        STR      R0,[R1, #+0]
// 1694   while(1);
??PWRLib_Reset_0:
        B.N      ??PWRLib_Reset_0
// 1695 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29:
        DC32     0xe000ed10

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_1:
        DC32     0x4007e001

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_2:
        DC32     0x4007e002

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_3:
        DC32     0x4007c000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_4:
        DC32     0x4007c004

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_5:
        DC32     0x4007c007

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_6:
        DC32     0x4007c001

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_7:
        DC32     0x4007c002

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_8:
        DC32     0x4007c003

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_9:
        DC32     0x4007c005

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_10:
        DC32     0x4007c006

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_11:
        DC32     0x40048038

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_12:
        DC32     0x40040000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_13:
        DC32     0x40040008

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_14:
        DC32     mPWRLib_RTIRemainingTicks

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_15:
        DC32     0x40040004

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_16:
        DC32     0x4004000c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_17:
        DC32     0x4004803c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_18:
        DC32     0x4003d010

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_19:
        DC32     0x4003d014

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_20:
        DC32     0x4003d008

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_21:
        DC32     0x4003d000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_22:
        DC32     0x4003d01c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_23:
        DC32     mPWRLib_RTC_IsOscStarted

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_24:
        DC32     mPWRLib_RTC_OscInitTmrID

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_25:
        DC32     0x4007f000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_26:
        DC32     0x4007f001

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_27:
        DC32     0x4007d000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_28:
        DC32     0x4007d001

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_29:
        DC32     0x5fa0004

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_30:
        DC32     0xe000ed0c

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        END
// 
//    11 bytes in section .bss
//   378 bytes in section .isr_handler
// 2 244 bytes in section .text
// 
// 2 622 bytes of CODE memory
//    11 bytes of DATA memory
//
//Errors: none
//Warnings: none
