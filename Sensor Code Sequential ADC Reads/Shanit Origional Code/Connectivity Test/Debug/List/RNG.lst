###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        30/Jun/2015  15:00:57
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity
#        Test\PLM\Source\RNG\RNG.c
#    Command line =  
#        "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity
#        Test\PLM\Source\RNG\RNG.c" -D IAR --preprocess
#        "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity Test\Debug\List\" -lC
#        "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity Test\Debug\List\" -lB
#        "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity Test\Debug\List\"
#        --diag_suppress Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o
#        "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity Test\Debug\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity Test\PLM\Configure\"
#        -I "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity
#        Test\PLM\Environment\" -I "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity Test\PLM\Interface\"
#        -I "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity Test\Generic
#        Services\Interface\" -I "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity
#        Test\PLM\Source\Uart\" -I "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity Test\PLM\Source\USB\"
#        -I "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity
#        Test\PLM\Source\USB\APP\" -I "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity
#        Test\PLM\Source\USB\APP\CDC\" -I "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity
#        Test\PLM\Source\USB\APP\Descriptor\" -I
#        "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity
#        Test\PLM\Source\USB\Class\" -I "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity
#        Test\PLM\Source\USB\Common\" -I "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity
#        Test\PLM\Source\USB\Driver\" -I "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity Test\PLM\Source\TMR\"
#        -I "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity
#        Test\PLM\Source\Radio\MC1324x\PHY\" -I "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity
#        Test\PLM\Source\Radio\MC1324x\DRV\" -I "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity Test\PLM\Source\Sys
#        Common\" -I "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity Test\SMAC\Source\" -I
#        "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity Test\SMAC\Interface\"
#        -I "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity Test\SMAC\Configure\"
#        -I "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity
#        Test\Application\Source\" -I "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity
#        Test\Application\Configure\" -I "C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity Test\PLM\Source\NVM\"
#        -On -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  
#        C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity
#        Test\Debug\List\RNG.lst
#    Object file  =  
#        C:\Users\lsw0lga\Documents\IAR
#        Projects\ConnectivityTest_basic_wkg\Connectivity Test\Debug\Obj\RNG.o
#
###############################################################################

C:\Users\lsw0lga\Documents\IAR Projects\ConnectivityTest_basic_wkg\Connectivity Test\PLM\Source\RNG\RNG.c
      1          /**************************************************************************
      2          * Filename: RNG.c
      3          *
      4          * Description: RNG implementation file for ARM CORTEX-M4 processor
      5          *
      6          * Copyright (c) 2014, Freescale Semiconductor, Inc.
      7          * All rights reserved.
      8          *
      9          * Redistribution and use in source and binary forms, with or without modification,
     10          * are permitted provided that the following conditions are met:
     11          *
     12          * o Redistributions of source code must retain the above copyright notice, this list
     13          *   of conditions and the following disclaimer.
     14          *
     15          * o Redistributions in binary form must reproduce the above copyright notice, this
     16          *   list of conditions and the following disclaimer in the documentation and/or
     17          *   other materials provided with the distribution.
     18          *
     19          * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     20          *   contributors may be used to endorse or promote products derived from this
     21          *   software without specific prior written permission.
     22          *
     23          * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     24          * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     25          * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     26          * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     27          * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     28          * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     29          * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     30          * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     31          * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     32          * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     33          *
     34          ***************************************************************************/
     35          
     36          #include "PortConfig.h"
     37          #include "RNG_Interface.h"
     38          #include "mmcau_interface.h"
     39          
     40          #ifndef gRNG_HwSupport_d
     41          #define gRNG_HwSupport_d 0
     42          #endif
     43          
     44          #if (gRNG_HwSupport_d == 1)
     45            #if !(defined(MCU_MK21DN512) || defined (MCU_MK21DX256) || defined(MCU_MK60D10) || defined(MCU_MK60N512VMD100))
     46              #warning The RNG module is not supported on this processor!
     47            #endif
     48          #else /* gRNG_HwSupport_d == 1 */
     49            extern void PhyGetRandomNo(uint32_t *pRandomNo);

   \                                 In section .bss, align 4
     50            static uint32_t mRandomNumber;
   \                     mRandomNumber:
   \   00000000                      DS8 4
     51          #endif
     52          
     53          
     54          /************************************************************************************
     55          *************************************************************************************
     56          * Private macros
     57          *************************************************************************************
     58          ************************************************************************************/
     59          #define mPRNG_NoOfBits_c      (160)
     60          #define mPRNG_NoOfBytes_c     (mPRNG_NoOfBits_c/8)
     61          #define mPRNG_NoOfLongWords_c (mPRNG_NoOfBits_c/32)
     62          
     63          /************************************************************************************
     64          *************************************************************************************
     65          * Private memory declarations
     66          *************************************************************************************
     67          ************************************************************************************/

   \                                 In section .bss, align 4
     68          static uint32_t XKEY[mPRNG_NoOfLongWords_c];
   \                     XKEY:
   \   00000000                      DS8 20

   \                                 In section .data, align 4
     69          static uint32_t mPRNG_Requests = gRngMaxRequests_d;
   \                     mPRNG_Requests:
   \   00000000   0x000186A0         DC32 100000
     70          
     71          /************************************************************************************
     72          *************************************************************************************
     73          * Public functions
     74          *************************************************************************************
     75          ************************************************************************************/
     76          
     77          /******************************************************************************
     78           * Name: RNG_Init()
     79           * Description: Initialize the RNG HW module
     80           * Parameter(s): -
     81           * Return: Status of the RNG module
     82           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     83          uint8_t RNG_Init()
     84          {
   \                     RNG_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     85          #if (gRNG_HwSupport_d == 1)
     86          
     87            /* Start module clock */
     88          #if (defined(MCU_MK21DN512) || defined(MCU_MK21DX256))
     89            SIM_SCGC6 |= SIM_SCGC6_RNGA_MASK;
     90          #elif defined(MCU_MK60D10)
     91            SIM_SCGC3 |= SIM_SCGC3_RNGA_MASK;
     92          #elif defined(MCU_MK60N512VMD100)
     93            SIM_SCGC3 |= SIM_SCGC3_RNGB_MASK;
     94          #endif
     95          
     96          #if (defined(MCU_MK60D10) || defined(MCU_MK21DN512) || defined(MCU_MK21DX256))
     97            /* Mask Interrupts and start RNG */
     98            RNG_CR = RNG_CR_INTM_MASK | RNG_CR_HA_MASK | RNG_CR_GO_MASK;
     99          #elif defined(MCU_MK60N512VMD100)
    100            /* Execute a SW Reset */
    101            RNG_CMD |= RNG_CMD_SR_MASK;
    102          
    103            /* Mask Interrupts */
    104            RNG_CR = RNG_CR_MASKDONE_MASK | RNG_CR_MASKERR_MASK;
    105          
    106            /* Start Self Test and Seed Generation */
    107            RNG_CMD = RNG_CMD_ST_MASK | RNG_CMD_GS_MASK;
    108          
    109            /* Wait for Self Test and Seed Generation to be done*/
    110            while (RNG_CMD & (RNG_CMD_ST_MASK | RNG_CMD_GS_MASK));
    111          
    112            /* Enable RNG Auto-Reseed */
    113            RNG_CR |= RNG_CR_AR_MASK;
    114          
    115            /* Check for Errors */
    116            if ( RNG_SR & RNG_SR_ERR_MASK )
    117            {
    118              return (uint8_t)(RNG_ESR);
    119            }
    120          #endif
    121          #else /* gRNG_HwSupport_d == 1 */
    122          
    123            PhyGetRandomNo(&mRandomNumber);
   \   00000002   0x....             LDR.N    R0,??DataTable3
   \   00000004   0x.... 0x....      BL       PhyGetRandomNo
    124          
    125          #endif /* gRNG_HwSupport_d == 1 */
    126          
    127            /* Init Successfull */
    128            return gRngSuccess_d;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    129          }
    130          
    131          
    132          /******************************************************************************
    133           * Name: RNG_HwGetRandomNo()
    134           * Description: Read a random number from the HW RNG module
    135           * Parameter(s): [OUT] pRandomNo - pointer to location where the RN will be stored
    136           * Return: status of the RNG module
    137           ******************************************************************************/
    138          #if gRNG_HwSupport_d
    139          static uint8_t RNG_HwGetRandomNo(uint32_t* pRandomNo)
    140          {
    141              /* Check for NULL pointers */
    142              if (NULL == pRandomNo)
    143                return gRngNullPointer_d;
    144          
    145          #if (defined(MCU_MK60D10) || defined(MCU_MK21DN512) || defined(MCU_MK21DX256))
    146              /* If output register is empty, wait for a new random number */
    147              while ( ((RNG_SR & RNG_SR_OREG_LVL_MASK) >> RNG_SR_OREG_LVL_SHIFT) == 0 );
    148          
    149              /* Copy the output of RNG module */
    150              *pRandomNo = RNG_OR;
    151          
    152          #elif defined(MCU_MK60N512VMD100)
    153              /* Check for Errors */
    154              if ( RNG_SR & RNG_SR_ERR_MASK )
    155                return (uint8_t)(RNG_ESR);
    156          
    157              /* If output FIFO is empty, wait for a new random number */
    158              while (((RNG_SR & RNG_SR_FIFO_LVL_MASK) >> RNG_SR_FIFO_LVL_SHIFT) == 0 );
    159          
    160              /* Copy the output of RNG module */
    161              *pRandomNo = RNG_OUT;
    162          #endif
    163          
    164              return gRngSuccess_d;
    165          }
    166          #endif /* gRNG_HwSupport_d */
    167          
    168          
    169          /******************************************************************************
    170           * Name: RNG_GetRandomNo()
    171           * Description: Read a random number from RNG module or from 802.15.4 PHY
    172           * Parameter(s): [OUT] pRandomNo - pointer to location where the RN will be stored
    173           * Return: none
    174           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    175          void RNG_GetRandomNo(uint32_t* pRandomNo)
    176          {
    177          #if (gRNG_HwSupport_d == 1)
    178            (void)RNG_HwGetRandomNo(pRandomNo);
    179          #else
    180            mRandomNumber = (mRandomNumber * 6075) + 1283;
   \                     RNG_GetRandomNo: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable3
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xF241 0x72BB      MOVW     R2,#+6075
   \   00000008   0x4351             MULS     R1,R2,R1
   \   0000000A   0xF201 0x5103      ADDW     R1,R1,#+1283
   \   0000000E   0x....             LDR.N    R2,??DataTable3
   \   00000010   0x6011             STR      R1,[R2, #+0]
    181            *pRandomNo = mRandomNumber;
   \   00000012   0x....             LDR.N    R1,??DataTable3
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x6001             STR      R1,[R0, #+0]
    182          #endif
    183          }
   \   00000018   0x4770             BX       LR               ;; return
    184          
    185          /******************************************************************************
    186           * Name: RNG_SetPseudoRandomNoSeed()
    187           * Description: Initialize seed for the PRNG algorithm.
    188           * Parameter(s):
    189           *      pSeed - pointer to a buffer containing 20 bytes (160 bits).
    190           *             Can be set using the RNG_GetRandomNo() function.
    191           * Return: None
    192           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    193          void RNG_SetPseudoRandomNoSeed(uint8_t* pSeed)
    194          {
    195              uint8_t i;
    196          
    197              mPRNG_Requests = 1;
   \                     RNG_SetPseudoRandomNoSeed: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0x....             LDR.N    R3,??DataTable3_1
   \   00000004   0x601A             STR      R2,[R3, #+0]
    198              for (i=0; i<mPRNG_NoOfBytes_c; i++)
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x0011             MOVS     R1,R2
   \                     ??RNG_SetPseudoRandomNoSeed_0: (+1)
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x2914             CMP      R1,#+20
   \   0000000E   0xDA06             BGE.N    ??RNG_SetPseudoRandomNoSeed_1
    199                  ((uint8_t*)XKEY)[i] = pSeed[i];
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x5C0A             LDRB     R2,[R1, R0]
   \   00000014   0x....             LDR.N    R3,??DataTable3_2
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0x54CA             STRB     R2,[R1, R3]
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
   \   0000001C   0xE7F5             B.N      ??RNG_SetPseudoRandomNoSeed_0
    200          }
   \                     ??RNG_SetPseudoRandomNoSeed_1: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
    201          
    202          /******************************************************************************
    203           * Name: RNG_GetRandomNo()
    204           *
    205           * Description: Pseudo Random Number Generator (PRNG) implementation
    206           *              according to NIST FIPS Publication 186-2, APPENDIX 3
    207           *
    208           * Let x be the signer's private key.  The following may be used to generate m values of x:
    209           *   Step 1. Choose a new, secret value for the seed-key, XKEY.
    210           *   Step 2. In hexadecimal notation let
    211           *     t = 67452301 EFCDAB89 98BADCFE 10325476 C3D2E1F0.
    212           *     This is the initial value for H0 || H1 || H2 || H3 || H4 in the SHS.
    213           *   Step 3. For j = 0 to m - 1 do
    214           *     a. XSEEDj = optional user input.
    215           *     b. XVAL = (XKEY + XSEEDj) mod 2^b
    216           *     c. xj = G(t,XVAL) mod q
    217           *     d. XKEY = (1 + XKEY + xj) mod 2^b
    218           *
    219           * Parameter(s):
    220           *      pOut - pointer to the output buffer
    221           *      outBytes - the number of bytes to be copyed (1-20)
    222           *      pXSEED - optional user SEED. Should be NULL if not used.
    223           *
    224           * Return: The number of bytes copied or -1 if reseed is needed
    225           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    226          int16_t RNG_GetPseudoRandomNo(uint8_t* pOut, uint8_t outBytes, uint8_t* pXSEED)
    227          {
   \                     RNG_GetPseudoRandomNo: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB095             SUB      SP,SP,#+84
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    228              uint32_t i;
    229              uint8_t M[64];
    230              uint32_t out[mPRNG_NoOfLongWords_c];
    231          
    232              if (mPRNG_Requests == gRngMaxRequests_d)
   \   0000000A   0x....             LDR.N    R0,??DataTable3_1
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x....             LDR.N    R1,??DataTable3_3  ;; 0x186a0
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD102             BNE.N    ??RNG_GetPseudoRandomNo_0
    233                  return -1;
   \   00000014   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000018   0xE059             B.N      ??RNG_GetPseudoRandomNo_1
    234              else
    235                  mPRNG_Requests++;
   \                     ??RNG_GetPseudoRandomNo_0: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable3_1
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0x....             LDR.N    R1,??DataTable3_1
   \   00000022   0x6008             STR      R0,[R1, #+0]
    236          
    237              /* a. XSEEDj = optional user input. */
    238              if (pXSEED)
   \   00000024   0x2E00             CMP      R6,#+0
   \   00000026   0xD00B             BEQ.N    ??RNG_GetPseudoRandomNo_2
    239                  /* b. XVAL = (XKEY + XSEEDj) mod 2^b */
    240                  for (i=0; i<20; i++)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x0007             MOVS     R7,R0
   \                     ??RNG_GetPseudoRandomNo_3: (+1)
   \   0000002C   0x2F14             CMP      R7,#+20
   \   0000002E   0xD211             BCS.N    ??RNG_GetPseudoRandomNo_4
    241                      M[i] = ((uint8_t*)XKEY)[i] + pXSEED[i];
   \   00000030   0x....             LDR.N    R0,??DataTable3_2
   \   00000032   0x5C38             LDRB     R0,[R7, R0]
   \   00000034   0x5DB9             LDRB     R1,[R7, R6]
   \   00000036   0x1808             ADDS     R0,R1,R0
   \   00000038   0xA905             ADD      R1,SP,#+20
   \   0000003A   0x5478             STRB     R0,[R7, R1]
   \   0000003C   0x1C7F             ADDS     R7,R7,#+1
   \   0000003E   0xE7F5             B.N      ??RNG_GetPseudoRandomNo_3
    242              else
    243                  for (i=0; i<20; i++)
   \                     ??RNG_GetPseudoRandomNo_2: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x0007             MOVS     R7,R0
   \                     ??RNG_GetPseudoRandomNo_5: (+1)
   \   00000044   0x2F14             CMP      R7,#+20
   \   00000046   0xD205             BCS.N    ??RNG_GetPseudoRandomNo_4
    244                      M[i] = ((uint8_t*)XKEY)[i];
   \   00000048   0x....             LDR.N    R0,??DataTable3_2
   \   0000004A   0x5C38             LDRB     R0,[R7, R0]
   \   0000004C   0xA905             ADD      R1,SP,#+20
   \   0000004E   0x5478             STRB     R0,[R7, R1]
   \   00000050   0x1C7F             ADDS     R7,R7,#+1
   \   00000052   0xE7F7             B.N      ??RNG_GetPseudoRandomNo_5
    245          
    246              /* c. xj = G(t,XVAL) mod q
    247              ***************************/
    248              /* The first b (160) bits of M contain c (XVAL),
    249                 and the remaining bits (512-160) are cleared */
    250              for (i=20; i<64; i++)
   \                     ??RNG_GetPseudoRandomNo_4: (+1)
   \   00000054   0x2014             MOVS     R0,#+20
   \   00000056   0x0007             MOVS     R7,R0
   \                     ??RNG_GetPseudoRandomNo_6: (+1)
   \   00000058   0x2F40             CMP      R7,#+64
   \   0000005A   0xD204             BCS.N    ??RNG_GetPseudoRandomNo_7
    251                  M[i] = 0;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xA905             ADD      R1,SP,#+20
   \   00000060   0x5478             STRB     R0,[R7, R1]
   \   00000062   0x1C7F             ADDS     R7,R7,#+1
   \   00000064   0xE7F8             B.N      ??RNG_GetPseudoRandomNo_6
    252          
    253              /* Prepare block for SHA1 */
    254              M[20] = 0x80; // append 1 bit to the end of the message
   \                     ??RNG_GetPseudoRandomNo_7: (+1)
   \   00000066   0x2080             MOVS     R0,#+128
   \   00000068   0xF88D 0x0028      STRB     R0,[SP, #+40]
    255              M[63] = 160;  // add the size of the message (in bits)
   \   0000006C   0x20A0             MOVS     R0,#+160
   \   0000006E   0xF88D 0x0053      STRB     R0,[SP, #+83]
    256          
    257              /* Apply SHA1 */
    258          #if gMMCAU_Support_d
    259              mmcau_sha1_initialize_output(out);
    260              mmcau_sha1_hash(M, out);
    261              /* OR
    262              mmcau_sha1_update ((uint8_t*)M, 1, (uint32_t*)res); */
    263          #else
    264              sw_sha1_initialize_output(out);
   \   00000072   0xA800             ADD      R0,SP,#+0
   \   00000074   0x.... 0x....      BL       sw_sha1_initialize_output
    265              sw_sha1_hash(M, out);
   \   00000078   0xA900             ADD      R1,SP,#+0
   \   0000007A   0xA805             ADD      R0,SP,#+20
   \   0000007C   0x.... 0x....      BL       sw_sha1_hash
    266              /* OR
    267              sw_sha1_update ((uint8_t*)M, 1, (uint32_t*)res); */
    268          #endif
    269          
    270              /* d. XKEY = (1 + XKEY + xj) mod 2^b */
    271              XKEY[0] += 1;
   \   00000080   0x....             LDR.N    R0,??DataTable3_2
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x1C40             ADDS     R0,R0,#+1
   \   00000086   0x....             LDR.N    R1,??DataTable3_2
   \   00000088   0x6008             STR      R0,[R1, #+0]
    272              for (i=0; i<mPRNG_NoOfLongWords_c; i++)
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x0007             MOVS     R7,R0
   \                     ??RNG_GetPseudoRandomNo_8: (+1)
   \   0000008E   0x2F05             CMP      R7,#+5
   \   00000090   0xD20B             BCS.N    ??RNG_GetPseudoRandomNo_9
    273                  XKEY[i] += out[i];
   \   00000092   0x....             LDR.N    R0,??DataTable3_2
   \   00000094   0xF850 0x0027      LDR      R0,[R0, R7, LSL #+2]
   \   00000098   0xA900             ADD      R1,SP,#+0
   \   0000009A   0xF851 0x1027      LDR      R1,[R1, R7, LSL #+2]
   \   0000009E   0x1808             ADDS     R0,R1,R0
   \   000000A0   0x....             LDR.N    R1,??DataTable3_2
   \   000000A2   0xF841 0x0027      STR      R0,[R1, R7, LSL #+2]
   \   000000A6   0x1C7F             ADDS     R7,R7,#+1
   \   000000A8   0xE7F1             B.N      ??RNG_GetPseudoRandomNo_8
    274          
    275              /* Check if the length provided exceeds the output data size */
    276              if (outBytes > mPRNG_NoOfBytes_c)
   \                     ??RNG_GetPseudoRandomNo_9: (+1)
   \   000000AA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000AC   0x2D15             CMP      R5,#+21
   \   000000AE   0xDB01             BLT.N    ??RNG_GetPseudoRandomNo_10
    277                  outBytes = mPRNG_NoOfBytes_c;
   \   000000B0   0x2014             MOVS     R0,#+20
   \   000000B2   0x0005             MOVS     R5,R0
    278          
    279              /* Copy the generated number */
    280              for (i=0; i < outBytes; i++)
   \                     ??RNG_GetPseudoRandomNo_10: (+1)
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x0007             MOVS     R7,R0
   \                     ??RNG_GetPseudoRandomNo_11: (+1)
   \   000000B8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BA   0x42AF             CMP      R7,R5
   \   000000BC   0xD204             BCS.N    ??RNG_GetPseudoRandomNo_12
    281                  pOut[i] = ((uint8_t*)out)[i];
   \   000000BE   0xA800             ADD      R0,SP,#+0
   \   000000C0   0x5C38             LDRB     R0,[R7, R0]
   \   000000C2   0x5538             STRB     R0,[R7, R4]
   \   000000C4   0x1C7F             ADDS     R7,R7,#+1
   \   000000C6   0xE7F7             B.N      ??RNG_GetPseudoRandomNo_11
    282          
    283              return outBytes;
   \                     ??RNG_GetPseudoRandomNo_12: (+1)
   \   000000C8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000CA   0x0028             MOVS     R0,R5
   \   000000CC   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \                     ??RNG_GetPseudoRandomNo_1: (+1)
   \   000000CE   0xB015             ADD      SP,SP,#+84
   \   000000D0   0xBDF0             POP      {R4-R7,PC}       ;; return
    284          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     mRandomNumber

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     mPRNG_Requests

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     XKEY

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x000186A0         DC32     0x186a0
    285          /********************************** EOF ***************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     104   RNG_GetPseudoRandomNo
       104   -> sw_sha1_hash
       104   -> sw_sha1_initialize_output
       0   RNG_GetRandomNo
       8   RNG_Init
         8   -> PhyGetRandomNo
       0   RNG_SetPseudoRandomNoSeed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
     210  RNG_GetPseudoRandomNo
      26  RNG_GetRandomNo
      12  RNG_Init
      32  RNG_SetPseudoRandomNoSeed
      20  XKEY
       4  mPRNG_Requests
       4  mRandomNumber

 
  24 bytes in section .bss
   4 bytes in section .data
 296 bytes in section .text
 
 296 bytes of CODE memory
  28 bytes of DATA memory

Errors: none
Warnings: none
