###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        20/Mar/2018  09:41:54
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\Driver\usb_dci.c
#    Command line =  
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\Driver\usb_dci.c" -D IAR --preprocess
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Debug\List\" -lC
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Debug\List\" -lB
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Debug\List\"
#        --diag_suppress Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Debug\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\rfrum\OneDrive\2018
#        Spring Semester\Senior Design\Sensor Code\Shanit Origional
#        Code\Connectivity Test\PLM\Configure\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Environment\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Interface\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Generic
#        Services\Interface\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Uart\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\CDC\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\Descriptor\" -I "C:\Users\rfrum\OneDrive\2018
#        Spring Semester\Senior Design\Sensor Code\Shanit Origional
#        Code\Connectivity Test\PLM\Source\USB\Class\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\"
#        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
#        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Radio\MC1324x\PHY\" -I "C:\Users\rfrum\OneDrive\2018
#        Spring Semester\Senior Design\Sensor Code\Shanit Origional
#        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\Sys Common\"
#        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Application\Source\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Application\Configure\"
#        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -On
#    List file    =  
#        C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Debug\List\usb_dci.lst
#    Object file  =  
#        C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Debug\Obj\usb_dci.o
#
###############################################################################

C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\usb_dci.c
      1          /******************************************************************************
      2           *
      3           * Freescale Semiconductor Inc.
      4           * (c) Copyright 2004-2012 Freescale Semiconductor, Inc.
      5           * ALL RIGHTS RESERVED.
      6           *
      7           ******************************************************************************
      8           *
      9           * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
     10           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
     11           * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
     12           * IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
     13           * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     14           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     15           * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     16           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
     17           * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
     18           * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
     19           * THE POSSIBILITY OF SUCH DAMAGE.
     20           *
     21           **************************************************************************//*!
     22           *
     23           * @file usb_dci_kinetis.c
     24           *
     25           * @author
     26           *
     27           * @version
     28           *
     29           * @date
     30           *
     31           * @brief The file contains Kinetis USB stack controller layer implementation.
     32           *
     33           *****************************************************************************/
     34          
     35          /******************************************************************************
     36           * Includes
     37           *****************************************************************************/
     38          #include <string.h>
     39          #include "USB_Interface.h"   
     40          #include "usb_dciapi.h" /* USB DCI API Header File */
     41          #include "usb_devapi.h" /* USB Device API Header File */
     42          #include "usb_dci.h"    /* USB DCI Header File */
     43          #include "usb_bdt.h"    /* USB BDT Structure Header File */
     44          #include "usb_class.h"
     45          #include "USB.h"
     46          #include "Utilities_Interface.h"
     47          #if gUsbIncluded_d   
     48          /*****************************************************************************
     49           * Constant and Macro's - None
     50           *****************************************************************************/
     51          /*****************************************************************************
     52           * Local Types - None
     53           *****************************************************************************/
     54          
     55          /****************************************************************************
     56           * Global Variables
     57           ****************************************************************************/
     58          /* location for BDT Table and buff */
     59          #if (defined(__CWCC__)||defined(__GNUC__))
     60          	__attribute__((__aligned__(512)))
     61          #elif defined(__IAR_SYSTEMS_ICC__)
     62          	#pragma data_alignment = 512
     63          #endif
     64          
     65          /* BDT Map Structure */
     66          #if defined __CC_ARM
     67             __align(512) static bdtMap_t gBDTMap; 
     68          #else

   \                                 In section .bss, align 512
     69             static bdtMap_t gBDTMap;      
   \                     gBDTMap:
   \   00000000                      DS8 512
     70          #endif
     71          /* endpoint buffers allocated by default */

   \                                 In section .bss, align 4
     72          static uint8_t gaEndpBuffers[gSizeOfUsbRam_d];   
   \                     gaEndpBuffers:
   \   00000000                      DS8 80
     73          /* Table of bdtElem_t used for endpoint management */

   \                                 In section .bss, align 4
     74          static bdtElem_t gBdtElem[gNumUsbEp_d];
   \                     gBdtElem:
   \   00000000                      DS8 92
     75          
     76          /* structure  used for endpoint buffers allocation and for binding the bdt map with bdt elem */
     77          static struct  endpCtl_tag
     78          {
     79          	uint32_t            endpBuffAddrAlloc;
     80            uint8_t             bdtElemIndexMap[gUsbMaxBdtIndex_d>>1];
     81          	uint8_t             bdtElemIndexAlloc;            

   \                                 In section .bss, align 4
     82          } endpCtl;
   \                     endpCtl:
   \   00000000                      DS8 40
     83          /* stores Controller ID */

   \                                 In section .bss, align 1
     84          static uint8_t gDciControllerId = 0;
   \                     gDciControllerId:
   \   00000000                      DS8 1
     85          /* Transfer direction */

   \                                 In section .data, align 1
     86          static uint8_t gTrfDirection = gUsbTrfDirUnknown_d;
   \                     gTrfDirection:
   \   00000000   0xFF               DC8 255
     87          
     88          /*****************************************************************************
     89           * Local Functions Prototypes
     90           *****************************************************************************/
     91          static void USB_DCI_BusResetHandler(void);
     92          
     93          static uint8_t USB_DCI_GetBDTMapIndex(uint8_t ep_num,
     94                                              uint8_t direction,
     95                                              bool_t odd);
     96          static uint8_t USB_DCI_GetBDTElemIndex (uint8_t bdtMapIndex);
     97          static uint8_t USB_DCI_ValidateParam(uint8_t ep_num,
     98                                              uint8_t direction,
     99                                              bool_t odd);
    100          static void USB_DCI_PrepareSendData(pBuffDsc_t pBuffDsc,
    101                                              pBdtElem_t pBdtElem);
    102          static void USB_DCI_BusTokenCplHandler(uint8_t stat,
    103                                              usbDeviceEvent_t* event);
    104          
    105          #ifdef USB_LOWPOWERMODE
    106          	static void Enter_StopMode(STOP_MODE stop_mode);
    107          #endif
    108          /*****************************************************************************
    109           * Local Variables - None
    110           *****************************************************************************/
    111          
    112          /*****************************************************************************
    113           * Local Functions
    114           *****************************************************************************/
    115          
    116          /**************************************************************************//*!
    117           *
    118           * @name  USB_DCI_BusResetHandler
    119           *
    120           * @brief The function handles Bus Reset Interrupt
    121           *
    122           * @param  None
    123           *
    124           * @return None
    125           *
    126           ******************************************************************************
    127           * This functions is called when USB Bus Reset event is received on USB Bus.
    128           * This function clears all the errors conditions and reinit Global data
    129           * structures. Also resets USB device controller.
    130           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    131            static void USB_DCI_BusResetHandler (void)
    132            {
   \                     USB_DCI_BusResetHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    133              USB0_ERRSTAT = gUsbDciErrStat_ClearAll_c;  /* clear USB error flag */
   \   00000002   0x20BF             MOVS     R0,#+191
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x40072088
   \   00000008   0x7008             STRB     R0,[R1, #+0]
    134              USB0_CTL |= USB_CTL_ODDRST_MASK;                /* Reset to Even buffer */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40072094
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0x40072094
   \   00000018   0x7008             STRB     R0,[R1, #+0]
    135              USB0_ADDR = 0;                       /* reset to default address */
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable16_2  ;; 0x40072098
   \   00000020   0x7008             STRB     R0,[R1, #+0]
    136              USB0_USBCTRL = 0x00;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable16_3  ;; 0x40072100
   \   00000028   0x7008             STRB     R0,[R1, #+0]
    137              
    138              MemorySet( gBdtElem,  (uint8_t)gUninitialisedVal_d, (uint16_t)sizeof(gBdtElem));
   \   0000002A   0x225A             MOVS     R2,#+90
   \   0000002C   0x21FF             MOVS     R1,#+255
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \   00000032   0x.... 0x....      BL       MemorySet
    139              endpCtl.bdtElemIndexAlloc = 0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   0000003C   0xF881 0x0024      STRB     R0,[R1, #+36]
    140              endpCtl.endpBuffAddrAlloc = (uint32_t)gaEndpBuffers;
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   00000048   0x6008             STR      R0,[R1, #+0]
    141              MemorySet(endpCtl.bdtElemIndexMap, (uint8_t)gUsbInvalidBdtIndex_d, (uint16_t)sizeof(endpCtl.bdtElemIndexMap));
   \   0000004A   0x2220             MOVS     R2,#+32
   \   0000004C   0x21FF             MOVS     R1,#+255
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable16_7
   \   00000052   0x.... 0x....      BL       MemorySet
    142              MemorySet(&gBDTMap, 0, (uint16_t)sizeof(gBDTMap));     
   \   00000056   0xF44F 0x7200      MOV      R2,#+512
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   00000060   0x.... 0x....      BL       MemorySet
    143              gTrfDirection = gUsbTrfDirUnknown_d;
   \   00000064   0x20FF             MOVS     R0,#+255
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable16_9
   \   0000006A   0x7008             STRB     R0,[R1, #+0]
    144              USB0_CTL &= ~USB_CTL_ODDRST_MASK;
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40072094
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0xF010 0x00FD      ANDS     R0,R0,#0xFD
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0x40072094
   \   0000007A   0x7008             STRB     R0,[R1, #+0]
    145              USB0_USBTRC0 |= 0x40;            
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable16_10  ;; 0x4007210c
   \   00000080   0x7800             LDRB     R0,[R0, #+0]
   \   00000082   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable16_10  ;; 0x4007210c
   \   0000008A   0x7008             STRB     R0,[R1, #+0]
    146              USB0_ERREN = gUsbDciErrEnb_EnableAll_c;   /* Enable All Error Interrupts */
   \   0000008C   0x20BF             MOVS     R0,#+191
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable16_11  ;; 0x4007208c
   \   00000092   0x7008             STRB     R0,[R1, #+0]
    147              USB0_INTEN = gUsbDciIntEnb_IntEnbAtBusReset_c; /* Enable All Interrupts except RESUME */
   \   00000094   0x209F             MOVS     R0,#+159
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable16_12  ;; 0x40072084
   \   0000009A   0x7008             STRB     R0,[R1, #+0]
    148              USB0_CTL &= ~USB_CTL_TXSUSPENDTOKENBUSY_MASK;
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40072094
   \   000000A0   0x7800             LDRB     R0,[R0, #+0]
   \   000000A2   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0x40072094
   \   000000AA   0x7008             STRB     R0,[R1, #+0]
    149            }
   \   000000AC   0xBD01             POP      {R0,PC}          ;; return
    150                  
    151          /**************************************************************************//*!
    152           *
    153           * @name  USB_DCI_GetBDTMapIndex
    154           *
    155           * @brief The function maps endpoint number and direction to bdt index
    156           *
    157           * @param  ep_num   : Endpoint Number
    158           * @param  direction: Endpoint direction
    159           * @param  odd      : Odd or even buffer
    160           *
    161           * @return bdt index         : Mapped bdt index
    162           *         gUsbInvalidBdtIndex_d : In case of error
    163           *
    164           ******************************************************************************
    165           * This function returns BDT Index from Endpoint number, direction,
    166           * odd/even buffer
    167           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    168            static uint8_t USB_DCI_GetBDTMapIndex 
    169              (
    170               uint8_t epNum,     /* [IN] Endpoint Number */
    171               uint8_t direction,  /* [IN] Endpoint direction */
    172               bool_t odd        /* [IN] Odd or even buffer */
    173              )
    174              {
   \                     USB_DCI_GetBDTMapIndex: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0003             MOVS     R3,R0
    175                uint8_t bdtMapIndex = gUsbInvalidBdtIndex_d;
   \   00000004   0x20FF             MOVS     R0,#+255
    176                
    177                if(epNum < gNumMaxEnpNumber_d)
   \   00000006   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000008   0x2B10             CMP      R3,#+16
   \   0000000A   0xDA09             BGE.N    ??USB_DCI_GetBDTMapIndex_0
    178                {
    179                  /* per endpoint 4 bdt_index -- 2 for recv 2 for send */
    180                  bdtMapIndex = (epNum <<2) ;
   \   0000000C   0x009C             LSLS     R4,R3,#+2
   \   0000000E   0x0020             MOVS     R0,R4
    181                  if(direction == gUsbEpDirection_In_c)
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x2901             CMP      R1,#+1
   \   00000014   0xD100             BNE.N    ??USB_DCI_GetBDTMapIndex_1
    182                  {
    183                    bdtMapIndex += 2;
   \   00000016   0x1C80             ADDS     R0,R0,#+2
    184                  }
    185                  if(odd)
   \                     ??USB_DCI_GetBDTMapIndex_1: (+1)
   \   00000018   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD000             BEQ.N    ??USB_DCI_GetBDTMapIndex_0
    186                  {
    187                    bdtMapIndex++;
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
    188                  }
    189                }
    190                return bdtMapIndex;
   \                     ??USB_DCI_GetBDTMapIndex_0: (+1)
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0xBC10             POP      {R4}
   \   00000024   0x4770             BX       LR               ;; return
    191              }
    192          
    193          /**************************************************************************//*!
    194           *
    195           * @name  USB_DCI_GetBDTElemIndex
    196           *
    197           * @brief The function returns the index of the associated gBdtElem
    198           *
    199           * @param  bdtMapIndex   : the index in the buffer descriptor table
    200           * 
    201           *
    202           * @return bdtElemIndex          : bdtElemIndex associated with the bdtMapIndex received as param
    203           *         gUsbInvalidBdtIndex_d : In case of error
    204           *
    205           ******************************************************************************
    206           * This function returns BDT Index from Endpoint number, direction,
    207           * odd/even buffer
    208           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    209            static uint8_t USB_DCI_GetBDTElemIndex (uint8_t bdtMapIndex)
    210            {
   \                     USB_DCI_GetBDTElemIndex: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    211              uint8_t bdtElemIndex;
    212              if(bdtMapIndex >= gUsbMaxBdtIndex_d)
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2940             CMP      R1,#+64
   \   00000006   0xDB01             BLT.N    ??USB_DCI_GetBDTElemIndex_0
    213              {
    214                return gUsbInvalidBdtIndex_d;
   \   00000008   0x20FF             MOVS     R0,#+255
   \   0000000A   0xE00D             B.N      ??USB_DCI_GetBDTElemIndex_1
    215              } 
    216              bdtElemIndex = endpCtl.bdtElemIndexMap[bdtMapIndex>>1];
   \                     ??USB_DCI_GetBDTElemIndex_0: (+1)
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0xEB10 0x0061      ADDS     R0,R0,R1, ASR #+1
   \   00000016   0x7900             LDRB     R0,[R0, #+4]
   \   00000018   0x0002             MOVS     R2,R0
    217              if(bdtElemIndex < gNumUsbEp_d)
   \   0000001A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001C   0x2A05             CMP      R2,#+5
   \   0000001E   0xDA02             BGE.N    ??USB_DCI_GetBDTElemIndex_2
    218              {
    219                return bdtElemIndex;
   \   00000020   0x0010             MOVS     R0,R2
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0xE000             B.N      ??USB_DCI_GetBDTElemIndex_1
    220              }
    221              return gUsbInvalidBdtIndex_d;
   \                     ??USB_DCI_GetBDTElemIndex_2: (+1)
   \   00000026   0x20FF             MOVS     R0,#+255
   \                     ??USB_DCI_GetBDTElemIndex_1: (+1)
   \   00000028   0x4770             BX       LR               ;; return
    222            }
    223          /**************************************************************************//*!
    224           *
    225           * @name  USB_DCI_ValidateParam
    226           *
    227           * @brief The function validates endpoint number & direction parameters
    228           *        and returns bdt index.
    229           *
    230           * @param  ep_num   : Endpoint Number
    231           * @param  direction: Endpoint direction
    232           * @param  odd      : odd or even buffer
    233           *
    234           * @return bdt index         : mapped bdt index
    235           *         gUsbInvalidBdtIndex_d : incase of error
    236           *
    237           ******************************************************************************
    238           * This function validates endpoint parameters and returns bdt index
    239           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    240            static uint8_t USB_DCI_ValidateParam 
    241              (
    242               uint8_t epNum,     /* [IN] Endpoint Number */
    243               uint8_t direction,  /* [IN] Endpoint direction */
    244               bool_t odd        /* [IN] Odd or even buffer */
    245                 )
    246              {
   \                     USB_DCI_ValidateParam: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    247                /* Get bdt index mapped to endpoint number-direction and odd/even buffer */
    248                uint8_t bdtElemIndex;
    249                uint8_t bdtMapIndex = USB_DCI_GetBDTMapIndex(epNum, direction, odd);
   \   0000000A   0x0032             MOVS     R2,R6
   \   0000000C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x.... 0x....      BL       USB_DCI_GetBDTMapIndex
   \   0000001A   0x4680             MOV      R8,R0
    250                
    251                if(bdtMapIndex  == gUsbInvalidBdtIndex_d)
   \   0000001C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000020   0xF1B8 0x0FFF      CMP      R8,#+255
   \   00000024   0xD101             BNE.N    ??USB_DCI_ValidateParam_0
    252                  return gUsbInvalidBdtIndex_d;
   \   00000026   0x20FF             MOVS     R0,#+255
   \   00000028   0xE018             B.N      ??USB_DCI_ValidateParam_1
    253                bdtElemIndex = USB_DCI_GetBDTElemIndex(bdtMapIndex);
   \                     ??USB_DCI_ValidateParam_0: (+1)
   \   0000002A   0x4640             MOV      R0,R8
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x.... 0x....      BL       USB_DCI_GetBDTElemIndex
   \   00000032   0x0007             MOVS     R7,R0
    254                if(bdtElemIndex  == gUsbInvalidBdtIndex_d)
   \   00000034   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000036   0x2FFF             CMP      R7,#+255
   \   00000038   0xD101             BNE.N    ??USB_DCI_ValidateParam_2
    255                  return gUsbInvalidBdtIndex_d;
   \   0000003A   0x20FF             MOVS     R0,#+255
   \   0000003C   0xE00E             B.N      ??USB_DCI_ValidateParam_1
    256                if(gBdtElem[bdtElemIndex].epSize == (uint16_t)gUninitialisedVal_d)
   \                     ??USB_DCI_ValidateParam_2: (+1)
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \   00000042   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000044   0x2112             MOVS     R1,#+18
   \   00000046   0xFB01 0x0007      MLA      R0,R1,R7,R0
   \   0000004A   0x8800             LDRH     R0,[R0, #+0]
   \   0000004C   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD101             BNE.N    ??USB_DCI_ValidateParam_3
    257                {
    258                  return gUsbInvalidBdtIndex_d;
   \   00000054   0x20FF             MOVS     R0,#+255
   \   00000056   0xE001             B.N      ??USB_DCI_ValidateParam_1
    259                } 
    260                
    261                return bdtMapIndex;
   \                     ??USB_DCI_ValidateParam_3: (+1)
   \   00000058   0x4640             MOV      R0,R8
   \   0000005A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DCI_ValidateParam_1: (+1)
   \   0000005C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    262              }
    263          
    264          /**************************************************************************//*!
    265           *
    266           * @name  USB_DCI_PrepareSendData
    267           *
    268           * @brief The function sets up the BDT for Send
    269           *
    270           * @param  buffer_dsc   : Pointer to buffer descriptor element in USB_RAM
    271           * @param  bdt_elem     : Pointer to per endpoint/direction structure
    272           *
    273           * @return None
    274           *
    275           ******************************************************************************
    276           * This functions configures Buffer Descriptor (Address and Count)
    277           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    278          static void USB_DCI_PrepareSendData (
    279              pBuffDsc_t pBuffDsc,  /* [OUT] Pointer to buffer descriptor
    280                                          element in USB_RAM */
    281              pBdtElem_t pBdtElem     /* [IN] Pointer to per endpoint/direction
    282                                          structure */
    283          )
    284          {
   \                     USB_DCI_PrepareSendData: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    285              uint8_t* pBuff = pBdtElem->pAppBuffer + pBdtElem->currOffset;
   \   00000002   0xF8D1 0x2006      LDR      R2,[R1, #+6]
   \   00000006   0x898B             LDRH     R3,[R1, #+12]
   \   00000008   0x189A             ADDS     R2,R3,R2
    286              uint16_t currentCount = 0;
   \   0000000A   0x2300             MOVS     R3,#+0
    287          
    288              /* adjust size based on the input at the init endpoint */
    289              if((pBdtElem->appLen - pBdtElem->currOffset) > pBdtElem->epSize)
   \   0000000C   0x880C             LDRH     R4,[R1, #+0]
   \   0000000E   0x894D             LDRH     R5,[R1, #+10]
   \   00000010   0x898E             LDRH     R6,[R1, #+12]
   \   00000012   0x1BAD             SUBS     R5,R5,R6
   \   00000014   0x42AC             CMP      R4,R5
   \   00000016   0xDA02             BGE.N    ??USB_DCI_PrepareSendData_0
    290              {
    291                  /* If size of packet is greater than endpoint buffer size */
    292                  currentCount = pBdtElem->epSize;
   \   00000018   0x880C             LDRH     R4,[R1, #+0]
   \   0000001A   0x0023             MOVS     R3,R4
   \   0000001C   0xE003             B.N      ??USB_DCI_PrepareSendData_1
    293              }
    294              else
    295              {
    296                  /* If size of packet is smaller than endpoint buffer size */
    297                  currentCount = (uint16_t)(pBdtElem->appLen - pBdtElem->currOffset);
   \                     ??USB_DCI_PrepareSendData_0: (+1)
   \   0000001E   0x894C             LDRH     R4,[R1, #+10]
   \   00000020   0x898D             LDRH     R5,[R1, #+12]
   \   00000022   0x1B64             SUBS     R4,R4,R5
   \   00000024   0x0023             MOVS     R3,R4
    298              }
    299              pBuffDsc->cnt = currentCount;
   \                     ??USB_DCI_PrepareSendData_1: (+1)
   \   00000026   0x8043             STRH     R3,[R0, #+2]
    300              pBuffDsc->addr = (uint32_t)pBuff;
   \   00000028   0x6042             STR      R2,[R0, #+4]
    301          }
   \   0000002A   0xBC70             POP      {R4-R6}
   \   0000002C   0x4770             BX       LR               ;; return
    302          
    303          /*****************************************************************************
    304           * Global Functions
    305           *****************************************************************************/
    306          
    307          /**************************************************************************//*!
    308           *
    309           * @name  USB_DCI_Init
    310           *
    311           * @brief The function initializes the Controller layer
    312           *
    313           * @param controller_ID : Controller ID
    314           *
    315           * @return status
    316           *         gUsbErr_NoError_c    : Always
    317           ******************************************************************************
    318           * Initializes the USB controller
    319           *****************************************************************************/ 

   \                                 In section .text, align 2, keep-with-next
    320          uint8_t USB_DCI_Init 
    321          (
    322          uint8_t    controllerId   /* [IN] Controller ID */
    323          )
    324          {
   \                     USB_DCI_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    325          	/* Select System Clock and Disable Weak Pull Downs */
    326          	USB0_USBCTRL = 0x00;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable16_3  ;; 0x40072100
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
    327          	/* save the controller_ID for future use */
    328            gDciControllerId = controllerId;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   00000010   0x7004             STRB     R4,[R0, #+0]
    329            /* Clear bdt elem structure */
    330            MemorySet( gBdtElem,  (uint8_t)gUninitialisedVal_d, (uint16_t)sizeof(gBdtElem));
   \   00000012   0x225A             MOVS     R2,#+90
   \   00000014   0x21FF             MOVS     R1,#+255
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \   0000001A   0x.... 0x....      BL       MemorySet
    331            endpCtl.bdtElemIndexAlloc = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   00000024   0xF881 0x0024      STRB     R0,[R1, #+36]
    332            endpCtl.endpBuffAddrAlloc = (uint32_t)gaEndpBuffers;
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   00000030   0x6008             STR      R0,[R1, #+0]
    333            MemorySet(endpCtl.bdtElemIndexMap, (uint8_t)gUsbInvalidBdtIndex_d, (uint16_t)sizeof(endpCtl.bdtElemIndexMap));
   \   00000032   0x2220             MOVS     R2,#+32
   \   00000034   0x21FF             MOVS     R1,#+255
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable16_7
   \   0000003A   0x.... 0x....      BL       MemorySet
    334            /* Clear Memory for BDT and buffer Data */
    335            MemorySet(&gBDTMap, 0, (uint16_t)sizeof(gBDTMap));        
   \   0000003E   0xF44F 0x7200      MOV      R2,#+512
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   00000048   0x.... 0x....      BL       MemorySet
    336            gTrfDirection = gUsbTrfDirUnknown_d;
   \   0000004C   0x20FF             MOVS     R0,#+255
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable16_9
   \   00000052   0x7008             STRB     R0,[R1, #+0]
    337            USB0_USBTRC0 |= 0x40;
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable16_10  ;; 0x4007210c
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable16_10  ;; 0x4007210c
   \   00000062   0x7008             STRB     R0,[R1, #+0]
    338            /* Set the BDT Table address, Need to be on 512 byte boundary */
    339            /* D8 Bit is masked in BDT_PAGE_01 */
    340            USB0_BDTPAGE1 = (uint8_t)(((uint32_t)&gBDTMap >> 8)& 0xFE);
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   00000068   0x0A00             LSRS     R0,R0,#+8
   \   0000006A   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x4007209c
   \   00000072   0x7008             STRB     R0,[R1, #+0]
    341            USB0_BDTPAGE2 = (uint8_t)((uint32_t)&gBDTMap >> 16);
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   00000078   0x0C00             LSRS     R0,R0,#+16
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable17_1  ;; 0x400720b0
   \   0000007E   0x7008             STRB     R0,[R1, #+0]
    342            USB0_BDTPAGE3 = (uint8_t)((uint32_t)&gBDTMap >> 24);
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   00000084   0x0E00             LSRS     R0,R0,#+24
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable17_2  ;; 0x400720b4
   \   0000008A   0x7008             STRB     R0,[R1, #+0]
    343            /* Pull Up configuration */
    344            USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG_MASK;
   \   0000008C   0x2010             MOVS     R0,#+16
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable17_3  ;; 0x40072108
   \   00000092   0x7008             STRB     R0,[R1, #+0]
    345            USB0_CTL = USB_CTL_USBENSOFEN_MASK; 	/* Enable USB module */
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0x40072094
   \   0000009A   0x7008             STRB     R0,[R1, #+0]
    346            USB0_ISTAT = gUsbDciIntStat_ClearAll_c;      	/* Clear USB interrupts*/
   \   0000009C   0x20BF             MOVS     R0,#+191
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable17_4  ;; 0x40072080
   \   000000A2   0x7008             STRB     R0,[R1, #+0]
    347            /* Remove suspend state */
    348            USB0_USBCTRL &= ~USB_USBCTRL_SUSP_MASK;
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x40072100
   \   000000A8   0x7800             LDRB     R0,[R0, #+0]
   \   000000AA   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable16_3  ;; 0x40072100
   \   000000B2   0x7008             STRB     R0,[R1, #+0]
    349            /* Enable USB RESET Interrupt */
    350            USB0_INTEN |= USB_INTEN_USBRSTEN_MASK;
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable17_5  ;; 0x40072084
   \   000000B8   0x7800             LDRB     R0,[R0, #+0]
   \   000000BA   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable17_5  ;; 0x40072084
   \   000000C2   0x7008             STRB     R0,[R1, #+0]
    351            /* Enable USB Sleep Interrupt */
    352            USB0_INTEN |= USB_INTEN_SLEEPEN_MASK;
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable17_5  ;; 0x40072084
   \   000000C8   0x7800             LDRB     R0,[R0, #+0]
   \   000000CA   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable17_5  ;; 0x40072084
   \   000000D2   0x7008             STRB     R0,[R1, #+0]
    353            // USB0_OTGCTL = USB_OTGCTL_DPHIGH_MASK | USB_OTGCTL_OTGEN_MASK;
    354            return gUsbErr_NoError_c;
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0xBD10             POP      {R4,PC}          ;; return
    355          }
    356          
    357          /**************************************************************************//*!
    358           *
    359           * @name  USB_DCI_DeInit
    360           *
    361           * @brief The function de-initializes the Controller layer
    362           *
    363           * @param controller_ID : Controller ID
    364           *
    365           * @return status
    366           *         gUsbErr_NoError_c    : Always
    367           ******************************************************************************
    368           * Initializes the USB controller
    369           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    370          uint8_t USB_DCI_DeInit(uint8_t    controllerId)
    371          {
   \                     USB_DCI_DeInit: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    372            uint8_t i;
    373            (void)controllerId;
    374            
    375            USB0_INTEN = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      LDR.W    R3,??DataTable16_12  ;; 0x40072084
   \   00000008   0x7018             STRB     R0,[R3, #+0]
    376            USB0_ERREN = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable16_11  ;; 0x4007208c
   \   00000010   0x7018             STRB     R0,[R3, #+0]
    377            USB0_CONTROL = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      LDR.W    R3,??DataTable17_3  ;; 0x40072108
   \   00000018   0x7018             STRB     R0,[R3, #+0]
    378            USB0_USBCTRL = 0xc0;
   \   0000001A   0x20C0             MOVS     R0,#+192
   \   0000001C   0x.... 0x....      LDR.W    R3,??DataTable16_3  ;; 0x40072100
   \   00000020   0x7018             STRB     R0,[R3, #+0]
    379            for(i=0;i<gNumMaxEnpNumber_d;i++)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x0002             MOVS     R2,R0
   \                     ??USB_DCI_DeInit_0: (+1)
   \   00000026   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000028   0x2A10             CMP      R2,#+16
   \   0000002A   0xDA05             BGE.N    ??USB_DCI_DeInit_1
    380            {
    381              USB_ENDPT_REG(USB0_BASE_PTR,0) =0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x.... 0x....      LDR.W    R3,??DataTable17_6  ;; 0x400720c0
   \   00000032   0x7018             STRB     R0,[R3, #+0]
    382            }
   \   00000034   0x1C52             ADDS     R2,R2,#+1
   \   00000036   0xE7F6             B.N      ??USB_DCI_DeInit_0
    383          	USB0_USBTRC0 = 0;
   \                     ??USB_DCI_DeInit_1: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      LDR.W    R3,??DataTable16_10  ;; 0x4007210c
   \   0000003E   0x7018             STRB     R0,[R3, #+0]
    384            USB0_ADDR = 0;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x.... 0x....      LDR.W    R3,??DataTable16_2  ;; 0x40072098
   \   00000046   0x7018             STRB     R0,[R3, #+0]
    385            /* Clear USB interrupts*/
    386          	USB0_ISTAT = gUsbDciIntStat_ClearAll_c;
   \   00000048   0x20BF             MOVS     R0,#+191
   \   0000004A   0x.... 0x....      LDR.W    R3,??DataTable17_4  ;; 0x40072080
   \   0000004E   0x7018             STRB     R0,[R3, #+0]
    387            USB0_ERRSTAT = gUsbDciErrStat_ClearAll_c;
   \   00000050   0x20BF             MOVS     R0,#+191
   \   00000052   0x.... 0x....      LDR.W    R3,??DataTable16  ;; 0x40072088
   \   00000056   0x7018             STRB     R0,[R3, #+0]
    388            USB0_CTL =0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      LDR.W    R3,??DataTable17_7  ;; 0x40072094
   \   0000005E   0x7018             STRB     R0,[R3, #+0]
    389          	
    390          	
    391          	
    392            
    393            
    394            return gUsbErr_NoError_c;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x4770             BX       LR               ;; return
    395          }
    396          
    397          /**************************************************************************//*!
    398           *
    399           * @name  USB_DCI_Init_EndPoint
    400           *
    401           * @brief The function initializes an endpoint
    402           *
    403           * @param controller_ID : Controller ID
    404           * @param ep_ptr        : Pointer to EndPoint Structures
    405           * @param flag          : Zero Termination
    406           *
    407           * @return status
    408           *         gUsbErr_NoError_c                    : When Successfull
    409           *         USBERR_EP_INIT_FAILED     : When Error
    410           ******************************************************************************
    411           *
    412           * This function initializes an endpoint and the Bufffer Descriptor Table
    413           * entry associated with it. Incase the input parameters are invalid it will
    414           * return USBERR_EP_INIT_FAILED error.
    415           *
    416           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    417          uint8_t USB_DCI_InitEndpoint
    418          (
    419          uint8_t               controller_ID,/* [IN] Controller ID */
    420          usbEpStruct_t*    pEpStruct,       /* [IN] Pointer to Endpoint structure,
    421                                                (endpoint number,
    422                                                endpoint type,
    423                                                endpoint direction,
    424                                                max packet size) */
    425          bool_t              flag          /* [IN] Zero Termination */
    426          )
    427          {
   \                     USB_DCI_InitEndpoint: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
    428            
    429            uint8_t bdtMapIndex;
    430            uint8_t bdtElemIndex;
    431            pBuffDsc_t  pBuffDsc;
    432            pBdtElem_t pBdtElem;    
    433            uint8_t epNum = pEpStruct->number;
   \   0000000A   0xF894 0xA000      LDRB     R10,[R4, #+0]
    434            uint8_t direction = pEpStruct->direction;
   \   0000000E   0xF894 0xB002      LDRB     R11,[R4, #+2]
    435            uint32_t epCtrl[2] = {gUsbEndpt_Out_c, gUsbEndpt_In_c};
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable17_8
   \   00000018   0xC90C             LDM      R1!,{R2,R3}
   \   0000001A   0xC00C             STM      R0!,{R2,R3}
   \   0000001C   0x3908             SUBS     R1,R1,#+8
   \   0000001E   0x3808             SUBS     R0,R0,#+8
    436            
    437            if((pEpStruct->type > gUsbEpType_Interrupt_c) || (pEpStruct->direction > gUsbEpDirection_In_c)) 
   \   00000020   0x7860             LDRB     R0,[R4, #+1]
   \   00000022   0x2804             CMP      R0,#+4
   \   00000024   0xDA02             BGE.N    ??USB_DCI_InitEndpoint_0
   \   00000026   0x78A0             LDRB     R0,[R4, #+2]
   \   00000028   0x2802             CMP      R0,#+2
   \   0000002A   0xDB01             BLT.N    ??USB_DCI_InitEndpoint_1
    438            {
    439              return gUsbErr_EpInitFailed_c;
   \                     ??USB_DCI_InitEndpoint_0: (+1)
   \   0000002C   0x2095             MOVS     R0,#+149
   \   0000002E   0xE0DC             B.N      ??USB_DCI_InitEndpoint_2
    440            } 
    441            bdtMapIndex = USB_DCI_GetBDTMapIndex(epNum, direction, gUsbBdtEvenBuffer_c);
   \                     ??USB_DCI_InitEndpoint_1: (+1)
   \   00000030   0x2200             MOVS     R2,#+0
   \   00000032   0x4659             MOV      R1,R11
   \   00000034   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000036   0x4650             MOV      R0,R10
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x.... 0x....      BL       USB_DCI_GetBDTMapIndex
   \   0000003E   0x0006             MOVS     R6,R0
    442            if(bdtMapIndex  == gUsbInvalidBdtIndex_d)
   \   00000040   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000042   0x2EFF             CMP      R6,#+255
   \   00000044   0xD101             BNE.N    ??USB_DCI_InitEndpoint_3
    443            {
    444              return gUsbErr_EpInitFailed_c;
   \   00000046   0x2095             MOVS     R0,#+149
   \   00000048   0xE0CF             B.N      ??USB_DCI_InitEndpoint_2
    445            }
    446            bdtElemIndex = USB_DCI_GetBDTElemIndex(bdtMapIndex); 
   \                     ??USB_DCI_InitEndpoint_3: (+1)
   \   0000004A   0x0030             MOVS     R0,R6
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0x.... 0x....      BL       USB_DCI_GetBDTElemIndex
   \   00000052   0x0007             MOVS     R7,R0
    447            if((bdtElemIndex  != gUsbInvalidBdtIndex_d) &&
    448               (gBdtElem[bdtElemIndex].epSize != (uint16_t)gUninitialisedVal_d))
   \   00000054   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000056   0x2FFF             CMP      R7,#+255
   \   00000058   0xD00C             BEQ.N    ??USB_DCI_InitEndpoint_4
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \   0000005E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000060   0x2112             MOVS     R1,#+18
   \   00000062   0xFB01 0x0007      MLA      R0,R1,R7,R0
   \   00000066   0x8800             LDRH     R0,[R0, #+0]
   \   00000068   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000006C   0x4288             CMP      R0,R1
   \   0000006E   0xD001             BEQ.N    ??USB_DCI_InitEndpoint_4
    449            {
    450              return gUsbErr_EpInitFailed_c;
   \   00000070   0x2095             MOVS     R0,#+149
   \   00000072   0xE0BA             B.N      ??USB_DCI_InitEndpoint_2
    451            }
    452            /* if the max packet size is greater than the max buffer size */    
    453            if(pEpStruct->size > gUsbMaxEpBufferSize_d)
   \                     ??USB_DCI_InitEndpoint_4: (+1)
   \   00000074   0x88A0             LDRH     R0,[R4, #+4]
   \   00000076   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000007A   0xDD02             BLE.N    ??USB_DCI_InitEndpoint_5
    454            {
    455              pEpStruct->size = gUsbMaxEpBufferSize_d;
   \   0000007C   0xF44F 0x7000      MOV      R0,#+512
   \   00000080   0x80A0             STRH     R0,[R4, #+4]
    456            }
    457            
    458            if(bdtElemIndex == gUsbInvalidBdtIndex_d)
   \                     ??USB_DCI_InitEndpoint_5: (+1)
   \   00000082   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000084   0x2FFF             CMP      R7,#+255
   \   00000086   0xD146             BNE.N    ??USB_DCI_InitEndpoint_6
    459            {
    460              if((endpCtl.bdtElemIndexAlloc >= gNumUsbEp_d) ||
    461                 ((endpCtl.endpBuffAddrAlloc + pEpStruct->size) > ((uint32_t)gaEndpBuffers + sizeof(gaEndpBuffers))))         
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   0000008C   0xF890 0x0024      LDRB     R0,[R0, #+36]
   \   00000090   0x2805             CMP      R0,#+5
   \   00000092   0xDA09             BGE.N    ??USB_DCI_InitEndpoint_7
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable17_9
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   0000009C   0x6809             LDR      R1,[R1, #+0]
   \   0000009E   0x88A2             LDRH     R2,[R4, #+4]
   \   000000A0   0xFA11 0xF182      UXTAH    R1,R1,R2
   \   000000A4   0x4288             CMP      R0,R1
   \   000000A6   0xD201             BCS.N    ??USB_DCI_InitEndpoint_8
    462              {
    463                return gUsbErr_EpInitFailed_c;
   \                     ??USB_DCI_InitEndpoint_7: (+1)
   \   000000A8   0x2095             MOVS     R0,#+149
   \   000000AA   0xE09E             B.N      ??USB_DCI_InitEndpoint_2
    464              }
    465              bdtElemIndex = endpCtl.bdtElemIndexMap[bdtMapIndex>>1] = endpCtl.bdtElemIndexAlloc;
   \                     ??USB_DCI_InitEndpoint_8: (+1)
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   000000B0   0xF890 0x0024      LDRB     R0,[R0, #+36]
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   000000B8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000BA   0xEB11 0x0166      ADDS     R1,R1,R6, ASR #+1
   \   000000BE   0x7108             STRB     R0,[R1, #+4]
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   000000C4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000C6   0xEB10 0x0066      ADDS     R0,R0,R6, ASR #+1
   \   000000CA   0x7900             LDRB     R0,[R0, #+4]
   \   000000CC   0x0007             MOVS     R7,R0
    466              endpCtl.bdtElemIndexAlloc++;
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   000000D2   0xF890 0x0024      LDRB     R0,[R0, #+36]
   \   000000D6   0x1C40             ADDS     R0,R0,#+1
   \   000000D8   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   000000DC   0xF881 0x0024      STRB     R0,[R1, #+36]
    467              gBdtElem[bdtElemIndex].bdtMapIndex = bdtMapIndex;
   \   000000E0   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \   000000E4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000E6   0x2112             MOVS     R1,#+18
   \   000000E8   0xFB01 0x0007      MLA      R0,R1,R7,R0
   \   000000EC   0x73C6             STRB     R6,[R0, #+15]
    468              gBdtElem[bdtElemIndex].addr = endpCtl.endpBuffAddrAlloc;
   \   000000EE   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   000000F2   0x6800             LDR      R0,[R0, #+0]
   \   000000F4   0x.... 0x....      LDR.W    R1,??DataTable16_4
   \   000000F8   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000FA   0x2212             MOVS     R2,#+18
   \   000000FC   0xFB02 0x1107      MLA      R1,R2,R7,R1
   \   00000100   0xF8C1 0x0002      STR      R0,[R1, #+2]
    469              endpCtl.endpBuffAddrAlloc += pEpStruct->size;
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   00000108   0x6800             LDR      R0,[R0, #+0]
   \   0000010A   0x88A1             LDRH     R1,[R4, #+4]
   \   0000010C   0xFA10 0xF081      UXTAH    R0,R0,R1
   \   00000110   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   00000114   0x6008             STR      R0,[R1, #+0]
    470            }
    471            pBdtElem = &gBdtElem[bdtElemIndex];
   \                     ??USB_DCI_InitEndpoint_6: (+1)
   \   00000116   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \   0000011A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000011C   0x2112             MOVS     R1,#+18
   \   0000011E   0xFB01 0x0007      MLA      R0,R1,R7,R0
   \   00000122   0x4681             MOV      R9,R0
    472            /* update bdt element structure */
    473            pBdtElem->epSize = pEpStruct->size;
   \   00000124   0x88A0             LDRH     R0,[R4, #+4]
   \   00000126   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    474            pBdtElem->flag = flag;
   \   0000012A   0xF889 0x500E      STRB     R5,[R9, #+14]
    475            /* Update BDTMAP  */
    476            pBuffDsc = &gBDTMap.epDsc[pBdtElem->bdtMapIndex]; 
   \   0000012E   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   00000132   0xF899 0x100F      LDRB     R1,[R9, #+15]
   \   00000136   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   0000013A   0x4680             MOV      R8,R0
    477            pBuffDsc->cnt = pEpStruct->size;
   \   0000013C   0x88A0             LDRH     R0,[R4, #+4]
   \   0000013E   0xF8A8 0x0002      STRH     R0,[R8, #+2]
    478            /* preserving even/odd buffer bit and address*/
    479            pBuffDsc->addr = pBdtElem->addr;
   \   00000142   0xF8D9 0x0002      LDR      R0,[R9, #+2]
   \   00000146   0xF8C8 0x0004      STR      R0,[R8, #+4]
    480            pBuffDsc->stat.byte = (gUsbBdtSCtl_CPU_d | gUsbBdtSCtl_Data0_d | gUsbBdtSCtl_DTS_d);
   \   0000014A   0x2008             MOVS     R0,#+8
   \   0000014C   0xF888 0x0000      STRB     R0,[R8, #+0]
    481            
    482            pBuffDsc = &gBDTMap.epDsc[(uint8_t)((pBdtElem->bdtMapIndex) ^ 1)];
   \   00000150   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   00000154   0xF899 0x100F      LDRB     R1,[R9, #+15]
   \   00000158   0xF091 0x0101      EORS     R1,R1,#0x1
   \   0000015C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000015E   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000162   0x4680             MOV      R8,R0
    483            pBuffDsc->cnt = pEpStruct->size;
   \   00000164   0x88A0             LDRH     R0,[R4, #+4]
   \   00000166   0xF8A8 0x0002      STRH     R0,[R8, #+2]
    484            pBuffDsc->addr = pBdtElem->addr;
   \   0000016A   0xF8D9 0x0002      LDR      R0,[R9, #+2]
   \   0000016E   0xF8C8 0x0004      STR      R0,[R8, #+4]
    485            pBuffDsc->stat.byte = (gUsbBdtSCtl_CPU_d | gUsbBdtSCtl_Data1_d | gUsbBdtSCtl_DTS_d);
   \   00000172   0x2048             MOVS     R0,#+72
   \   00000174   0xF888 0x0000      STRB     R0,[R8, #+0]
    486            if(direction == gUsbEpDirection_Out_c)
   \   00000178   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000017C   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000180   0xD10F             BNE.N    ??USB_DCI_InitEndpoint_9
    487            {
    488              /* For Recv Endpoints Give SIE Control to DATA0 */
    489              pBuffDsc = &gBDTMap.epDsc[pBdtElem->bdtMapIndex];
   \   00000182   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   00000186   0xF899 0x100F      LDRB     R1,[R9, #+15]
   \   0000018A   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   0000018E   0x4680             MOV      R8,R0
    490              pBdtElem->noTransferInProgress = FALSE;
   \   00000190   0x2000             MOVS     R0,#+0
   \   00000192   0xF889 0x0011      STRB     R0,[R9, #+17]
    491              pBuffDsc->stat.byte |= gUsbBdtSCtl_SIE_d;
   \   00000196   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   0000019A   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000019E   0xF888 0x0000      STRB     R0,[R8, #+0]
    492            }
    493            
    494            /* enable handshake for Non-Isochronous Endpoints */
    495            epCtrl[direction] |= ((pEpStruct->type != gUsbEpType_Isochronous_c) ? gUsbEndpt_HshkEn_c:0x00);
   \                     ??USB_DCI_InitEndpoint_9: (+1)
   \   000001A2   0x7860             LDRB     R0,[R4, #+1]
   \   000001A4   0x2801             CMP      R0,#+1
   \   000001A6   0xD001             BEQ.N    ??USB_DCI_InitEndpoint_10
   \   000001A8   0x2001             MOVS     R0,#+1
   \   000001AA   0xE000             B.N      ??USB_DCI_InitEndpoint_11
   \                     ??USB_DCI_InitEndpoint_10: (+1)
   \   000001AC   0x2000             MOVS     R0,#+0
   \                     ??USB_DCI_InitEndpoint_11: (+1)
   \   000001AE   0xA900             ADD      R1,SP,#+0
   \   000001B0   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000001B4   0xF851 0x102B      LDR      R1,[R1, R11, LSL #+2]
   \   000001B8   0x4308             ORRS     R0,R0,R1
   \   000001BA   0xA900             ADD      R1,SP,#+0
   \   000001BC   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000001C0   0xF841 0x002B      STR      R0,[R1, R11, LSL #+2]
    496            /* set the EndPoint Control MCU Register*/
    497            *((&USB0_ENDPT0) + (4 * epNum)) |= epCtrl[direction];
   \   000001C4   0x.... 0x....      LDR.W    R0,??DataTable17_6  ;; 0x400720c0
   \   000001C8   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001CC   0xF810 0x002A      LDRB     R0,[R0, R10, LSL #+2]
   \   000001D0   0xA900             ADD      R1,SP,#+0
   \   000001D2   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000001D6   0xF851 0x102B      LDR      R1,[R1, R11, LSL #+2]
   \   000001DA   0x4308             ORRS     R0,R1,R0
   \   000001DC   0x.... 0x....      LDR.W    R1,??DataTable17_6  ;; 0x400720c0
   \   000001E0   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001E4   0xF801 0x002A      STRB     R0,[R1, R10, LSL #+2]
    498            return gUsbErr_NoError_c;
   \   000001E8   0x2000             MOVS     R0,#+0
   \                     ??USB_DCI_InitEndpoint_2: (+1)
   \   000001EA   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    499          }
    500          
    501          /**************************************************************************//*!
    502           *
    503           * @name  USB_DCI_CancelTransfer
    504           *
    505           * @brief The function cancels any pending Transfers which ahve not been sent
    506           *
    507           * @param handle          : USB Device handle
    508           * @param endpoint_number : Endpoint number
    509           * @param direction       : Endpoint direction
    510           *
    511           * @return status
    512           *         gUsbErr_NotSupported_c : Always
    513           ******************************************************************************
    514           * This function just returns Error Code not supported
    515           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    516          uint8_t USB_DCI_CancelTransfer 
    517          (
    518          uint8_t  controllerId,                                 
    519          uint8_t  endpNumber,    /* [IN] Endpoint number */
    520          uint8_t  direction  /* [IN] Endpoint direction */
    521          )
    522          {
   \                     USB_DeviceCancelTransfer: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    523            uint8_t bdtElemIndex;
    524            uint8_t status= gUsbErr_UnknownError_c;
   \   0000000A   0xF05F 0x08C4      MOVS     R8,#+196
    525            /* validate params and get the bdt index */
    526            uint8_t bdtMapIndex = USB_DCI_ValidateParam (endpNumber, direction, gUsbBdtEvenBuffer_c);
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x0031             MOVS     R1,R6
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x.... 0x....      BL       USB_DCI_ValidateParam
   \   0000001C   0x4681             MOV      R9,R0
    527            bdtElemIndex = USB_DCI_GetBDTElemIndex(bdtMapIndex);
   \   0000001E   0x4648             MOV      R0,R9
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x.... 0x....      BL       USB_DCI_GetBDTElemIndex
   \   00000026   0x0007             MOVS     R7,R0
    528            /* Check for valid bdt index */
    529            if(bdtMapIndex != gUsbInvalidBdtIndex_d)
   \   00000028   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000002C   0xF1B9 0x0FFF      CMP      R9,#+255
   \   00000030   0xD020             BEQ.N    ??USB_DeviceCancelTransfer_0
    530            {
    531              pBdtElem_t pBdtElem = &gBdtElem[bdtElemIndex];
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \   00000036   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000038   0x2112             MOVS     R1,#+18
   \   0000003A   0xFB01 0x0007      MLA      R0,R1,R7,R0
    532              pBuffDsc_t pBuffDsc = &gBDTMap.epDsc[pBdtElem->bdtMapIndex];
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable16_8
   \   00000042   0x7BC2             LDRB     R2,[R0, #+15]
   \   00000044   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
    533              pBuffDsc_t pBuffDscAlt = &gBDTMap.epDsc[pBdtElem->bdtMapIndex ^ 1];
   \   00000048   0x.... 0x....      LDR.W    R2,??DataTable16_8
   \   0000004C   0x7BC3             LDRB     R3,[R0, #+15]
   \   0000004E   0xF093 0x0301      EORS     R3,R3,#0x1
   \   00000052   0xEB12 0x02C3      ADDS     R2,R2,R3, LSL #+3
    534              /* Clear SIE Control Bit for both buffers*/
    535              pBuffDsc->stat.byte &= ~gUsbBdtSCtl_SIE_d;
   \   00000056   0x780B             LDRB     R3,[R1, #+0]
   \   00000058   0xF013 0x037F      ANDS     R3,R3,#0x7F
   \   0000005C   0x700B             STRB     R3,[R1, #+0]
    536              pBuffDscAlt->stat.byte &= ~gUsbBdtSCtl_SIE_d;
   \   0000005E   0x7813             LDRB     R3,[R2, #+0]
   \   00000060   0xF013 0x037F      ANDS     R3,R3,#0x7F
   \   00000064   0x7013             STRB     R3,[R2, #+0]
    537              pBdtElem->appLen = (usbPacketSize_t)gUninitialisedVal_d;
   \   00000066   0xF64F 0x73FF      MOVW     R3,#+65535
   \   0000006A   0x8143             STRH     R3,[R0, #+10]
    538              pBdtElem->noTransferInProgress = TRUE;
   \   0000006C   0x2301             MOVS     R3,#+1
   \   0000006E   0x7443             STRB     R3,[R0, #+17]
    539              status = gUsbErr_NoError_c;
   \   00000070   0x2300             MOVS     R3,#+0
   \   00000072   0x4698             MOV      R8,R3
    540            }
    541            return status;
   \                     ??USB_DeviceCancelTransfer_0: (+1)
   \   00000074   0x4640             MOV      R0,R8
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    542          }
    543          
    544          /**************************************************************************//*!
    545           *
    546           * @name  USB_DCI_DeinitEndpoint
    547           *
    548           * @brief The function de initializes an endpoint
    549           *
    550           * @param controller_ID : Controller ID
    551           * @param ep_num        : Endpoint number
    552           * @param direction     : Endpoint direction
    553           *
    554           * @return status
    555           *         gUsbErr_NoError_c                   : When successfull
    556           *         gUsbErr_EpDeinitFailed_c  : When unsuccessfull
    557           ******************************************************************************
    558           *
    559           * This function un-intializes the endpoint by clearing the corresponding
    560           * endpoint control register and then clearing the bdt elem.
    561           *
    562           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    563          uint8_t USB_DCI_DeinitEndpoint 
    564          (
    565          uint8_t    controllerId,   /* [IN] Controller ID */
    566          uint8_t    epNum,          /* [IN] Endpoint number */
    567          uint8_t    direction        /* [IN] Endpoint direction */
    568          )
    569          {
   \                     USB_DCI_DeinitEndpoint: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    570            /* validate params and get the bdt index */
    571            uint8_t bdtElemIndex;
    572            uint8_t bdtMapIndex = USB_DCI_ValidateParam (epNum, direction, gUsbBdtEvenBuffer_c);
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x0031             MOVS     R1,R6
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x.... 0x....      BL       USB_DCI_ValidateParam
   \   00000018   0x4680             MOV      R8,R0
    573            /* in case the bdt_index is invalid*/
    574            if(bdtMapIndex  == gUsbInvalidBdtIndex_d)
   \   0000001A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000001E   0xF1B8 0x0FFF      CMP      R8,#+255
   \   00000022   0xD101             BNE.N    ??USB_DCI_DeinitEndpoint_0
    575            {
    576              return gUsbErr_EpDeinitFailed_c;
   \   00000024   0x2096             MOVS     R0,#+150
   \   00000026   0xE01C             B.N      ??USB_DCI_DeinitEndpoint_1
    577            }
    578            bdtElemIndex = USB_DCI_GetBDTElemIndex(bdtMapIndex);
   \                     ??USB_DCI_DeinitEndpoint_0: (+1)
   \   00000028   0x4640             MOV      R0,R8
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x.... 0x....      BL       USB_DCI_GetBDTElemIndex
   \   00000030   0x0007             MOVS     R7,R0
    579            USB_DCI_CancelTransfer(controllerId, epNum, direction);
   \   00000032   0x0032             MOVS     R2,R6
   \   00000034   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000036   0x0029             MOVS     R1,R5
   \   00000038   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0x.... 0x....      BL       USB_DeviceCancelTransfer
    580            /* Disable endpoint */
    581            *((&USB0_ENDPT0) + (4 * epNum)) = gUsbEndpt_Disable_c;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable17_6  ;; 0x400720c0
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0xF801 0x0025      STRB     R0,[R1, R5, LSL #+2]
    582            /* un-initialize the bdt_elem structure for this endpoint */
    583            gBdtElem[bdtElemIndex].epSize = (uint16_t)gUninitialisedVal_d;
   \   0000004E   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable16_4
   \   00000056   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000058   0x2212             MOVS     R2,#+18
   \   0000005A   0xFB02 0x1107      MLA      R1,R2,R7,R1
   \   0000005E   0x8008             STRH     R0,[R1, #+0]
    584            return gUsbErr_NoError_c;
   \   00000060   0x2000             MOVS     R0,#+0
   \                     ??USB_DCI_DeinitEndpoint_1: (+1)
   \   00000062   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    585          }
    586          
    587          /**************************************************************************//*!
    588           *
    589           * @name  USB_DCI_StallEndpoint
    590           *
    591           * @brief The function stalls an endpoint
    592           *
    593           * @param handle          : USB Device handle
    594           * @param endpoint_number : Endpoint number
    595           * @param direction       : Endpoint direction
    596           *
    597           * @return None
    598           *
    599           ******************************************************************************
    600           * This function stalls the endpoint by setting Endpoint BDT
    601           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    602          void USB_DCI_StallEndpoint 
    603          (
    604          uint8_t  controllerId,                         
    605          uint8_t endpNum,    /* [IN] Endpoint number to stall */
    606          uint8_t direction   /* [IN] Direction to stall */
    607          )
    608          {
   \                     USB_DeviceStallEndpoint: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    609            uint8_t bdtElemIndex;
    610            /* validate params and get the bdt index */
    611            uint8_t bdtMapIndex = USB_DCI_ValidateParam (endpNum, direction, gUsbBdtEvenBuffer_c);
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x0031             MOVS     R1,R6
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x.... 0x....      BL       USB_DCI_ValidateParam
   \   00000018   0x4680             MOV      R8,R0
    612            if(bdtMapIndex == gUsbInvalidBdtIndex_d)
   \   0000001A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000001E   0xF1B8 0x0FFF      CMP      R8,#+255
   \   00000022   0xD022             BEQ.N    ??USB_DeviceStallEndpoint_0
    613            {
    614              return;
    615            }
    616            bdtElemIndex = USB_DCI_GetBDTElemIndex(bdtMapIndex); 
   \                     ??USB_DeviceStallEndpoint_1: (+1)
   \   00000024   0x4640             MOV      R0,R8
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x.... 0x....      BL       USB_DCI_GetBDTElemIndex
   \   0000002C   0x0007             MOVS     R7,R0
    617            bdtMapIndex = gBdtElem[bdtElemIndex].bdtMapIndex;
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \   00000032   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000034   0x2112             MOVS     R1,#+18
   \   00000036   0xFB01 0x0007      MLA      R0,R1,R7,R0
   \   0000003A   0x7BC0             LDRB     R0,[R0, #+15]
   \   0000003C   0x4680             MOV      R8,R0
    618            (void)USB_DCI_CancelTransfer(controllerId, endpNum, direction);
   \   0000003E   0x0032             MOVS     R2,R6
   \   00000040   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000042   0x0029             MOVS     R1,R5
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0x.... 0x....      BL       USB_DeviceCancelTransfer
    619            gBDTMap.epDsc[bdtMapIndex].stat.byte |= (gUsbBdtSCtl_SIE_d | gUsbBdtSCtl_Stall_d);
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable16_8
   \   00000052   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000056   0xF811 0x1038      LDRB     R1,[R1, R8, LSL #+3]
   \   0000005A   0xF051 0x0184      ORRS     R1,R1,#0x84
   \   0000005E   0x.... 0x....      LDR.W    R2,??DataTable16_8
   \   00000062   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000066   0xF802 0x1038      STRB     R1,[R2, R8, LSL #+3]
    620          }
   \                     ??USB_DeviceStallEndpoint_0: (+1)
   \   0000006A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    621          
    622          /**************************************************************************//*!
    623           *
    624           * @name  USB_DCI_UnstallEndpoint
    625           *
    626           * @brief The function unstalls an endpoint
    627           *
    628           * @param handle          : USB Device handle
    629           * @param endpoint_number : Endpoint number
    630           * @param direction       : Endpoint direction
    631           *
    632           * @return None
    633           *
    634           ******************************************************************************
    635           * This function unstalls the endpoint by clearing Endpoint Control Register
    636           * and BDT
    637           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    638          void USB_DCI_UnstallEndpoint
    639          (
    640          uint8_t  controllerId,                           
    641          uint8_t  endpNumber,    /* [IN] Endpoint number to unstall */
    642          uint8_t  direction           /* [IN] Direction to unstall */
    643          )
    644          {
   \                     USB_DeviceUnstallEndpoint: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    645            uint8_t bdtElemIndex;
    646            /* validate params and get the bdt index */
    647            uint8_t bdtMapIndex = USB_DCI_ValidateParam (endpNumber, direction, gUsbBdtEvenBuffer_c);
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x0031             MOVS     R1,R6
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x.... 0x....      BL       USB_DCI_ValidateParam
   \   00000018   0x4680             MOV      R8,R0
    648            /* Check for valid bdt index */
    649            if(bdtMapIndex == gUsbInvalidBdtIndex_d)
   \   0000001A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000001E   0xF1B8 0x0FFF      CMP      R8,#+255
   \   00000022   0xD01E             BEQ.N    ??USB_DeviceUnstallEndpoint_0
    650            {
    651              return;
    652            }
    653            bdtElemIndex = USB_DCI_GetBDTElemIndex(bdtMapIndex); 
   \                     ??USB_DeviceUnstallEndpoint_1: (+1)
   \   00000024   0x4640             MOV      R0,R8
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x.... 0x....      BL       USB_DCI_GetBDTElemIndex
   \   0000002C   0x0007             MOVS     R7,R0
    654            bdtMapIndex = gBdtElem[bdtElemIndex].bdtMapIndex;
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \   00000032   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000034   0x2112             MOVS     R1,#+18
   \   00000036   0xFB01 0x0007      MLA      R0,R1,R7,R0
   \   0000003A   0x7BC0             LDRB     R0,[R0, #+15]
   \   0000003C   0x4680             MOV      R8,R0
    655            /* We Require DATA0 PID to be zero on unstall */
    656            gBDTMap.epDsc[bdtMapIndex].stat.byte = gUsbBdtSCtl_Data0_d;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable16_8
   \   00000044   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000048   0xF801 0x0038      STRB     R0,[R1, R8, LSL #+3]
    657            if(direction == gUsbEpDirection_Out_c)
   \   0000004C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004E   0x2E00             CMP      R6,#+0
   \   00000050   0xD107             BNE.N    ??USB_DeviceUnstallEndpoint_2
    658            {
    659              /* Initiate Next receive Transfer */
    660              USB_DCI_RecvData(controllerId, endpNumber, NULL, 0);
   \   00000052   0x2300             MOVS     R3,#+0
   \   00000054   0x2200             MOVS     R2,#+0
   \   00000056   0x0029             MOVS     R1,R5
   \   00000058   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0x.... 0x....      BL       USB_DeviceRecvData
    661            } 	
    662            return;
   \                     ??USB_DeviceUnstallEndpoint_2: (+1)
   \                     ??USB_DeviceUnstallEndpoint_0: (+1)
   \   00000062   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    663          }
    664          
    665          /**************************************************************************//*!
    666           *
    667           * @name  USB_DCI_GetSetupData
    668           *
    669           * @brief The function copies Setup Packet from USB RAM to application buffer
    670           *
    671           * @param handle          : USB Device handle
    672           * @param endpoint_number : Endpoint number
    673           * @param buffer_ptr      : Application buffer pointer
    674           *
    675           * @return None
    676           *
    677           ******************************************************************************
    678           * Copies setup packet from USB RAM to Application Buffer
    679           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    680          void USB_DCI_GetSetupData 
    681          (
    682          uint8_t  controllerId,                             
    683          uint8_t  endpNumber,    /* [IN] Endpoint number for the transaction */
    684          uint8_t* pBuff          /* [IN] Pointer to the buffer into which to read data */
    685          )
    686          {
   \                     USB_Device_ReadSetupData: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    687          	uint8_t* pSetupAddr;
    688            uint8_t bdtElemIndex;
    689            /* validate params and get the bdt index */
    690            uint8_t bdtMapIndex = USB_DCI_ValidateParam (endpNumber, gUsbEpDirection_Out_c, gUsbBdtEvenBuffer_c);
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x0028             MOVS     R0,R5
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x.... 0x....      BL       USB_DCI_ValidateParam
   \   00000016   0x4681             MOV      R9,R0
    691            if(bdtMapIndex == gUsbInvalidBdtIndex_d)
   \   00000018   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000001C   0xF1B9 0x0FFF      CMP      R9,#+255
   \   00000020   0xD01A             BEQ.N    ??USB_Device_ReadSetupData_0
    692            {
    693              return;
    694            }
    695            bdtElemIndex = USB_DCI_GetBDTElemIndex(bdtMapIndex);
   \                     ??USB_Device_ReadSetupData_1: (+1)
   \   00000022   0x4648             MOV      R0,R9
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x.... 0x....      BL       USB_DCI_GetBDTElemIndex
   \   0000002A   0x4680             MOV      R8,R0
    696            bdtMapIndex = gBdtElem[bdtElemIndex].bdtMapIndex;
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \   00000030   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000034   0x2112             MOVS     R1,#+18
   \   00000036   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   0000003A   0x7BC0             LDRB     R0,[R0, #+15]
   \   0000003C   0x4681             MOV      R9,R0
    697            /* address correponding to the endpoint */
    698            pSetupAddr = (uint8_t*)(gBDTMap.epDsc[bdtMapIndex].addr);
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   00000042   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000046   0xEB10 0x00C9      ADDS     R0,R0,R9, LSL #+3
   \   0000004A   0x6840             LDR      R0,[R0, #+4]
   \   0000004C   0x0007             MOVS     R7,R0
    699            /* copy bdt buffer to application buffer */
    700            MemoryCpy( pBuff,   pSetupAddr,   gUsbSetupPacketSize_d     );
   \   0000004E   0x2208             MOVS     R2,#+8
   \   00000050   0x0039             MOVS     R1,R7
   \   00000052   0x0030             MOVS     R0,R6
   \   00000054   0x.... 0x....      BL       MemoryCpy
    701            return;
   \                     ??USB_Device_ReadSetupData_0: (+1)
   \   00000058   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    702          }
    703          
    704          /**************************************************************************//*!
    705           *
    706           * @name  USB_DCI_GetTransferStatus
    707           *
    708           * @brief The function retrieves the Transfer status of an endpoint
    709           *
    710           * @param handle          : USB Device handle
    711           * @param endpoint_number : Endpoint number
    712           * @param direction       : Endpoint direction
    713           *
    714           * @return status
    715           *         USBERR_TR_FAILED                : When unsuccessful
    716           *         gUsbStatus_Idle_d                 : No transfer on endpoint
    717           *         gUsbStatus_Disabled_d             : endpoint is disabled
    718           *         gUsbStatus_Stalled_d              : endpoint is stalled
    719           *         gUsbStatus_TransferInProgress_d : When SIE has control of BDT
    720           ******************************************************************************
    721           *
    722           * This function retrieves the transfer status of the endpoint by checking the
    723           * BDT as well as the endpoint control register
    724           *
    725           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    726          uint8_t USB_DCI_GetTransferStatus 
    727          (
    728          uint8_t  controllerId ,                                    
    729          uint8_t  endpNumber,    /* [IN] Endpoint number */
    730          uint8_t  direction           /* [IN] Endpoint direction */
    731          )
    732          {
   \                     USB_Device_GetTransferStatus: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    733            uint8_t bdtElemIndex;  
    734            uint8_t status = gUsbStatus_Disabled_d;
   \   0000000A   0xF05F 0x0805      MOVS     R8,#+5
    735            /* validate params and get the bdt index */
    736            uint8_t bdtMapIndex = USB_DCI_ValidateParam (endpNumber, direction, gUsbBdtEvenBuffer_c);
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x0031             MOVS     R1,R6
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x.... 0x....      BL       USB_DCI_ValidateParam
   \   0000001C   0x4681             MOV      R9,R0
    737            /* Check for valid bdt index */
    738            if(bdtMapIndex != gUsbInvalidBdtIndex_d)
   \   0000001E   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000022   0xF1B9 0x0FFF      CMP      R9,#+255
   \   00000026   0xD03E             BEQ.N    ??USB_Device_GetTransferStatus_0
    739            {
    740              uint8_t epCtrl = (uint8_t)(*((&USB0_ENDPT0)+4*endpNumber));
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable17_6  ;; 0x400720c0
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0xF810 0xA025      LDRB     R10,[R0, R5, LSL #+2]
    741              bdtElemIndex = USB_DCI_GetBDTElemIndex(bdtMapIndex);
   \   00000032   0x4648             MOV      R0,R9
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x.... 0x....      BL       USB_DCI_GetBDTElemIndex
   \   0000003A   0x0007             MOVS     R7,R0
    742              bdtMapIndex = gBdtElem[bdtElemIndex].bdtMapIndex;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \   00000040   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000042   0x2112             MOVS     R1,#+18
   \   00000044   0xFB01 0x0007      MLA      R0,R1,R7,R0
   \   00000048   0x7BC0             LDRB     R0,[R0, #+15]
   \   0000004A   0x4681             MOV      R9,R0
    743              status = gUsbStatus_Idle_d;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x4680             MOV      R8,R0
    744              /* Check for direction in endpoint control register */
    745              if((epCtrl & (gUsbEndpt_In_c|gUsbEndpt_Out_c)) == gUsbEndpt_Disable_c)
   \   00000050   0x210C             MOVS     R1,#+12
   \   00000052   0xEA1A 0x0F01      TST      R10,R1
   \   00000056   0xD102             BNE.N    ??USB_Device_GetTransferStatus_1
    746              {
    747                status = gUsbStatus_Disabled_d;
   \   00000058   0x2005             MOVS     R0,#+5
   \   0000005A   0x4680             MOV      R8,R0
   \   0000005C   0xE023             B.N      ??USB_Device_GetTransferStatus_0
    748              }
    749              /* Check for stall bit in endpoint control register */
    750              else if(
    751                      (gBDTMap.epDsc[bdtMapIndex].stat.mcuCtlBit.bdtstall == 1)
    752                        &&(gBDTMap.epDsc[bdtMapIndex].stat.sieCtlBit.own == 1)
    753                          )
   \                     ??USB_Device_GetTransferStatus_1: (+1)
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   00000062   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000066   0xF810 0x0039      LDRB     R0,[R0, R9, LSL #+3]
   \   0000006A   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   0000006E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD00D             BEQ.N    ??USB_Device_GetTransferStatus_2
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   00000078   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000007C   0xF810 0x0039      LDRB     R0,[R0, R9, LSL #+3]
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0x09C0             LSRS     R0,R0,#+7
   \   00000084   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD002             BEQ.N    ??USB_Device_GetTransferStatus_2
    754              {
    755                status = gUsbStatus_Stalled_d ;
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x4680             MOV      R8,R0
   \   0000008E   0xE00A             B.N      ??USB_Device_GetTransferStatus_0
    756              }
    757              /* Check whether SIE has control of BDT */
    758              else if (gBdtElem[bdtElemIndex].noTransferInProgress == FALSE)
   \                     ??USB_Device_GetTransferStatus_2: (+1)
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \   00000094   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000096   0x2112             MOVS     R1,#+18
   \   00000098   0xFB01 0x0007      MLA      R0,R1,R7,R0
   \   0000009C   0x7C40             LDRB     R0,[R0, #+17]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD101             BNE.N    ??USB_Device_GetTransferStatus_0
    759              {
    760                status = gUsbStatus_TransferInProgress_d;
   \   000000A2   0x2003             MOVS     R0,#+3
   \   000000A4   0x4680             MOV      R8,R0
    761              }
    762            }
    763            return status;
   \                     ??USB_Device_GetTransferStatus_0: (+1)
   \   000000A6   0x4640             MOV      R0,R8
   \   000000A8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AA   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    764          }
    765          
    766          /**************************************************************************//*!
    767           *
    768           * @name  USB_DCI_RecvData
    769           *
    770           * @brief The function retrieves data received on an RECV endpoint
    771           *
    772           * @param handle          : USB Device handle
    773           * @param endpoint_number : Endpoint number
    774           * @param buffer_ptr      : Application buffer pointer
    775           * @param size            : Size of the buffer
    776           *
    777           * @return status
    778           *         gUsbErr_NoError_c                          : When successful
    779           *         gUsbErr_RxFailed_c                : When unsuccessful
    780           ******************************************************************************
    781           * This function retrieves data received data on a RECV endpoint by copying it
    782           * from USB RAM to application buffer
    783           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    784          uint8_t USB_DCI_RecvData 
    785          (
    786          uint8_t  controllerId,                           
    787          uint8_t  endpNumber,    /* [IN] Endpoint number for the transaction */
    788          uint8_t* pBuff,         /* [OUT] Pointer to the buffer into which to receive data */
    789          usbPacketSize_t size
    790          )
    791          {
   \                     USB_DeviceRecvData: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    792            uint8_t status = gUsbErr_RxFailed_c;
   \   0000000E   0xF05F 0x0B94      MOVS     R11,#+148
    793            uint8_t bdtElemIndex;
    794            pBdtElem_t pBdtElem;
    795            pBuffDsc_t pBuffDsc;
    796            uint32_t ccr;
    797            /* validate params and get the bdt index */
    798            uint8_t bdtMapIndex = USB_DCI_ValidateParam (endpNumber, gUsbEpDirection_Out_c, gUsbBdtEvenBuffer_c);
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x.... 0x....      BL       USB_DCI_ValidateParam
   \   0000001E   0x4682             MOV      R10,R0
    799            (void)(controllerId);
    800            /* Check for valid bdt index */
    801            if(bdtMapIndex == gUsbInvalidBdtIndex_d)
   \   00000020   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000024   0xF1BA 0x0FFF      CMP      R10,#+255
   \   00000028   0xD102             BNE.N    ??USB_DeviceRecvData_0
    802            {
    803              return status;
   \   0000002A   0x4658             MOV      R0,R11
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0xE050             B.N      ??USB_DeviceRecvData_1
    804            }
    805            ccr = IntDisableAll();
   \                     ??USB_DeviceRecvData_0: (+1)
   \   00000030   0x.... 0x....      BL       IntDisableAll
   \   00000034   0x9000             STR      R0,[SP, #+0]
    806            bdtElemIndex = USB_DCI_GetBDTElemIndex(bdtMapIndex);
   \   00000036   0x4650             MOV      R0,R10
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x.... 0x....      BL       USB_DCI_GetBDTElemIndex
   \   0000003E   0xF88D 0x0004      STRB     R0,[SP, #+4]
    807            pBdtElem = &gBdtElem[bdtElemIndex];
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \   00000046   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   0000004A   0x2212             MOVS     R2,#+18
   \   0000004C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000050   0x4680             MOV      R8,R0
    808            /* For selecting even/odd buffer */
    809            bdtMapIndex = pBdtElem->bdtMapIndex;
   \   00000052   0xF898 0x000F      LDRB     R0,[R8, #+15]
   \   00000056   0x4682             MOV      R10,R0
    810            pBuffDsc = &gBDTMap.epDsc[bdtMapIndex];
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   0000005C   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000060   0xEB10 0x00CA      ADDS     R0,R0,R10, LSL #+3
   \   00000064   0x4681             MOV      R9,R0
    811            /* Does MCU owns it */
    812            if(pBdtElem->noTransferInProgress)
   \   00000066   0xF898 0x0011      LDRB     R0,[R8, #+17]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD02C             BEQ.N    ??USB_DeviceRecvData_2
    813            {
    814              if(size == 0)
   \   0000006E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000070   0x2F00             CMP      R7,#+0
   \   00000072   0xD108             BNE.N    ??USB_DeviceRecvData_3
    815              {
    816                pBuffDsc->cnt = pBdtElem->epSize;
   \   00000074   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   00000078   0xF8A9 0x0002      STRH     R0,[R9, #+2]
    817                pBuffDsc->addr = pBdtElem->addr;
   \   0000007C   0xF8D8 0x0002      LDR      R0,[R8, #+2]
   \   00000080   0xF8C9 0x0004      STR      R0,[R9, #+4]
   \   00000084   0xE012             B.N      ??USB_DeviceRecvData_4
    818                
    819                /* Give the ownership to SIE and TOGGLE DATA BIT */
    820              }
    821              /* adjust size based on the input at the init endpoint */
    822              else
    823              {
    824                /* Initialise transfer */
    825                pBdtElem->appLen = size;
   \                     ??USB_DeviceRecvData_3: (+1)
   \   00000086   0xF8A8 0x700A      STRH     R7,[R8, #+10]
    826                pBdtElem->pAppBuffer = pBuff;
   \   0000008A   0xF8C8 0x6006      STR      R6,[R8, #+6]
    827                if(size > pBdtElem->epSize)
   \   0000008E   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   00000092   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000094   0x42B8             CMP      R0,R7
   \   00000096   0xD202             BCS.N    ??USB_DeviceRecvData_5
    828                {
    829                  size = pBdtElem->epSize;
   \   00000098   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   0000009C   0x0007             MOVS     R7,R0
    830                }
    831                pBdtElem->currOffset = 0;
   \                     ??USB_DeviceRecvData_5: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xF8A8 0x000C      STRH     R0,[R8, #+12]
    832                pBuffDsc->cnt = size;
   \   000000A4   0xF8A9 0x7002      STRH     R7,[R9, #+2]
    833                pBuffDsc->addr = (uint32_t)pBuff;
   \   000000A8   0xF8C9 0x6004      STR      R6,[R9, #+4]
    834              } 
    835              pBdtElem->noTransferInProgress = FALSE;
   \                     ??USB_DeviceRecvData_4: (+1)
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0xF888 0x0011      STRB     R0,[R8, #+17]
    836              pBuffDsc->stat.byte = (uint8_t)(
    837                                                 (pBuffDsc->stat.mcuCtlBit.data << 6) |
    838                                                   gUsbBdtSCtl_SIE_d | gUsbBdtSCtl_DTS_d);
   \   000000B2   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   000000B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B8   0x0980             LSRS     R0,R0,#+6
   \   000000BA   0x0180             LSLS     R0,R0,#+6
   \   000000BC   0xF050 0x0088      ORRS     R0,R0,#0x88
   \   000000C0   0xF889 0x0000      STRB     R0,[R9, #+0]
    839              status = gUsbErr_NoError_c;
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0x4683             MOV      R11,R0
    840            }
    841            IntRestoreAll(ccr);
   \                     ??USB_DeviceRecvData_2: (+1)
   \   000000C8   0x9800             LDR      R0,[SP, #+0]
   \   000000CA   0x.... 0x....      BL       IntRestoreAll
    842            return status;
   \   000000CE   0x4658             MOV      R0,R11
   \   000000D0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceRecvData_1: (+1)
   \   000000D2   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    843          }
    844          
    845          /**************************************************************************//*!
    846           *
    847           * @name  USB_DCI_SendData
    848           *
    849           * @brief The function configures Controller to send data on an SEND endpoint
    850           *
    851           * @param handle          : USB Device handle
    852           * @param endpoint_number : Endpoint number
    853           * @param buffer_ptr      : Application buffer pointer
    854           * @param size            : Size of the buffer
    855           *
    856           * @return status
    857           *         gUsbErr_NoError_c           : When successfull
    858           *         gUsbErr_TxFailed_c : When unsuccessfull
    859           ******************************************************************************
    860           * This function configures Controller to send data on a SEND endpoint by
    861           * setting the BDT to send data.
    862           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    863          uint8_t USB_DCI_SendData 
    864          (
    865           uint8_t          controllerId,                           
    866           uint8_t          endpNumber,    /* [IN] Endpoint number */
    867           uint8_t*         pBuff,         /* [IN] Application buffer pointer */
    868           usbPacketSize_t  size    ,            /* [IN] Size of the buffer */
    869           bool_t           shortSend  
    870           )
    871          {
   \                     USB_DeviceSendData: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0005             MOVS     R5,R0
   \   00000008   0x000E             MOVS     R6,R1
   \   0000000A   0x0017             MOVS     R7,R2
   \   0000000C   0x4698             MOV      R8,R3
   \   0000000E   0x9C0C             LDR      R4,[SP, #+48]
    872            
    873            uint8_t status = gUsbErr_TxFailed_c;
   \   00000010   0xF05F 0x0B93      MOVS     R11,#+147
    874            pBuffDsc_t pBuffDsc;
    875            pBdtElem_t pBdtElem;
    876            uint32_t ccr;
    877            /* validate params and get the bdt index */
    878            uint8_t bdtMapIndex = USB_DCI_ValidateParam (endpNumber, gUsbEpDirection_In_c, gUsbBdtEvenBuffer_c);
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x0030             MOVS     R0,R6
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x.... 0x....      BL       USB_DCI_ValidateParam
   \   00000020   0x4682             MOV      R10,R0
    879            (void)(controllerId);
    880            if(bdtMapIndex == gUsbInvalidBdtIndex_d)
   \   00000022   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000026   0xF1BA 0x0FFF      CMP      R10,#+255
   \   0000002A   0xD102             BNE.N    ??USB_DeviceSendData_0
    881            {
    882              return status;
   \   0000002C   0x4658             MOV      R0,R11
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0xE041             B.N      ??USB_DeviceSendData_1
    883            }
    884            ccr = IntDisableAll();
   \                     ??USB_DeviceSendData_0: (+1)
   \   00000032   0x.... 0x....      BL       IntDisableAll
   \   00000036   0x9001             STR      R0,[SP, #+4]
    885            pBdtElem = &gBdtElem[USB_DCI_GetBDTElemIndex(bdtMapIndex)];
   \   00000038   0x4650             MOV      R0,R10
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x.... 0x....      BL       USB_DCI_GetBDTElemIndex
   \   00000040   0x2112             MOVS     R1,#+18
   \   00000042   0x.... 0x....      LDR.W    R2,??DataTable16_4
   \   00000046   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   0000004A   0x4681             MOV      R9,R0
    886            bdtMapIndex = pBdtElem->bdtMapIndex;
   \   0000004C   0xF899 0x000F      LDRB     R0,[R9, #+15]
   \   00000050   0x4682             MOV      R10,R0
    887            pBuffDsc = &gBDTMap.epDsc[bdtMapIndex];
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   00000056   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000005A   0xEB10 0x00CA      ADDS     R0,R0,R10, LSL #+3
   \   0000005E   0x9000             STR      R0,[SP, #+0]
    888            /* Does MCU owns it and it is not stalled */
    889              if(
    890               pBdtElem->noTransferInProgress 
    891               && (pBuffDsc->stat.mcuCtlBit.bdtstall == 0)
    892                 )
   \   00000060   0xF899 0x0011      LDRB     R0,[R9, #+17]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD021             BEQ.N    ??USB_DeviceSendData_2
   \   00000068   0x9800             LDR      R0,[SP, #+0]
   \   0000006A   0x7800             LDRB     R0,[R0, #+0]
   \   0000006C   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD11A             BNE.N    ??USB_DeviceSendData_2
    893            {
    894              /* Initialize transfer */
    895              pBdtElem->appLen = size;
   \   00000076   0xF8A9 0x800A      STRH     R8,[R9, #+10]
    896              pBdtElem->pAppBuffer = pBuff;
   \   0000007A   0xF8C9 0x7006      STR      R7,[R9, #+6]
    897              pBdtElem->currOffset = 0;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xF8A9 0x000C      STRH     R0,[R9, #+12]
    898              pBdtElem->shortSend = shortSend;
   \   00000084   0xF889 0x4010      STRB     R4,[R9, #+16]
    899              /* Prepare for send */
    900              USB_DCI_PrepareSendData(pBuffDsc, pBdtElem);
   \   00000088   0x4649             MOV      R1,R9
   \   0000008A   0x9800             LDR      R0,[SP, #+0]
   \   0000008C   0x.... 0x....      BL       USB_DCI_PrepareSendData
    901              pBdtElem->noTransferInProgress = FALSE;
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xF889 0x0011      STRB     R0,[R9, #+17]
    902              pBuffDsc->stat.byte = (uint8_t)((pBuffDsc->stat.mcuCtlBit.data << 6) | gUsbBdtSCtl_SIE_d | gUsbBdtSCtl_DTS_d);
   \   00000096   0x9800             LDR      R0,[SP, #+0]
   \   00000098   0x7800             LDRB     R0,[R0, #+0]
   \   0000009A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009C   0x0980             LSRS     R0,R0,#+6
   \   0000009E   0x0180             LSLS     R0,R0,#+6
   \   000000A0   0xF050 0x0088      ORRS     R0,R0,#0x88
   \   000000A4   0x9900             LDR      R1,[SP, #+0]
   \   000000A6   0x7008             STRB     R0,[R1, #+0]
    903              status = gUsbErr_NoError_c;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x4683             MOV      R11,R0
    904            } /* Does MCU own IN BDT */
    905            IntRestoreAll(ccr);
   \                     ??USB_DeviceSendData_2: (+1)
   \   000000AC   0x9801             LDR      R0,[SP, #+4]
   \   000000AE   0x.... 0x....      BL       IntRestoreAll
    906            return status;
   \   000000B2   0x4658             MOV      R0,R11
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceSendData_1: (+1)
   \   000000B6   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    907          }
    908          
    909          /**************************************************************************//*!
    910           *
    911           * @name  USB_DCI_SetAddress
    912           *
    913           * @brief The function configures Controller to send data on an SEND endpoint
    914           *
    915           * @param handle  : USB Device handle
    916           * @param address : Controller Address
    917           *
    918           * @return None
    919           *
    920           ******************************************************************************
    921           * Assigns the Address to the Controller
    922           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    923          void  USB_DCI_SetAddress 
    924          (
    925          uint8_t controllerId,                           
    926          uint8_t address    /* [IN] Address of the USB device */
    927          )
    928          {
   \                     USB_DeviceSetAddress: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    929            (void)(controllerId);
    930          	/* set the address */
    931            USB0_ADDR = address;
   \   00000006   0x....             LDR.N    R0,??DataTable16_2  ;; 0x40072098
   \   00000008   0x7005             STRB     R5,[R0, #+0]
    932            USB_DeviceSetStatus(gDciControllerId, gUsbComponentStatus_DeviceState_d,gUsbDeviceState_Address_d);
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable17_10
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x.... 0x....      BL       USB_DeviceSetStatus
    933            return;
   \   00000018   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    934          }
    935          /**************************************************************************//*!
    936           *
    937           * @name  USB_DCI_AssertResume
    938           *
    939           * @brief The function makes the Controller start USB RESUME signaling
    940           *
    941           * @param handle : USB Device handle
    942           *
    943           * @return None
    944           *
    945           ******************************************************************************
    946           *
    947           * This function starts RESUME signalling and then stops it after some delay.
    948           * In this delay make sure that COP is reset.
    949           *
    950           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    951          void USB_DCI_AssertResume
    952          (
    953          uint8_t controllerId                            
    954          )
    955          {
    956            uint16_t delayCount;
    957            (void)controllerId;
    958            /* Clear SUSP Bit from USB_CTRL */
    959            USB0_USBCTRL &= ~USB_USBCTRL_SUSP_MASK;
   \                     USB_DeviceAssertResume: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable16_3  ;; 0x40072100
   \   00000002   0x7812             LDRB     R2,[R2, #+0]
   \   00000004   0xF012 0x027F      ANDS     R2,R2,#0x7F
   \   00000008   0x....             LDR.N    R3,??DataTable16_3  ;; 0x40072100
   \   0000000A   0x701A             STRB     R2,[R3, #+0]
    960            /* Reset Low Power RESUME enable */
    961            USB0_USBTRC0 &= ~USB_USBTRC0_USBRESMEN_MASK;
   \   0000000C   0x....             LDR.N    R2,??DataTable16_10  ;; 0x4007210c
   \   0000000E   0x7812             LDRB     R2,[R2, #+0]
   \   00000010   0xF012 0x02DF      ANDS     R2,R2,#0xDF
   \   00000014   0x....             LDR.N    R3,??DataTable16_10  ;; 0x4007210c
   \   00000016   0x701A             STRB     R2,[R3, #+0]
    962            /* Setup the controller for Remote Wakeup */
    963          	USB0_ISTAT |= USB_ISTAT_RESUME_MASK; 
   \   00000018   0x.... 0x....      LDR.W    R2,??DataTable17_4  ;; 0x40072080
   \   0000001C   0x7812             LDRB     R2,[R2, #+0]
   \   0000001E   0xF052 0x0220      ORRS     R2,R2,#0x20
   \   00000022   0x.... 0x....      LDR.W    R3,??DataTable17_4  ;; 0x40072080
   \   00000026   0x701A             STRB     R2,[R3, #+0]
    964          	USB0_INTEN &= ~USB_INTEN_RESUMEEN_MASK;
   \   00000028   0x....             LDR.N    R2,??DataTable16_12  ;; 0x40072084
   \   0000002A   0x7812             LDRB     R2,[R2, #+0]
   \   0000002C   0xF012 0x02DF      ANDS     R2,R2,#0xDF
   \   00000030   0x....             LDR.N    R3,??DataTable16_12  ;; 0x40072084
   \   00000032   0x701A             STRB     R2,[R3, #+0]
    965          	USB0_CTL &= ~USB_CTL_TXSUSPENDTOKENBUSY_MASK;
   \   00000034   0x.... 0x....      LDR.W    R2,??DataTable17_7  ;; 0x40072094
   \   00000038   0x7812             LDRB     R2,[R2, #+0]
   \   0000003A   0xF012 0x02DF      ANDS     R2,R2,#0xDF
   \   0000003E   0x.... 0x....      LDR.W    R3,??DataTable17_7  ;; 0x40072094
   \   00000042   0x701A             STRB     R2,[R3, #+0]
    966            USB0_CTL |= USB_CTL_RESUME_MASK;   /* Start RESUME signaling and make SUSPEND bit 0*/
   \   00000044   0x.... 0x....      LDR.W    R2,??DataTable17_7  ;; 0x40072094
   \   00000048   0x7812             LDRB     R2,[R2, #+0]
   \   0000004A   0xF052 0x0204      ORRS     R2,R2,#0x4
   \   0000004E   0x.... 0x....      LDR.W    R3,??DataTable17_7  ;; 0x40072094
   \   00000052   0x701A             STRB     R2,[R3, #+0]
    967            delayCount = gUsbDci_AssertResumeDelayCount_c; /* Set RESUME line for 1-15 ms*/
   \   00000054   0xF649 0x4240      MOVW     R2,#+40000
   \   00000058   0x0011             MOVS     R1,R2
    968            do
    969            {
    970              delayCount--;
   \                     ??USB_DeviceAssertResume_0: (+1)
   \   0000005A   0x1E49             SUBS     R1,R1,#+1
    971              //  Watchdog_Reset();    /* Reset the COP */
    972            }while(delayCount);
   \   0000005C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000005E   0x2900             CMP      R1,#+0
   \   00000060   0xD1FB             BNE.N    ??USB_DeviceAssertResume_0
    973            USB0_CTL &= ~USB_CTL_RESUME_MASK;          /* Stop RESUME signalling */
   \   00000062   0x.... 0x....      LDR.W    R2,??DataTable17_7  ;; 0x40072094
   \   00000066   0x7812             LDRB     R2,[R2, #+0]
   \   00000068   0xF012 0x02FB      ANDS     R2,R2,#0xFB
   \   0000006C   0x.... 0x....      LDR.W    R3,??DataTable17_7  ;; 0x40072094
   \   00000070   0x701A             STRB     R2,[R3, #+0]
    974            return;
   \   00000072   0x4770             BX       LR               ;; return
    975          }
    976          
    977          /**************************************************************************//*!
    978           *
    979           * @name  USB_DCI_BusTokenCplHandler
    980           *
    981           * @brief The function handles Token Complete USB interrupts on the bus.
    982           *
    983           * @param stat  : BDT stat byte
    984           * @param event : Pointer to USB EVENT Structure
    985           *
    986           * @return None
    987           ******************************************************************************
    988           * This function handles Token Complete USB interrupts on the bus.
    989           *****************************************************************************/
    990          

   \                                 In section .text, align 2, keep-with-next
    991          void USB_DCI_BusTokenCplHandler 
    992          (
    993          uint8_t stat,            /* [IN] Value of STAT register */
    994          usbDeviceEvent_t* event /* [IN] Pointer to USB EVENT Structure */
    995          )
    996          {
   \                     USB_DCI_BusTokenCplHandler: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    997            uint8_t bdtMapIndex = 0 ;
   \   00000008   0x2600             MOVS     R6,#+0
    998            uint8_t bdtElemIndex;
    999            pBuffDsc_t pBuffDsc = NULL;
   \   0000000A   0x2700             MOVS     R7,#+0
   1000            pBuffDsc_t pBuffDscAlt = NULL;/* stores data of alternate buffer */
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1001            pBdtElem_t pBdtElem = NULL;
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
   1002            /* Get the direction from STAT register */
   1003            event->direction = (uint8_t)((stat & gUsbStat_EndpDirMask_c) >>gUsbStat_EndpDirShift_c);
   \   00000014   0xF3C4 0x00C0      UBFX     R0,R4,#+3,#+1
   \   00000018   0x70E8             STRB     R0,[R5, #+3]
   1004            /* Get bdt index from STAT register*/
   1005            bdtMapIndex =  stat>>2;
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x08A0             LSRS     R0,R4,#+2
   \   0000001E   0x0006             MOVS     R6,R0
   1006            pBuffDsc = &gBDTMap.epDsc[bdtMapIndex];
   \   00000020   0x....             LDR.N    R0,??DataTable16_8
   \   00000022   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000024   0xEB10 0x00C6      ADDS     R0,R0,R6, LSL #+3
   \   00000028   0x0007             MOVS     R7,R0
   1007            pBuffDscAlt = &gBDTMap.epDsc[bdtMapIndex ^ 1];
   \   0000002A   0x....             LDR.N    R0,??DataTable16_8
   \   0000002C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002E   0xF096 0x0101      EORS     R1,R6,#0x1
   \   00000032   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000036   0x4680             MOV      R8,R0
   1008            bdtElemIndex = USB_DCI_GetBDTElemIndex(bdtMapIndex);
   \   00000038   0x0030             MOVS     R0,R6
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x.... 0x....      BL       USB_DCI_GetBDTElemIndex
   \   00000040   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1009          #ifdef gUSB_Debug_d 
   1010            if(bdtElemIndex == gUsbInvalidBdtIndex_d)
   1011            {
   1012              while(TRUE);
   1013            }
   1014          #endif
   1015            pBdtElem = &gBdtElem[bdtElemIndex];
   \   00000044   0x....             LDR.N    R0,??DataTable16_4
   \   00000046   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   0000004A   0x2212             MOVS     R2,#+18
   \   0000004C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000050   0x4681             MOV      R9,R0
   1016            /* Get address from BDT */
   1017            event->pBuffer = (uint8_t*)(pBuffDsc->addr);
   \   00000052   0x6878             LDR      R0,[R7, #+4]
   \   00000054   0x6068             STR      R0,[R5, #+4]
   1018            /* Get len from BDT */
   1019            event->len = pBuffDsc->cnt;
   \   00000056   0x8878             LDRH     R0,[R7, #+2]
   \   00000058   0x8128             STRH     R0,[R5, #+8]
   1020            event->shortSend = pBdtElem->shortSend;
   \   0000005A   0xF899 0x0010      LDRB     R0,[R9, #+16]
   \   0000005E   0x72E8             STRB     R0,[R5, #+11]
   1021            /* Prepare for Next USB Transaction */
   1022            pBdtElem->bdtMapIndex = bdtMapIndex^1;
   \   00000060   0xF096 0x0001      EORS     R0,R6,#0x1
   \   00000064   0xF889 0x000F      STRB     R0,[R9, #+15]
   1023            /* Toggle Data PID*/
   1024            pBuffDscAlt->stat.byte = (uint8_t)((pBuffDsc->stat.mcuCtlBit.data ^ 1) << 6);
   \   00000068   0x7838             LDRB     R0,[R7, #+0]
   \   0000006A   0xF3C0 0x1080      UBFX     R0,R0,#+6,#+1
   \   0000006E   0xF090 0x0001      EORS     R0,R0,#0x1
   \   00000072   0x0180             LSLS     R0,R0,#+6
   \   00000074   0xF888 0x0000      STRB     R0,[R8, #+0]
   1025            if(event->direction == gUsbEpDirection_In_c)
   \   00000078   0x78E8             LDRB     R0,[R5, #+3]
   \   0000007A   0x2801             CMP      R0,#+1
   \   0000007C   0xD162             BNE.N    ??USB_DCI_BusTokenCplHandler_0
   1026            {
   1027              if(event->epNum == gUsbControlEndpoint_d)
   \   0000007E   0x7868             LDRB     R0,[R5, #+1]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD126             BNE.N    ??USB_DCI_BusTokenCplHandler_1
   1028              {
   1029                /* for Control Endpoint */
   1030                /* For Transfer Direction Host to Device */
   1031                if(gTrfDirection == gUsbEpDirection_Out_c)
   \   00000084   0x....             LDR.N    R0,??DataTable16_9
   \   00000086   0x7800             LDRB     R0,[R0, #+0]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD122             BNE.N    ??USB_DCI_BusTokenCplHandler_1
   1032                {
   1033                  uint8_t ctrlOutBdtElemIndex;
   1034                  pBdtElem_t pCtrlOutBdtElem;
   1035                  pBuffDsc_t pCtrlOutBufferDsc;
   1036                  /* make Transfer Direction UNKNOWN */                
   1037                  gTrfDirection = gUsbTrfDirUnknown_d;
   \   0000008C   0x20FF             MOVS     R0,#+255
   \   0000008E   0x....             LDR.N    R1,??DataTable16_9
   \   00000090   0x7008             STRB     R0,[R1, #+0]
   1038                  ctrlOutBdtElemIndex = USB_DCI_GetBDTElemIndex(bdtMapIndex^2);
   \   00000092   0xF096 0x0002      EORS     R0,R6,#0x2
   \   00000096   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000098   0x.... 0x....      BL       USB_DCI_GetBDTElemIndex
   \   0000009C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1039          #ifdef gUSB_Debug_d 
   1040                  if(ctrlOutBdtElemIndex == gUsbInvalidBdtIndex_d)
   1041                  {
   1042                    while(TRUE);
   1043                  }
   1044          #endif
   1045                  pCtrlOutBdtElem = &gBdtElem[ctrlOutBdtElemIndex];
   \   000000A0   0x....             LDR.N    R0,??DataTable16_4
   \   000000A2   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000000A6   0x2212             MOVS     R2,#+18
   \   000000A8   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000000AC   0x4682             MOV      R10,R0
   1046                  pCtrlOutBufferDsc = &gBDTMap.epDsc[pCtrlOutBdtElem->bdtMapIndex];
   \   000000AE   0x....             LDR.N    R0,??DataTable16_8
   \   000000B0   0xF89A 0x100F      LDRB     R1,[R10, #+15]
   \   000000B4   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   000000B8   0x4683             MOV      R11,R0
   1047                  
   1048                  pCtrlOutBufferDsc->stat.byte = gUsbBdtSCtl_Data0_d;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xF88B 0x0000      STRB     R0,[R11, #+0]
   1049                  pCtrlOutBdtElem->noTransferInProgress = TRUE;
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0xF88A 0x0011      STRB     R0,[R10, #+17]
   1050                  USB_DCI_RecvData((event->controllerId), gUsbControlEndpoint_d, NULL,0);
   \   000000C6   0x2300             MOVS     R3,#+0
   \   000000C8   0x2200             MOVS     R2,#+0
   \   000000CA   0x2100             MOVS     R1,#+0
   \   000000CC   0x7828             LDRB     R0,[R5, #+0]
   \   000000CE   0x.... 0x....      BL       USB_DeviceRecvData
   1051                  
   1052                }
   1053              }/* ep_num is CONTROL ENDPOINT */
   1054              
   1055              if((pBdtElem->shortSend == FALSE)&& ((gTrfDirection == gUsbEpDirection_In_c) ||
   1056                                                   (event->epNum != gUsbControlEndpoint_d)))
   \                     ??USB_DCI_BusTokenCplHandler_1: (+1)
   \   000000D2   0xF899 0x0010      LDRB     R0,[R9, #+16]
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xF040 0x80CF      BNE.W    ??USB_DCI_BusTokenCplHandler_2
   \   000000DC   0x....             LDR.N    R0,??DataTable16_9
   \   000000DE   0x7800             LDRB     R0,[R0, #+0]
   \   000000E0   0x2801             CMP      R0,#+1
   \   000000E2   0xD003             BEQ.N    ??USB_DCI_BusTokenCplHandler_3
   \   000000E4   0x7868             LDRB     R0,[R5, #+1]
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xF000 0x80C7      BEQ.W    ??USB_DCI_BusTokenCplHandler_2
   1057              {
   1058                /* update the request */
   1059                pBdtElem->currOffset += event->len;
   \                     ??USB_DCI_BusTokenCplHandler_3: (+1)
   \   000000EC   0xF8B9 0x000C      LDRH     R0,[R9, #+12]
   \   000000F0   0x8929             LDRH     R1,[R5, #+8]
   \   000000F2   0x1808             ADDS     R0,R1,R0
   \   000000F4   0xF8A9 0x000C      STRH     R0,[R9, #+12]
   1060                /*
   1061                Initiate next USB SEND if:
   1062                1. More Data is still pending OR
   1063                2. Send Data == Endpoint Size AND
   1064                3. Zero Termination Flag is TRUE
   1065                */
   1066                if ((pBdtElem->appLen > pBdtElem->currOffset) ||
   1067                    (((uint8_t)event->len == pBdtElem->epSize) && (pBdtElem->flag == TRUE))
   1068                      )
   \   000000F8   0xF8B9 0x000C      LDRH     R0,[R9, #+12]
   \   000000FC   0xF8B9 0x100A      LDRH     R1,[R9, #+10]
   \   00000100   0x4288             CMP      R0,R1
   \   00000102   0xD30A             BCC.N    ??USB_DCI_BusTokenCplHandler_4
   \   00000104   0x8928             LDRH     R0,[R5, #+8]
   \   00000106   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000108   0xF8B9 0x1000      LDRH     R1,[R9, #+0]
   \   0000010C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000010E   0x4288             CMP      R0,R1
   \   00000110   0xD111             BNE.N    ??USB_DCI_BusTokenCplHandler_5
   \   00000112   0xF899 0x000E      LDRB     R0,[R9, #+14]
   \   00000116   0x2801             CMP      R0,#+1
   \   00000118   0xD10D             BNE.N    ??USB_DCI_BusTokenCplHandler_5
   1069                {
   1070                  /* send next Req */
   1071                  USB_DCI_PrepareSendData(pBuffDscAlt, pBdtElem);
   \                     ??USB_DCI_BusTokenCplHandler_4: (+1)
   \   0000011A   0x4649             MOV      R1,R9
   \   0000011C   0x4640             MOV      R0,R8
   \   0000011E   0x.... 0x....      BL       USB_DCI_PrepareSendData
   1072                  
   1073                  /* give the ownership to SIE and TOGGLE DATA BIT */
   1074                  pBuffDscAlt->stat.byte = (uint8_t)(
   1075                                                      ((pBuffDscAlt->stat.mcuCtlBit.data) << 6) |
   1076                                                        gUsbBdtSCtl_SIE_d | gUsbBdtSCtl_DTS_d);;
   \   00000122   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   00000126   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000128   0x0980             LSRS     R0,R0,#+6
   \   0000012A   0x0180             LSLS     R0,R0,#+6
   \   0000012C   0xF050 0x0088      ORRS     R0,R0,#0x88
   \   00000130   0xF888 0x0000      STRB     R0,[R8, #+0]
   1077                                                        return;
   \   00000134   0xE0A8             B.N      ??USB_DCI_BusTokenCplHandler_6
   1078                }
   1079                else
   1080                {
   1081                  event->pBuffer = pBdtElem->pAppBuffer;
   \                     ??USB_DCI_BusTokenCplHandler_5: (+1)
   \   00000136   0xF8D9 0x0006      LDR      R0,[R9, #+6]
   \   0000013A   0x6068             STR      R0,[R5, #+4]
   1082                  event->len = pBdtElem->currOffset;
   \   0000013C   0xF8B9 0x000C      LDRH     R0,[R9, #+12]
   \   00000140   0x8128             STRH     R0,[R5, #+8]
   \   00000142   0xE09A             B.N      ??USB_DCI_BusTokenCplHandler_2
   1083                }
   1084              }
   1085              
   1086            }/* End of SEND loop */
   1087            else /* direction IS gUsbEpDirection_Out_c */
   1088            {
   1089              if(event->epNum == gUsbControlEndpoint_d)
   \                     ??USB_DCI_BusTokenCplHandler_0: (+1)
   \   00000144   0x7868             LDRB     R0,[R5, #+1]
   \   00000146   0x2800             CMP      R0,#+0
   \   00000148   0xD13C             BNE.N    ??USB_DCI_BusTokenCplHandler_7
   1090              {
   1091                /* for Control Endpoint */
   1092                if(pBuffDsc->stat.recPid.pid == gUsbToken_Setup_c)
   \   0000014A   0x7838             LDRB     R0,[R7, #+0]
   \   0000014C   0xF3C0 0x0083      UBFX     R0,R0,#+2,#+4
   \   00000150   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000152   0x280D             CMP      R0,#+13
   \   00000154   0xD122             BNE.N    ??USB_DCI_BusTokenCplHandler_8
   1093                {
   1094                  uint8_t ctrlInBdtElemIndex;
   1095                  pBdtElem_t pCtrlInBdtElem;
   1096                  pBuffDsc_t pCtrlInBufferDsc;
   1097                  /* set setup phase */
   1098                  event->setup = TRUE;
   \   00000156   0x2001             MOVS     R0,#+1
   \   00000158   0x70A8             STRB     R0,[R5, #+2]
   1099                  /* Transfer direction of next packet */
   1100                  gTrfDirection = event->pBuffer[0] >> 7;
   \   0000015A   0x6868             LDR      R0,[R5, #+4]
   \   0000015C   0x7800             LDRB     R0,[R0, #+0]
   \   0000015E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000160   0x09C0             LSRS     R0,R0,#+7
   \   00000162   0x....             LDR.N    R1,??DataTable16_9
   \   00000164   0x7008             STRB     R0,[R1, #+0]
   1101                  ctrlInBdtElemIndex = USB_DCI_GetBDTElemIndex(bdtMapIndex^2);
   \   00000166   0xF096 0x0002      EORS     R0,R6,#0x2
   \   0000016A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000016C   0x.... 0x....      BL       USB_DCI_GetBDTElemIndex
   \   00000170   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1102          #ifdef gUSB_Debug_d 
   1103                  if(ctrlInBdtElemIndex == gUsbInvalidBdtIndex_d)
   1104                  {
   1105                    while(TRUE);
   1106                  }
   1107          #endif
   1108                  pCtrlInBdtElem = &gBdtElem[ctrlInBdtElemIndex];
   \   00000174   0x....             LDR.N    R0,??DataTable16_4
   \   00000176   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000017A   0x2212             MOVS     R2,#+18
   \   0000017C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000180   0x4682             MOV      R10,R0
   1109                  pCtrlInBufferDsc = &gBDTMap.epDsc[pCtrlInBdtElem->bdtMapIndex];
   \   00000182   0x....             LDR.N    R0,??DataTable16_8
   \   00000184   0xF89A 0x100F      LDRB     R1,[R10, #+15]
   \   00000188   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   0000018C   0x4683             MOV      R11,R0
   1110                  pCtrlInBufferDsc->stat.byte = gUsbBdtSCtl_Data1_d;
   \   0000018E   0x2040             MOVS     R0,#+64
   \   00000190   0xF88B 0x0000      STRB     R0,[R11, #+0]
   1111                  pCtrlInBdtElem->noTransferInProgress = TRUE;
   \   00000194   0x2001             MOVS     R0,#+1
   \   00000196   0xF88A 0x0011      STRB     R0,[R10, #+17]
   \   0000019A   0xE013             B.N      ??USB_DCI_BusTokenCplHandler_7
   1112                  
   1113                }
   1114                else if(gTrfDirection == gUsbEpDirection_In_c)
   \                     ??USB_DCI_BusTokenCplHandler_8: (+1)
   \   0000019C   0x....             LDR.N    R0,??DataTable16_9
   \   0000019E   0x7800             LDRB     R0,[R0, #+0]
   \   000001A0   0x2801             CMP      R0,#+1
   \   000001A2   0xD10F             BNE.N    ??USB_DCI_BusTokenCplHandler_7
   1115                {
   1116                  /* make Transfer Direction UNKNOWN */
   1117                  gTrfDirection = gUsbTrfDirUnknown_d;
   \   000001A4   0x20FF             MOVS     R0,#+255
   \   000001A6   0x....             LDR.N    R1,??DataTable16_9
   \   000001A8   0x7008             STRB     R0,[R1, #+0]
   1118                  /* We Require DATA0 PID for Setup Token */
   1119                  pBuffDscAlt->stat.byte = gUsbBdtSCtl_Data0_d;
   \   000001AA   0x2000             MOVS     R0,#+0
   \   000001AC   0xF888 0x0000      STRB     R0,[R8, #+0]
   1120                  pBdtElem->noTransferInProgress = TRUE;
   \   000001B0   0x2001             MOVS     R0,#+1
   \   000001B2   0xF889 0x0011      STRB     R0,[R9, #+17]
   1121                  /* Prepare for Next SETUP PACKET Receive */
   1122                  USB_DCI_RecvData((event->controllerId), gUsbControlEndpoint_d, NULL,0);
   \   000001B6   0x2300             MOVS     R3,#+0
   \   000001B8   0x2200             MOVS     R2,#+0
   \   000001BA   0x2100             MOVS     R1,#+0
   \   000001BC   0x7828             LDRB     R0,[R5, #+0]
   \   000001BE   0x.... 0x....      BL       USB_DeviceRecvData
   1123                  return;
   \   000001C2   0xE061             B.N      ??USB_DCI_BusTokenCplHandler_6
   1124                }
   1125              }   /* ep_num is CONTROL ENDPOINT */
   1126              
   1127              if(pBdtElem->appLen != (usbPacketSize_t)gUninitialisedVal_d)
   \                     ??USB_DCI_BusTokenCplHandler_7: (+1)
   \   000001C4   0xF8B9 0x000A      LDRH     R0,[R9, #+10]
   \   000001C8   0xF64F 0x71FF      MOVW     R1,#+65535
   \   000001CC   0x4288             CMP      R0,R1
   \   000001CE   0xD054             BEQ.N    ??USB_DCI_BusTokenCplHandler_2
   1128              {
   1129                /* on control endpoint the data is only 8 bytes */
   1130                usbPacketSize_t size = event->len;
   \   000001D0   0x8928             LDRH     R0,[R5, #+8]
   1131                pBdtElem->currOffset += size;
   \   000001D2   0xF8B9 0x100C      LDRH     R1,[R9, #+12]
   \   000001D6   0x1841             ADDS     R1,R0,R1
   \   000001D8   0xF8A9 0x100C      STRH     R1,[R9, #+12]
   1132                /*
   1133                Initiate next USB RECV if:
   1134                1. More Data is still pending OR
   1135                2. Received Data == Endpoint Size AND
   1136                3. Zero Termination Flag is TRUE
   1137                */
   1138                if(
   1139                   (size == pBdtElem->epSize) &&
   1140                     ((pBdtElem->appLen > pBdtElem->currOffset) || ((pBdtElem->appLen == pBdtElem->currOffset) && (pBdtElem->flag == TRUE)))
   1141                       ) 
   \   000001DC   0xF8B9 0x1000      LDRH     R1,[R9, #+0]
   \   000001E0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001E2   0x4288             CMP      R0,R1
   \   000001E4   0xD13F             BNE.N    ??USB_DCI_BusTokenCplHandler_9
   \   000001E6   0xF8B9 0x100C      LDRH     R1,[R9, #+12]
   \   000001EA   0xF8B9 0x200A      LDRH     R2,[R9, #+10]
   \   000001EE   0x4291             CMP      R1,R2
   \   000001F0   0xD309             BCC.N    ??USB_DCI_BusTokenCplHandler_10
   \   000001F2   0xF8B9 0x100A      LDRH     R1,[R9, #+10]
   \   000001F6   0xF8B9 0x200C      LDRH     R2,[R9, #+12]
   \   000001FA   0x4291             CMP      R1,R2
   \   000001FC   0xD133             BNE.N    ??USB_DCI_BusTokenCplHandler_9
   \   000001FE   0xF899 0x100E      LDRB     R1,[R9, #+14]
   \   00000202   0x2901             CMP      R1,#+1
   \   00000204   0xD12F             BNE.N    ??USB_DCI_BusTokenCplHandler_9
   1142                {
   1143                  /* send next IO */
   1144                  uint16_t count;
   1145                  count = (uint16_t)(((pBdtElem->appLen - pBdtElem->currOffset)
   1146                                      > pBdtElem->epSize) ? pBdtElem->epSize :
   1147                                         (pBdtElem->appLen - pBdtElem->currOffset));
   \                     ??USB_DCI_BusTokenCplHandler_10: (+1)
   \   00000206   0xF8B9 0x2000      LDRH     R2,[R9, #+0]
   \   0000020A   0xF8B9 0x300A      LDRH     R3,[R9, #+10]
   \   0000020E   0xF8B9 0xC00C      LDRH     R12,[R9, #+12]
   \   00000212   0xEBB3 0x030C      SUBS     R3,R3,R12
   \   00000216   0x429A             CMP      R2,R3
   \   00000218   0xDA02             BGE.N    ??USB_DCI_BusTokenCplHandler_11
   \   0000021A   0xF8B9 0x1000      LDRH     R1,[R9, #+0]
   \   0000021E   0xE004             B.N      ??USB_DCI_BusTokenCplHandler_12
   \                     ??USB_DCI_BusTokenCplHandler_11: (+1)
   \   00000220   0xF8B9 0x100A      LDRH     R1,[R9, #+10]
   \   00000224   0xF8B9 0x200C      LDRH     R2,[R9, #+12]
   \   00000228   0x1A89             SUBS     R1,R1,R2
   1148          				if(count == 0)
   \                     ??USB_DCI_BusTokenCplHandler_12: (+1)
   \   0000022A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000022C   0x2900             CMP      R1,#+0
   \   0000022E   0xD107             BNE.N    ??USB_DCI_BusTokenCplHandler_13
   1149          				{
   1150                    /* For Zero byte Packet Receive */
   1151          					pBuffDscAlt->addr = pBdtElem->addr;
   \   00000230   0xF8D9 0x2002      LDR      R2,[R9, #+2]
   \   00000234   0xF8C8 0x2004      STR      R2,[R8, #+4]
   1152                    pBuffDscAlt->cnt = 0;
   \   00000238   0x2200             MOVS     R2,#+0
   \   0000023A   0xF8A8 0x2002      STRH     R2,[R8, #+2]
   \   0000023E   0xE008             B.N      ??USB_DCI_BusTokenCplHandler_14
   1153          				}
   1154          				else
   1155          				{
   1156                    pBuffDscAlt->addr = (uint32_t)(pBdtElem->pAppBuffer + pBdtElem->currOffset);
   \                     ??USB_DCI_BusTokenCplHandler_13: (+1)
   \   00000240   0xF8D9 0x2006      LDR      R2,[R9, #+6]
   \   00000244   0xF8B9 0x300C      LDRH     R3,[R9, #+12]
   \   00000248   0x189A             ADDS     R2,R3,R2
   \   0000024A   0xF8C8 0x2004      STR      R2,[R8, #+4]
   1157                    pBuffDscAlt->cnt = count;
   \   0000024E   0xF8A8 0x1002      STRH     R1,[R8, #+2]
   1158          				}
   1159                  /* give the ownership to SIE and Toggle DATA bit*/
   1160                  pBuffDscAlt->stat.byte = (uint8_t)((
   1161                                                       (pBuffDscAlt->stat.mcuCtlBit.data) << 6) |
   1162                                                      gUsbBdtSCtl_SIE_d | gUsbBdtSCtl_DTS_d);
   \                     ??USB_DCI_BusTokenCplHandler_14: (+1)
   \   00000252   0xF898 0x2000      LDRB     R2,[R8, #+0]
   \   00000256   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000258   0x0992             LSRS     R2,R2,#+6
   \   0000025A   0x0192             LSLS     R2,R2,#+6
   \   0000025C   0xF052 0x0288      ORRS     R2,R2,#0x88
   \   00000260   0xF888 0x2000      STRB     R2,[R8, #+0]
   1163                  return;
   \   00000264   0xE010             B.N      ??USB_DCI_BusTokenCplHandler_6
   1164                }
   1165                else /* request completed */
   1166                {
   1167                  /* populate buffer structure */
   1168                  event->pBuffer = pBdtElem->pAppBuffer;
   \                     ??USB_DCI_BusTokenCplHandler_9: (+1)
   \   00000266   0xF8D9 0x1006      LDR      R1,[R9, #+6]
   \   0000026A   0x6069             STR      R1,[R5, #+4]
   1169                  event->len = pBdtElem->currOffset;
   \   0000026C   0xF8B9 0x100C      LDRH     R1,[R9, #+12]
   \   00000270   0x8129             STRH     R1,[R5, #+8]
   1170                  pBdtElem->appLen = (usbPacketSize_t)gUninitialisedVal_d;
   \   00000272   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000276   0xF8A9 0x100A      STRH     R1,[R9, #+10]
   1171                }
   1172              }
   1173            } /* End of RECV loop */
   1174            pBdtElem->noTransferInProgress = TRUE;
   \                     ??USB_DCI_BusTokenCplHandler_2: (+1)
   \   0000027A   0x2001             MOVS     R0,#+1
   \   0000027C   0xF889 0x0011      STRB     R0,[R9, #+17]
   1175            /* Notify Device Layer of Data Received or Sent Event */
   1176            (void)USB_DeviceCallService(event->epNum, event);
   \   00000280   0x0029             MOVS     R1,R5
   \   00000282   0x7868             LDRB     R0,[R5, #+1]
   \   00000284   0x.... 0x....      BL       USB_DeviceCallService
   1177            return;
   \                     ??USB_DCI_BusTokenCplHandler_6: (+1)
   \   00000288   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
   1178          }
   1179          
   1180          
   1181          
   1182          
   1183          /**************************************************************************//*!
   1184           *
   1185           * @name  USB_ISR
   1186           *
   1187           * @brief The function handles USB interrupts on the bus.
   1188           *
   1189           * @param None
   1190           *
   1191           * @return None
   1192           *
   1193           ******************************************************************************
   1194           * This function is hooked onto interrupt 69 and handles the USB interrupts.
   1195           * After handling the interrupt it calls the Device Layer to notify it about
   1196           * the event.
   1197           *****************************************************************************/
   1198          

   \                                 In section .text, align 2, keep-with-next
   1199          void USB_ISR(void)
   1200          {
   \                     USB_ISR: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   1201            usbDeviceEvent_t event;
   1202            uint16_t devState = gUsbStatus_Unknown_d;
   \   00000004   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000008   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   1203            uint8_t stat = (uint8_t)USB0_STAT;
   \   0000000C   0x....             LDR.N    R0,??DataTable17_11  ;; 0x40072090
   \   0000000E   0x7804             LDRB     R4,[R0, #+0]
   1204            /* Which interrupt occured and also was enabled */
   1205            uint8_t intrStat =  USB0_ISTAT;
   \   00000010   0x....             LDR.N    R0,??DataTable17_4  ;; 0x40072080
   \   00000012   0x7805             LDRB     R5,[R0, #+0]
   1206            intrStat &= USB0_INTEN;
   \   00000014   0x....             LDR.N    R0,??DataTable17_5  ;; 0x40072084
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x4005             ANDS     R5,R0,R5
   1207            /* initialize event structure */
   1208            event.controllerId = gDciControllerId;
   \   0000001A   0x....             LDR.N    R0,??DataTable17_10
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1209            event.setup = FALSE;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xF88D 0x0006      STRB     R0,[SP, #+6]
   1210            event.pBuffer = NULL;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x9002             STR      R0,[SP, #+8]
   1211            event.len = 0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF8AD 0x000C      STRH     R0,[SP, #+12]
   1212            event.direction = gUsbEpDirection_Out_c;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF88D 0x0007      STRB     R0,[SP, #+7]
   1213            event.errors = 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xF88D 0x000E      STRB     R0,[SP, #+14]
   1214            event.shortSend = FALSE;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xF88D 0x000F      STRB     R0,[SP, #+15]
   1215            event.epNum = (uint8_t)gUninitialisedVal_d;
   \   00000044   0x20FF             MOVS     R0,#+255
   \   00000046   0xF88D 0x0005      STRB     R0,[SP, #+5]
   1216            /* Get the device state from the Device Layer */
   1217            (void)USB_DeviceGetStatus(gDciControllerId, gUsbComponentStatus_DeviceState_d,&devState);
   \   0000004A   0xF10D 0x0202      ADD      R2,SP,#+2
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0x....             LDR.N    R0,??DataTable17_10
   \   00000052   0x7800             LDRB     R0,[R0, #+0]
   \   00000054   0x.... 0x....      BL       USB_DeviceGetStatus
   1218            /* if current device state is SUSPEND and Low Power Resume Flag set */
   1219            if((USB0_USBTRC0 & USB_USBTRC0_USB_RESUME_INT_MASK) && (devState == gUsbDeviceState_Suspend_d))
   \   00000058   0x....             LDR.N    R1,??DataTable17_12  ;; 0x4007210c
   \   0000005A   0x7809             LDRB     R1,[R1, #+0]
   \   0000005C   0x07C9             LSLS     R1,R1,#+31
   \   0000005E   0xD50F             BPL.N    ??USB_ISR_0
   \   00000060   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   00000064   0x2880             CMP      R0,#+128
   \   00000066   0xD10B             BNE.N    ??USB_ISR_0
   1220            {
   1221              /* Clear SUSP Bit from USB_CTRL */
   1222              USB0_USBCTRL &= ~USB_USBCTRL_SUSP_MASK;
   \   00000068   0x....             LDR.N    R0,??DataTable17_13  ;; 0x40072100
   \   0000006A   0x7800             LDRB     R0,[R0, #+0]
   \   0000006C   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000070   0x....             LDR.N    R1,??DataTable17_13  ;; 0x40072100
   \   00000072   0x7008             STRB     R0,[R1, #+0]
   1223              /* Reset Low Power RESUME enable */
   1224              USB0_USBTRC0 &= ~USB_USBTRC0_USBRESMEN_MASK;
   \   00000074   0x....             LDR.N    R0,??DataTable17_12  ;; 0x4007210c
   \   00000076   0x7800             LDRB     R0,[R0, #+0]
   \   00000078   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   0000007C   0x....             LDR.N    R1,??DataTable17_12  ;; 0x4007210c
   \   0000007E   0x7008             STRB     R0,[R1, #+0]
   1225            }
   1226            
   1227            /* SOF received */
   1228            if(UsbDciIntFlag_SofToken(intrStat))
   \                     ??USB_ISR_0: (+1)
   \   00000080   0x0768             LSLS     R0,R5,#+29
   \   00000082   0xD51A             BPL.N    ??USB_ISR_1
   1229            {
   1230              uint16_t sofCount;
   1231              sofCount = USB0_FRMNUMH;
   \   00000084   0x....             LDR.N    R0,??DataTable17_14  ;; 0x400720a4
   \   00000086   0x7800             LDRB     R0,[R0, #+0]
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1232              sofCount <<= 8;
   \   0000008E   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000092   0x0200             LSLS     R0,R0,#+8
   \   00000094   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1233              sofCount += USB0_FRMNUML;
   \   00000098   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000009C   0x....             LDR.N    R1,??DataTable17_15  ;; 0x400720a0
   \   0000009E   0x7809             LDRB     R1,[R1, #+0]
   \   000000A0   0xFA50 0xF081      UXTAB    R0,R0,R1
   \   000000A4   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1234              /* Clear SOF Interrupt */
   1235              USB0_ISTAT = USB_ISTAT_SOFTOK_MASK;
   \   000000A8   0x2004             MOVS     R0,#+4
   \   000000AA   0x....             LDR.N    R1,??DataTable17_4  ;; 0x40072080
   \   000000AC   0x7008             STRB     R0,[R1, #+0]
   1236              /*address of Lower byte of Frame number*/
   1237              event.pBuffer = (uint8_t*)(&sofCount);
   \   000000AE   0xA800             ADD      R0,SP,#+0
   \   000000B0   0x9002             STR      R0,[SP, #+8]
   1238              /* Notify Device Layer of SOF Event */
   1239              (void)USB_DeviceCallService(gUsbService_SOF_d, &event);
   \   000000B2   0xA901             ADD      R1,SP,#+4
   \   000000B4   0x2011             MOVS     R0,#+17
   \   000000B6   0x.... 0x....      BL       USB_DeviceCallService
   1240            }
   1241            
   1242            if(UsbDciIntFlag_BusReset(intrStat))
   \                     ??USB_ISR_1: (+1)
   \   000000BA   0x07E8             LSLS     R0,R5,#+31
   \   000000BC   0xD50F             BPL.N    ??USB_ISR_2
   1243            {
   1244              /* Clear Reset Flag */
   1245              USB0_ISTAT = USB_ISTAT_USBRST_MASK;
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0x....             LDR.N    R1,??DataTable17_4  ;; 0x40072080
   \   000000C2   0x7008             STRB     R0,[R1, #+0]
   1246              /* Handle RESET Interrupt */
   1247              USB_DCI_BusResetHandler();
   \   000000C4   0x.... 0x....      BL       USB_DCI_BusResetHandler
   1248              /* Notify Device Layer of RESET Event */
   1249              (void)USB_DeviceCallService(gUsbService_BusReset_d, &event);
   \   000000C8   0xA901             ADD      R1,SP,#+4
   \   000000CA   0x2010             MOVS     R0,#+16
   \   000000CC   0x.... 0x....      BL       USB_DeviceCallService
   1250              /* Clearing this bit allows the SIE to continue token processing and clear suspend condition */
   1251              USB0_CTL &= ~USB_CTL_TXSUSPENDTOKENBUSY_MASK;
   \   000000D0   0x....             LDR.N    R1,??DataTable17_7  ;; 0x40072094
   \   000000D2   0x7809             LDRB     R1,[R1, #+0]
   \   000000D4   0xF011 0x01DF      ANDS     R1,R1,#0xDF
   \   000000D8   0x....             LDR.N    R2,??DataTable17_7  ;; 0x40072094
   \   000000DA   0x7011             STRB     R1,[R2, #+0]
   1252              /* No need to process other interrupts */
   1253              return;
   \   000000DC   0xE07F             B.N      ??USB_ISR_3
   1254            }
   1255            
   1256            if(UsbDciIntFlag_TokenComplete(intrStat))
   \                     ??USB_ISR_2: (+1)
   \   000000DE   0x0728             LSLS     R0,R5,#+28
   \   000000E0   0xD511             BPL.N    ??USB_ISR_4
   1257            {
   1258              /* Clear TOKEN Interrupt */
   1259              USB0_ISTAT = USB_ISTAT_TOKDNE_MASK;
   \   000000E2   0x2008             MOVS     R0,#+8
   \   000000E4   0x....             LDR.N    R1,??DataTable17_4  ;; 0x40072080
   \   000000E6   0x7008             STRB     R0,[R1, #+0]
   1260              event.epNum = (uint8_t)((stat & gUsbStat_EndpNumberMask_c) >> gUsbStat_EndpNumberShift_c);
   \   000000E8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000EA   0x0920             LSRS     R0,R4,#+4
   \   000000EC   0xF88D 0x0005      STRB     R0,[SP, #+5]
   1261              USB_DCI_BusTokenCplHandler(stat, &event);
   \   000000F0   0xA901             ADD      R1,SP,#+4
   \   000000F2   0x0020             MOVS     R0,R4
   \   000000F4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F6   0x.... 0x....      BL       USB_DCI_BusTokenCplHandler
   1262              /* Clearing this bit allows the SIE to continue token processing and clear suspend condition */
   1263              USB0_CTL &= ~USB_CTL_TXSUSPENDTOKENBUSY_MASK;
   \   000000FA   0x....             LDR.N    R0,??DataTable17_7  ;; 0x40072094
   \   000000FC   0x7800             LDRB     R0,[R0, #+0]
   \   000000FE   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   00000102   0x....             LDR.N    R1,??DataTable17_7  ;; 0x40072094
   \   00000104   0x7008             STRB     R0,[R1, #+0]
   1264            }
   1265            
   1266            if(UsbDciIntFlag_Error(intrStat))
   \                     ??USB_ISR_4: (+1)
   \   00000106   0x07A8             LSLS     R0,R5,#+30
   \   00000108   0xD51A             BPL.N    ??USB_ISR_5
   1267            {
   1268              /* Clear ERROR Interrupt */
   1269              USB0_ISTAT = USB_ISTAT_ERROR_MASK;
   \   0000010A   0x2002             MOVS     R0,#+2
   \   0000010C   0x....             LDR.N    R1,??DataTable17_4  ;; 0x40072080
   \   0000010E   0x7008             STRB     R0,[R1, #+0]
   1270              event.errors = USB0_ERRSTAT;
   \   00000110   0x....             LDR.N    R0,??DataTable17_16  ;; 0x40072088
   \   00000112   0x7800             LDRB     R0,[R0, #+0]
   \   00000114   0xF88D 0x000E      STRB     R0,[SP, #+14]
   1271              event.errors &= USB0_ERREN;
   \   00000118   0xF89D 0x000E      LDRB     R0,[SP, #+14]
   \   0000011C   0x....             LDR.N    R1,??DataTable17_17  ;; 0x4007208c
   \   0000011E   0x7809             LDRB     R1,[R1, #+0]
   \   00000120   0x4008             ANDS     R0,R1,R0
   \   00000122   0xF88D 0x000E      STRB     R0,[SP, #+14]
   1272              /* Notify Device Layer of ERROR Event to error service */
   1273              (void)USB_DeviceCallService(gUsbService_Error_d, &event);
   \   00000126   0xA901             ADD      R1,SP,#+4
   \   00000128   0x2014             MOVS     R0,#+20
   \   0000012A   0x.... 0x....      BL       USB_DeviceCallService
   1274              USB0_ERRSTAT = gUsbDciErrStat_ClearAll_c;  /*clear all errors*/
   \   0000012E   0x21BF             MOVS     R1,#+191
   \   00000130   0x....             LDR.N    R2,??DataTable17_16  ;; 0x40072088
   \   00000132   0x7011             STRB     R1,[R2, #+0]
   1275              /* Clearing this bit allows the SIE to continue token processing and clear suspend condition */
   1276              USB0_CTL &= ~USB_CTL_TXSUSPENDTOKENBUSY_MASK;
   \   00000134   0x....             LDR.N    R1,??DataTable17_7  ;; 0x40072094
   \   00000136   0x7809             LDRB     R1,[R1, #+0]
   \   00000138   0xF011 0x01DF      ANDS     R1,R1,#0xDF
   \   0000013C   0x....             LDR.N    R2,??DataTable17_7  ;; 0x40072094
   \   0000013E   0x7011             STRB     R1,[R2, #+0]
   1277            }
   1278            
   1279            if(UsbDciIntFlag_Sleep(intrStat))
   \                     ??USB_ISR_5: (+1)
   \   00000140   0x06E8             LSLS     R0,R5,#+27
   \   00000142   0xD51B             BPL.N    ??USB_ISR_6
   1280            {
   1281              /* Clear RESUME Interrupt if Pending */
   1282              USB0_ISTAT = USB_ISTAT_RESUME_MASK;
   \   00000144   0x2020             MOVS     R0,#+32
   \   00000146   0x....             LDR.N    R1,??DataTable17_4  ;; 0x40072080
   \   00000148   0x7008             STRB     R0,[R1, #+0]
   1283              /* Clear SLEEP Interrupt */
   1284            	USB0_ISTAT = USB_ISTAT_SLEEP_MASK;
   \   0000014A   0x2010             MOVS     R0,#+16
   \   0000014C   0x....             LDR.N    R1,??DataTable17_4  ;; 0x40072080
   \   0000014E   0x7008             STRB     R0,[R1, #+0]
   1285              /* Notify Device Layer of SLEEP Event */
   1286              (void)USB_DeviceCallService(gUsbService_Sleep_d, &event);
   \   00000150   0xA901             ADD      R1,SP,#+4
   \   00000152   0x2013             MOVS     R0,#+19
   \   00000154   0x.... 0x....      BL       USB_DeviceCallService
   1287              /* Set Low Power RESUME enable */
   1288              USB0_USBTRC0 |= USB_USBTRC0_USBRESMEN_MASK;
   \   00000158   0x....             LDR.N    R1,??DataTable17_12  ;; 0x4007210c
   \   0000015A   0x7809             LDRB     R1,[R1, #+0]
   \   0000015C   0xF051 0x0120      ORRS     R1,R1,#0x20
   \   00000160   0x....             LDR.N    R2,??DataTable17_12  ;; 0x4007210c
   \   00000162   0x7011             STRB     R1,[R2, #+0]
   1289              /* Set SUSP Bit in USB_CTRL */
   1290              USB0_USBCTRL |= USB_USBCTRL_SUSP_MASK;
   \   00000164   0x....             LDR.N    R1,??DataTable17_13  ;; 0x40072100
   \   00000166   0x7809             LDRB     R1,[R1, #+0]
   \   00000168   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   0000016C   0x....             LDR.N    R2,??DataTable17_13  ;; 0x40072100
   \   0000016E   0x7011             STRB     R1,[R2, #+0]
   1291              /* Enable RESUME Interrupt */
   1292              USB0_INTEN |= USB_INTEN_RESUMEEN_MASK;
   \   00000170   0x....             LDR.N    R1,??DataTable17_5  ;; 0x40072084
   \   00000172   0x7809             LDRB     R1,[R1, #+0]
   \   00000174   0xF051 0x0120      ORRS     R1,R1,#0x20
   \   00000178   0x....             LDR.N    R2,??DataTable17_5  ;; 0x40072084
   \   0000017A   0x7011             STRB     R1,[R2, #+0]
   1293            }
   1294            
   1295            if(UsbDciIntFlag_Resume(intrStat))
   \                     ??USB_ISR_6: (+1)
   \   0000017C   0x06A8             LSLS     R0,R5,#+26
   \   0000017E   0xD50C             BPL.N    ??USB_ISR_7
   1296            {
   1297              /* Clear RESUME Interrupt */
   1298              USB0_ISTAT = USB_ISTAT_RESUME_MASK;
   \   00000180   0x2020             MOVS     R0,#+32
   \   00000182   0x....             LDR.N    R1,??DataTable17_4  ;; 0x40072080
   \   00000184   0x7008             STRB     R0,[R1, #+0]
   1299              /* Notify Device Layer of RESUME Event */
   1300              (void)USB_DeviceCallService(gUsbService_Resume_d, &event);
   \   00000186   0xA901             ADD      R1,SP,#+4
   \   00000188   0x2012             MOVS     R0,#+18
   \   0000018A   0x.... 0x....      BL       USB_DeviceCallService
   1301              /* Disable RESUME Interrupt */
   1302              USB0_INTEN &= ~USB_INTEN_RESUMEEN_MASK;
   \   0000018E   0x....             LDR.N    R1,??DataTable17_5  ;; 0x40072084
   \   00000190   0x7809             LDRB     R1,[R1, #+0]
   \   00000192   0xF011 0x01DF      ANDS     R1,R1,#0xDF
   \   00000196   0x....             LDR.N    R2,??DataTable17_5  ;; 0x40072084
   \   00000198   0x7011             STRB     R1,[R2, #+0]
   1303            }
   1304            
   1305            if(UsbDciIntFlag_Stall(intrStat))
   \                     ??USB_ISR_7: (+1)
   \   0000019A   0x0628             LSLS     R0,R5,#+24
   \   0000019C   0xD51F             BPL.N    ??USB_ISR_8
   1306            {
   1307              uint16_t endpStatus;
   1308              event.epNum = (uint8_t)gUninitialisedVal_d;
   \   0000019E   0x20FF             MOVS     R0,#+255
   \   000001A0   0xF88D 0x0005      STRB     R0,[SP, #+5]
   1309              /* If Control Endpoint is stalled then unstall it.
   1310              For other endpoints host issues clear endpoint feature request
   1311              to unstall them */
   1312              /* Get Control Endpoint Status*/
   1313              (void)USB_DeviceGetStatus((event.controllerId),
   1314                                        (gUsbComponentStatus_Endpoint_d|gUsbControlEndpoint_d),
   1315                                        &endpStatus);
   \   000001A4   0xAA04             ADD      R2,SP,#+16
   \   000001A6   0x2110             MOVS     R1,#+16
   \   000001A8   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000001AC   0x.... 0x....      BL       USB_DeviceGetStatus
   1316               if(endpStatus == gUsbStatus_Stalled_d)
   \   000001B0   0xF8BD 0x1010      LDRH     R1,[SP, #+16]
   \   000001B4   0x2901             CMP      R1,#+1
   \   000001B6   0xD105             BNE.N    ??USB_ISR_9
   1317               {
   1318                 event.epNum = gUsbControlEndpoint_d;
   \   000001B8   0x2000             MOVS     R0,#+0
   \   000001BA   0xF88D 0x0005      STRB     R0,[SP, #+5]
   1319                 event.direction = gUsbEpDirection_In_c;
   \   000001BE   0x2001             MOVS     R0,#+1
   \   000001C0   0xF88D 0x0007      STRB     R0,[SP, #+7]
   1320               }
   1321               /* Clear STALL Interrupt */
   1322               USB0_ISTAT = USB_ISTAT_STALL_MASK;
   \                     ??USB_ISR_9: (+1)
   \   000001C4   0x2080             MOVS     R0,#+128
   \   000001C6   0x....             LDR.N    R1,??DataTable17_4  ;; 0x40072080
   \   000001C8   0x7008             STRB     R0,[R1, #+0]
   1323               /* Notify Device Layer of STALL Event */
   1324               (void)USB_DeviceCallService(gUsbService_Stall_d, &event);
   \   000001CA   0xA901             ADD      R1,SP,#+4
   \   000001CC   0x2015             MOVS     R0,#+21
   \   000001CE   0x.... 0x....      BL       USB_DeviceCallService
   1325               /* Clearing this bit allows the SIE to continue token processing and clear suspend condition */
   1326               USB0_CTL &= ~USB_CTL_TXSUSPENDTOKENBUSY_MASK;
   \   000001D2   0x....             LDR.N    R1,??DataTable17_7  ;; 0x40072094
   \   000001D4   0x7809             LDRB     R1,[R1, #+0]
   \   000001D6   0xF011 0x01DF      ANDS     R1,R1,#0xDF
   \   000001DA   0x....             LDR.N    R2,??DataTable17_7  ;; 0x40072094
   \   000001DC   0x7011             STRB     R1,[R2, #+0]
   1327            }
   1328            return;
   \                     ??USB_ISR_8: (+1)
   \                     ??USB_ISR_3: (+1)
   \   000001DE   0xB005             ADD      SP,SP,#+20
   \   000001E0   0xBD30             POP      {R4,R5,PC}       ;; return
   1329          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x40072088         DC32     0x40072088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x40072094         DC32     0x40072094

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x40072098         DC32     0x40072098

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x40072100         DC32     0x40072100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x........         DC32     gBdtElem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x........         DC32     endpCtl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x........         DC32     gaEndpBuffers

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0x........         DC32     endpCtl+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   0x........         DC32     gBDTMap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   0x........         DC32     gTrfDirection

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   0x4007210C         DC32     0x4007210c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   0x4007208C         DC32     0x4007208c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \   00000000   0x40072084         DC32     0x40072084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \   00000000   0x........         DC32     gDciControllerId

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x4007209C         DC32     0x4007209c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x400720B0         DC32     0x400720b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x400720B4         DC32     0x400720b4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x40072108         DC32     0x40072108

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x40072080         DC32     0x40072080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0x40072084         DC32     0x40072084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   0x400720C0         DC32     0x400720c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   0x40072094         DC32     0x40072094

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_9:
   \   00000000   0x........         DC32     gaEndpBuffers+0x50

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_10:
   \   00000000   0x........         DC32     gDciControllerId

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_11:
   \   00000000   0x40072090         DC32     0x40072090

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_12:
   \   00000000   0x4007210C         DC32     0x4007210c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_13:
   \   00000000   0x40072100         DC32     0x40072100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_14:
   \   00000000   0x400720A4         DC32     0x400720a4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_15:
   \   00000000   0x400720A0         DC32     0x400720a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_16:
   \   00000000   0x40072088         DC32     0x40072088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_17:
   \   00000000   0x4007208C         DC32     0x4007208c

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x00000008         DC32 8, 4
   \              0x00000004   
   1330          
   1331          #endif//gUsbIncluded_d

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   USB_DCI_BusResetHandler
         8   -> MemorySet
      40   USB_DCI_BusTokenCplHandler
        40   -> USB_DCI_GetBDTElemIndex
        40   -> USB_DCI_PrepareSendData
        40   -> USB_DeviceCallService
        40   -> USB_DeviceRecvData
       0   USB_DCI_DeInit
      24   USB_DCI_DeinitEndpoint
        24   -> USB_DCI_GetBDTElemIndex
        24   -> USB_DCI_ValidateParam
        24   -> USB_DeviceCancelTransfer
       0   USB_DCI_GetBDTElemIndex
       4   USB_DCI_GetBDTMapIndex
       8   USB_DCI_Init
         8   -> MemorySet
      48   USB_DCI_InitEndpoint
        48   -> USB_DCI_GetBDTElemIndex
        48   -> USB_DCI_GetBDTMapIndex
      12   USB_DCI_PrepareSendData
      24   USB_DCI_ValidateParam
        24   -> USB_DCI_GetBDTElemIndex
        24   -> USB_DCI_GetBDTMapIndex
       0   USB_DeviceAssertResume
      32   USB_DeviceCancelTransfer
        32   -> USB_DCI_GetBDTElemIndex
        32   -> USB_DCI_ValidateParam
      48   USB_DeviceRecvData
        48   -> IntDisableAll
        48   -> IntRestoreAll
        48   -> USB_DCI_GetBDTElemIndex
        48   -> USB_DCI_ValidateParam
      48   USB_DeviceSendData
        48   -> IntDisableAll
        48   -> IntRestoreAll
        48   -> USB_DCI_GetBDTElemIndex
        48   -> USB_DCI_PrepareSendData
        48   -> USB_DCI_ValidateParam
      16   USB_DeviceSetAddress
        16   -> USB_DeviceSetStatus
      24   USB_DeviceStallEndpoint
        24   -> USB_DCI_GetBDTElemIndex
        24   -> USB_DCI_ValidateParam
        24   -> USB_DeviceCancelTransfer
      24   USB_DeviceUnstallEndpoint
        24   -> USB_DCI_GetBDTElemIndex
        24   -> USB_DCI_ValidateParam
        24   -> USB_DeviceRecvData
      32   USB_Device_GetTransferStatus
        32   -> USB_DCI_GetBDTElemIndex
        32   -> USB_DCI_ValidateParam
      32   USB_Device_ReadSetupData
        32   -> MemoryCpy
        32   -> USB_DCI_GetBDTElemIndex
        32   -> USB_DCI_ValidateParam
      32   USB_ISR
        32   -> USB_DCI_BusResetHandler
        32   -> USB_DCI_BusTokenCplHandler
        32   -> USB_DeviceCallService
        32   -> USB_DeviceGetStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_10
       4  ??DataTable17_11
       4  ??DataTable17_12
       4  ??DataTable17_13
       4  ??DataTable17_14
       4  ??DataTable17_15
       4  ??DataTable17_16
       4  ??DataTable17_17
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable17_9
       8  ?_0
     174  USB_DCI_BusResetHandler
     652  USB_DCI_BusTokenCplHandler
     100  USB_DCI_DeInit
     102  USB_DCI_DeinitEndpoint
      42  USB_DCI_GetBDTElemIndex
      38  USB_DCI_GetBDTMapIndex
     216  USB_DCI_Init
     494  USB_DCI_InitEndpoint
      46  USB_DCI_PrepareSendData
      96  USB_DCI_ValidateParam
     116  USB_DeviceAssertResume
     124  USB_DeviceCancelTransfer
     214  USB_DeviceRecvData
     186  USB_DeviceSendData
      26  USB_DeviceSetAddress
     110  USB_DeviceStallEndpoint
     102  USB_DeviceUnstallEndpoint
     174  USB_Device_GetTransferStatus
      92  USB_Device_ReadSetupData
     482  USB_ISR
      40  endpCtl
     512  gBDTMap
      92  gBdtElem
       1  gDciControllerId
       1  gTrfDirection
      80  gaEndpBuffers

 
   725 bytes in section .bss
     1 byte  in section .data
     8 bytes in section .rodata
 3 714 bytes in section .text
 
 3 714 bytes of CODE  memory
     8 bytes of CONST memory
   726 bytes of DATA  memory

Errors: none
Warnings: none
