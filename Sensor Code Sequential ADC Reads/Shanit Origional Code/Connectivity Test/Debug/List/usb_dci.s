///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM       02/Sep/2018  14:19:43
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\Driver\usb_dci.c
//    Command line =  
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\Driver\usb_dci.c" -D IAR --preprocess
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\" -lC
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\" -lB
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\"
//        --diag_suppress Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\Obj\" --no_cse
//        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
//        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\APP\CDC\" -I "F:\Guardrail Work\Sensor Code\Git
//        Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\USB\APP\Descriptor\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Class\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Sys Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
//    List file    =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\usb_dci.s
//
///////////////////////////////////////////////////////////////////////////////

        #define SHT_PROGBITS 0x1

        EXTERN IntDisableAll
        EXTERN IntRestoreAll
        EXTERN MemoryCpy
        EXTERN MemorySet
        EXTERN USB_DeviceCallService
        EXTERN USB_DeviceGetStatus
        EXTERN USB_DeviceSetStatus

        PUBLIC USB_DCI_DeInit
        PUBLIC USB_DCI_DeinitEndpoint
        PUBLIC USB_DCI_Init
        PUBLIC USB_DCI_InitEndpoint
        PUBLIC USB_DeviceAssertResume
        PUBLIC USB_DeviceCancelTransfer
        PUBLIC USB_DeviceRecvData
        PUBLIC USB_DeviceSendData
        PUBLIC USB_DeviceSetAddress
        PUBLIC USB_DeviceStallEndpoint
        PUBLIC USB_DeviceUnstallEndpoint
        PUBLIC USB_Device_GetTransferStatus
        PUBLIC USB_Device_ReadSetupData
        PUBLIC USB_ISR

// F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\usb_dci.c
//    1 /******************************************************************************
//    2  *
//    3  * Freescale Semiconductor Inc.
//    4  * (c) Copyright 2004-2012 Freescale Semiconductor, Inc.
//    5  * ALL RIGHTS RESERVED.
//    6  *
//    7  ******************************************************************************
//    8  *
//    9  * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
//   10  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//   11  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//   12  * IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//   13  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//   14  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//   15  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//   16  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//   17  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//   18  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
//   19  * THE POSSIBILITY OF SUCH DAMAGE.
//   20  *
//   21  **************************************************************************//*!
//   22  *
//   23  * @file usb_dci_kinetis.c
//   24  *
//   25  * @author
//   26  *
//   27  * @version
//   28  *
//   29  * @date
//   30  *
//   31  * @brief The file contains Kinetis USB stack controller layer implementation.
//   32  *
//   33  *****************************************************************************/
//   34 
//   35 /******************************************************************************
//   36  * Includes
//   37  *****************************************************************************/
//   38 #include <string.h>
//   39 #include "USB_Interface.h"   
//   40 #include "usb_dciapi.h" /* USB DCI API Header File */
//   41 #include "usb_devapi.h" /* USB Device API Header File */
//   42 #include "usb_dci.h"    /* USB DCI Header File */
//   43 #include "usb_bdt.h"    /* USB BDT Structure Header File */
//   44 #include "usb_class.h"
//   45 #include "USB.h"
//   46 #include "Utilities_Interface.h"
//   47 #if gUsbIncluded_d   
//   48 /*****************************************************************************
//   49  * Constant and Macro's - None
//   50  *****************************************************************************/
//   51 /*****************************************************************************
//   52  * Local Types - None
//   53  *****************************************************************************/
//   54 
//   55 /****************************************************************************
//   56  * Global Variables
//   57  ****************************************************************************/
//   58 /* location for BDT Table and buff */
//   59 #if (defined(__CWCC__)||defined(__GNUC__))
//   60 	__attribute__((__aligned__(512)))
//   61 #elif defined(__IAR_SYSTEMS_ICC__)
//   62 	#pragma data_alignment = 512
//   63 #endif
//   64 
//   65 /* BDT Map Structure */
//   66 #if defined __CC_ARM
//   67    __align(512) static bdtMap_t gBDTMap; 
//   68 #else

        SECTION `.bss`:DATA:REORDER:NOROOT(9)
//   69    static bdtMap_t gBDTMap;      
gBDTMap:
        DS8 512
//   70 #endif
//   71 /* endpoint buffers allocated by default */

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   72 static uint8_t gaEndpBuffers[gSizeOfUsbRam_d];   
gaEndpBuffers:
        DS8 80
//   73 /* Table of bdtElem_t used for endpoint management */

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   74 static bdtElem_t gBdtElem[gNumUsbEp_d];
gBdtElem:
        DS8 92
//   75 
//   76 /* structure  used for endpoint buffers allocation and for binding the bdt map with bdt elem */
//   77 static struct  endpCtl_tag
//   78 {
//   79 	uint32_t            endpBuffAddrAlloc;
//   80   uint8_t             bdtElemIndexMap[gUsbMaxBdtIndex_d>>1];
//   81 	uint8_t             bdtElemIndexAlloc;            

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   82 } endpCtl;
endpCtl:
        DS8 40
//   83 /* stores Controller ID */

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   84 static uint8_t gDciControllerId = 0;
gDciControllerId:
        DS8 1
//   85 /* Transfer direction */

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//   86 static uint8_t gTrfDirection = gUsbTrfDirUnknown_d;
gTrfDirection:
        DATA
        DC8 255
//   87 
//   88 /*****************************************************************************
//   89  * Local Functions Prototypes
//   90  *****************************************************************************/
//   91 static void USB_DCI_BusResetHandler(void);
//   92 
//   93 static uint8_t USB_DCI_GetBDTMapIndex(uint8_t ep_num,
//   94                                     uint8_t direction,
//   95                                     bool_t odd);
//   96 static uint8_t USB_DCI_GetBDTElemIndex (uint8_t bdtMapIndex);
//   97 static uint8_t USB_DCI_ValidateParam(uint8_t ep_num,
//   98                                     uint8_t direction,
//   99                                     bool_t odd);
//  100 static void USB_DCI_PrepareSendData(pBuffDsc_t pBuffDsc,
//  101                                     pBdtElem_t pBdtElem);
//  102 static void USB_DCI_BusTokenCplHandler(uint8_t stat,
//  103                                     usbDeviceEvent_t* event);
//  104 
//  105 #ifdef USB_LOWPOWERMODE
//  106 	static void Enter_StopMode(STOP_MODE stop_mode);
//  107 #endif
//  108 /*****************************************************************************
//  109  * Local Variables - None
//  110  *****************************************************************************/
//  111 
//  112 /*****************************************************************************
//  113  * Local Functions
//  114  *****************************************************************************/
//  115 
//  116 /**************************************************************************//*!
//  117  *
//  118  * @name  USB_DCI_BusResetHandler
//  119  *
//  120  * @brief The function handles Bus Reset Interrupt
//  121  *
//  122  * @param  None
//  123  *
//  124  * @return None
//  125  *
//  126  ******************************************************************************
//  127  * This functions is called when USB Bus Reset event is received on USB Bus.
//  128  * This function clears all the errors conditions and reinit Global data
//  129  * structures. Also resets USB device controller.
//  130  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  131   static void USB_DCI_BusResetHandler (void)
//  132   {
USB_DCI_BusResetHandler:
        PUSH     {R7,LR}
//  133     USB0_ERRSTAT = gUsbDciErrStat_ClearAll_c;  /* clear USB error flag */
        MOVS     R0,#+191
        LDR.W    R1,??DataTable16  ;; 0x40072088
        STRB     R0,[R1, #+0]
//  134     USB0_CTL |= USB_CTL_ODDRST_MASK;                /* Reset to Even buffer */
        LDR.W    R0,??DataTable16_1  ;; 0x40072094
        LDRB     R0,[R0, #+0]
        ORRS     R0,R0,#0x2
        LDR.W    R1,??DataTable16_1  ;; 0x40072094
        STRB     R0,[R1, #+0]
//  135     USB0_ADDR = 0;                       /* reset to default address */
        MOVS     R0,#+0
        LDR.W    R1,??DataTable16_2  ;; 0x40072098
        STRB     R0,[R1, #+0]
//  136     USB0_USBCTRL = 0x00;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable16_3  ;; 0x40072100
        STRB     R0,[R1, #+0]
//  137     
//  138     MemorySet( gBdtElem,  (uint8_t)gUninitialisedVal_d, (uint16_t)sizeof(gBdtElem));
        MOVS     R2,#+90
        MOVS     R1,#+255
        LDR.W    R0,??DataTable16_4
        BL       MemorySet
//  139     endpCtl.bdtElemIndexAlloc = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable16_5
        STRB     R0,[R1, #+36]
//  140     endpCtl.endpBuffAddrAlloc = (uint32_t)gaEndpBuffers;
        LDR.W    R0,??DataTable16_6
        LDR.W    R1,??DataTable16_5
        STR      R0,[R1, #+0]
//  141     MemorySet(endpCtl.bdtElemIndexMap, (uint8_t)gUsbInvalidBdtIndex_d, (uint16_t)sizeof(endpCtl.bdtElemIndexMap));
        MOVS     R2,#+32
        MOVS     R1,#+255
        LDR.W    R0,??DataTable16_7
        BL       MemorySet
//  142     MemorySet(&gBDTMap, 0, (uint16_t)sizeof(gBDTMap));     
        MOV      R2,#+512
        MOVS     R1,#+0
        LDR.W    R0,??DataTable16_8
        BL       MemorySet
//  143     gTrfDirection = gUsbTrfDirUnknown_d;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable16_9
        STRB     R0,[R1, #+0]
//  144     USB0_CTL &= ~USB_CTL_ODDRST_MASK;
        LDR.W    R0,??DataTable16_1  ;; 0x40072094
        LDRB     R0,[R0, #+0]
        ANDS     R0,R0,#0xFD
        LDR.W    R1,??DataTable16_1  ;; 0x40072094
        STRB     R0,[R1, #+0]
//  145     USB0_USBTRC0 |= 0x40;            
        LDR.W    R0,??DataTable16_10  ;; 0x4007210c
        LDRB     R0,[R0, #+0]
        ORRS     R0,R0,#0x40
        LDR.W    R1,??DataTable16_10  ;; 0x4007210c
        STRB     R0,[R1, #+0]
//  146     USB0_ERREN = gUsbDciErrEnb_EnableAll_c;   /* Enable All Error Interrupts */
        MOVS     R0,#+191
        LDR.W    R1,??DataTable16_11  ;; 0x4007208c
        STRB     R0,[R1, #+0]
//  147     USB0_INTEN = gUsbDciIntEnb_IntEnbAtBusReset_c; /* Enable All Interrupts except RESUME */
        MOVS     R0,#+159
        LDR.W    R1,??DataTable16_12  ;; 0x40072084
        STRB     R0,[R1, #+0]
//  148     USB0_CTL &= ~USB_CTL_TXSUSPENDTOKENBUSY_MASK;
        LDR.W    R0,??DataTable16_1  ;; 0x40072094
        LDRB     R0,[R0, #+0]
        ANDS     R0,R0,#0xDF
        LDR.W    R1,??DataTable16_1  ;; 0x40072094
        STRB     R0,[R1, #+0]
//  149   }
        POP      {R0,PC}          ;; return
//  150         
//  151 /**************************************************************************//*!
//  152  *
//  153  * @name  USB_DCI_GetBDTMapIndex
//  154  *
//  155  * @brief The function maps endpoint number and direction to bdt index
//  156  *
//  157  * @param  ep_num   : Endpoint Number
//  158  * @param  direction: Endpoint direction
//  159  * @param  odd      : Odd or even buffer
//  160  *
//  161  * @return bdt index         : Mapped bdt index
//  162  *         gUsbInvalidBdtIndex_d : In case of error
//  163  *
//  164  ******************************************************************************
//  165  * This function returns BDT Index from Endpoint number, direction,
//  166  * odd/even buffer
//  167  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  168   static uint8_t USB_DCI_GetBDTMapIndex 
//  169     (
//  170      uint8_t epNum,     /* [IN] Endpoint Number */
//  171      uint8_t direction,  /* [IN] Endpoint direction */
//  172      bool_t odd        /* [IN] Odd or even buffer */
//  173     )
//  174     {
USB_DCI_GetBDTMapIndex:
        PUSH     {R4}
        MOVS     R3,R0
//  175       uint8_t bdtMapIndex = gUsbInvalidBdtIndex_d;
        MOVS     R0,#+255
//  176       
//  177       if(epNum < gNumMaxEnpNumber_d)
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+16
        BGE.N    ??USB_DCI_GetBDTMapIndex_0
//  178       {
//  179         /* per endpoint 4 bdt_index -- 2 for recv 2 for send */
//  180         bdtMapIndex = (epNum <<2) ;
        LSLS     R4,R3,#+2
        MOVS     R0,R4
//  181         if(direction == gUsbEpDirection_In_c)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.N    ??USB_DCI_GetBDTMapIndex_1
//  182         {
//  183           bdtMapIndex += 2;
        ADDS     R0,R0,#+2
//  184         }
//  185         if(odd)
??USB_DCI_GetBDTMapIndex_1:
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+0
        BEQ.N    ??USB_DCI_GetBDTMapIndex_0
//  186         {
//  187           bdtMapIndex++;
        ADDS     R0,R0,#+1
//  188         }
//  189       }
//  190       return bdtMapIndex;
??USB_DCI_GetBDTMapIndex_0:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R4}
        BX       LR               ;; return
//  191     }
//  192 
//  193 /**************************************************************************//*!
//  194  *
//  195  * @name  USB_DCI_GetBDTElemIndex
//  196  *
//  197  * @brief The function returns the index of the associated gBdtElem
//  198  *
//  199  * @param  bdtMapIndex   : the index in the buffer descriptor table
//  200  * 
//  201  *
//  202  * @return bdtElemIndex          : bdtElemIndex associated with the bdtMapIndex received as param
//  203  *         gUsbInvalidBdtIndex_d : In case of error
//  204  *
//  205  ******************************************************************************
//  206  * This function returns BDT Index from Endpoint number, direction,
//  207  * odd/even buffer
//  208  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  209   static uint8_t USB_DCI_GetBDTElemIndex (uint8_t bdtMapIndex)
//  210   {
USB_DCI_GetBDTElemIndex:
        MOVS     R1,R0
//  211     uint8_t bdtElemIndex;
//  212     if(bdtMapIndex >= gUsbMaxBdtIndex_d)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+64
        BLT.N    ??USB_DCI_GetBDTElemIndex_0
//  213     {
//  214       return gUsbInvalidBdtIndex_d;
        MOVS     R0,#+255
        B.N      ??USB_DCI_GetBDTElemIndex_1
//  215     } 
//  216     bdtElemIndex = endpCtl.bdtElemIndexMap[bdtMapIndex>>1];
??USB_DCI_GetBDTElemIndex_0:
        LDR.W    R0,??DataTable16_5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        ADDS     R0,R0,R1, ASR #+1
        LDRB     R0,[R0, #+4]
        MOVS     R2,R0
//  217     if(bdtElemIndex < gNumUsbEp_d)
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+5
        BGE.N    ??USB_DCI_GetBDTElemIndex_2
//  218     {
//  219       return bdtElemIndex;
        MOVS     R0,R2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        B.N      ??USB_DCI_GetBDTElemIndex_1
//  220     }
//  221     return gUsbInvalidBdtIndex_d;
??USB_DCI_GetBDTElemIndex_2:
        MOVS     R0,#+255
??USB_DCI_GetBDTElemIndex_1:
        BX       LR               ;; return
//  222   }
//  223 /**************************************************************************//*!
//  224  *
//  225  * @name  USB_DCI_ValidateParam
//  226  *
//  227  * @brief The function validates endpoint number & direction parameters
//  228  *        and returns bdt index.
//  229  *
//  230  * @param  ep_num   : Endpoint Number
//  231  * @param  direction: Endpoint direction
//  232  * @param  odd      : odd or even buffer
//  233  *
//  234  * @return bdt index         : mapped bdt index
//  235  *         gUsbInvalidBdtIndex_d : incase of error
//  236  *
//  237  ******************************************************************************
//  238  * This function validates endpoint parameters and returns bdt index
//  239  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  240   static uint8_t USB_DCI_ValidateParam 
//  241     (
//  242      uint8_t epNum,     /* [IN] Endpoint Number */
//  243      uint8_t direction,  /* [IN] Endpoint direction */
//  244      bool_t odd        /* [IN] Odd or even buffer */
//  245        )
//  246     {
USB_DCI_ValidateParam:
        PUSH     {R4-R8,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
//  247       /* Get bdt index mapped to endpoint number-direction and odd/even buffer */
//  248       uint8_t bdtElemIndex;
//  249       uint8_t bdtMapIndex = USB_DCI_GetBDTMapIndex(epNum, direction, odd);
        MOVS     R2,R6
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,R5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_GetBDTMapIndex
        MOV      R8,R0
//  250       
//  251       if(bdtMapIndex  == gUsbInvalidBdtIndex_d)
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+255
        BNE.N    ??USB_DCI_ValidateParam_0
//  252         return gUsbInvalidBdtIndex_d;
        MOVS     R0,#+255
        B.N      ??USB_DCI_ValidateParam_1
//  253       bdtElemIndex = USB_DCI_GetBDTElemIndex(bdtMapIndex);
??USB_DCI_ValidateParam_0:
        MOV      R0,R8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_GetBDTElemIndex
        MOVS     R7,R0
//  254       if(bdtElemIndex  == gUsbInvalidBdtIndex_d)
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+255
        BNE.N    ??USB_DCI_ValidateParam_2
//  255         return gUsbInvalidBdtIndex_d;
        MOVS     R0,#+255
        B.N      ??USB_DCI_ValidateParam_1
//  256       if(gBdtElem[bdtElemIndex].epSize == (uint16_t)gUninitialisedVal_d)
??USB_DCI_ValidateParam_2:
        LDR.W    R0,??DataTable16_4
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R1,#+18
        MLA      R0,R1,R7,R0
        LDRH     R0,[R0, #+0]
        MOVW     R1,#+65535
        CMP      R0,R1
        BNE.N    ??USB_DCI_ValidateParam_3
//  257       {
//  258         return gUsbInvalidBdtIndex_d;
        MOVS     R0,#+255
        B.N      ??USB_DCI_ValidateParam_1
//  259       } 
//  260       
//  261       return bdtMapIndex;
??USB_DCI_ValidateParam_3:
        MOV      R0,R8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
??USB_DCI_ValidateParam_1:
        POP      {R4-R8,PC}       ;; return
//  262     }
//  263 
//  264 /**************************************************************************//*!
//  265  *
//  266  * @name  USB_DCI_PrepareSendData
//  267  *
//  268  * @brief The function sets up the BDT for Send
//  269  *
//  270  * @param  buffer_dsc   : Pointer to buffer descriptor element in USB_RAM
//  271  * @param  bdt_elem     : Pointer to per endpoint/direction structure
//  272  *
//  273  * @return None
//  274  *
//  275  ******************************************************************************
//  276  * This functions configures Buffer Descriptor (Address and Count)
//  277  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  278 static void USB_DCI_PrepareSendData (
//  279     pBuffDsc_t pBuffDsc,  /* [OUT] Pointer to buffer descriptor
//  280                                 element in USB_RAM */
//  281     pBdtElem_t pBdtElem     /* [IN] Pointer to per endpoint/direction
//  282                                 structure */
//  283 )
//  284 {
USB_DCI_PrepareSendData:
        PUSH     {R4-R6}
//  285     uint8_t* pBuff = pBdtElem->pAppBuffer + pBdtElem->currOffset;
        LDR      R2,[R1, #+6]
        LDRH     R3,[R1, #+12]
        ADDS     R2,R3,R2
//  286     uint16_t currentCount = 0;
        MOVS     R3,#+0
//  287 
//  288     /* adjust size based on the input at the init endpoint */
//  289     if((pBdtElem->appLen - pBdtElem->currOffset) > pBdtElem->epSize)
        LDRH     R4,[R1, #+0]
        LDRH     R5,[R1, #+10]
        LDRH     R6,[R1, #+12]
        SUBS     R5,R5,R6
        CMP      R4,R5
        BGE.N    ??USB_DCI_PrepareSendData_0
//  290     {
//  291         /* If size of packet is greater than endpoint buffer size */
//  292         currentCount = pBdtElem->epSize;
        LDRH     R4,[R1, #+0]
        MOVS     R3,R4
        B.N      ??USB_DCI_PrepareSendData_1
//  293     }
//  294     else
//  295     {
//  296         /* If size of packet is smaller than endpoint buffer size */
//  297         currentCount = (uint16_t)(pBdtElem->appLen - pBdtElem->currOffset);
??USB_DCI_PrepareSendData_0:
        LDRH     R4,[R1, #+10]
        LDRH     R5,[R1, #+12]
        SUBS     R4,R4,R5
        MOVS     R3,R4
//  298     }
//  299     pBuffDsc->cnt = currentCount;
??USB_DCI_PrepareSendData_1:
        STRH     R3,[R0, #+2]
//  300     pBuffDsc->addr = (uint32_t)pBuff;
        STR      R2,[R0, #+4]
//  301 }
        POP      {R4-R6}
        BX       LR               ;; return
//  302 
//  303 /*****************************************************************************
//  304  * Global Functions
//  305  *****************************************************************************/
//  306 
//  307 /**************************************************************************//*!
//  308  *
//  309  * @name  USB_DCI_Init
//  310  *
//  311  * @brief The function initializes the Controller layer
//  312  *
//  313  * @param controller_ID : Controller ID
//  314  *
//  315  * @return status
//  316  *         gUsbErr_NoError_c    : Always
//  317  ******************************************************************************
//  318  * Initializes the USB controller
//  319  *****************************************************************************/ 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  320 uint8_t USB_DCI_Init 
//  321 (
//  322 uint8_t    controllerId   /* [IN] Controller ID */
//  323 )
//  324 {
USB_DCI_Init:
        PUSH     {R4,LR}
        MOVS     R4,R0
//  325 	/* Select System Clock and Disable Weak Pull Downs */
//  326 	USB0_USBCTRL = 0x00;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable16_3  ;; 0x40072100
        STRB     R0,[R1, #+0]
//  327 	/* save the controller_ID for future use */
//  328   gDciControllerId = controllerId;
        LDR.W    R0,??DataTable16_13
        STRB     R4,[R0, #+0]
//  329   /* Clear bdt elem structure */
//  330   MemorySet( gBdtElem,  (uint8_t)gUninitialisedVal_d, (uint16_t)sizeof(gBdtElem));
        MOVS     R2,#+90
        MOVS     R1,#+255
        LDR.W    R0,??DataTable16_4
        BL       MemorySet
//  331   endpCtl.bdtElemIndexAlloc = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable16_5
        STRB     R0,[R1, #+36]
//  332   endpCtl.endpBuffAddrAlloc = (uint32_t)gaEndpBuffers;
        LDR.W    R0,??DataTable16_6
        LDR.W    R1,??DataTable16_5
        STR      R0,[R1, #+0]
//  333   MemorySet(endpCtl.bdtElemIndexMap, (uint8_t)gUsbInvalidBdtIndex_d, (uint16_t)sizeof(endpCtl.bdtElemIndexMap));
        MOVS     R2,#+32
        MOVS     R1,#+255
        LDR.W    R0,??DataTable16_7
        BL       MemorySet
//  334   /* Clear Memory for BDT and buffer Data */
//  335   MemorySet(&gBDTMap, 0, (uint16_t)sizeof(gBDTMap));        
        MOV      R2,#+512
        MOVS     R1,#+0
        LDR.W    R0,??DataTable16_8
        BL       MemorySet
//  336   gTrfDirection = gUsbTrfDirUnknown_d;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable16_9
        STRB     R0,[R1, #+0]
//  337   USB0_USBTRC0 |= 0x40;
        LDR.W    R0,??DataTable16_10  ;; 0x4007210c
        LDRB     R0,[R0, #+0]
        ORRS     R0,R0,#0x40
        LDR.W    R1,??DataTable16_10  ;; 0x4007210c
        STRB     R0,[R1, #+0]
//  338   /* Set the BDT Table address, Need to be on 512 byte boundary */
//  339   /* D8 Bit is masked in BDT_PAGE_01 */
//  340   USB0_BDTPAGE1 = (uint8_t)(((uint32_t)&gBDTMap >> 8)& 0xFE);
        LDR.W    R0,??DataTable16_8
        LSRS     R0,R0,#+8
        ANDS     R0,R0,#0xFE
        LDR.W    R1,??DataTable17  ;; 0x4007209c
        STRB     R0,[R1, #+0]
//  341   USB0_BDTPAGE2 = (uint8_t)((uint32_t)&gBDTMap >> 16);
        LDR.W    R0,??DataTable16_8
        LSRS     R0,R0,#+16
        LDR.W    R1,??DataTable17_1  ;; 0x400720b0
        STRB     R0,[R1, #+0]
//  342   USB0_BDTPAGE3 = (uint8_t)((uint32_t)&gBDTMap >> 24);
        LDR.W    R0,??DataTable16_8
        LSRS     R0,R0,#+24
        LDR.W    R1,??DataTable17_2  ;; 0x400720b4
        STRB     R0,[R1, #+0]
//  343   /* Pull Up configuration */
//  344   USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG_MASK;
        MOVS     R0,#+16
        LDR.W    R1,??DataTable17_3  ;; 0x40072108
        STRB     R0,[R1, #+0]
//  345   USB0_CTL = USB_CTL_USBENSOFEN_MASK; 	/* Enable USB module */
        MOVS     R0,#+1
        LDR.W    R1,??DataTable16_1  ;; 0x40072094
        STRB     R0,[R1, #+0]
//  346   USB0_ISTAT = gUsbDciIntStat_ClearAll_c;      	/* Clear USB interrupts*/
        MOVS     R0,#+191
        LDR.W    R1,??DataTable17_4  ;; 0x40072080
        STRB     R0,[R1, #+0]
//  347   /* Remove suspend state */
//  348   USB0_USBCTRL &= ~USB_USBCTRL_SUSP_MASK;
        LDR.W    R0,??DataTable16_3  ;; 0x40072100
        LDRB     R0,[R0, #+0]
        ANDS     R0,R0,#0x7F
        LDR.W    R1,??DataTable16_3  ;; 0x40072100
        STRB     R0,[R1, #+0]
//  349   /* Enable USB RESET Interrupt */
//  350   USB0_INTEN |= USB_INTEN_USBRSTEN_MASK;
        LDR.W    R0,??DataTable17_5  ;; 0x40072084
        LDRB     R0,[R0, #+0]
        ORRS     R0,R0,#0x1
        LDR.W    R1,??DataTable17_5  ;; 0x40072084
        STRB     R0,[R1, #+0]
//  351   /* Enable USB Sleep Interrupt */
//  352   USB0_INTEN |= USB_INTEN_SLEEPEN_MASK;
        LDR.W    R0,??DataTable17_5  ;; 0x40072084
        LDRB     R0,[R0, #+0]
        ORRS     R0,R0,#0x10
        LDR.W    R1,??DataTable17_5  ;; 0x40072084
        STRB     R0,[R1, #+0]
//  353   // USB0_OTGCTL = USB_OTGCTL_DPHIGH_MASK | USB_OTGCTL_OTGEN_MASK;
//  354   return gUsbErr_NoError_c;
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
//  355 }
//  356 
//  357 /**************************************************************************//*!
//  358  *
//  359  * @name  USB_DCI_DeInit
//  360  *
//  361  * @brief The function de-initializes the Controller layer
//  362  *
//  363  * @param controller_ID : Controller ID
//  364  *
//  365  * @return status
//  366  *         gUsbErr_NoError_c    : Always
//  367  ******************************************************************************
//  368  * Initializes the USB controller
//  369  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  370 uint8_t USB_DCI_DeInit(uint8_t    controllerId)
//  371 {
USB_DCI_DeInit:
        MOVS     R1,R0
//  372   uint8_t i;
//  373   (void)controllerId;
//  374   
//  375   USB0_INTEN = 0;
        MOVS     R0,#+0
        LDR.W    R3,??DataTable16_12  ;; 0x40072084
        STRB     R0,[R3, #+0]
//  376   USB0_ERREN = 0;
        MOVS     R0,#+0
        LDR.W    R3,??DataTable16_11  ;; 0x4007208c
        STRB     R0,[R3, #+0]
//  377   USB0_CONTROL = 0;
        MOVS     R0,#+0
        LDR.W    R3,??DataTable17_3  ;; 0x40072108
        STRB     R0,[R3, #+0]
//  378   USB0_USBCTRL = 0xc0;
        MOVS     R0,#+192
        LDR.W    R3,??DataTable16_3  ;; 0x40072100
        STRB     R0,[R3, #+0]
//  379   for(i=0;i<gNumMaxEnpNumber_d;i++)
        MOVS     R0,#+0
        MOVS     R2,R0
??USB_DCI_DeInit_0:
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+16
        BGE.N    ??USB_DCI_DeInit_1
//  380   {
//  381     USB_ENDPT_REG(USB0_BASE_PTR,0) =0;
        MOVS     R0,#+0
        LDR.W    R3,??DataTable17_6  ;; 0x400720c0
        STRB     R0,[R3, #+0]
//  382   }
        ADDS     R2,R2,#+1
        B.N      ??USB_DCI_DeInit_0
//  383 	USB0_USBTRC0 = 0;
??USB_DCI_DeInit_1:
        MOVS     R0,#+0
        LDR.W    R3,??DataTable16_10  ;; 0x4007210c
        STRB     R0,[R3, #+0]
//  384   USB0_ADDR = 0;
        MOVS     R0,#+0
        LDR.W    R3,??DataTable16_2  ;; 0x40072098
        STRB     R0,[R3, #+0]
//  385   /* Clear USB interrupts*/
//  386 	USB0_ISTAT = gUsbDciIntStat_ClearAll_c;
        MOVS     R0,#+191
        LDR.W    R3,??DataTable17_4  ;; 0x40072080
        STRB     R0,[R3, #+0]
//  387   USB0_ERRSTAT = gUsbDciErrStat_ClearAll_c;
        MOVS     R0,#+191
        LDR.W    R3,??DataTable16  ;; 0x40072088
        STRB     R0,[R3, #+0]
//  388   USB0_CTL =0;
        MOVS     R0,#+0
        LDR.W    R3,??DataTable17_7  ;; 0x40072094
        STRB     R0,[R3, #+0]
//  389 	
//  390 	
//  391 	
//  392   
//  393   
//  394   return gUsbErr_NoError_c;
        MOVS     R0,#+0
        BX       LR               ;; return
//  395 }
//  396 
//  397 /**************************************************************************//*!
//  398  *
//  399  * @name  USB_DCI_Init_EndPoint
//  400  *
//  401  * @brief The function initializes an endpoint
//  402  *
//  403  * @param controller_ID : Controller ID
//  404  * @param ep_ptr        : Pointer to EndPoint Structures
//  405  * @param flag          : Zero Termination
//  406  *
//  407  * @return status
//  408  *         gUsbErr_NoError_c                    : When Successfull
//  409  *         USBERR_EP_INIT_FAILED     : When Error
//  410  ******************************************************************************
//  411  *
//  412  * This function initializes an endpoint and the Bufffer Descriptor Table
//  413  * entry associated with it. Incase the input parameters are invalid it will
//  414  * return USBERR_EP_INIT_FAILED error.
//  415  *
//  416  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  417 uint8_t USB_DCI_InitEndpoint
//  418 (
//  419 uint8_t               controller_ID,/* [IN] Controller ID */
//  420 usbEpStruct_t*    pEpStruct,       /* [IN] Pointer to Endpoint structure,
//  421                                       (endpoint number,
//  422                                       endpoint type,
//  423                                       endpoint direction,
//  424                                       max packet size) */
//  425 bool_t              flag          /* [IN] Zero Termination */
//  426 )
//  427 {
USB_DCI_InitEndpoint:
        PUSH     {R0,R4-R11,LR}
        SUB      SP,SP,#+8
        MOVS     R4,R1
        MOVS     R5,R2
//  428   
//  429   uint8_t bdtMapIndex;
//  430   uint8_t bdtElemIndex;
//  431   pBuffDsc_t  pBuffDsc;
//  432   pBdtElem_t pBdtElem;    
//  433   uint8_t epNum = pEpStruct->number;
        LDRB     R10,[R4, #+0]
//  434   uint8_t direction = pEpStruct->direction;
        LDRB     R11,[R4, #+2]
//  435   uint32_t epCtrl[2] = {gUsbEndpt_Out_c, gUsbEndpt_In_c};
        ADD      R0,SP,#+0
        LDR.W    R1,??DataTable17_8
        LDM      R1!,{R2,R3}
        STM      R0!,{R2,R3}
        SUBS     R1,R1,#+8
        SUBS     R0,R0,#+8
//  436   
//  437   if((pEpStruct->type > gUsbEpType_Interrupt_c) || (pEpStruct->direction > gUsbEpDirection_In_c)) 
        LDRB     R0,[R4, #+1]
        CMP      R0,#+4
        BGE.N    ??USB_DCI_InitEndpoint_0
        LDRB     R0,[R4, #+2]
        CMP      R0,#+2
        BLT.N    ??USB_DCI_InitEndpoint_1
//  438   {
//  439     return gUsbErr_EpInitFailed_c;
??USB_DCI_InitEndpoint_0:
        MOVS     R0,#+149
        B.N      ??USB_DCI_InitEndpoint_2
//  440   } 
//  441   bdtMapIndex = USB_DCI_GetBDTMapIndex(epNum, direction, gUsbBdtEvenBuffer_c);
??USB_DCI_InitEndpoint_1:
        MOVS     R2,#+0
        MOV      R1,R11
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOV      R0,R10
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_GetBDTMapIndex
        MOVS     R6,R0
//  442   if(bdtMapIndex  == gUsbInvalidBdtIndex_d)
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+255
        BNE.N    ??USB_DCI_InitEndpoint_3
//  443   {
//  444     return gUsbErr_EpInitFailed_c;
        MOVS     R0,#+149
        B.N      ??USB_DCI_InitEndpoint_2
//  445   }
//  446   bdtElemIndex = USB_DCI_GetBDTElemIndex(bdtMapIndex); 
??USB_DCI_InitEndpoint_3:
        MOVS     R0,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_GetBDTElemIndex
        MOVS     R7,R0
//  447   if((bdtElemIndex  != gUsbInvalidBdtIndex_d) &&
//  448      (gBdtElem[bdtElemIndex].epSize != (uint16_t)gUninitialisedVal_d))
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+255
        BEQ.N    ??USB_DCI_InitEndpoint_4
        LDR.W    R0,??DataTable16_4
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R1,#+18
        MLA      R0,R1,R7,R0
        LDRH     R0,[R0, #+0]
        MOVW     R1,#+65535
        CMP      R0,R1
        BEQ.N    ??USB_DCI_InitEndpoint_4
//  449   {
//  450     return gUsbErr_EpInitFailed_c;
        MOVS     R0,#+149
        B.N      ??USB_DCI_InitEndpoint_2
//  451   }
//  452   /* if the max packet size is greater than the max buffer size */    
//  453   if(pEpStruct->size > gUsbMaxEpBufferSize_d)
??USB_DCI_InitEndpoint_4:
        LDRH     R0,[R4, #+4]
        CMP      R0,#+512
        BLE.N    ??USB_DCI_InitEndpoint_5
//  454   {
//  455     pEpStruct->size = gUsbMaxEpBufferSize_d;
        MOV      R0,#+512
        STRH     R0,[R4, #+4]
//  456   }
//  457   
//  458   if(bdtElemIndex == gUsbInvalidBdtIndex_d)
??USB_DCI_InitEndpoint_5:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+255
        BNE.N    ??USB_DCI_InitEndpoint_6
//  459   {
//  460     if((endpCtl.bdtElemIndexAlloc >= gNumUsbEp_d) ||
//  461        ((endpCtl.endpBuffAddrAlloc + pEpStruct->size) > ((uint32_t)gaEndpBuffers + sizeof(gaEndpBuffers))))         
        LDR.W    R0,??DataTable16_5
        LDRB     R0,[R0, #+36]
        CMP      R0,#+5
        BGE.N    ??USB_DCI_InitEndpoint_7
        LDR.W    R0,??DataTable17_9
        LDR.W    R1,??DataTable16_5
        LDR      R1,[R1, #+0]
        LDRH     R2,[R4, #+4]
        UXTAH    R1,R1,R2
        CMP      R0,R1
        BCS.N    ??USB_DCI_InitEndpoint_8
//  462     {
//  463       return gUsbErr_EpInitFailed_c;
??USB_DCI_InitEndpoint_7:
        MOVS     R0,#+149
        B.N      ??USB_DCI_InitEndpoint_2
//  464     }
//  465     bdtElemIndex = endpCtl.bdtElemIndexMap[bdtMapIndex>>1] = endpCtl.bdtElemIndexAlloc;
??USB_DCI_InitEndpoint_8:
        LDR.W    R0,??DataTable16_5
        LDRB     R0,[R0, #+36]
        LDR.W    R1,??DataTable16_5
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        ADDS     R1,R1,R6, ASR #+1
        STRB     R0,[R1, #+4]
        LDR.W    R0,??DataTable16_5
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        ADDS     R0,R0,R6, ASR #+1
        LDRB     R0,[R0, #+4]
        MOVS     R7,R0
//  466     endpCtl.bdtElemIndexAlloc++;
        LDR.W    R0,??DataTable16_5
        LDRB     R0,[R0, #+36]
        ADDS     R0,R0,#+1
        LDR.W    R1,??DataTable16_5
        STRB     R0,[R1, #+36]
//  467     gBdtElem[bdtElemIndex].bdtMapIndex = bdtMapIndex;
        LDR.W    R0,??DataTable16_4
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R1,#+18
        MLA      R0,R1,R7,R0
        STRB     R6,[R0, #+15]
//  468     gBdtElem[bdtElemIndex].addr = endpCtl.endpBuffAddrAlloc;
        LDR.W    R0,??DataTable16_5
        LDR      R0,[R0, #+0]
        LDR.W    R1,??DataTable16_4
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R2,#+18
        MLA      R1,R2,R7,R1
        STR      R0,[R1, #+2]
//  469     endpCtl.endpBuffAddrAlloc += pEpStruct->size;
        LDR.W    R0,??DataTable16_5
        LDR      R0,[R0, #+0]
        LDRH     R1,[R4, #+4]
        UXTAH    R0,R0,R1
        LDR.W    R1,??DataTable16_5
        STR      R0,[R1, #+0]
//  470   }
//  471   pBdtElem = &gBdtElem[bdtElemIndex];
??USB_DCI_InitEndpoint_6:
        LDR.W    R0,??DataTable16_4
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R1,#+18
        MLA      R0,R1,R7,R0
        MOV      R9,R0
//  472   /* update bdt element structure */
//  473   pBdtElem->epSize = pEpStruct->size;
        LDRH     R0,[R4, #+4]
        STRH     R0,[R9, #+0]
//  474   pBdtElem->flag = flag;
        STRB     R5,[R9, #+14]
//  475   /* Update BDTMAP  */
//  476   pBuffDsc = &gBDTMap.epDsc[pBdtElem->bdtMapIndex]; 
        LDR.W    R0,??DataTable16_8
        LDRB     R1,[R9, #+15]
        ADDS     R0,R0,R1, LSL #+3
        MOV      R8,R0
//  477   pBuffDsc->cnt = pEpStruct->size;
        LDRH     R0,[R4, #+4]
        STRH     R0,[R8, #+2]
//  478   /* preserving even/odd buffer bit and address*/
//  479   pBuffDsc->addr = pBdtElem->addr;
        LDR      R0,[R9, #+2]
        STR      R0,[R8, #+4]
//  480   pBuffDsc->stat.byte = (gUsbBdtSCtl_CPU_d | gUsbBdtSCtl_Data0_d | gUsbBdtSCtl_DTS_d);
        MOVS     R0,#+8
        STRB     R0,[R8, #+0]
//  481   
//  482   pBuffDsc = &gBDTMap.epDsc[(uint8_t)((pBdtElem->bdtMapIndex) ^ 1)];
        LDR.W    R0,??DataTable16_8
        LDRB     R1,[R9, #+15]
        EORS     R1,R1,#0x1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        ADDS     R0,R0,R1, LSL #+3
        MOV      R8,R0
//  483   pBuffDsc->cnt = pEpStruct->size;
        LDRH     R0,[R4, #+4]
        STRH     R0,[R8, #+2]
//  484   pBuffDsc->addr = pBdtElem->addr;
        LDR      R0,[R9, #+2]
        STR      R0,[R8, #+4]
//  485   pBuffDsc->stat.byte = (gUsbBdtSCtl_CPU_d | gUsbBdtSCtl_Data1_d | gUsbBdtSCtl_DTS_d);
        MOVS     R0,#+72
        STRB     R0,[R8, #+0]
//  486   if(direction == gUsbEpDirection_Out_c)
        UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
        CMP      R11,#+0
        BNE.N    ??USB_DCI_InitEndpoint_9
//  487   {
//  488     /* For Recv Endpoints Give SIE Control to DATA0 */
//  489     pBuffDsc = &gBDTMap.epDsc[pBdtElem->bdtMapIndex];
        LDR.W    R0,??DataTable16_8
        LDRB     R1,[R9, #+15]
        ADDS     R0,R0,R1, LSL #+3
        MOV      R8,R0
//  490     pBdtElem->noTransferInProgress = FALSE;
        MOVS     R0,#+0
        STRB     R0,[R9, #+17]
//  491     pBuffDsc->stat.byte |= gUsbBdtSCtl_SIE_d;
        LDRB     R0,[R8, #+0]
        ORRS     R0,R0,#0x80
        STRB     R0,[R8, #+0]
//  492   }
//  493   
//  494   /* enable handshake for Non-Isochronous Endpoints */
//  495   epCtrl[direction] |= ((pEpStruct->type != gUsbEpType_Isochronous_c) ? gUsbEndpt_HshkEn_c:0x00);
??USB_DCI_InitEndpoint_9:
        LDRB     R0,[R4, #+1]
        CMP      R0,#+1
        BEQ.N    ??USB_DCI_InitEndpoint_10
        MOVS     R0,#+1
        B.N      ??USB_DCI_InitEndpoint_11
??USB_DCI_InitEndpoint_10:
        MOVS     R0,#+0
??USB_DCI_InitEndpoint_11:
        ADD      R1,SP,#+0
        UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
        LDR      R1,[R1, R11, LSL #+2]
        ORRS     R0,R0,R1
        ADD      R1,SP,#+0
        UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
        STR      R0,[R1, R11, LSL #+2]
//  496   /* set the EndPoint Control MCU Register*/
//  497   *((&USB0_ENDPT0) + (4 * epNum)) |= epCtrl[direction];
        LDR.W    R0,??DataTable17_6  ;; 0x400720c0
        UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
        LDRB     R0,[R0, R10, LSL #+2]
        ADD      R1,SP,#+0
        UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
        LDR      R1,[R1, R11, LSL #+2]
        ORRS     R0,R1,R0
        LDR.W    R1,??DataTable17_6  ;; 0x400720c0
        UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
        STRB     R0,[R1, R10, LSL #+2]
//  498   return gUsbErr_NoError_c;
        MOVS     R0,#+0
??USB_DCI_InitEndpoint_2:
        POP      {R1-R11,PC}      ;; return
//  499 }
//  500 
//  501 /**************************************************************************//*!
//  502  *
//  503  * @name  USB_DCI_CancelTransfer
//  504  *
//  505  * @brief The function cancels any pending Transfers which ahve not been sent
//  506  *
//  507  * @param handle          : USB Device handle
//  508  * @param endpoint_number : Endpoint number
//  509  * @param direction       : Endpoint direction
//  510  *
//  511  * @return status
//  512  *         gUsbErr_NotSupported_c : Always
//  513  ******************************************************************************
//  514  * This function just returns Error Code not supported
//  515  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  516 uint8_t USB_DCI_CancelTransfer 
//  517 (
//  518 uint8_t  controllerId,                                 
//  519 uint8_t  endpNumber,    /* [IN] Endpoint number */
//  520 uint8_t  direction  /* [IN] Endpoint direction */
//  521 )
//  522 {
USB_DeviceCancelTransfer:
        PUSH     {R3-R9,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
//  523   uint8_t bdtElemIndex;
//  524   uint8_t status= gUsbErr_UnknownError_c;
        MOVS     R8,#+196
//  525   /* validate params and get the bdt index */
//  526   uint8_t bdtMapIndex = USB_DCI_ValidateParam (endpNumber, direction, gUsbBdtEvenBuffer_c);
        MOVS     R2,#+0
        MOVS     R1,R6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_ValidateParam
        MOV      R9,R0
//  527   bdtElemIndex = USB_DCI_GetBDTElemIndex(bdtMapIndex);
        MOV      R0,R9
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_GetBDTElemIndex
        MOVS     R7,R0
//  528   /* Check for valid bdt index */
//  529   if(bdtMapIndex != gUsbInvalidBdtIndex_d)
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R9,#+255
        BEQ.N    ??USB_DeviceCancelTransfer_0
//  530   {
//  531     pBdtElem_t pBdtElem = &gBdtElem[bdtElemIndex];
        LDR.W    R0,??DataTable16_4
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R1,#+18
        MLA      R0,R1,R7,R0
//  532     pBuffDsc_t pBuffDsc = &gBDTMap.epDsc[pBdtElem->bdtMapIndex];
        LDR.W    R1,??DataTable16_8
        LDRB     R2,[R0, #+15]
        ADDS     R1,R1,R2, LSL #+3
//  533     pBuffDsc_t pBuffDscAlt = &gBDTMap.epDsc[pBdtElem->bdtMapIndex ^ 1];
        LDR.W    R2,??DataTable16_8
        LDRB     R3,[R0, #+15]
        EORS     R3,R3,#0x1
        ADDS     R2,R2,R3, LSL #+3
//  534     /* Clear SIE Control Bit for both buffers*/
//  535     pBuffDsc->stat.byte &= ~gUsbBdtSCtl_SIE_d;
        LDRB     R3,[R1, #+0]
        ANDS     R3,R3,#0x7F
        STRB     R3,[R1, #+0]
//  536     pBuffDscAlt->stat.byte &= ~gUsbBdtSCtl_SIE_d;
        LDRB     R3,[R2, #+0]
        ANDS     R3,R3,#0x7F
        STRB     R3,[R2, #+0]
//  537     pBdtElem->appLen = (usbPacketSize_t)gUninitialisedVal_d;
        MOVW     R3,#+65535
        STRH     R3,[R0, #+10]
//  538     pBdtElem->noTransferInProgress = TRUE;
        MOVS     R3,#+1
        STRB     R3,[R0, #+17]
//  539     status = gUsbErr_NoError_c;
        MOVS     R3,#+0
        MOV      R8,R3
//  540   }
//  541   return status;
??USB_DeviceCancelTransfer_0:
        MOV      R0,R8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R1,R4-R9,PC}    ;; return
//  542 }
//  543 
//  544 /**************************************************************************//*!
//  545  *
//  546  * @name  USB_DCI_DeinitEndpoint
//  547  *
//  548  * @brief The function de initializes an endpoint
//  549  *
//  550  * @param controller_ID : Controller ID
//  551  * @param ep_num        : Endpoint number
//  552  * @param direction     : Endpoint direction
//  553  *
//  554  * @return status
//  555  *         gUsbErr_NoError_c                   : When successfull
//  556  *         gUsbErr_EpDeinitFailed_c  : When unsuccessfull
//  557  ******************************************************************************
//  558  *
//  559  * This function un-intializes the endpoint by clearing the corresponding
//  560  * endpoint control register and then clearing the bdt elem.
//  561  *
//  562  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  563 uint8_t USB_DCI_DeinitEndpoint 
//  564 (
//  565 uint8_t    controllerId,   /* [IN] Controller ID */
//  566 uint8_t    epNum,          /* [IN] Endpoint number */
//  567 uint8_t    direction        /* [IN] Endpoint direction */
//  568 )
//  569 {
USB_DCI_DeinitEndpoint:
        PUSH     {R4-R8,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
//  570   /* validate params and get the bdt index */
//  571   uint8_t bdtElemIndex;
//  572   uint8_t bdtMapIndex = USB_DCI_ValidateParam (epNum, direction, gUsbBdtEvenBuffer_c);
        MOVS     R2,#+0
        MOVS     R1,R6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_ValidateParam
        MOV      R8,R0
//  573   /* in case the bdt_index is invalid*/
//  574   if(bdtMapIndex  == gUsbInvalidBdtIndex_d)
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+255
        BNE.N    ??USB_DCI_DeinitEndpoint_0
//  575   {
//  576     return gUsbErr_EpDeinitFailed_c;
        MOVS     R0,#+150
        B.N      ??USB_DCI_DeinitEndpoint_1
//  577   }
//  578   bdtElemIndex = USB_DCI_GetBDTElemIndex(bdtMapIndex);
??USB_DCI_DeinitEndpoint_0:
        MOV      R0,R8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_GetBDTElemIndex
        MOVS     R7,R0
//  579   USB_DCI_CancelTransfer(controllerId, epNum, direction);
        MOVS     R2,R6
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,R5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceCancelTransfer
//  580   /* Disable endpoint */
//  581   *((&USB0_ENDPT0) + (4 * epNum)) = gUsbEndpt_Disable_c;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable17_6  ;; 0x400720c0
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        STRB     R0,[R1, R5, LSL #+2]
//  582   /* un-initialize the bdt_elem structure for this endpoint */
//  583   gBdtElem[bdtElemIndex].epSize = (uint16_t)gUninitialisedVal_d;
        MOVW     R0,#+65535
        LDR.W    R1,??DataTable16_4
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R2,#+18
        MLA      R1,R2,R7,R1
        STRH     R0,[R1, #+0]
//  584   return gUsbErr_NoError_c;
        MOVS     R0,#+0
??USB_DCI_DeinitEndpoint_1:
        POP      {R4-R8,PC}       ;; return
//  585 }
//  586 
//  587 /**************************************************************************//*!
//  588  *
//  589  * @name  USB_DCI_StallEndpoint
//  590  *
//  591  * @brief The function stalls an endpoint
//  592  *
//  593  * @param handle          : USB Device handle
//  594  * @param endpoint_number : Endpoint number
//  595  * @param direction       : Endpoint direction
//  596  *
//  597  * @return None
//  598  *
//  599  ******************************************************************************
//  600  * This function stalls the endpoint by setting Endpoint BDT
//  601  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  602 void USB_DCI_StallEndpoint 
//  603 (
//  604 uint8_t  controllerId,                         
//  605 uint8_t endpNum,    /* [IN] Endpoint number to stall */
//  606 uint8_t direction   /* [IN] Direction to stall */
//  607 )
//  608 {
USB_DeviceStallEndpoint:
        PUSH     {R4-R8,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
//  609   uint8_t bdtElemIndex;
//  610   /* validate params and get the bdt index */
//  611   uint8_t bdtMapIndex = USB_DCI_ValidateParam (endpNum, direction, gUsbBdtEvenBuffer_c);
        MOVS     R2,#+0
        MOVS     R1,R6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_ValidateParam
        MOV      R8,R0
//  612   if(bdtMapIndex == gUsbInvalidBdtIndex_d)
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+255
        BEQ.N    ??USB_DeviceStallEndpoint_0
//  613   {
//  614     return;
//  615   }
//  616   bdtElemIndex = USB_DCI_GetBDTElemIndex(bdtMapIndex); 
??USB_DeviceStallEndpoint_1:
        MOV      R0,R8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_GetBDTElemIndex
        MOVS     R7,R0
//  617   bdtMapIndex = gBdtElem[bdtElemIndex].bdtMapIndex;
        LDR.W    R0,??DataTable16_4
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R1,#+18
        MLA      R0,R1,R7,R0
        LDRB     R0,[R0, #+15]
        MOV      R8,R0
//  618   (void)USB_DCI_CancelTransfer(controllerId, endpNum, direction);
        MOVS     R2,R6
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,R5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceCancelTransfer
//  619   gBDTMap.epDsc[bdtMapIndex].stat.byte |= (gUsbBdtSCtl_SIE_d | gUsbBdtSCtl_Stall_d);
        LDR.W    R1,??DataTable16_8
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDRB     R1,[R1, R8, LSL #+3]
        ORRS     R1,R1,#0x84
        LDR.W    R2,??DataTable16_8
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRB     R1,[R2, R8, LSL #+3]
//  620 }
??USB_DeviceStallEndpoint_0:
        POP      {R4-R8,PC}       ;; return
//  621 
//  622 /**************************************************************************//*!
//  623  *
//  624  * @name  USB_DCI_UnstallEndpoint
//  625  *
//  626  * @brief The function unstalls an endpoint
//  627  *
//  628  * @param handle          : USB Device handle
//  629  * @param endpoint_number : Endpoint number
//  630  * @param direction       : Endpoint direction
//  631  *
//  632  * @return None
//  633  *
//  634  ******************************************************************************
//  635  * This function unstalls the endpoint by clearing Endpoint Control Register
//  636  * and BDT
//  637  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  638 void USB_DCI_UnstallEndpoint
//  639 (
//  640 uint8_t  controllerId,                           
//  641 uint8_t  endpNumber,    /* [IN] Endpoint number to unstall */
//  642 uint8_t  direction           /* [IN] Direction to unstall */
//  643 )
//  644 {
USB_DeviceUnstallEndpoint:
        PUSH     {R4-R8,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
//  645   uint8_t bdtElemIndex;
//  646   /* validate params and get the bdt index */
//  647   uint8_t bdtMapIndex = USB_DCI_ValidateParam (endpNumber, direction, gUsbBdtEvenBuffer_c);
        MOVS     R2,#+0
        MOVS     R1,R6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_ValidateParam
        MOV      R8,R0
//  648   /* Check for valid bdt index */
//  649   if(bdtMapIndex == gUsbInvalidBdtIndex_d)
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+255
        BEQ.N    ??USB_DeviceUnstallEndpoint_0
//  650   {
//  651     return;
//  652   }
//  653   bdtElemIndex = USB_DCI_GetBDTElemIndex(bdtMapIndex); 
??USB_DeviceUnstallEndpoint_1:
        MOV      R0,R8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_GetBDTElemIndex
        MOVS     R7,R0
//  654   bdtMapIndex = gBdtElem[bdtElemIndex].bdtMapIndex;
        LDR.W    R0,??DataTable16_4
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R1,#+18
        MLA      R0,R1,R7,R0
        LDRB     R0,[R0, #+15]
        MOV      R8,R0
//  655   /* We Require DATA0 PID to be zero on unstall */
//  656   gBDTMap.epDsc[bdtMapIndex].stat.byte = gUsbBdtSCtl_Data0_d;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable16_8
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRB     R0,[R1, R8, LSL #+3]
//  657   if(direction == gUsbEpDirection_Out_c)
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BNE.N    ??USB_DeviceUnstallEndpoint_2
//  658   {
//  659     /* Initiate Next receive Transfer */
//  660     USB_DCI_RecvData(controllerId, endpNumber, NULL, 0);
        MOVS     R3,#+0
        MOVS     R2,#+0
        MOVS     R1,R5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceRecvData
//  661   } 	
//  662   return;
??USB_DeviceUnstallEndpoint_2:
??USB_DeviceUnstallEndpoint_0:
        POP      {R4-R8,PC}       ;; return
//  663 }
//  664 
//  665 /**************************************************************************//*!
//  666  *
//  667  * @name  USB_DCI_GetSetupData
//  668  *
//  669  * @brief The function copies Setup Packet from USB RAM to application buffer
//  670  *
//  671  * @param handle          : USB Device handle
//  672  * @param endpoint_number : Endpoint number
//  673  * @param buffer_ptr      : Application buffer pointer
//  674  *
//  675  * @return None
//  676  *
//  677  ******************************************************************************
//  678  * Copies setup packet from USB RAM to Application Buffer
//  679  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  680 void USB_DCI_GetSetupData 
//  681 (
//  682 uint8_t  controllerId,                             
//  683 uint8_t  endpNumber,    /* [IN] Endpoint number for the transaction */
//  684 uint8_t* pBuff          /* [IN] Pointer to the buffer into which to read data */
//  685 )
//  686 {
USB_Device_ReadSetupData:
        PUSH     {R3-R9,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
//  687 	uint8_t* pSetupAddr;
//  688   uint8_t bdtElemIndex;
//  689   /* validate params and get the bdt index */
//  690   uint8_t bdtMapIndex = USB_DCI_ValidateParam (endpNumber, gUsbEpDirection_Out_c, gUsbBdtEvenBuffer_c);
        MOVS     R2,#+0
        MOVS     R1,#+0
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_ValidateParam
        MOV      R9,R0
//  691   if(bdtMapIndex == gUsbInvalidBdtIndex_d)
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R9,#+255
        BEQ.N    ??USB_Device_ReadSetupData_0
//  692   {
//  693     return;
//  694   }
//  695   bdtElemIndex = USB_DCI_GetBDTElemIndex(bdtMapIndex);
??USB_Device_ReadSetupData_1:
        MOV      R0,R9
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_GetBDTElemIndex
        MOV      R8,R0
//  696   bdtMapIndex = gBdtElem[bdtElemIndex].bdtMapIndex;
        LDR.W    R0,??DataTable16_4
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R1,#+18
        MLA      R0,R1,R8,R0
        LDRB     R0,[R0, #+15]
        MOV      R9,R0
//  697   /* address correponding to the endpoint */
//  698   pSetupAddr = (uint8_t*)(gBDTMap.epDsc[bdtMapIndex].addr);
        LDR.W    R0,??DataTable16_8
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        ADDS     R0,R0,R9, LSL #+3
        LDR      R0,[R0, #+4]
        MOVS     R7,R0
//  699   /* copy bdt buffer to application buffer */
//  700   MemoryCpy( pBuff,   pSetupAddr,   gUsbSetupPacketSize_d     );
        MOVS     R2,#+8
        MOVS     R1,R7
        MOVS     R0,R6
        BL       MemoryCpy
//  701   return;
??USB_Device_ReadSetupData_0:
        POP      {R0,R4-R9,PC}    ;; return
//  702 }
//  703 
//  704 /**************************************************************************//*!
//  705  *
//  706  * @name  USB_DCI_GetTransferStatus
//  707  *
//  708  * @brief The function retrieves the Transfer status of an endpoint
//  709  *
//  710  * @param handle          : USB Device handle
//  711  * @param endpoint_number : Endpoint number
//  712  * @param direction       : Endpoint direction
//  713  *
//  714  * @return status
//  715  *         USBERR_TR_FAILED                : When unsuccessful
//  716  *         gUsbStatus_Idle_d                 : No transfer on endpoint
//  717  *         gUsbStatus_Disabled_d             : endpoint is disabled
//  718  *         gUsbStatus_Stalled_d              : endpoint is stalled
//  719  *         gUsbStatus_TransferInProgress_d : When SIE has control of BDT
//  720  ******************************************************************************
//  721  *
//  722  * This function retrieves the transfer status of the endpoint by checking the
//  723  * BDT as well as the endpoint control register
//  724  *
//  725  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  726 uint8_t USB_DCI_GetTransferStatus 
//  727 (
//  728 uint8_t  controllerId ,                                    
//  729 uint8_t  endpNumber,    /* [IN] Endpoint number */
//  730 uint8_t  direction           /* [IN] Endpoint direction */
//  731 )
//  732 {
USB_Device_GetTransferStatus:
        PUSH     {R4-R10,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
//  733   uint8_t bdtElemIndex;  
//  734   uint8_t status = gUsbStatus_Disabled_d;
        MOVS     R8,#+5
//  735   /* validate params and get the bdt index */
//  736   uint8_t bdtMapIndex = USB_DCI_ValidateParam (endpNumber, direction, gUsbBdtEvenBuffer_c);
        MOVS     R2,#+0
        MOVS     R1,R6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_ValidateParam
        MOV      R9,R0
//  737   /* Check for valid bdt index */
//  738   if(bdtMapIndex != gUsbInvalidBdtIndex_d)
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R9,#+255
        BEQ.N    ??USB_Device_GetTransferStatus_0
//  739   {
//  740     uint8_t epCtrl = (uint8_t)(*((&USB0_ENDPT0)+4*endpNumber));
        LDR.W    R0,??DataTable17_6  ;; 0x400720c0
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        LDRB     R10,[R0, R5, LSL #+2]
//  741     bdtElemIndex = USB_DCI_GetBDTElemIndex(bdtMapIndex);
        MOV      R0,R9
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_GetBDTElemIndex
        MOVS     R7,R0
//  742     bdtMapIndex = gBdtElem[bdtElemIndex].bdtMapIndex;
        LDR.W    R0,??DataTable16_4
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R1,#+18
        MLA      R0,R1,R7,R0
        LDRB     R0,[R0, #+15]
        MOV      R9,R0
//  743     status = gUsbStatus_Idle_d;
        MOVS     R0,#+0
        MOV      R8,R0
//  744     /* Check for direction in endpoint control register */
//  745     if((epCtrl & (gUsbEndpt_In_c|gUsbEndpt_Out_c)) == gUsbEndpt_Disable_c)
        MOVS     R1,#+12
        TST      R10,R1
        BNE.N    ??USB_Device_GetTransferStatus_1
//  746     {
//  747       status = gUsbStatus_Disabled_d;
        MOVS     R0,#+5
        MOV      R8,R0
        B.N      ??USB_Device_GetTransferStatus_0
//  748     }
//  749     /* Check for stall bit in endpoint control register */
//  750     else if(
//  751             (gBDTMap.epDsc[bdtMapIndex].stat.mcuCtlBit.bdtstall == 1)
//  752               &&(gBDTMap.epDsc[bdtMapIndex].stat.sieCtlBit.own == 1)
//  753                 )
??USB_Device_GetTransferStatus_1:
        LDR.W    R0,??DataTable16_8
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        LDRB     R0,[R0, R9, LSL #+3]
        UBFX     R0,R0,#+2,#+1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BEQ.N    ??USB_Device_GetTransferStatus_2
        LDR.W    R0,??DataTable16_8
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        LDRB     R0,[R0, R9, LSL #+3]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LSRS     R0,R0,#+7
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BEQ.N    ??USB_Device_GetTransferStatus_2
//  754     {
//  755       status = gUsbStatus_Stalled_d ;
        MOVS     R0,#+1
        MOV      R8,R0
        B.N      ??USB_Device_GetTransferStatus_0
//  756     }
//  757     /* Check whether SIE has control of BDT */
//  758     else if (gBdtElem[bdtElemIndex].noTransferInProgress == FALSE)
??USB_Device_GetTransferStatus_2:
        LDR.W    R0,??DataTable16_4
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R1,#+18
        MLA      R0,R1,R7,R0
        LDRB     R0,[R0, #+17]
        CMP      R0,#+0
        BNE.N    ??USB_Device_GetTransferStatus_0
//  759     {
//  760       status = gUsbStatus_TransferInProgress_d;
        MOVS     R0,#+3
        MOV      R8,R0
//  761     }
//  762   }
//  763   return status;
??USB_Device_GetTransferStatus_0:
        MOV      R0,R8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R4-R10,PC}      ;; return
//  764 }
//  765 
//  766 /**************************************************************************//*!
//  767  *
//  768  * @name  USB_DCI_RecvData
//  769  *
//  770  * @brief The function retrieves data received on an RECV endpoint
//  771  *
//  772  * @param handle          : USB Device handle
//  773  * @param endpoint_number : Endpoint number
//  774  * @param buffer_ptr      : Application buffer pointer
//  775  * @param size            : Size of the buffer
//  776  *
//  777  * @return status
//  778  *         gUsbErr_NoError_c                          : When successful
//  779  *         gUsbErr_RxFailed_c                : When unsuccessful
//  780  ******************************************************************************
//  781  * This function retrieves data received data on a RECV endpoint by copying it
//  782  * from USB RAM to application buffer
//  783  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  784 uint8_t USB_DCI_RecvData 
//  785 (
//  786 uint8_t  controllerId,                           
//  787 uint8_t  endpNumber,    /* [IN] Endpoint number for the transaction */
//  788 uint8_t* pBuff,         /* [OUT] Pointer to the buffer into which to receive data */
//  789 usbPacketSize_t size
//  790 )
//  791 {
USB_DeviceRecvData:
        PUSH     {R4-R11,LR}
        SUB      SP,SP,#+12
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
        MOVS     R7,R3
//  792   uint8_t status = gUsbErr_RxFailed_c;
        MOVS     R11,#+148
//  793   uint8_t bdtElemIndex;
//  794   pBdtElem_t pBdtElem;
//  795   pBuffDsc_t pBuffDsc;
//  796   uint32_t ccr;
//  797   /* validate params and get the bdt index */
//  798   uint8_t bdtMapIndex = USB_DCI_ValidateParam (endpNumber, gUsbEpDirection_Out_c, gUsbBdtEvenBuffer_c);
        MOVS     R2,#+0
        MOVS     R1,#+0
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_ValidateParam
        MOV      R10,R0
//  799   (void)(controllerId);
//  800   /* Check for valid bdt index */
//  801   if(bdtMapIndex == gUsbInvalidBdtIndex_d)
        UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
        CMP      R10,#+255
        BNE.N    ??USB_DeviceRecvData_0
//  802   {
//  803     return status;
        MOV      R0,R11
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        B.N      ??USB_DeviceRecvData_1
//  804   }
//  805   ccr = IntDisableAll();
??USB_DeviceRecvData_0:
        BL       IntDisableAll
        STR      R0,[SP, #+0]
//  806   bdtElemIndex = USB_DCI_GetBDTElemIndex(bdtMapIndex);
        MOV      R0,R10
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_GetBDTElemIndex
        STRB     R0,[SP, #+4]
//  807   pBdtElem = &gBdtElem[bdtElemIndex];
        LDR.W    R0,??DataTable16_4
        LDRB     R1,[SP, #+4]
        MOVS     R2,#+18
        MLA      R0,R2,R1,R0
        MOV      R8,R0
//  808   /* For selecting even/odd buffer */
//  809   bdtMapIndex = pBdtElem->bdtMapIndex;
        LDRB     R0,[R8, #+15]
        MOV      R10,R0
//  810   pBuffDsc = &gBDTMap.epDsc[bdtMapIndex];
        LDR.W    R0,??DataTable16_8
        UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
        ADDS     R0,R0,R10, LSL #+3
        MOV      R9,R0
//  811   /* Does MCU owns it */
//  812   if(pBdtElem->noTransferInProgress)
        LDRB     R0,[R8, #+17]
        CMP      R0,#+0
        BEQ.N    ??USB_DeviceRecvData_2
//  813   {
//  814     if(size == 0)
        UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
        CMP      R7,#+0
        BNE.N    ??USB_DeviceRecvData_3
//  815     {
//  816       pBuffDsc->cnt = pBdtElem->epSize;
        LDRH     R0,[R8, #+0]
        STRH     R0,[R9, #+2]
//  817       pBuffDsc->addr = pBdtElem->addr;
        LDR      R0,[R8, #+2]
        STR      R0,[R9, #+4]
        B.N      ??USB_DeviceRecvData_4
//  818       
//  819       /* Give the ownership to SIE and TOGGLE DATA BIT */
//  820     }
//  821     /* adjust size based on the input at the init endpoint */
//  822     else
//  823     {
//  824       /* Initialise transfer */
//  825       pBdtElem->appLen = size;
??USB_DeviceRecvData_3:
        STRH     R7,[R8, #+10]
//  826       pBdtElem->pAppBuffer = pBuff;
        STR      R6,[R8, #+6]
//  827       if(size > pBdtElem->epSize)
        LDRH     R0,[R8, #+0]
        UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
        CMP      R0,R7
        BCS.N    ??USB_DeviceRecvData_5
//  828       {
//  829         size = pBdtElem->epSize;
        LDRH     R0,[R8, #+0]
        MOVS     R7,R0
//  830       }
//  831       pBdtElem->currOffset = 0;
??USB_DeviceRecvData_5:
        MOVS     R0,#+0
        STRH     R0,[R8, #+12]
//  832       pBuffDsc->cnt = size;
        STRH     R7,[R9, #+2]
//  833       pBuffDsc->addr = (uint32_t)pBuff;
        STR      R6,[R9, #+4]
//  834     } 
//  835     pBdtElem->noTransferInProgress = FALSE;
??USB_DeviceRecvData_4:
        MOVS     R0,#+0
        STRB     R0,[R8, #+17]
//  836     pBuffDsc->stat.byte = (uint8_t)(
//  837                                        (pBuffDsc->stat.mcuCtlBit.data << 6) |
//  838                                          gUsbBdtSCtl_SIE_d | gUsbBdtSCtl_DTS_d);
        LDRB     R0,[R9, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LSRS     R0,R0,#+6
        LSLS     R0,R0,#+6
        ORRS     R0,R0,#0x88
        STRB     R0,[R9, #+0]
//  839     status = gUsbErr_NoError_c;
        MOVS     R0,#+0
        MOV      R11,R0
//  840   }
//  841   IntRestoreAll(ccr);
??USB_DeviceRecvData_2:
        LDR      R0,[SP, #+0]
        BL       IntRestoreAll
//  842   return status;
        MOV      R0,R11
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
??USB_DeviceRecvData_1:
        POP      {R1-R11,PC}      ;; return
//  843 }
//  844 
//  845 /**************************************************************************//*!
//  846  *
//  847  * @name  USB_DCI_SendData
//  848  *
//  849  * @brief The function configures Controller to send data on an SEND endpoint
//  850  *
//  851  * @param handle          : USB Device handle
//  852  * @param endpoint_number : Endpoint number
//  853  * @param buffer_ptr      : Application buffer pointer
//  854  * @param size            : Size of the buffer
//  855  *
//  856  * @return status
//  857  *         gUsbErr_NoError_c           : When successfull
//  858  *         gUsbErr_TxFailed_c : When unsuccessfull
//  859  ******************************************************************************
//  860  * This function configures Controller to send data on a SEND endpoint by
//  861  * setting the BDT to send data.
//  862  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  863 uint8_t USB_DCI_SendData 
//  864 (
//  865  uint8_t          controllerId,                           
//  866  uint8_t          endpNumber,    /* [IN] Endpoint number */
//  867  uint8_t*         pBuff,         /* [IN] Application buffer pointer */
//  868  usbPacketSize_t  size    ,            /* [IN] Size of the buffer */
//  869  bool_t           shortSend  
//  870  )
//  871 {
USB_DeviceSendData:
        PUSH     {R4-R11,LR}
        SUB      SP,SP,#+12
        MOVS     R5,R0
        MOVS     R6,R1
        MOVS     R7,R2
        MOV      R8,R3
        LDR      R4,[SP, #+48]
//  872   
//  873   uint8_t status = gUsbErr_TxFailed_c;
        MOVS     R11,#+147
//  874   pBuffDsc_t pBuffDsc;
//  875   pBdtElem_t pBdtElem;
//  876   uint32_t ccr;
//  877   /* validate params and get the bdt index */
//  878   uint8_t bdtMapIndex = USB_DCI_ValidateParam (endpNumber, gUsbEpDirection_In_c, gUsbBdtEvenBuffer_c);
        MOVS     R2,#+0
        MOVS     R1,#+1
        MOVS     R0,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_ValidateParam
        MOV      R10,R0
//  879   (void)(controllerId);
//  880   if(bdtMapIndex == gUsbInvalidBdtIndex_d)
        UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
        CMP      R10,#+255
        BNE.N    ??USB_DeviceSendData_0
//  881   {
//  882     return status;
        MOV      R0,R11
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        B.N      ??USB_DeviceSendData_1
//  883   }
//  884   ccr = IntDisableAll();
??USB_DeviceSendData_0:
        BL       IntDisableAll
        STR      R0,[SP, #+4]
//  885   pBdtElem = &gBdtElem[USB_DCI_GetBDTElemIndex(bdtMapIndex)];
        MOV      R0,R10
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_GetBDTElemIndex
        MOVS     R1,#+18
        LDR.W    R2,??DataTable16_4
        MLA      R0,R1,R0,R2
        MOV      R9,R0
//  886   bdtMapIndex = pBdtElem->bdtMapIndex;
        LDRB     R0,[R9, #+15]
        MOV      R10,R0
//  887   pBuffDsc = &gBDTMap.epDsc[bdtMapIndex];
        LDR.W    R0,??DataTable16_8
        UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
        ADDS     R0,R0,R10, LSL #+3
        STR      R0,[SP, #+0]
//  888   /* Does MCU owns it and it is not stalled */
//  889     if(
//  890      pBdtElem->noTransferInProgress 
//  891      && (pBuffDsc->stat.mcuCtlBit.bdtstall == 0)
//  892        )
        LDRB     R0,[R9, #+17]
        CMP      R0,#+0
        BEQ.N    ??USB_DeviceSendData_2
        LDR      R0,[SP, #+0]
        LDRB     R0,[R0, #+0]
        UBFX     R0,R0,#+2,#+1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??USB_DeviceSendData_2
//  893   {
//  894     /* Initialize transfer */
//  895     pBdtElem->appLen = size;
        STRH     R8,[R9, #+10]
//  896     pBdtElem->pAppBuffer = pBuff;
        STR      R7,[R9, #+6]
//  897     pBdtElem->currOffset = 0;
        MOVS     R0,#+0
        STRH     R0,[R9, #+12]
//  898     pBdtElem->shortSend = shortSend;
        STRB     R4,[R9, #+16]
//  899     /* Prepare for send */
//  900     USB_DCI_PrepareSendData(pBuffDsc, pBdtElem);
        MOV      R1,R9
        LDR      R0,[SP, #+0]
        BL       USB_DCI_PrepareSendData
//  901     pBdtElem->noTransferInProgress = FALSE;
        MOVS     R0,#+0
        STRB     R0,[R9, #+17]
//  902     pBuffDsc->stat.byte = (uint8_t)((pBuffDsc->stat.mcuCtlBit.data << 6) | gUsbBdtSCtl_SIE_d | gUsbBdtSCtl_DTS_d);
        LDR      R0,[SP, #+0]
        LDRB     R0,[R0, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LSRS     R0,R0,#+6
        LSLS     R0,R0,#+6
        ORRS     R0,R0,#0x88
        LDR      R1,[SP, #+0]
        STRB     R0,[R1, #+0]
//  903     status = gUsbErr_NoError_c;
        MOVS     R0,#+0
        MOV      R11,R0
//  904   } /* Does MCU own IN BDT */
//  905   IntRestoreAll(ccr);
??USB_DeviceSendData_2:
        LDR      R0,[SP, #+4]
        BL       IntRestoreAll
//  906   return status;
        MOV      R0,R11
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
??USB_DeviceSendData_1:
        POP      {R1-R11,PC}      ;; return
//  907 }
//  908 
//  909 /**************************************************************************//*!
//  910  *
//  911  * @name  USB_DCI_SetAddress
//  912  *
//  913  * @brief The function configures Controller to send data on an SEND endpoint
//  914  *
//  915  * @param handle  : USB Device handle
//  916  * @param address : Controller Address
//  917  *
//  918  * @return None
//  919  *
//  920  ******************************************************************************
//  921  * Assigns the Address to the Controller
//  922  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  923 void  USB_DCI_SetAddress 
//  924 (
//  925 uint8_t controllerId,                           
//  926 uint8_t address    /* [IN] Address of the USB device */
//  927 )
//  928 {
USB_DeviceSetAddress:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
        MOVS     R5,R1
//  929   (void)(controllerId);
//  930 	/* set the address */
//  931   USB0_ADDR = address;
        LDR.N    R0,??DataTable16_2  ;; 0x40072098
        STRB     R5,[R0, #+0]
//  932   USB_DeviceSetStatus(gDciControllerId, gUsbComponentStatus_DeviceState_d,gUsbDeviceState_Address_d);
        MOVS     R2,#+1
        MOVS     R1,#+1
        LDR.W    R0,??DataTable17_10
        LDRB     R0,[R0, #+0]
        BL       USB_DeviceSetStatus
//  933   return;
        POP      {R0,R4,R5,PC}    ;; return
//  934 }
//  935 /**************************************************************************//*!
//  936  *
//  937  * @name  USB_DCI_AssertResume
//  938  *
//  939  * @brief The function makes the Controller start USB RESUME signaling
//  940  *
//  941  * @param handle : USB Device handle
//  942  *
//  943  * @return None
//  944  *
//  945  ******************************************************************************
//  946  *
//  947  * This function starts RESUME signalling and then stops it after some delay.
//  948  * In this delay make sure that COP is reset.
//  949  *
//  950  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  951 void USB_DCI_AssertResume
//  952 (
//  953 uint8_t controllerId                            
//  954 )
//  955 {
//  956   uint16_t delayCount;
//  957   (void)controllerId;
//  958   /* Clear SUSP Bit from USB_CTRL */
//  959   USB0_USBCTRL &= ~USB_USBCTRL_SUSP_MASK;
USB_DeviceAssertResume:
        LDR.N    R2,??DataTable16_3  ;; 0x40072100
        LDRB     R2,[R2, #+0]
        ANDS     R2,R2,#0x7F
        LDR.N    R3,??DataTable16_3  ;; 0x40072100
        STRB     R2,[R3, #+0]
//  960   /* Reset Low Power RESUME enable */
//  961   USB0_USBTRC0 &= ~USB_USBTRC0_USBRESMEN_MASK;
        LDR.N    R2,??DataTable16_10  ;; 0x4007210c
        LDRB     R2,[R2, #+0]
        ANDS     R2,R2,#0xDF
        LDR.N    R3,??DataTable16_10  ;; 0x4007210c
        STRB     R2,[R3, #+0]
//  962   /* Setup the controller for Remote Wakeup */
//  963 	USB0_ISTAT |= USB_ISTAT_RESUME_MASK; 
        LDR.W    R2,??DataTable17_4  ;; 0x40072080
        LDRB     R2,[R2, #+0]
        ORRS     R2,R2,#0x20
        LDR.W    R3,??DataTable17_4  ;; 0x40072080
        STRB     R2,[R3, #+0]
//  964 	USB0_INTEN &= ~USB_INTEN_RESUMEEN_MASK;
        LDR.N    R2,??DataTable16_12  ;; 0x40072084
        LDRB     R2,[R2, #+0]
        ANDS     R2,R2,#0xDF
        LDR.N    R3,??DataTable16_12  ;; 0x40072084
        STRB     R2,[R3, #+0]
//  965 	USB0_CTL &= ~USB_CTL_TXSUSPENDTOKENBUSY_MASK;
        LDR.W    R2,??DataTable17_7  ;; 0x40072094
        LDRB     R2,[R2, #+0]
        ANDS     R2,R2,#0xDF
        LDR.W    R3,??DataTable17_7  ;; 0x40072094
        STRB     R2,[R3, #+0]
//  966   USB0_CTL |= USB_CTL_RESUME_MASK;   /* Start RESUME signaling and make SUSPEND bit 0*/
        LDR.W    R2,??DataTable17_7  ;; 0x40072094
        LDRB     R2,[R2, #+0]
        ORRS     R2,R2,#0x4
        LDR.W    R3,??DataTable17_7  ;; 0x40072094
        STRB     R2,[R3, #+0]
//  967   delayCount = gUsbDci_AssertResumeDelayCount_c; /* Set RESUME line for 1-15 ms*/
        MOVW     R2,#+40000
        MOVS     R1,R2
//  968   do
//  969   {
//  970     delayCount--;
??USB_DeviceAssertResume_0:
        SUBS     R1,R1,#+1
//  971     //  Watchdog_Reset();    /* Reset the COP */
//  972   }while(delayCount);
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        CMP      R1,#+0
        BNE.N    ??USB_DeviceAssertResume_0
//  973   USB0_CTL &= ~USB_CTL_RESUME_MASK;          /* Stop RESUME signalling */
        LDR.W    R2,??DataTable17_7  ;; 0x40072094
        LDRB     R2,[R2, #+0]
        ANDS     R2,R2,#0xFB
        LDR.W    R3,??DataTable17_7  ;; 0x40072094
        STRB     R2,[R3, #+0]
//  974   return;
        BX       LR               ;; return
//  975 }
//  976 
//  977 /**************************************************************************//*!
//  978  *
//  979  * @name  USB_DCI_BusTokenCplHandler
//  980  *
//  981  * @brief The function handles Token Complete USB interrupts on the bus.
//  982  *
//  983  * @param stat  : BDT stat byte
//  984  * @param event : Pointer to USB EVENT Structure
//  985  *
//  986  * @return None
//  987  ******************************************************************************
//  988  * This function handles Token Complete USB interrupts on the bus.
//  989  *****************************************************************************/
//  990 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  991 void USB_DCI_BusTokenCplHandler 
//  992 (
//  993 uint8_t stat,            /* [IN] Value of STAT register */
//  994 usbDeviceEvent_t* event /* [IN] Pointer to USB EVENT Structure */
//  995 )
//  996 {
USB_DCI_BusTokenCplHandler:
        PUSH     {R3-R11,LR}
        MOVS     R4,R0
        MOVS     R5,R1
//  997   uint8_t bdtMapIndex = 0 ;
        MOVS     R6,#+0
//  998   uint8_t bdtElemIndex;
//  999   pBuffDsc_t pBuffDsc = NULL;
        MOVS     R7,#+0
// 1000   pBuffDsc_t pBuffDscAlt = NULL;/* stores data of alternate buffer */
        MOVS     R8,#+0
// 1001   pBdtElem_t pBdtElem = NULL;
        MOVS     R9,#+0
// 1002   /* Get the direction from STAT register */
// 1003   event->direction = (uint8_t)((stat & gUsbStat_EndpDirMask_c) >>gUsbStat_EndpDirShift_c);
        UBFX     R0,R4,#+3,#+1
        STRB     R0,[R5, #+3]
// 1004   /* Get bdt index from STAT register*/
// 1005   bdtMapIndex =  stat>>2;
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LSRS     R0,R4,#+2
        MOVS     R6,R0
// 1006   pBuffDsc = &gBDTMap.epDsc[bdtMapIndex];
        LDR.N    R0,??DataTable16_8
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        ADDS     R0,R0,R6, LSL #+3
        MOVS     R7,R0
// 1007   pBuffDscAlt = &gBDTMap.epDsc[bdtMapIndex ^ 1];
        LDR.N    R0,??DataTable16_8
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        EORS     R1,R6,#0x1
        ADDS     R0,R0,R1, LSL #+3
        MOV      R8,R0
// 1008   bdtElemIndex = USB_DCI_GetBDTElemIndex(bdtMapIndex);
        MOVS     R0,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_GetBDTElemIndex
        STRB     R0,[SP, #+1]
// 1009 #ifdef gUSB_Debug_d 
// 1010   if(bdtElemIndex == gUsbInvalidBdtIndex_d)
// 1011   {
// 1012     while(TRUE);
// 1013   }
// 1014 #endif
// 1015   pBdtElem = &gBdtElem[bdtElemIndex];
        LDR.N    R0,??DataTable16_4
        LDRB     R1,[SP, #+1]
        MOVS     R2,#+18
        MLA      R0,R2,R1,R0
        MOV      R9,R0
// 1016   /* Get address from BDT */
// 1017   event->pBuffer = (uint8_t*)(pBuffDsc->addr);
        LDR      R0,[R7, #+4]
        STR      R0,[R5, #+4]
// 1018   /* Get len from BDT */
// 1019   event->len = pBuffDsc->cnt;
        LDRH     R0,[R7, #+2]
        STRH     R0,[R5, #+8]
// 1020   event->shortSend = pBdtElem->shortSend;
        LDRB     R0,[R9, #+16]
        STRB     R0,[R5, #+11]
// 1021   /* Prepare for Next USB Transaction */
// 1022   pBdtElem->bdtMapIndex = bdtMapIndex^1;
        EORS     R0,R6,#0x1
        STRB     R0,[R9, #+15]
// 1023   /* Toggle Data PID*/
// 1024   pBuffDscAlt->stat.byte = (uint8_t)((pBuffDsc->stat.mcuCtlBit.data ^ 1) << 6);
        LDRB     R0,[R7, #+0]
        UBFX     R0,R0,#+6,#+1
        EORS     R0,R0,#0x1
        LSLS     R0,R0,#+6
        STRB     R0,[R8, #+0]
// 1025   if(event->direction == gUsbEpDirection_In_c)
        LDRB     R0,[R5, #+3]
        CMP      R0,#+1
        BNE.N    ??USB_DCI_BusTokenCplHandler_0
// 1026   {
// 1027     if(event->epNum == gUsbControlEndpoint_d)
        LDRB     R0,[R5, #+1]
        CMP      R0,#+0
        BNE.N    ??USB_DCI_BusTokenCplHandler_1
// 1028     {
// 1029       /* for Control Endpoint */
// 1030       /* For Transfer Direction Host to Device */
// 1031       if(gTrfDirection == gUsbEpDirection_Out_c)
        LDR.N    R0,??DataTable16_9
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??USB_DCI_BusTokenCplHandler_1
// 1032       {
// 1033         uint8_t ctrlOutBdtElemIndex;
// 1034         pBdtElem_t pCtrlOutBdtElem;
// 1035         pBuffDsc_t pCtrlOutBufferDsc;
// 1036         /* make Transfer Direction UNKNOWN */                
// 1037         gTrfDirection = gUsbTrfDirUnknown_d;
        MOVS     R0,#+255
        LDR.N    R1,??DataTable16_9
        STRB     R0,[R1, #+0]
// 1038         ctrlOutBdtElemIndex = USB_DCI_GetBDTElemIndex(bdtMapIndex^2);
        EORS     R0,R6,#0x2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_GetBDTElemIndex
        STRB     R0,[SP, #+0]
// 1039 #ifdef gUSB_Debug_d 
// 1040         if(ctrlOutBdtElemIndex == gUsbInvalidBdtIndex_d)
// 1041         {
// 1042           while(TRUE);
// 1043         }
// 1044 #endif
// 1045         pCtrlOutBdtElem = &gBdtElem[ctrlOutBdtElemIndex];
        LDR.N    R0,??DataTable16_4
        LDRB     R1,[SP, #+0]
        MOVS     R2,#+18
        MLA      R0,R2,R1,R0
        MOV      R10,R0
// 1046         pCtrlOutBufferDsc = &gBDTMap.epDsc[pCtrlOutBdtElem->bdtMapIndex];
        LDR.N    R0,??DataTable16_8
        LDRB     R1,[R10, #+15]
        ADDS     R0,R0,R1, LSL #+3
        MOV      R11,R0
// 1047         
// 1048         pCtrlOutBufferDsc->stat.byte = gUsbBdtSCtl_Data0_d;
        MOVS     R0,#+0
        STRB     R0,[R11, #+0]
// 1049         pCtrlOutBdtElem->noTransferInProgress = TRUE;
        MOVS     R0,#+1
        STRB     R0,[R10, #+17]
// 1050         USB_DCI_RecvData((event->controllerId), gUsbControlEndpoint_d, NULL,0);
        MOVS     R3,#+0
        MOVS     R2,#+0
        MOVS     R1,#+0
        LDRB     R0,[R5, #+0]
        BL       USB_DeviceRecvData
// 1051         
// 1052       }
// 1053     }/* ep_num is CONTROL ENDPOINT */
// 1054     
// 1055     if((pBdtElem->shortSend == FALSE)&& ((gTrfDirection == gUsbEpDirection_In_c) ||
// 1056                                          (event->epNum != gUsbControlEndpoint_d)))
??USB_DCI_BusTokenCplHandler_1:
        LDRB     R0,[R9, #+16]
        CMP      R0,#+0
        BNE.W    ??USB_DCI_BusTokenCplHandler_2
        LDR.N    R0,??DataTable16_9
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.N    ??USB_DCI_BusTokenCplHandler_3
        LDRB     R0,[R5, #+1]
        CMP      R0,#+0
        BEQ.W    ??USB_DCI_BusTokenCplHandler_2
// 1057     {
// 1058       /* update the request */
// 1059       pBdtElem->currOffset += event->len;
??USB_DCI_BusTokenCplHandler_3:
        LDRH     R0,[R9, #+12]
        LDRH     R1,[R5, #+8]
        ADDS     R0,R1,R0
        STRH     R0,[R9, #+12]
// 1060       /*
// 1061       Initiate next USB SEND if:
// 1062       1. More Data is still pending OR
// 1063       2. Send Data == Endpoint Size AND
// 1064       3. Zero Termination Flag is TRUE
// 1065       */
// 1066       if ((pBdtElem->appLen > pBdtElem->currOffset) ||
// 1067           (((uint8_t)event->len == pBdtElem->epSize) && (pBdtElem->flag == TRUE))
// 1068             )
        LDRH     R0,[R9, #+12]
        LDRH     R1,[R9, #+10]
        CMP      R0,R1
        BCC.N    ??USB_DCI_BusTokenCplHandler_4
        LDRH     R0,[R5, #+8]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDRH     R1,[R9, #+0]
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        CMP      R0,R1
        BNE.N    ??USB_DCI_BusTokenCplHandler_5
        LDRB     R0,[R9, #+14]
        CMP      R0,#+1
        BNE.N    ??USB_DCI_BusTokenCplHandler_5
// 1069       {
// 1070         /* send next Req */
// 1071         USB_DCI_PrepareSendData(pBuffDscAlt, pBdtElem);
??USB_DCI_BusTokenCplHandler_4:
        MOV      R1,R9
        MOV      R0,R8
        BL       USB_DCI_PrepareSendData
// 1072         
// 1073         /* give the ownership to SIE and TOGGLE DATA BIT */
// 1074         pBuffDscAlt->stat.byte = (uint8_t)(
// 1075                                             ((pBuffDscAlt->stat.mcuCtlBit.data) << 6) |
// 1076                                               gUsbBdtSCtl_SIE_d | gUsbBdtSCtl_DTS_d);;
        LDRB     R0,[R8, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LSRS     R0,R0,#+6
        LSLS     R0,R0,#+6
        ORRS     R0,R0,#0x88
        STRB     R0,[R8, #+0]
// 1077                                               return;
        B.N      ??USB_DCI_BusTokenCplHandler_6
// 1078       }
// 1079       else
// 1080       {
// 1081         event->pBuffer = pBdtElem->pAppBuffer;
??USB_DCI_BusTokenCplHandler_5:
        LDR      R0,[R9, #+6]
        STR      R0,[R5, #+4]
// 1082         event->len = pBdtElem->currOffset;
        LDRH     R0,[R9, #+12]
        STRH     R0,[R5, #+8]
        B.N      ??USB_DCI_BusTokenCplHandler_2
// 1083       }
// 1084     }
// 1085     
// 1086   }/* End of SEND loop */
// 1087   else /* direction IS gUsbEpDirection_Out_c */
// 1088   {
// 1089     if(event->epNum == gUsbControlEndpoint_d)
??USB_DCI_BusTokenCplHandler_0:
        LDRB     R0,[R5, #+1]
        CMP      R0,#+0
        BNE.N    ??USB_DCI_BusTokenCplHandler_7
// 1090     {
// 1091       /* for Control Endpoint */
// 1092       if(pBuffDsc->stat.recPid.pid == gUsbToken_Setup_c)
        LDRB     R0,[R7, #+0]
        UBFX     R0,R0,#+2,#+4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+13
        BNE.N    ??USB_DCI_BusTokenCplHandler_8
// 1093       {
// 1094         uint8_t ctrlInBdtElemIndex;
// 1095         pBdtElem_t pCtrlInBdtElem;
// 1096         pBuffDsc_t pCtrlInBufferDsc;
// 1097         /* set setup phase */
// 1098         event->setup = TRUE;
        MOVS     R0,#+1
        STRB     R0,[R5, #+2]
// 1099         /* Transfer direction of next packet */
// 1100         gTrfDirection = event->pBuffer[0] >> 7;
        LDR      R0,[R5, #+4]
        LDRB     R0,[R0, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LSRS     R0,R0,#+7
        LDR.N    R1,??DataTable16_9
        STRB     R0,[R1, #+0]
// 1101         ctrlInBdtElemIndex = USB_DCI_GetBDTElemIndex(bdtMapIndex^2);
        EORS     R0,R6,#0x2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_GetBDTElemIndex
        STRB     R0,[SP, #+0]
// 1102 #ifdef gUSB_Debug_d 
// 1103         if(ctrlInBdtElemIndex == gUsbInvalidBdtIndex_d)
// 1104         {
// 1105           while(TRUE);
// 1106         }
// 1107 #endif
// 1108         pCtrlInBdtElem = &gBdtElem[ctrlInBdtElemIndex];
        LDR.N    R0,??DataTable16_4
        LDRB     R1,[SP, #+0]
        MOVS     R2,#+18
        MLA      R0,R2,R1,R0
        MOV      R10,R0
// 1109         pCtrlInBufferDsc = &gBDTMap.epDsc[pCtrlInBdtElem->bdtMapIndex];
        LDR.N    R0,??DataTable16_8
        LDRB     R1,[R10, #+15]
        ADDS     R0,R0,R1, LSL #+3
        MOV      R11,R0
// 1110         pCtrlInBufferDsc->stat.byte = gUsbBdtSCtl_Data1_d;
        MOVS     R0,#+64
        STRB     R0,[R11, #+0]
// 1111         pCtrlInBdtElem->noTransferInProgress = TRUE;
        MOVS     R0,#+1
        STRB     R0,[R10, #+17]
        B.N      ??USB_DCI_BusTokenCplHandler_7
// 1112         
// 1113       }
// 1114       else if(gTrfDirection == gUsbEpDirection_In_c)
??USB_DCI_BusTokenCplHandler_8:
        LDR.N    R0,??DataTable16_9
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??USB_DCI_BusTokenCplHandler_7
// 1115       {
// 1116         /* make Transfer Direction UNKNOWN */
// 1117         gTrfDirection = gUsbTrfDirUnknown_d;
        MOVS     R0,#+255
        LDR.N    R1,??DataTable16_9
        STRB     R0,[R1, #+0]
// 1118         /* We Require DATA0 PID for Setup Token */
// 1119         pBuffDscAlt->stat.byte = gUsbBdtSCtl_Data0_d;
        MOVS     R0,#+0
        STRB     R0,[R8, #+0]
// 1120         pBdtElem->noTransferInProgress = TRUE;
        MOVS     R0,#+1
        STRB     R0,[R9, #+17]
// 1121         /* Prepare for Next SETUP PACKET Receive */
// 1122         USB_DCI_RecvData((event->controllerId), gUsbControlEndpoint_d, NULL,0);
        MOVS     R3,#+0
        MOVS     R2,#+0
        MOVS     R1,#+0
        LDRB     R0,[R5, #+0]
        BL       USB_DeviceRecvData
// 1123         return;
        B.N      ??USB_DCI_BusTokenCplHandler_6
// 1124       }
// 1125     }   /* ep_num is CONTROL ENDPOINT */
// 1126     
// 1127     if(pBdtElem->appLen != (usbPacketSize_t)gUninitialisedVal_d)
??USB_DCI_BusTokenCplHandler_7:
        LDRH     R0,[R9, #+10]
        MOVW     R1,#+65535
        CMP      R0,R1
        BEQ.N    ??USB_DCI_BusTokenCplHandler_2
// 1128     {
// 1129       /* on control endpoint the data is only 8 bytes */
// 1130       usbPacketSize_t size = event->len;
        LDRH     R0,[R5, #+8]
// 1131       pBdtElem->currOffset += size;
        LDRH     R1,[R9, #+12]
        ADDS     R1,R0,R1
        STRH     R1,[R9, #+12]
// 1132       /*
// 1133       Initiate next USB RECV if:
// 1134       1. More Data is still pending OR
// 1135       2. Received Data == Endpoint Size AND
// 1136       3. Zero Termination Flag is TRUE
// 1137       */
// 1138       if(
// 1139          (size == pBdtElem->epSize) &&
// 1140            ((pBdtElem->appLen > pBdtElem->currOffset) || ((pBdtElem->appLen == pBdtElem->currOffset) && (pBdtElem->flag == TRUE)))
// 1141              ) 
        LDRH     R1,[R9, #+0]
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        CMP      R0,R1
        BNE.N    ??USB_DCI_BusTokenCplHandler_9
        LDRH     R1,[R9, #+12]
        LDRH     R2,[R9, #+10]
        CMP      R1,R2
        BCC.N    ??USB_DCI_BusTokenCplHandler_10
        LDRH     R1,[R9, #+10]
        LDRH     R2,[R9, #+12]
        CMP      R1,R2
        BNE.N    ??USB_DCI_BusTokenCplHandler_9
        LDRB     R1,[R9, #+14]
        CMP      R1,#+1
        BNE.N    ??USB_DCI_BusTokenCplHandler_9
// 1142       {
// 1143         /* send next IO */
// 1144         uint16_t count;
// 1145         count = (uint16_t)(((pBdtElem->appLen - pBdtElem->currOffset)
// 1146                             > pBdtElem->epSize) ? pBdtElem->epSize :
// 1147                                (pBdtElem->appLen - pBdtElem->currOffset));
??USB_DCI_BusTokenCplHandler_10:
        LDRH     R2,[R9, #+0]
        LDRH     R3,[R9, #+10]
        LDRH     R12,[R9, #+12]
        SUBS     R3,R3,R12
        CMP      R2,R3
        BGE.N    ??USB_DCI_BusTokenCplHandler_11
        LDRH     R1,[R9, #+0]
        B.N      ??USB_DCI_BusTokenCplHandler_12
??USB_DCI_BusTokenCplHandler_11:
        LDRH     R1,[R9, #+10]
        LDRH     R2,[R9, #+12]
        SUBS     R1,R1,R2
// 1148 				if(count == 0)
??USB_DCI_BusTokenCplHandler_12:
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        CMP      R1,#+0
        BNE.N    ??USB_DCI_BusTokenCplHandler_13
// 1149 				{
// 1150           /* For Zero byte Packet Receive */
// 1151 					pBuffDscAlt->addr = pBdtElem->addr;
        LDR      R2,[R9, #+2]
        STR      R2,[R8, #+4]
// 1152           pBuffDscAlt->cnt = 0;
        MOVS     R2,#+0
        STRH     R2,[R8, #+2]
        B.N      ??USB_DCI_BusTokenCplHandler_14
// 1153 				}
// 1154 				else
// 1155 				{
// 1156           pBuffDscAlt->addr = (uint32_t)(pBdtElem->pAppBuffer + pBdtElem->currOffset);
??USB_DCI_BusTokenCplHandler_13:
        LDR      R2,[R9, #+6]
        LDRH     R3,[R9, #+12]
        ADDS     R2,R3,R2
        STR      R2,[R8, #+4]
// 1157           pBuffDscAlt->cnt = count;
        STRH     R1,[R8, #+2]
// 1158 				}
// 1159         /* give the ownership to SIE and Toggle DATA bit*/
// 1160         pBuffDscAlt->stat.byte = (uint8_t)((
// 1161                                              (pBuffDscAlt->stat.mcuCtlBit.data) << 6) |
// 1162                                             gUsbBdtSCtl_SIE_d | gUsbBdtSCtl_DTS_d);
??USB_DCI_BusTokenCplHandler_14:
        LDRB     R2,[R8, #+0]
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        LSRS     R2,R2,#+6
        LSLS     R2,R2,#+6
        ORRS     R2,R2,#0x88
        STRB     R2,[R8, #+0]
// 1163         return;
        B.N      ??USB_DCI_BusTokenCplHandler_6
// 1164       }
// 1165       else /* request completed */
// 1166       {
// 1167         /* populate buffer structure */
// 1168         event->pBuffer = pBdtElem->pAppBuffer;
??USB_DCI_BusTokenCplHandler_9:
        LDR      R1,[R9, #+6]
        STR      R1,[R5, #+4]
// 1169         event->len = pBdtElem->currOffset;
        LDRH     R1,[R9, #+12]
        STRH     R1,[R5, #+8]
// 1170         pBdtElem->appLen = (usbPacketSize_t)gUninitialisedVal_d;
        MOVW     R1,#+65535
        STRH     R1,[R9, #+10]
// 1171       }
// 1172     }
// 1173   } /* End of RECV loop */
// 1174   pBdtElem->noTransferInProgress = TRUE;
??USB_DCI_BusTokenCplHandler_2:
        MOVS     R0,#+1
        STRB     R0,[R9, #+17]
// 1175   /* Notify Device Layer of Data Received or Sent Event */
// 1176   (void)USB_DeviceCallService(event->epNum, event);
        MOVS     R1,R5
        LDRB     R0,[R5, #+1]
        BL       USB_DeviceCallService
// 1177   return;
??USB_DCI_BusTokenCplHandler_6:
        POP      {R0,R4-R11,PC}   ;; return
// 1178 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16:
        DC32     0x40072088

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_1:
        DC32     0x40072094

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_2:
        DC32     0x40072098

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_3:
        DC32     0x40072100

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_4:
        DC32     gBdtElem

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_5:
        DC32     endpCtl

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_6:
        DC32     gaEndpBuffers

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_7:
        DC32     endpCtl+0x4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_8:
        DC32     gBDTMap

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_9:
        DC32     gTrfDirection

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_10:
        DC32     0x4007210c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_11:
        DC32     0x4007208c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_12:
        DC32     0x40072084

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_13:
        DC32     gDciControllerId
// 1179 
// 1180 
// 1181 
// 1182 
// 1183 /**************************************************************************//*!
// 1184  *
// 1185  * @name  USB_ISR
// 1186  *
// 1187  * @brief The function handles USB interrupts on the bus.
// 1188  *
// 1189  * @param None
// 1190  *
// 1191  * @return None
// 1192  *
// 1193  ******************************************************************************
// 1194  * This function is hooked onto interrupt 69 and handles the USB interrupts.
// 1195  * After handling the interrupt it calls the Device Layer to notify it about
// 1196  * the event.
// 1197  *****************************************************************************/
// 1198 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1199 void USB_ISR(void)
// 1200 {
USB_ISR:
        PUSH     {R4,R5,LR}
        SUB      SP,SP,#+20
// 1201   usbDeviceEvent_t event;
// 1202   uint16_t devState = gUsbStatus_Unknown_d;
        MOVW     R0,#+65535
        STRH     R0,[SP, #+2]
// 1203   uint8_t stat = (uint8_t)USB0_STAT;
        LDR.N    R0,??DataTable17_11  ;; 0x40072090
        LDRB     R4,[R0, #+0]
// 1204   /* Which interrupt occured and also was enabled */
// 1205   uint8_t intrStat =  USB0_ISTAT;
        LDR.N    R0,??DataTable17_4  ;; 0x40072080
        LDRB     R5,[R0, #+0]
// 1206   intrStat &= USB0_INTEN;
        LDR.N    R0,??DataTable17_5  ;; 0x40072084
        LDRB     R0,[R0, #+0]
        ANDS     R5,R0,R5
// 1207   /* initialize event structure */
// 1208   event.controllerId = gDciControllerId;
        LDR.N    R0,??DataTable17_10
        LDRB     R0,[R0, #+0]
        STRB     R0,[SP, #+4]
// 1209   event.setup = FALSE;
        MOVS     R0,#+0
        STRB     R0,[SP, #+6]
// 1210   event.pBuffer = NULL;
        MOVS     R0,#+0
        STR      R0,[SP, #+8]
// 1211   event.len = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+12]
// 1212   event.direction = gUsbEpDirection_Out_c;
        MOVS     R0,#+0
        STRB     R0,[SP, #+7]
// 1213   event.errors = 0;
        MOVS     R0,#+0
        STRB     R0,[SP, #+14]
// 1214   event.shortSend = FALSE;
        MOVS     R0,#+0
        STRB     R0,[SP, #+15]
// 1215   event.epNum = (uint8_t)gUninitialisedVal_d;
        MOVS     R0,#+255
        STRB     R0,[SP, #+5]
// 1216   /* Get the device state from the Device Layer */
// 1217   (void)USB_DeviceGetStatus(gDciControllerId, gUsbComponentStatus_DeviceState_d,&devState);
        ADD      R2,SP,#+2
        MOVS     R1,#+1
        LDR.N    R0,??DataTable17_10
        LDRB     R0,[R0, #+0]
        BL       USB_DeviceGetStatus
// 1218   /* if current device state is SUSPEND and Low Power Resume Flag set */
// 1219   if((USB0_USBTRC0 & USB_USBTRC0_USB_RESUME_INT_MASK) && (devState == gUsbDeviceState_Suspend_d))
        LDR.N    R1,??DataTable17_12  ;; 0x4007210c
        LDRB     R1,[R1, #+0]
        LSLS     R1,R1,#+31
        BPL.N    ??USB_ISR_0
        LDRH     R0,[SP, #+2]
        CMP      R0,#+128
        BNE.N    ??USB_ISR_0
// 1220   {
// 1221     /* Clear SUSP Bit from USB_CTRL */
// 1222     USB0_USBCTRL &= ~USB_USBCTRL_SUSP_MASK;
        LDR.N    R0,??DataTable17_13  ;; 0x40072100
        LDRB     R0,[R0, #+0]
        ANDS     R0,R0,#0x7F
        LDR.N    R1,??DataTable17_13  ;; 0x40072100
        STRB     R0,[R1, #+0]
// 1223     /* Reset Low Power RESUME enable */
// 1224     USB0_USBTRC0 &= ~USB_USBTRC0_USBRESMEN_MASK;
        LDR.N    R0,??DataTable17_12  ;; 0x4007210c
        LDRB     R0,[R0, #+0]
        ANDS     R0,R0,#0xDF
        LDR.N    R1,??DataTable17_12  ;; 0x4007210c
        STRB     R0,[R1, #+0]
// 1225   }
// 1226   
// 1227   /* SOF received */
// 1228   if(UsbDciIntFlag_SofToken(intrStat))
??USB_ISR_0:
        LSLS     R0,R5,#+29
        BPL.N    ??USB_ISR_1
// 1229   {
// 1230     uint16_t sofCount;
// 1231     sofCount = USB0_FRMNUMH;
        LDR.N    R0,??DataTable17_14  ;; 0x400720a4
        LDRB     R0,[R0, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRH     R0,[SP, #+0]
// 1232     sofCount <<= 8;
        LDRH     R0,[SP, #+0]
        LSLS     R0,R0,#+8
        STRH     R0,[SP, #+0]
// 1233     sofCount += USB0_FRMNUML;
        LDRH     R0,[SP, #+0]
        LDR.N    R1,??DataTable17_15  ;; 0x400720a0
        LDRB     R1,[R1, #+0]
        UXTAB    R0,R0,R1
        STRH     R0,[SP, #+0]
// 1234     /* Clear SOF Interrupt */
// 1235     USB0_ISTAT = USB_ISTAT_SOFTOK_MASK;
        MOVS     R0,#+4
        LDR.N    R1,??DataTable17_4  ;; 0x40072080
        STRB     R0,[R1, #+0]
// 1236     /*address of Lower byte of Frame number*/
// 1237     event.pBuffer = (uint8_t*)(&sofCount);
        ADD      R0,SP,#+0
        STR      R0,[SP, #+8]
// 1238     /* Notify Device Layer of SOF Event */
// 1239     (void)USB_DeviceCallService(gUsbService_SOF_d, &event);
        ADD      R1,SP,#+4
        MOVS     R0,#+17
        BL       USB_DeviceCallService
// 1240   }
// 1241   
// 1242   if(UsbDciIntFlag_BusReset(intrStat))
??USB_ISR_1:
        LSLS     R0,R5,#+31
        BPL.N    ??USB_ISR_2
// 1243   {
// 1244     /* Clear Reset Flag */
// 1245     USB0_ISTAT = USB_ISTAT_USBRST_MASK;
        MOVS     R0,#+1
        LDR.N    R1,??DataTable17_4  ;; 0x40072080
        STRB     R0,[R1, #+0]
// 1246     /* Handle RESET Interrupt */
// 1247     USB_DCI_BusResetHandler();
        BL       USB_DCI_BusResetHandler
// 1248     /* Notify Device Layer of RESET Event */
// 1249     (void)USB_DeviceCallService(gUsbService_BusReset_d, &event);
        ADD      R1,SP,#+4
        MOVS     R0,#+16
        BL       USB_DeviceCallService
// 1250     /* Clearing this bit allows the SIE to continue token processing and clear suspend condition */
// 1251     USB0_CTL &= ~USB_CTL_TXSUSPENDTOKENBUSY_MASK;
        LDR.N    R1,??DataTable17_7  ;; 0x40072094
        LDRB     R1,[R1, #+0]
        ANDS     R1,R1,#0xDF
        LDR.N    R2,??DataTable17_7  ;; 0x40072094
        STRB     R1,[R2, #+0]
// 1252     /* No need to process other interrupts */
// 1253     return;
        B.N      ??USB_ISR_3
// 1254   }
// 1255   
// 1256   if(UsbDciIntFlag_TokenComplete(intrStat))
??USB_ISR_2:
        LSLS     R0,R5,#+28
        BPL.N    ??USB_ISR_4
// 1257   {
// 1258     /* Clear TOKEN Interrupt */
// 1259     USB0_ISTAT = USB_ISTAT_TOKDNE_MASK;
        MOVS     R0,#+8
        LDR.N    R1,??DataTable17_4  ;; 0x40072080
        STRB     R0,[R1, #+0]
// 1260     event.epNum = (uint8_t)((stat & gUsbStat_EndpNumberMask_c) >> gUsbStat_EndpNumberShift_c);
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LSRS     R0,R4,#+4
        STRB     R0,[SP, #+5]
// 1261     USB_DCI_BusTokenCplHandler(stat, &event);
        ADD      R1,SP,#+4
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DCI_BusTokenCplHandler
// 1262     /* Clearing this bit allows the SIE to continue token processing and clear suspend condition */
// 1263     USB0_CTL &= ~USB_CTL_TXSUSPENDTOKENBUSY_MASK;
        LDR.N    R0,??DataTable17_7  ;; 0x40072094
        LDRB     R0,[R0, #+0]
        ANDS     R0,R0,#0xDF
        LDR.N    R1,??DataTable17_7  ;; 0x40072094
        STRB     R0,[R1, #+0]
// 1264   }
// 1265   
// 1266   if(UsbDciIntFlag_Error(intrStat))
??USB_ISR_4:
        LSLS     R0,R5,#+30
        BPL.N    ??USB_ISR_5
// 1267   {
// 1268     /* Clear ERROR Interrupt */
// 1269     USB0_ISTAT = USB_ISTAT_ERROR_MASK;
        MOVS     R0,#+2
        LDR.N    R1,??DataTable17_4  ;; 0x40072080
        STRB     R0,[R1, #+0]
// 1270     event.errors = USB0_ERRSTAT;
        LDR.N    R0,??DataTable17_16  ;; 0x40072088
        LDRB     R0,[R0, #+0]
        STRB     R0,[SP, #+14]
// 1271     event.errors &= USB0_ERREN;
        LDRB     R0,[SP, #+14]
        LDR.N    R1,??DataTable17_17  ;; 0x4007208c
        LDRB     R1,[R1, #+0]
        ANDS     R0,R1,R0
        STRB     R0,[SP, #+14]
// 1272     /* Notify Device Layer of ERROR Event to error service */
// 1273     (void)USB_DeviceCallService(gUsbService_Error_d, &event);
        ADD      R1,SP,#+4
        MOVS     R0,#+20
        BL       USB_DeviceCallService
// 1274     USB0_ERRSTAT = gUsbDciErrStat_ClearAll_c;  /*clear all errors*/
        MOVS     R1,#+191
        LDR.N    R2,??DataTable17_16  ;; 0x40072088
        STRB     R1,[R2, #+0]
// 1275     /* Clearing this bit allows the SIE to continue token processing and clear suspend condition */
// 1276     USB0_CTL &= ~USB_CTL_TXSUSPENDTOKENBUSY_MASK;
        LDR.N    R1,??DataTable17_7  ;; 0x40072094
        LDRB     R1,[R1, #+0]
        ANDS     R1,R1,#0xDF
        LDR.N    R2,??DataTable17_7  ;; 0x40072094
        STRB     R1,[R2, #+0]
// 1277   }
// 1278   
// 1279   if(UsbDciIntFlag_Sleep(intrStat))
??USB_ISR_5:
        LSLS     R0,R5,#+27
        BPL.N    ??USB_ISR_6
// 1280   {
// 1281     /* Clear RESUME Interrupt if Pending */
// 1282     USB0_ISTAT = USB_ISTAT_RESUME_MASK;
        MOVS     R0,#+32
        LDR.N    R1,??DataTable17_4  ;; 0x40072080
        STRB     R0,[R1, #+0]
// 1283     /* Clear SLEEP Interrupt */
// 1284   	USB0_ISTAT = USB_ISTAT_SLEEP_MASK;
        MOVS     R0,#+16
        LDR.N    R1,??DataTable17_4  ;; 0x40072080
        STRB     R0,[R1, #+0]
// 1285     /* Notify Device Layer of SLEEP Event */
// 1286     (void)USB_DeviceCallService(gUsbService_Sleep_d, &event);
        ADD      R1,SP,#+4
        MOVS     R0,#+19
        BL       USB_DeviceCallService
// 1287     /* Set Low Power RESUME enable */
// 1288     USB0_USBTRC0 |= USB_USBTRC0_USBRESMEN_MASK;
        LDR.N    R1,??DataTable17_12  ;; 0x4007210c
        LDRB     R1,[R1, #+0]
        ORRS     R1,R1,#0x20
        LDR.N    R2,??DataTable17_12  ;; 0x4007210c
        STRB     R1,[R2, #+0]
// 1289     /* Set SUSP Bit in USB_CTRL */
// 1290     USB0_USBCTRL |= USB_USBCTRL_SUSP_MASK;
        LDR.N    R1,??DataTable17_13  ;; 0x40072100
        LDRB     R1,[R1, #+0]
        ORRS     R1,R1,#0x80
        LDR.N    R2,??DataTable17_13  ;; 0x40072100
        STRB     R1,[R2, #+0]
// 1291     /* Enable RESUME Interrupt */
// 1292     USB0_INTEN |= USB_INTEN_RESUMEEN_MASK;
        LDR.N    R1,??DataTable17_5  ;; 0x40072084
        LDRB     R1,[R1, #+0]
        ORRS     R1,R1,#0x20
        LDR.N    R2,??DataTable17_5  ;; 0x40072084
        STRB     R1,[R2, #+0]
// 1293   }
// 1294   
// 1295   if(UsbDciIntFlag_Resume(intrStat))
??USB_ISR_6:
        LSLS     R0,R5,#+26
        BPL.N    ??USB_ISR_7
// 1296   {
// 1297     /* Clear RESUME Interrupt */
// 1298     USB0_ISTAT = USB_ISTAT_RESUME_MASK;
        MOVS     R0,#+32
        LDR.N    R1,??DataTable17_4  ;; 0x40072080
        STRB     R0,[R1, #+0]
// 1299     /* Notify Device Layer of RESUME Event */
// 1300     (void)USB_DeviceCallService(gUsbService_Resume_d, &event);
        ADD      R1,SP,#+4
        MOVS     R0,#+18
        BL       USB_DeviceCallService
// 1301     /* Disable RESUME Interrupt */
// 1302     USB0_INTEN &= ~USB_INTEN_RESUMEEN_MASK;
        LDR.N    R1,??DataTable17_5  ;; 0x40072084
        LDRB     R1,[R1, #+0]
        ANDS     R1,R1,#0xDF
        LDR.N    R2,??DataTable17_5  ;; 0x40072084
        STRB     R1,[R2, #+0]
// 1303   }
// 1304   
// 1305   if(UsbDciIntFlag_Stall(intrStat))
??USB_ISR_7:
        LSLS     R0,R5,#+24
        BPL.N    ??USB_ISR_8
// 1306   {
// 1307     uint16_t endpStatus;
// 1308     event.epNum = (uint8_t)gUninitialisedVal_d;
        MOVS     R0,#+255
        STRB     R0,[SP, #+5]
// 1309     /* If Control Endpoint is stalled then unstall it.
// 1310     For other endpoints host issues clear endpoint feature request
// 1311     to unstall them */
// 1312     /* Get Control Endpoint Status*/
// 1313     (void)USB_DeviceGetStatus((event.controllerId),
// 1314                               (gUsbComponentStatus_Endpoint_d|gUsbControlEndpoint_d),
// 1315                               &endpStatus);
        ADD      R2,SP,#+16
        MOVS     R1,#+16
        LDRB     R0,[SP, #+4]
        BL       USB_DeviceGetStatus
// 1316      if(endpStatus == gUsbStatus_Stalled_d)
        LDRH     R1,[SP, #+16]
        CMP      R1,#+1
        BNE.N    ??USB_ISR_9
// 1317      {
// 1318        event.epNum = gUsbControlEndpoint_d;
        MOVS     R0,#+0
        STRB     R0,[SP, #+5]
// 1319        event.direction = gUsbEpDirection_In_c;
        MOVS     R0,#+1
        STRB     R0,[SP, #+7]
// 1320      }
// 1321      /* Clear STALL Interrupt */
// 1322      USB0_ISTAT = USB_ISTAT_STALL_MASK;
??USB_ISR_9:
        MOVS     R0,#+128
        LDR.N    R1,??DataTable17_4  ;; 0x40072080
        STRB     R0,[R1, #+0]
// 1323      /* Notify Device Layer of STALL Event */
// 1324      (void)USB_DeviceCallService(gUsbService_Stall_d, &event);
        ADD      R1,SP,#+4
        MOVS     R0,#+21
        BL       USB_DeviceCallService
// 1325      /* Clearing this bit allows the SIE to continue token processing and clear suspend condition */
// 1326      USB0_CTL &= ~USB_CTL_TXSUSPENDTOKENBUSY_MASK;
        LDR.N    R1,??DataTable17_7  ;; 0x40072094
        LDRB     R1,[R1, #+0]
        ANDS     R1,R1,#0xDF
        LDR.N    R2,??DataTable17_7  ;; 0x40072094
        STRB     R1,[R2, #+0]
// 1327   }
// 1328   return;
??USB_ISR_8:
??USB_ISR_3:
        ADD      SP,SP,#+20
        POP      {R4,R5,PC}       ;; return
// 1329 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17:
        DC32     0x4007209c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_1:
        DC32     0x400720b0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_2:
        DC32     0x400720b4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_3:
        DC32     0x40072108

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_4:
        DC32     0x40072080

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_5:
        DC32     0x40072084

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_6:
        DC32     0x400720c0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_7:
        DC32     0x40072094

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_8:
        DC32     ?_0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_9:
        DC32     gaEndpBuffers+0x50

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_10:
        DC32     gDciControllerId

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_11:
        DC32     0x40072090

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_12:
        DC32     0x4007210c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_13:
        DC32     0x40072100

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_14:
        DC32     0x400720a4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_15:
        DC32     0x400720a0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_16:
        DC32     0x40072088

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_17:
        DC32     0x4007208c

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
?_0:
        DATA
        DC32 8, 4

        END
// 1330 
// 1331 #endif//gUsbIncluded_d
// 
//   725 bytes in section .bss
//     1 byte  in section .data
//     8 bytes in section .rodata
// 3 714 bytes in section .text
// 
// 3 714 bytes of CODE  memory
//     8 bytes of CONST memory
//   726 bytes of DATA  memory
//
//Errors: none
//Warnings: none
