###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        02/Sep/2018  13:33:19
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\SMAC.c
#    Command line =  
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\SMAC.c" -D
#        IAR --preprocess "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code
#        Sequential ADC Reads\Shanit Origional Code\Connectivity
#        Test\Debug\List\" -lC "F:\Guardrail Work\Sensor Code\Git Repo\Sensor
#        Code Sequential ADC Reads\Shanit Origional Code\Connectivity
#        Test\Debug\List\" -lB "F:\Guardrail Work\Sensor Code\Git Repo\Sensor
#        Code Sequential ADC Reads\Shanit Origional Code\Connectivity
#        Test\Debug\List\" --diag_suppress
#        Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\Obj\" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\CDC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\Descriptor\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\USB\Class\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Sys Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
#    List file    =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\List\SMAC.lst
#    Object file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\Obj\SMAC.o
#
###############################################################################

F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\SMAC.c
      1          /*****************************************************************************
      2          * SMAC implementation.
      3          * 
      4          * Copyright (c) 2012, Freescale, Inc. All rights reserved.
      5          *
      6          * No part of this document must be reproduced in any form - including copied,
      7          * transcribed, printed or by any electronic means - without specific written
      8          * permission from Freescale Semiconductor.
      9          *
     10          *****************************************************************************/
     11          
     12          #include "SMAC.h"
     13          
     14          
     15          /************************************************************************************
     16          *************************************************************************************
     17          * Private memory declarations
     18          *************************************************************************************
     19          ************************************************************************************/
     20          

   \                                 In section .rodata, align 4
     21          const uint8_t au8SmacVersion[7] = 
   \                     au8SmacVersion:
   \   00000000   0x01 0x01          DC8 1, 1, 0, 8, 14, 13, 1, 0
   \              0x00 0x08    
   \              0x0E 0x0D    
   \              0x01 0x00    
     22          {
     23            mMajorSmacV_c, 
     24            mMiddleSmacV_c, 
     25            mMinorSmacV_c, 
     26            mMonthSmacV_c,
     27            mDaySmacV_c, 
     28            mYearSmacV_c, 
     29            mConsSmacV_c
     30          };
     31                                          

   \                                 In section .bss, align 4
     32          static uint32_t        smacTimeout;
   \                     smacTimeout:
   \   00000000                      DS8 4

   \                                 In section .bss, align 2
     33          static uint16_t        smacChannelsBeingScanned;
   \                     smacChannelsBeingScanned:
   \   00000000                      DS8 2

   \                                 In section .bss, align 1
     34          static uint8_t         smacEdValue;
   \                     smacEdValue:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     35          static smacStates_t    smacState;
   \                     smacState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     36          static phyRxParams_t   smacLastDataRxParams;
   \                     smacLastDataRxParams:
   \   00000000                      DS8 8

   \                                 In section .bss, align 1
     37          static channels_t      smacCurrentChannel;
   \                     smacCurrentChannel:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     38          static channels_t      smacScanCurrentChannel;
   \                     smacScanCurrentChannel:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     39          static channels_t      smacClearestChann;
   \                     smacClearestChann:
   \   00000000                      DS8 1

   \                                 In section .data, align 4
     40          static uint8_t         u8TestBuffer[65] = 
   \                     u8TestBuffer:
   \   00000000   0x42 0xFF          DC8 66, 255, 193, 251, 232, 76, 144, 114, 139, 231, 179, 81, 137, 99
   \              0xC1 0xFB    
   \              0xE8 0x4C    
   \              0x90 0x72    
   \              0x8B 0xE7    
   \              0xB3 0x51    
   \              0x89 0x63    
   \   0000000E   0xAB 0x23          DC8 171, 35, 35, 2, 132, 24, 114, 170, 97, 47, 59, 81, 168, 229, 55, 73
   \              0x23 0x02    
   \              0x84 0x18    
   \              0x72 0xAA    
   \              0x61 0x2F    
   \              0x3B 0x51    
   \              0xA8 0xE5    
   \              0x37 0x49    
   \   0000001E   0xFB 0xC9          DC8 251, 201, 202, 12, 24, 83, 44, 253, 69, 227, 154, 230, 241, 93, 176
   \              0xCA 0x0C    
   \              0x18 0x53    
   \              0x2C 0xFD    
   \              0x45 0xE3    
   \              0x9A 0xE6    
   \              0xF1 0x5D    
   \              0xB0         
   \   0000002D   0xB6 0x1B          DC8 182, 27, 180, 190, 42, 80, 234, 233, 14, 156, 75, 94, 87, 36, 204
   \              0xB4 0xBE    
   \              0x2A 0x50    
   \              0xEA 0xE9    
   \              0x0E 0x9C    
   \              0x4B 0x5E    
   \              0x57 0x24    
   \              0xCC         
   \   0000003C   0xA1 0xB7          DC8 161, 183, 89, 184, 135, 0, 0, 0
   \              0x59 0xB8    
   \              0x87 0x00    
   \              0x00 0x00    
     41          { 
     42            0x42,
     43            0xff,0xc1,0xfb,0xe8,0x4c,0x90,0x72,0x8b,0xe7,0xb3,0x51,0x89,0x63,0xab,0x23,0x23,  
     44            0x02,0x84,0x18,0x72,0xaa,0x61,0x2f,0x3b,0x51,0xa8,0xe5,0x37,0x49,0xfb,0xc9,0xca,
     45            0x0c,0x18,0x53,0x2c,0xfd,0x45,0xe3,0x9a,0xe6,0xf1,0x5d,0xb0,0xb6,0x1b,0xb4,0xbe,
     46            0x2a,0x50,0xea,0xe9,0x0e,0x9c,0x4b,0x5e,0x57,0x24,0xcc,0xa1,0xb7,0x59,0xb8,0x87
     47          };

   \                                 In section .bss, align 4
     48          static phyPacket_t     *pTestPacket;  
   \                     pTestPacket:
   \   00000000                      DS8 4
     49          

   \                                 In section .bss, align 4
     50          volatile static prssPacketPtr_t smacProccesPacketPtr;
   \                     smacProccesPacketPtr:
   \   00000000                      DS8 4
     51          

   \                                 In section .bss, align 4
     52          flagsRegister_t smacFlags;
   \                     smacFlags:
   \   00000000                      DS8 4
     53          

   \                                 In section .rodata, align 4
     54          static const uint16_t Local_pll_frac[16] = {0x2400, 0x4C00, 0x7400, 0x9C00, 0xC400, 0xEC00, 0x1400, 0x3C00, 0x6400, 0x8C00, 0xB400, 0xDC00, 0x0400, 0x2C00, 0x5400, 0x7C00};
   \                     Local_pll_frac:
   \   00000000   0x2400 0x4C00      DC16 9216, 19456, 29696, 39936, 50176, 60416, 5120, 15360, 25600, 35840
   \              0x7400 0x9C00
   \              0xC400 0xEC00
   \              0x1400 0x3C00
   \              0x6400 0x8C00
   \   00000014   0xB400 0xDC00      DC16 46080, 56320, 1024, 11264, 21504, 31744
   \              0x0400 0x2C00
   \              0x5400 0x7C00
     55          
     56          
     57          /************************************************************************************
     58          *************************************************************************************
     59          * Interface functions
     60          *************************************************************************************
     61          ************************************************************************************/
     62          
     63          
     64          /***********************************************************************************/
     65          /******************************** SMAC Data primitives *****************************/
     66          /***********************************************************************************/
     67          
     68          /************************************************************************************
     69          * MCPSDataRequest
     70          * 
     71          * This data primitive is used to send an over the air packet. This is an asyncronous 
     72          * function,  it means it ask SMAC to transmit one OTA packet,  but when the runction 
     73          * returns it is not sent already.
     74          *
     75          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     76          smacErrors_t MCPSDataRequest
     77          (
     78          txPacket_t *psTxPacket /* IN:Pointer to the packet to be transmitted */
     79          )
     80          {
   \                     MCPSDataRequest: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
     81            
     82            uint8_t u8PhyRes = 0; 
   \   00000004   0x2500             MOVS     R5,#+0
     83            
     84          #if (TRUE == smacParametersValidation_d)
     85            uint8_t u8MaxLen=0;
   \   00000006   0x2600             MOVS     R6,#+0
     86            
     87            if (mPromiscuousModeEnabled)
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable27
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD002             BEQ.N    ??MCPSDataRequest_0
     88            {
     89              u8MaxLen = gMaxPromiscuousSmacSDULength_c;
   \   00000016   0x207D             MOVS     R0,#+125
   \   00000018   0x0006             MOVS     R6,R0
   \   0000001A   0xE001             B.N      ??MCPSDataRequest_1
     90            }
     91            else
     92            {
     93              u8MaxLen = gMaxSmacSDULength_c;
   \                     ??MCPSDataRequest_0: (+1)
   \   0000001C   0x207B             MOVS     R0,#+123
   \   0000001E   0x0006             MOVS     R6,R0
     94            }
     95            
     96            if((NULL == psTxPacket) || (u8MaxLen < psTxPacket->u8DataLength))
   \                     ??MCPSDataRequest_1: (+1)
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD003             BEQ.N    ??MCPSDataRequest_2
   \   00000024   0x7820             LDRB     R0,[R4, #+0]
   \   00000026   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000028   0x4286             CMP      R6,R0
   \   0000002A   0xD201             BCS.N    ??MCPSDataRequest_3
     97            {
     98              return gErrorOutOfRange_c;
   \                     ??MCPSDataRequest_2: (+1)
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xE028             B.N      ??MCPSDataRequest_4
     99            } 
    100          #endif
    101          
    102          #if(TRUE == smacInitializationValidation_d)
    103           if(FALSE == mSmacInitialized)
   \                     ??MCPSDataRequest_3: (+1)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD101             BNE.N    ??MCPSDataRequest_5
    104            {
    105              return gErrorNoValidCondition_c;
   \   00000040   0x2004             MOVS     R0,#+4
   \   00000042   0xE01E             B.N      ??MCPSDataRequest_4
    106            }
    107          #endif
    108            if(mSmacStateIdle_c != smacState)
   \                     ??MCPSDataRequest_5: (+1)
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   00000048   0x7800             LDRB     R0,[R0, #+0]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD001             BEQ.N    ??MCPSDataRequest_6
    109            {
    110              return gErrorBusy_c;
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xE017             B.N      ??MCPSDataRequest_4
    111            }
    112            
    113            smacProccesPacketPtr.smacTxPacketPointer  = SmacFormatTxPacket(psTxPacket);
   \                     ??MCPSDataRequest_6: (+1)
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       SmacFormatTxPacket
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    114          
    115            u8PhyRes = PhyPdDataRequest(smacProccesPacketPtr.smacTxPacketPointer, gDataReq_NoAck_NoCca_Unslotted_c, NULL);
   \   0000005E   0x2200             MOVS     R2,#+0
   \   00000060   0x2101             MOVS     R1,#+1
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0x.... 0x....      BL       PhyPdDataRequest
   \   0000006C   0x0005             MOVS     R5,R0
    116          
    117            if(gPhySuccess_c == u8PhyRes)
   \   0000006E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000070   0x2D00             CMP      R5,#+0
   \   00000072   0xD105             BNE.N    ??MCPSDataRequest_7
    118            {
    119              smacState= mSmacStateTransmitting_c; 
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable27_1
   \   0000007A   0x7008             STRB     R0,[R1, #+0]
    120              return gErrorNoError_c;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xE000             B.N      ??MCPSDataRequest_4
    121            }
    122            else
    123            {
    124              return gErrorNoResourcesAvailable_c;
   \                     ??MCPSDataRequest_7: (+1)
   \   00000080   0x2003             MOVS     R0,#+3
   \                     ??MCPSDataRequest_4: (+1)
   \   00000082   0xBD70             POP      {R4-R6,PC}       ;; return
    125            }
    126          }
    127          
    128          
    129          /************************************************************************************
    130          * MLMERXEnableRequest
    131          * 
    132          * Function used to configure the radio into receive mode 
    133          *
    134          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    135          smacErrors_t MLMERXEnableRequest
    136          (
    137          rxPacket_t *gsRxPacket, /* OUT: Pointer to the structure where the reception results 
    138                                          will be store. */
    139          uint32_t u32Timeout     /* IN:  32-bit timeout value, this is directly the value that 
    140                                          is stored on the Radio's timer register.*/
    141          )
    142          {
   \                     MLMERXEnableRequest: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    143          
    144            uint8_t u8PhyRes = 0; 
   \   00000008   0x2600             MOVS     R6,#+0
    145            phyPacket_t * pAuxPacket;
    146          
    147          #if(TRUE == smacParametersValidation_d)
    148            uint8_t u8MaxLen=0;
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
    149          #endif
    150            
    151            if (mPromiscuousModeEnabled)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD004             BEQ.N    ??MLMERXEnableRequest_0
    152            {
    153          #if(TRUE == smacParametersValidation_d)
    154              u8MaxLen = gMaxPromiscuousSmacSDULength_c;
   \   0000001C   0x207D             MOVS     R0,#+125
   \   0000001E   0x4680             MOV      R8,R0
    155          #endif
    156              pAuxPacket = (phyPacket_t *)&gsRxPacket->smacPdu.reserved[1]; 
   \   00000020   0x1D20             ADDS     R0,R4,#+4
   \   00000022   0x0007             MOVS     R7,R0
   \   00000024   0xE003             B.N      ??MLMERXEnableRequest_1
    157            }
    158            else
    159            {
    160          #if(TRUE == smacParametersValidation_d)
    161              u8MaxLen = gMaxSmacSDULength_c;
   \                     ??MLMERXEnableRequest_0: (+1)
   \   00000026   0x207B             MOVS     R0,#+123
   \   00000028   0x4680             MOV      R8,R0
    162          #endif
    163              pAuxPacket = (phyPacket_t *)&gsRxPacket->u8DataLength; 
   \   0000002A   0x1CA0             ADDS     R0,R4,#+2
   \   0000002C   0x0007             MOVS     R7,R0
    164            }
    165            
    166          #if(TRUE == smacParametersValidation_d)
    167            if((NULL == gsRxPacket) || (u8MaxLen < gsRxPacket->u8MaxDataLength))
   \                     ??MLMERXEnableRequest_1: (+1)
   \   0000002E   0x2C00             CMP      R4,#+0
   \   00000030   0xD004             BEQ.N    ??MLMERXEnableRequest_2
   \   00000032   0x7820             LDRB     R0,[R4, #+0]
   \   00000034   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000038   0x4580             CMP      R8,R0
   \   0000003A   0xD201             BCS.N    ??MLMERXEnableRequest_3
    168            {
    169              return gErrorOutOfRange_c;
   \                     ??MLMERXEnableRequest_2: (+1)
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0xE040             B.N      ??MLMERXEnableRequest_4
    170            }
    171          #endif
    172            
    173          
    174          #if(TRUE == smacInitializationValidation_d)
    175           if(FALSE == mSmacInitialized)
   \                     ??MLMERXEnableRequest_3: (+1)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000044   0x7800             LDRB     R0,[R0, #+0]
   \   00000046   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD101             BNE.N    ??MLMERXEnableRequest_5
    176            {
    177              return gErrorNoValidCondition_c;
   \   00000050   0x2004             MOVS     R0,#+4
   \   00000052   0xE036             B.N      ??MLMERXEnableRequest_4
    178            }
    179          #endif
    180          
    181            if(mSmacStateIdle_c != smacState)
   \                     ??MLMERXEnableRequest_5: (+1)
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD001             BEQ.N    ??MLMERXEnableRequest_6
    182            {
    183              return gErrorBusy_c;
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xE02F             B.N      ??MLMERXEnableRequest_4
    184            }
    185            
    186            u8PhyRes = PhyPlmeRxRequest(pAuxPacket, &smacLastDataRxParams);
   \                     ??MLMERXEnableRequest_6: (+1)
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable27_3
   \   00000066   0x0038             MOVS     R0,R7
   \   00000068   0x.... 0x....      BL       PhyPlmeRxRequest
   \   0000006C   0x0006             MOVS     R6,R0
    187            
    188            if(gPhySuccess_c == u8PhyRes)
   \   0000006E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000070   0x2E00             CMP      R6,#+0
   \   00000072   0xD125             BNE.N    ??MLMERXEnableRequest_7
    189            {
    190              if(u32Timeout)
   \   00000074   0x2D00             CMP      R5,#+0
   \   00000076   0xD010             BEQ.N    ??MLMERXEnableRequest_8
    191              {
    192                smacTimeout = u32Timeout; 
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable27_4
   \   0000007C   0x6005             STR      R5,[R0, #+0]
    193                SmacSetRxTimeout((zbClock24_t)smacTimeout);
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable27_4
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x.... 0x....      BL       SmacSetRxTimeout
    194                mSmacTimeoutAsked = TRUE;
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable27
   \   0000008C   0x7800             LDRB     R0,[R0, #+0]
   \   0000008E   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable27
   \   00000096   0x7008             STRB     R0,[R1, #+0]
   \   00000098   0xE007             B.N      ??MLMERXEnableRequest_9
    195              } 
    196              else
    197              {
    198                mSmacTimeoutAsked = FALSE;
   \                     ??MLMERXEnableRequest_8: (+1)
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable27
   \   0000009E   0x7800             LDRB     R0,[R0, #+0]
   \   000000A0   0xF010 0x00EF      ANDS     R0,R0,#0xEF
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable27
   \   000000A8   0x7008             STRB     R0,[R1, #+0]
    199              }
    200          
    201              gsRxPacket->rxStatus = rxProcessingReceptionStatus_c;
   \                     ??MLMERXEnableRequest_9: (+1)
   \   000000AA   0x2001             MOVS     R0,#+1
   \   000000AC   0x7060             STRB     R0,[R4, #+1]
    202              smacProccesPacketPtr.smacRxPacketPointer  = gsRxPacket;
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   000000B2   0x6004             STR      R4,[R0, #+0]
    203          
    204              smacState= mSmacStateReceiving_c; 
   \   000000B4   0x2002             MOVS     R0,#+2
   \   000000B6   0x.... 0x....      LDR.W    R1,??DataTable27_1
   \   000000BA   0x7008             STRB     R0,[R1, #+0]
    205              return gErrorNoError_c;
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0xE000             B.N      ??MLMERXEnableRequest_4
    206            }
    207            else
    208            {
    209              return gErrorNoResourcesAvailable_c;
   \                     ??MLMERXEnableRequest_7: (+1)
   \   000000C0   0x2003             MOVS     R0,#+3
   \                     ??MLMERXEnableRequest_4: (+1)
   \   000000C2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    210            }
    211          }
    212          
    213          /************************************************************************************
    214          * MLMERXDisableRequest
    215          * 
    216          * Returns the radio to idle mode from receive mode.
    217          *
    218          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    219          smacErrors_t MLMERXDisableRequest(void)
    220          {
   \                     MLMERXDisableRequest: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    221          #if(TRUE == smacInitializationValidation_d)
    222           if(FALSE == mSmacInitialized)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD101             BNE.N    ??MLMERXDisableRequest_0
    223            {
    224              return gErrorNoValidCondition_c;
   \   00000012   0x2004             MOVS     R0,#+4
   \   00000014   0xE01A             B.N      ??MLMERXDisableRequest_1
    225            }
    226          #endif
    227           
    228            if((mSmacStateReceiving_c != smacState) && (mSmacStateIdle_c != smacState))
   \                     ??MLMERXDisableRequest_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2802             CMP      R0,#+2
   \   0000001E   0xD006             BEQ.N    ??MLMERXDisableRequest_2
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD001             BEQ.N    ??MLMERXDisableRequest_2
    229            {
    230              return gErrorNoValidCondition_c;
   \   0000002A   0x2004             MOVS     R0,#+4
   \   0000002C   0xE00E             B.N      ??MLMERXDisableRequest_1
    231            }
    232            
    233            PhyAbort();
   \                     ??MLMERXDisableRequest_2: (+1)
   \   0000002E   0x.... 0x....      BL       PhyAbort
    234            
    235            mSmacTimeoutAsked = FALSE;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0xF010 0x00EF      ANDS     R0,R0,#0xEF
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable27
   \   00000040   0x7008             STRB     R0,[R1, #+0]
    236            
    237            smacState= mSmacStateIdle_c;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable27_1
   \   00000048   0x7008             STRB     R0,[R1, #+0]
    238            return gErrorNoError_c;
   \   0000004A   0x2000             MOVS     R0,#+0
   \                     ??MLMERXDisableRequest_1: (+1)
   \   0000004C   0xBD02             POP      {R1,PC}          ;; return
    239          
    240          }
    241           
    242          
    243          /************************************************************************************
    244          * MLMELinkQuality
    245          * 
    246          * This  function  returns  an  integer  value  from 0 to 255
    247          *
    248          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    249          smacErrors_t MLMELinkQuality
    250          (
    251          uint8_t * u8LinkQuality /* OUT: Pointer to the variable where the Link Quality 
    252                                          will be store. */
    253          )
    254          {
   \                     MLMELinkQuality: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    255          #if(TRUE == smacInitializationValidation_d)
    256           if(FALSE == mSmacInitialized)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD101             BNE.N    ??MLMELinkQuality_0
    257            {
    258              return gErrorNoValidCondition_c;
   \   00000012   0x2004             MOVS     R0,#+4
   \   00000014   0xE004             B.N      ??MLMELinkQuality_1
    259            }
    260          #endif
    261           
    262            *(u8LinkQuality) = smacLastDataRxParams.linkQuality;
   \                     ??MLMELinkQuality_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \   0000001A   0x7900             LDRB     R0,[R0, #+4]
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
    263            
    264            return gErrorNoError_c;
   \   0000001E   0x2000             MOVS     R0,#+0
   \                     ??MLMELinkQuality_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return
    265          }
    266          
    267          
    268          
    269          /***********************************************************************************/
    270          /******************************** SMAC Radio primitives ****************************/
    271          /***********************************************************************************/
    272          
    273          /************************************************************************************
    274          * MLMERadioInit
    275          * 
    276          * This function initializes the Radio parameters.
    277          *
    278          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    279          smacErrors_t MLMERadioInit(void)
    280          {    
   \                     MLMERadioInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    281            /* Configure the transceiver IRQ_B port */  
    282            MC1324xDrv_IRQ_PortConfig();
   \   00000002   0x.... 0x....      BL       MC1324xDrv_IRQ_PortConfig
    283            
    284            /* Configure the transceiver RST_B port */ 
    285            MC1324xDrv_RST_B_PortConfig();
   \   00000006   0x.... 0x....      BL       MC1324xDrv_RST_B_PortConfig
    286            
    287            /* Transceiver Hard/RST_B RESET */
    288            MC1324xDrv_RST_B_Assert();
   \   0000000A   0x.... 0x....      BL       MC1324xDrv_RST_B_Assert
    289            delayMs(mRst_B_AssertTime_c);
   \   0000000E   0x2032             MOVS     R0,#+50
   \   00000010   0x.... 0x....      BL       delayMs
    290            MC1324xDrv_RST_B_Deassert();
   \   00000014   0x.... 0x....      BL       MC1324xDrv_RST_B_Deassert
    291            
    292            /* Wait for transceiver wakeup from POR iterrupt */
    293            while(!MC1324xDrv_IsIrqPending()){;};
   \                     ??MLMERadioInit_0: (+1)
   \   00000018   0x.... 0x....      BL       MC1324xDrv_IsIrqPending
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD0FB             BEQ.N    ??MLMERadioInit_0
    294            
    295             /* Enable transceiver SPI interrupt request */
    296            NVIC_EnableIRQ(MC1324x_Irq_Number);
   \   00000020   0x203C             MOVS     R0,#+60
   \   00000022   0x.... 0x....      BL       NVIC_EnableIRQ
    297            
    298            NVIC_SetPriority(MC1324x_Irq_Number, MC1324x_Irq_Priority);
   \   00000026   0x210A             MOVS     R1,#+10
   \   00000028   0x203C             MOVS     R0,#+60
   \   0000002A   0x.... 0x....      BL       NVIC_SetPriority
    299            
    300            /* Enable the transceiver IRQ_B interrupt request */
    301            MC1324xDrv_IRQ_Enable();
   \   0000002E   0x.... 0x....      BL       MC1324xDrv_IRQ_Enable
    302            
    303            MC1324xDrv_Set_CLK_OUT_Freq(gCLK_OUT_FREQ_4_MHz);
   \   00000032   0x2003             MOVS     R0,#+3
   \   00000034   0x.... 0x....      BL       MC1324xDrv_Set_CLK_OUT_Freq
    304            
    305            /* wait until the external reference clock is stable */    
    306              delayMs(mClkSwitchDelayTime_c);
   \   00000038   0x2032             MOVS     R0,#+50
   \   0000003A   0x.... 0x....      BL       delayMs
    307            
    308            #if ( (gTargetTWR_K60D100M_d == 1) || (gTargetTWR_K60N512_d == 1) )
    309            /* If target != mohave. disable transceiver CLK_OUT. */
    310            MC1324xDrv_Set_CLK_OUT_Freq(gCLK_OUT_FREQ_DISABLE); //TODO
    311            #endif
    312            
    313            /* Init MCU Clock*/
    314            MCU_InitClock();
   \   0000003E   0x.... 0x....      BL       MCU_InitClock
    315              
    316            PhyInit();
   \   00000042   0x.... 0x....      BL       PhyInit
    317            PhyPpSetPromiscuous(TRUE);
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x.... 0x....      BL       PhyPpSetPromiscuous
    318            
    319            smacCurrentChannel = gChannel11_c;
   \   0000004C   0x200B             MOVS     R0,#+11
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable27_5
   \   00000052   0x7008             STRB     R0,[R1, #+0]
    320            smacState= mSmacStateIdle_c;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable27_1
   \   0000005A   0x7008             STRB     R0,[R1, #+0]
    321            smacLastDataRxParams.linkQuality = 0;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable27_3
   \   00000062   0x7108             STRB     R0,[R1, #+4]
    322            smacLastDataRxParams.timeStamp = 0;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable27_3
   \   0000006A   0x6008             STR      R0,[R1, #+0]
    323            smacEdValue = 0;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable27_6
   \   00000072   0x7008             STRB     R0,[R1, #+0]
    324            smacClearestChann = gChannelOutOfRange_c; 
   \   00000074   0x201B             MOVS     R0,#+27
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable27_7
   \   0000007A   0x7008             STRB     R0,[R1, #+0]
    325            smacFlags.flags.flag0 = gPromiscuousMode_d;
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000080   0x7800             LDRB     R0,[R0, #+0]
   \   00000082   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable27
   \   0000008A   0x7008             STRB     R0,[R1, #+0]
    326            smacFlags.flags.flag1 = 0;
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000090   0x7800             LDRB     R0,[R0, #+0]
   \   00000092   0xF010 0x00FD      ANDS     R0,R0,#0xFD
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable27
   \   0000009A   0x7008             STRB     R0,[R1, #+0]
    327            smacFlags.flags.flag2 = 0;
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000000A0   0x7800             LDRB     R0,[R0, #+0]
   \   000000A2   0xF010 0x00FB      ANDS     R0,R0,#0xFB
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable27
   \   000000AA   0x7008             STRB     R0,[R1, #+0]
    328            smacFlags.flags.flag3 = 0;
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000000B0   0x7800             LDRB     R0,[R0, #+0]
   \   000000B2   0xF010 0x00F7      ANDS     R0,R0,#0xF7
   \   000000B6   0x.... 0x....      LDR.W    R1,??DataTable27
   \   000000BA   0x7008             STRB     R0,[R1, #+0]
    329            smacFlags.flags.flag4 = 0;
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000000C0   0x7800             LDRB     R0,[R0, #+0]
   \   000000C2   0xF010 0x00EF      ANDS     R0,R0,#0xEF
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable27
   \   000000CA   0x7008             STRB     R0,[R1, #+0]
    330            smacFlags.flags.flag5 = 0;
   \   000000CC   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000000D0   0x7800             LDRB     R0,[R0, #+0]
   \   000000D2   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable27
   \   000000DA   0x7008             STRB     R0,[R1, #+0]
    331            smacFlags.flags.flag6 = 0;
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000000E0   0x7800             LDRB     R0,[R0, #+0]
   \   000000E2   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable27
   \   000000EA   0x7008             STRB     R0,[R1, #+0]
    332            smacFlags.flags.flag7 = 0;
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000000F0   0x7800             LDRB     R0,[R0, #+0]
   \   000000F2   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   000000F6   0x.... 0x....      LDR.W    R1,??DataTable27
   \   000000FA   0x7008             STRB     R0,[R1, #+0]
    333            /* it means:
    334                        mPromiscuousModeEnabled = FALSE;
    335                        mSmacInitialized        = FALSE;
    336                        mSmacTimeoutAsked       = FALSE;
    337                        mSmacPerformingCCAScan  = FALSE;
    338                        mSmacPerformingEDScan   = FALSE;
    339                        mSmacPerformingED       = FALSE;
    340            */
    341                  
    342          #if(TRUE == smacInitializationValidation_d)
    343              mSmacInitialized = TRUE;  
   \   000000FC   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000100   0x7800             LDRB     R0,[R0, #+0]
   \   00000102   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000106   0x.... 0x....      LDR.W    R1,??DataTable27
   \   0000010A   0x7008             STRB     R0,[R1, #+0]
    344          #endif
    345              return gErrorNoError_c; 
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0xBD02             POP      {R1,PC}          ;; return
    346            
    347            
    348          }
    349          
    350          /************************************************************************************
    351          * MLMEDozeRequest
    352          * 
    353          * Doze request allow the user to put the radio either in Normal Doze Mode (without 
    354          * CLKO but with automatic wake up) or Acoma Doze Mode (with CLKout, but without 
    355          * timeout). 
    356          *
    357          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    358          smacErrors_t MLMEDozeRequest
    359          (
    360            uint32_t u32Timeout /* IN: Is the automatic wake up time for this mode.*/
    361          )
    362          {	
   \                     MLMEDozeRequest: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    363            if(mSmacStateIdle_c != smacState)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD001             BEQ.N    ??MLMEDozeRequest_0
    364            {
    365                return gErrorBusy_c;   /* The radio is busy in other activity as transmitting  
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE007             B.N      ??MLMEDozeRequest_1
    366                                            or receiving data. Or performing a channel scan*/
    367            }
    368                        
    369            PhyPlmeDozeRequest(u32Timeout);
   \                     ??MLMEDozeRequest_0: (+1)
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       PhyPlmeDozeRequest
    370            
    371            smacState = mSmacStateDoze_c;
   \   00000018   0x2006             MOVS     R0,#+6
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable27_1
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
    372            return gErrorNoError_c; /*The radio has been set in Doze Mode*/;
   \   00000020   0x2000             MOVS     R0,#+0
   \                     ??MLMEDozeRequest_1: (+1)
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    373            
    374          }
    375          
    376          /************************************************************************************
    377          * MLMEEnergyDetect
    378          * 
    379          * This call starts an energy detect(ED) cycle, it returns the energy value (-power)
    380          * via the returned argument. For example, if the Energy Detect returns 80 then the 
    381          * interpreted value is -80 dBm.
    382          *
    383          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    384          smacErrors_t MLMEEnergyDetect
    385          (
    386          uint8_t * u8EnergyValue /* OUT: Pointer to the variable where the Energy value 
    387                                          will be store. */
    388          )
    389          {
   \                     MLMEEnergyDetect: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    390          	
    391          #if(TRUE == smacInitializationValidation_d)
    392            if(FALSE == mSmacInitialized)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD101             BNE.N    ??MLMEEnergyDetect_0
    393            {
    394              return gErrorNoValidCondition_c;
   \   00000014   0x2004             MOVS     R0,#+4
   \   00000016   0xE026             B.N      ??MLMEEnergyDetect_1
    395            }
    396          #endif
    397          
    398            if(mSmacStateIdle_c != smacState)
   \                     ??MLMEEnergyDetect_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD001             BEQ.N    ??MLMEEnergyDetect_2
    399            {
    400              return gErrorBusy_c;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE01F             B.N      ??MLMEEnergyDetect_1
    401            }
    402            mSmacPerformingED = TRUE;
   \                     ??MLMEEnergyDetect_2: (+1)
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable27
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable27
   \   00000034   0x7008             STRB     R0,[R1, #+0]
    403            smacEdValue = 0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable27_6
   \   0000003C   0x7008             STRB     R0,[R1, #+0]
    404            
    405            if(PhyPlmeEdRequest())
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x.... 0x....      BL       PhyPlmeCcaEdRequest
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD001             BEQ.N    ??MLMEEnergyDetect_3
    406            {
    407              return gErrorNoValidCondition_c;
   \   00000048   0x2004             MOVS     R0,#+4
   \   0000004A   0xE00C             B.N      ??MLMEEnergyDetect_1
    408            }
    409            
    410            while(TRUE == mSmacPerformingED)
   \                     ??MLMEEnergyDetect_3: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000050   0x7800             LDRB     R0,[R0, #+0]
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000054   0x09C0             LSRS     R0,R0,#+7
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD1F7             BNE.N    ??MLMEEnergyDetect_3
    411            {
    412              /*Add a method to avoid blocking the system*/
    413            }
    414            *(u8EnergyValue) = smacEdValue;
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable27_6
   \   00000060   0x7800             LDRB     R0,[R0, #+0]
   \   00000062   0x7020             STRB     R0,[R4, #+0]
    415            
    416            return gErrorNoError_c;
   \   00000064   0x2000             MOVS     R0,#+0
   \                     ??MLMEEnergyDetect_1: (+1)
   \   00000066   0xBD10             POP      {R4,PC}          ;; return
    417          }
    418          
    419          /************************************************************************************
    420          * MLMEFEGainAdjust
    421          * 
    422          * This is a compensator for the energy detection and AGC. In case users need to 
    423          * calibrate the readings due to a specific application like an external low noise 
    424          * amplifier, this is where users can set the offset.
    425          *
    426          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    427          smacErrors_t MLMEFEGainAdjust
    428          (
    429            uint8_t u8GainValue /* IN: 8 bit value for the gain adjust.*/
    430          )
    431          {
   \                     MLMEFEGainAdjust: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    432            if(mSmacStateIdle_c != smacState)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD001             BEQ.N    ??MLMEFEGainAdjust_0
    433            {
    434              return gErrorBusy_c;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE004             B.N      ??MLMEFEGainAdjust_1
    435            }
    436            PhyAdjustCcaOffsetCmp(u8GainValue);
   \                     ??MLMEFEGainAdjust_0: (+1)
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x.... 0x....      BL       PhyAdjustCcaOffsetCmpReg
    437            
    438            return gErrorNoError_c;
   \   0000001A   0x2000             MOVS     R0,#+0
   \                     ??MLMEFEGainAdjust_1: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    439          }
    440          
    441          /************************************************************************************
    442          * MLMESetChannelRequest
    443          * 
    444          * This function sets the frequency on which the radio will transmit or receive on.
    445          *
    446          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    447          smacErrors_t MLMESetChannelRequest
    448          (
    449          channels_t newChannel /* IN: Enumeration value that represents the requested channel. */
    450          )
    451          {
   \                     MLMESetChannelRequest: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    452           uint8_t u8PhyRes;
    453          
    454          #if(TRUE == smacParametersValidation_d)
    455            if((gChannel11_c > newChannel) || (gChannel26_c < newChannel))
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C0B             CMP      R4,#+11
   \   00000008   0xDB02             BLT.N    ??MLMESetChannelRequest_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C1B             CMP      R4,#+27
   \   0000000E   0xDB01             BLT.N    ??MLMESetChannelRequest_1
    456            {
    457              return gErrorOutOfRange_c;
   \                     ??MLMESetChannelRequest_0: (+1)
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE028             B.N      ??MLMESetChannelRequest_2
    458            }
    459          #endif
    460          
    461          #if(TRUE == smacInitializationValidation_d)
    462            if(FALSE == mSmacInitialized)
   \                     ??MLMESetChannelRequest_1: (+1)
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD101             BNE.N    ??MLMESetChannelRequest_3
    463            {
    464              return gErrorNoValidCondition_c;
   \   00000024   0x2004             MOVS     R0,#+4
   \   00000026   0xE01E             B.N      ??MLMESetChannelRequest_2
    465            }
    466          #endif
    467          
    468            if((mSmacStateIdle_c != smacState) && (mSmacStatePerformingTest_c != smacState))
   \                     ??MLMESetChannelRequest_3: (+1)
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD006             BEQ.N    ??MLMESetChannelRequest_4
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0x2804             CMP      R0,#+4
   \   0000003A   0xD001             BEQ.N    ??MLMESetChannelRequest_4
    469            {
    470              return gErrorBusy_c;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xE012             B.N      ??MLMESetChannelRequest_2
    471            }
    472            
    473            u8PhyRes = PhyPlmeSetCurrentChannelRequest((uint8_t)newChannel);
   \                     ??MLMESetChannelRequest_4: (+1)
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0x.... 0x....      BL       PhyPlmeSetCurrentChannelRequestPAN0
   \   00000048   0x0005             MOVS     R5,R0
    474            MC1324xDrv_IRQ_Clear();
   \   0000004A   0x.... 0x....      BL       MC1324xDrv_IRQ_Clear
    475            NVIC_ClearPendingIRQ(MC1324x_Irq_Number);
   \   0000004E   0x203C             MOVS     R0,#+60
   \   00000050   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    476            
    477            if(!u8PhyRes)
   \   00000054   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000056   0x2D00             CMP      R5,#+0
   \   00000058   0xD104             BNE.N    ??MLMESetChannelRequest_5
    478            {
    479              smacCurrentChannel = newChannel;
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable27_5
   \   0000005E   0x7004             STRB     R4,[R0, #+0]
    480              return gErrorNoError_c;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xE000             B.N      ??MLMESetChannelRequest_2
    481            }
    482            else 
    483            {
    484              return gErrorNoResourcesAvailable_c;
   \                     ??MLMESetChannelRequest_5: (+1)
   \   00000064   0x2003             MOVS     R0,#+3
   \                     ??MLMESetChannelRequest_2: (+1)
   \   00000066   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    485            }
    486          }
    487          
    488          /************************************************************************************
    489          * MLMEGetChannelRequest
    490          * 
    491          * This function returns the current channel, if an error is detected it returns 
    492          * gChannelOutOfRange_c.
    493          *
    494          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    495          channels_t MLMEGetChannelRequest(void)
    496          {
    497          #if(TRUE == smacInitializationValidation_d)
    498            if(FALSE == mSmacInitialized)
   \                     MLMEGetChannelRequest: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD101             BNE.N    ??MLMEGetChannelRequest_0
    499            {
    500              return gChannelOutOfRange_c;
   \   00000010   0x201B             MOVS     R0,#+27
   \   00000012   0xE00E             B.N      ??MLMEGetChannelRequest_1
    501            }
    502          #endif
    503            if((gChannel11_c > smacCurrentChannel) || (gChannel26_c < smacCurrentChannel))
   \                     ??MLMEGetChannelRequest_0: (+1)
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable27_5
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x280B             CMP      R0,#+11
   \   0000001C   0xDB04             BLT.N    ??MLMEGetChannelRequest_2
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable27_5
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x281B             CMP      R0,#+27
   \   00000026   0xDB01             BLT.N    ??MLMEGetChannelRequest_3
    504            {
    505              return gChannelOutOfRange_c;
   \                     ??MLMEGetChannelRequest_2: (+1)
   \   00000028   0x201B             MOVS     R0,#+27
   \   0000002A   0xE002             B.N      ??MLMEGetChannelRequest_1
    506            }
    507            else
    508            {
    509              return smacCurrentChannel;
   \                     ??MLMEGetChannelRequest_3: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable27_5
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \                     ??MLMEGetChannelRequest_1: (+1)
   \   00000032   0x4770             BX       LR               ;; return
    510            }
    511          }
    512          
    513          /************************************************************************************
    514          * MLMEHibernateRequest
    515          * 
    516          * This call places the radio into Hibernate mode. 
    517          *
    518          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    519          smacErrors_t MLMEHibernateRequest(void)
    520          {
   \                     MLMEHibernateRequest: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    521           #if(TRUE == smacInitializationValidation_d)
    522            if(FALSE == mSmacInitialized)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD101             BNE.N    ??MLMEHibernateRequest_0
    523            {
    524              return gErrorNoValidCondition_c;
   \   00000012   0x2004             MOVS     R0,#+4
   \   00000014   0xE00D             B.N      ??MLMEHibernateRequest_1
    525            }
    526           #endif
    527          
    528            if(mSmacStateIdle_c != smacState)
   \                     ??MLMEHibernateRequest_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD001             BEQ.N    ??MLMEHibernateRequest_2
    529            {
    530              return gErrorBusy_c;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE006             B.N      ??MLMEHibernateRequest_1
    531            }
    532          
    533            PhyHibernateRequest();
   \                     ??MLMEHibernateRequest_2: (+1)
   \   00000024   0x.... 0x....      BL       PhyHibernateRequest
    534            
    535            smacState = mSmacStateHibernate_c;
   \   00000028   0x2005             MOVS     R0,#+5
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable27_1
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
    536            
    537            return gErrorNoError_c;
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??MLMEHibernateRequest_1: (+1)
   \   00000032   0xBD02             POP      {R1,PC}          ;; return
    538          }
    539          
    540          
    541          /************************************************************************************
    542          * MLMEPAOutputAdjust
    543          * 
    544          * This function adjusts the output power of the transmitter. 
    545          *
    546          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    547          smacErrors_t MLMEPAOutputAdjust
    548          (
    549          uint8_t u8PaValue /*IN: Value for the output power desired. Values 3-31 are required.*/
    550          )
    551          {    
   \                     MLMEPAOutputAdjust: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    552            uint8_t u8PhyRes;
    553          
    554          #if(TRUE == smacParametersValidation_d)
    555            if((gMaxOutputPower_c < u8PaValue) || (gMinOutputPower_c > u8PaValue))
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C20             CMP      R4,#+32
   \   00000008   0xDA02             BGE.N    ??MLMEPAOutputAdjust_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C03             CMP      R4,#+3
   \   0000000E   0xDA01             BGE.N    ??MLMEPAOutputAdjust_1
    556            {
    557              return gErrorOutOfRange_c;
   \                     ??MLMEPAOutputAdjust_0: (+1)
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE020             B.N      ??MLMEPAOutputAdjust_2
    558            }
    559          #endif
    560          
    561          #if(TRUE == smacInitializationValidation_d)
    562            if(FALSE == mSmacInitialized)
   \                     ??MLMEPAOutputAdjust_1: (+1)
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD101             BNE.N    ??MLMEPAOutputAdjust_3
    563            {
    564              return gErrorNoValidCondition_c;
   \   00000024   0x2004             MOVS     R0,#+4
   \   00000026   0xE016             B.N      ??MLMEPAOutputAdjust_2
    565            }
    566          #endif
    567          
    568            if((mSmacStateIdle_c != smacState) && (mSmacStatePerformingTest_c != smacState))
   \                     ??MLMEPAOutputAdjust_3: (+1)
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD006             BEQ.N    ??MLMEPAOutputAdjust_4
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0x2804             CMP      R0,#+4
   \   0000003A   0xD001             BEQ.N    ??MLMEPAOutputAdjust_4
    569            {
    570              return gErrorBusy_c;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xE00A             B.N      ??MLMEPAOutputAdjust_2
    571            }
    572            
    573            u8PhyRes = PhyPlmeSetPwrLevelRequest(u8PaValue);
   \                     ??MLMEPAOutputAdjust_4: (+1)
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0x.... 0x....      BL       PhyPlmeSetPwrLevelRequest
   \   00000048   0x0005             MOVS     R5,R0
    574            
    575            if(!u8PhyRes)
   \   0000004A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004C   0x2D00             CMP      R5,#+0
   \   0000004E   0xD101             BNE.N    ??MLMEPAOutputAdjust_5
    576            {
    577              return gErrorNoError_c;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xE000             B.N      ??MLMEPAOutputAdjust_2
    578            }
    579            else 
    580            {
    581              return gErrorNoResourcesAvailable_c;
   \                     ??MLMEPAOutputAdjust_5: (+1)
   \   00000054   0x2003             MOVS     R0,#+3
   \                     ??MLMEPAOutputAdjust_2: (+1)
   \   00000056   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    582            }
    583          }
    584          
    585          /************************************************************************************
    586          * MLMEPHYXtalAdjust
    587          * 
    588          * This function is used to adjust the radio reference clock by a trim value.
    589          *
    590          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    591          smacErrors_t MLMEXtalAdjust
    592          (
    593          uint8_t u8ReqValue /* IN: value representing the trim value to the oscillator.*/
    594          )
    595          {
   \                     MLMEXtalAdjust: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    596            if((mSmacStateIdle_c != smacState) && (mSmacStatePerformingTest_c != smacState))
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD006             BEQ.N    ??MLMEXtalAdjust_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2804             CMP      R0,#+4
   \   00000016   0xD001             BEQ.N    ??MLMEXtalAdjust_0
    597            {
    598              return gErrorBusy_c;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE004             B.N      ??MLMEXtalAdjust_1
    599            }
    600            
    601            PhyXtalAdjust(u8ReqValue);
   \                     ??MLMEXtalAdjust_0: (+1)
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x.... 0x....      BL       PhyXtalAdjust
    602            
    603            return gErrorNoError_c;
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??MLMEXtalAdjust_1: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    604          }
    605          
    606          /************************************************************************************
    607          * MLMESoftReset
    608          * 
    609          * This function performs a software reset on the radio,  PHY and SMAC state machines.
    610          *
    611          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    612          smacErrors_t MLMESoftReset(void)
    613          {
   \                     MLMESoftReset: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    614            PhyAbort();
   \   00000002   0x.... 0x....      BL       PhyAbort
    615            return MLMERadioInit();
   \   00000006   0x.... 0x....      BL       MLMERadioInit
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    616          }
    617          
    618          /************************************************************************************
    619          * MLMESetClockRate
    620          * 
    621          * This function is called to set the desired clock out from radio.
    622          *
    623          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    624          smacErrors_t MLMESetClockRate
    625          (
    626          clkoFrequency_t clkoFreq  /* IN: Enumeration value that represents radio clock out 
    627                                          frequency (CLKO). */ 
    628          )
    629          {
   \                     MLMESetClockRate: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    630            return (smacErrors_t)PhyPlmeSetClockOutRate(clkoFreq);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       PhyPlmeSetClockOutRateReg
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    631          }
    632          
    633          
    634          
    635          /************************************************************************************
    636          * MLMESetTmrPrescale
    637          * 
    638          * This function changes the rate aacollinst which the radio timers operate.
    639          *
    640          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    641          smacErrors_t MLMESetTmrPrescale
    642          (
    643          timerTimeBase_t TimeBase /*IN: enumeration value that represents that represents  
    644                                         timer prescale or time base.*/
    645          )
    646          {
   \                     MLMESetTmrPrescale: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    647          #if(TRUE == smacParametersValidation_d)
    648            if((gTimeBase500kHz_c > TimeBase) || (gTimeBase15p625kHz_c < TimeBase))
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C02             CMP      R4,#+2
   \   00000008   0xDB02             BLT.N    ??MLMESetTmrPrescale_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C08             CMP      R4,#+8
   \   0000000E   0xDB01             BLT.N    ??MLMESetTmrPrescale_1
    649            {
    650              return gErrorOutOfRange_c;
   \                     ??MLMESetTmrPrescale_0: (+1)
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE00F             B.N      ??MLMESetTmrPrescale_2
    651            }
    652          #endif
    653          
    654          #if(TRUE == smacInitializationValidation_d)
    655            if(FALSE == mSmacInitialized)
   \                     ??MLMESetTmrPrescale_1: (+1)
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD101             BNE.N    ??MLMESetTmrPrescale_3
    656            {
    657              return gErrorNoValidCondition_c;
   \   00000024   0x2004             MOVS     R0,#+4
   \   00000026   0xE005             B.N      ??MLMESetTmrPrescale_2
    658            }
    659          #endif
    660          
    661            (void)PhySetRadioTimerPrescaler((uint8_t)TimeBase);
   \                     ??MLMESetTmrPrescale_3: (+1)
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x.... 0x....      BL       PhySetRadioTimerPrescalerReg
   \   00000030   0x0001             MOVS     R1,R0
    662            return gErrorNoError_c;
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??MLMESetTmrPrescale_2: (+1)
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    663          }
    664          
    665          /************************************************************************************
    666          * MLMEWakeRequest
    667          * 
    668          * This primitive brings the radio out of low power mode.
    669          *
    670          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    671          smacErrors_t MLMEWakeRequest(void)
    672          {
   \                     MLMEWakeRequest: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    673          
    674             #if(TRUE == smacInitializationValidation_d)
    675            if(FALSE == mSmacInitialized)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD101             BNE.N    ??MLMEWakeRequest_0
    676            {
    677              return gErrorNoValidCondition_c;
   \   00000012   0x2004             MOVS     R0,#+4
   \   00000014   0xE00E             B.N      ??MLMEWakeRequest_1
    678            }
    679           #endif
    680          
    681            if (smacState == mSmacStateDoze_c || smacState == mSmacStateHibernate_c)
   \                     ??MLMEWakeRequest_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2806             CMP      R0,#+6
   \   0000001E   0xD004             BEQ.N    ??MLMEWakeRequest_2
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x2805             CMP      R0,#+5
   \   00000028   0xD103             BNE.N    ??MLMEWakeRequest_3
    682            {
    683                PhyWakeRequest();
   \                     ??MLMEWakeRequest_2: (+1)
   \   0000002A   0x.... 0x....      BL       PhyWakeRequest
    684                return gErrorNoError_c;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xE000             B.N      ??MLMEWakeRequest_1
    685            }
    686          
    687            return gErrorNoValidCondition_c;
   \                     ??MLMEWakeRequest_3: (+1)
   \   00000032   0x2004             MOVS     R0,#+4
   \                     ??MLMEWakeRequest_1: (+1)
   \   00000034   0xBD02             POP      {R1,PC}          ;; return
    688            
    689          }
    690          
    691          /************************************************************************************
    692          * XCVRContReset
    693          * 
    694          * This function asserts the reset line of the transceiver, shutting it down to its 
    695          * lowest power mode.
    696          *
    697          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    698          void XCVRContReset(void)
    699          {
   \                     XCVRContReset: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    700            MC1324xDrv_RST_B_Assert();
   \   00000002   0x.... 0x....      BL       MC1324xDrv_RST_B_Assert
    701          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    702          
    703          /************************************************************************************
    704          * XCVRRestart
    705          * 
    706          * This function deasserts the reset line, thus it power the transceiver up.
    707          *
    708          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    709          void XCVRRestart(void)
    710          {
   \                     XCVRRestart: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    711            MC1324xDrv_RST_B_Deassert();
   \   00000002   0x.... 0x....      BL       MC1324xDrv_RST_B_Deassert
    712          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    713          
    714          
    715          /***********************************************************************************/
    716          /***************************** SMAC management primitives **************************/
    717          /***********************************************************************************/
    718          
    719          /************************************************************************************
    720          * MLMEGetRficVersion
    721          * 
    722          * This function is used to read the version number of different hardware and software 
    723          * modules inside the SMAC platform.
    724          *
    725          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    726          smacErrors_t MLMEGetRficVersion
    727          (
    728          versionedEntity_t Entity, /* IN: The module for which the version is required. */
    729          uint8_t *Buffer           /* OUT: A pointer to the buffer where the version will be 
    730                                            written. */
    731          )
    732          {
   \                     MLMEGetRficVersion: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    733            uint8_t u8i;
    734          
    735          #if(TRUE == smacParametersValidation_d)
    736            if(gMaxVersionedEntity_c <= Entity){
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C02             CMP      R4,#+2
   \   0000000A   0xDB01             BLT.N    ??MLMEGetRficVersion_0
    737              return gErrorOutOfRange_c;
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE024             B.N      ??MLMEGetRficVersion_1
    738            }
    739          #endif
    740          
    741          #if(TRUE == smacInitializationValidation_d)
    742            if(FALSE == mSmacInitialized)
   \                     ??MLMEGetRficVersion_0: (+1)
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD101             BNE.N    ??MLMEGetRficVersion_2
    743            {
    744              return gErrorNoValidCondition_c;
   \   00000020   0x2004             MOVS     R0,#+4
   \   00000022   0xE01A             B.N      ??MLMEGetRficVersion_1
    745            }
    746          #endif
    747          
    748            if(mSmacStateIdle_c != smacState)
   \                     ??MLMEGetRficVersion_2: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD001             BEQ.N    ??MLMEGetRficVersion_3
    749            {
    750              return gErrorBusy_c;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xE013             B.N      ??MLMEGetRficVersion_1
    751            }
    752          
    753            if(gSwSmacVersion_c == Entity)
   \                     ??MLMEGetRficVersion_3: (+1)
   \   00000032   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000034   0x2C00             CMP      R4,#+0
   \   00000036   0xD10C             BNE.N    ??MLMEGetRficVersion_4
    754            {
    755              for(u8i=0; u8i < gSwSmacVersionLength_c; u8i++)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x0006             MOVS     R6,R0
   \                     ??MLMEGetRficVersion_5: (+1)
   \   0000003C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003E   0x2E07             CMP      R6,#+7
   \   00000040   0xDA0A             BGE.N    ??MLMEGetRficVersion_6
    756              {
    757                *Buffer++ = au8SmacVersion[u8i];
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable27_8
   \   00000046   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000048   0x5C30             LDRB     R0,[R6, R0]
   \   0000004A   0x7028             STRB     R0,[R5, #+0]
   \   0000004C   0x1C6D             ADDS     R5,R5,#+1
    758              }
   \   0000004E   0x1C76             ADDS     R6,R6,#+1
   \   00000050   0xE7F4             B.N      ??MLMEGetRficVersion_5
    759            }
    760            else
    761            {
    762             *Buffer = PhyGetRfIcVersion();    
   \                     ??MLMEGetRficVersion_4: (+1)
   \   00000052   0x.... 0x....      BL       PhyGetRfIcVersion
   \   00000056   0x7028             STRB     R0,[R5, #+0]
    763            }
    764          
    765            return gErrorNoError_c;
   \                     ??MLMEGetRficVersion_6: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??MLMEGetRficVersion_1: (+1)
   \   0000005A   0xBD70             POP      {R4-R6,PC}       ;; return
    766          }
    767          
    768          /************************************************************************************
    769          * MLMESetPromiscuousMode
    770          * 
    771          * This promiscous mode is different than PHY layer promiscous. 
    772          * SMAC appends 0xFF7E as the first two bytes of the packet to identify its own 
    773          * packets from other packets in the same PHY layer. When promiscuous mode is off 
    774          * SMAC filters the received packets and just allows those beginning with 0xFF7E; 
    775          * when promiscuous mode is on SMAC let pass all the messages beginning or not with
    776          * 0xFF7E. MLMESetPromiscuousMode allows setting or clearing the promiscuous mode. 
    777          *
    778          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    779          void MLMESetPromiscuousMode
    780          (
    781          bool_t isPromiscousMode /* IN: This is a boolean value that indicates if the promiscuous 
    782                                     mode is on (TRUE) or off (FALSE). */
    783          )
    784          {
    785             mPromiscuousModeEnabled = isPromiscousMode; 
   \                     MLMESetPromiscuousMode: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable27
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xF360 0x0100      BFI      R1,R0,#+0,#+1
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable27
   \   0000000E   0x7011             STRB     R1,[R2, #+0]
    786          }
   \   00000010   0x4770             BX       LR               ;; return
    787          
    788          /************************************************************************************
    789          * MLMEGetPromiscuousMode
    790          * 
    791          * This function returns the current state of promiscuous mode.
    792          *
    793          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    794          bool_t MLMEGetPromiscuousMode(void)
    795          {
    796            return mPromiscuousModeEnabled;
   \                     MLMEGetPromiscuousMode: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000000A   0x4770             BX       LR               ;; return
    797          }
    798          
    799          /************************************************************************************
    800          * MLMEScanRequest
    801          * 
    802          * This function scans the different channels using one out of two techniques and 
    803          * returns the amount of energy in all of the channels.
    804          *
    805          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    806          smacErrors_t MLMEScanRequest
    807          (
    808          uint16_t u16ChannelsToScan, /*IN: Bitmap of the Channels to be scanned.*/
    809          scanModes_t ScanMode,       /*IN: Technique to be used CCA or ED.*/
    810          uint8_t *pu8ChannelScan     /*OUT: The buffer where the values of the scan will be 
    811                                            returned. */
    812          )
    813          {
   \                     MLMEScanRequest: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    814          
    815            smacErrors_t scanRes;
    816          
    817          #if(TRUE == smacParametersValidation_d)
    818            if((0 == u16ChannelsToScan) || (gMaxScanMode_c <= ScanMode) || (NULL == pu8ChannelScan))
   \   00000008   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD004             BEQ.N    ??MLMEScanRequest_0
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x2D02             CMP      R5,#+2
   \   00000012   0xDA01             BGE.N    ??MLMEScanRequest_0
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD101             BNE.N    ??MLMEScanRequest_1
    819            {
    820              return gErrorOutOfRange_c;
   \                     ??MLMEScanRequest_0: (+1)
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xE056             B.N      ??MLMEScanRequest_2
    821            }
    822          #endif
    823          
    824          #if(TRUE == smacInitializationValidation_d)
    825            if(FALSE == mSmacInitialized)
   \                     ??MLMEScanRequest_1: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD101             BNE.N    ??MLMEScanRequest_3
    826            {
    827              return gErrorNoValidCondition_c;
   \   0000002C   0x2004             MOVS     R0,#+4
   \   0000002E   0xE04C             B.N      ??MLMEScanRequest_2
    828            }
    829          #endif
    830          
    831            if(mSmacStateIdle_c != smacState)
   \                     ??MLMEScanRequest_3: (+1)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD001             BEQ.N    ??MLMEScanRequest_4
    832            {
    833              return gErrorBusy_c;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xE045             B.N      ??MLMEScanRequest_2
    834            }
    835            
    836            smacChannelsBeingScanned = u16ChannelsToScan;
   \                     ??MLMEScanRequest_4: (+1)
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable27_9
   \   00000042   0x8004             STRH     R4,[R0, #+0]
    837            smacScanCurrentChannel   = gChannel11_c;
   \   00000044   0x200B             MOVS     R0,#+11
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable27_10
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
    838            smacClearestChann        = gChannel11_c;
   \   0000004C   0x200B             MOVS     R0,#+11
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable27_7
   \   00000052   0x7008             STRB     R0,[R1, #+0]
    839            smacProccesPacketPtr.smacScanResultsPointer = pu8ChannelScan;
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   00000058   0x6006             STR      R6,[R0, #+0]
    840            smacEdValue              = 0xFF;
   \   0000005A   0x20FF             MOVS     R0,#+255
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable27_6
   \   00000060   0x7008             STRB     R0,[R1, #+0]
    841            
    842            if(gScanModeED_c == ScanMode)
   \   00000062   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000064   0x2D01             CMP      R5,#+1
   \   00000066   0xD108             BNE.N    ??MLMEScanRequest_5
    843            {
    844              mSmacPerformingEDScan = TRUE;
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable27
   \   0000006C   0x7800             LDRB     R0,[R0, #+0]
   \   0000006E   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable27
   \   00000076   0x7008             STRB     R0,[R1, #+0]
   \   00000078   0xE007             B.N      ??MLMEScanRequest_6
    845            }
    846            else
    847            {
    848              mSmacPerformingCCAScan = TRUE;
   \                     ??MLMEScanRequest_5: (+1)
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable27
   \   0000007E   0x7800             LDRB     R0,[R0, #+0]
   \   00000080   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable27
   \   00000088   0x7008             STRB     R0,[R1, #+0]
    849            }
    850          
    851            smacState = mSmacStateScanningChannels_c; 
   \                     ??MLMEScanRequest_6: (+1)
   \   0000008A   0x2003             MOVS     R0,#+3
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable27_1
   \   00000090   0x7008             STRB     R0,[R1, #+0]
    852            scanRes = SmacScanTheNextChannel();
   \   00000092   0x.... 0x....      BL       SmacScanTheNextChannel
   \   00000096   0x0007             MOVS     R7,R0
    853            
    854            if(scanRes)
   \   00000098   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000009A   0x2F00             CMP      R7,#+0
   \   0000009C   0xD013             BEQ.N    ??MLMEScanRequest_7
    855            {
    856              smacState = mSmacStateIdle_c; 
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable27_1
   \   000000A4   0x7008             STRB     R0,[R1, #+0]
    857              mSmacPerformingEDScan  = FALSE;
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000000AA   0x7800             LDRB     R0,[R0, #+0]
   \   000000AC   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable27
   \   000000B4   0x7008             STRB     R0,[R1, #+0]
    858              mSmacPerformingCCAScan = FALSE;
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000000BA   0x7800             LDRB     R0,[R0, #+0]
   \   000000BC   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable27
   \   000000C4   0x7008             STRB     R0,[R1, #+0]
    859            }
    860            
    861            return scanRes;
   \                     ??MLMEScanRequest_7: (+1)
   \   000000C6   0x0038             MOVS     R0,R7
   \   000000C8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??MLMEScanRequest_2: (+1)
   \   000000CA   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    862          }
    863          
    864          /************************************************************************************
    865          * MLMETestMode
    866          * 
    867          * By employing this function, users can execute a test of the radio. Test mode 
    868          * implements the following:
    869          *   -PRBS9 Mode, 
    870          *   -Force_idle, 
    871          *   -Continuos TX without modulation, 
    872          *   -Continuos TX with modulation.
    873          *
    874          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    875          smacErrors_t MLMETestMode
    876          (
    877          smacTestMode_t  mode  /*IN: The test mode to start.*/
    878          )
    879          {
   \                     MLMETestMode: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    880            
    881          #if(TRUE == smacParametersValidation_d)
    882            if(gMaxTestMode_c <= mode)
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C04             CMP      R4,#+4
   \   00000008   0xDB01             BLT.N    ??MLMETestMode_0
    883            {
    884              return gErrorOutOfRange_c;
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE078             B.N      ??MLMETestMode_1
    885            }
    886          #endif
    887          
    888          #if(TRUE == smacInitializationValidation_d)
    889            if(FALSE == mSmacInitialized)
   \                     ??MLMETestMode_0: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD101             BNE.N    ??MLMETestMode_2
    890            {
    891              return gErrorNoValidCondition_c;
   \   0000001E   0x2004             MOVS     R0,#+4
   \   00000020   0xE06E             B.N      ??MLMETestMode_1
    892            }
    893          #endif
    894            
    895            if((mSmacStateIdle_c != smacState) && (mSmacStatePerformingTest_c != smacState))
   \                     ??MLMETestMode_2: (+1)
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD006             BEQ.N    ??MLMETestMode_3
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x2804             CMP      R0,#+4
   \   00000034   0xD001             BEQ.N    ??MLMETestMode_3
    896            {
    897              return gErrorBusy_c;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xE062             B.N      ??MLMETestMode_1
    898            }
    899          
    900            pTestPacket = (phyPacket_t*)&u8TestBuffer;
   \                     ??MLMETestMode_3: (+1)
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable27_11
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable27_12
   \   00000042   0x6008             STR      R0,[R1, #+0]
    901            
    902            smacState = mSmacStatePerformingTest_c;
   \   00000044   0x2004             MOVS     R0,#+4
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable27_1
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
    903            
    904            /* Disable Continuous Tx Mode */
    905            MC1324xDrv_IndirectAccessSPIWrite(TESTMODE_CTRL, 0x00);
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x20A3             MOVS     R0,#+163
   \   00000050   0x.... 0x....      BL       MC1324xDrv_IndirectAccessSPIWrite
    906            MC1324xDrv_IndirectAccessSPIWrite(TX_MODE_CTRL, 0x00);   
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x204E             MOVS     R0,#+78
   \   00000058   0x.... 0x....      BL       MC1324xDrv_IndirectAccessSPIWrite
    907            
    908            /* Abort Radio Sequences */
    909            PhyAbort(); 
   \   0000005C   0x.... 0x....      BL       PhyAbort
    910            
    911             
    912            if(gTestModeForceIdle_c == mode)
   \   00000060   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000062   0x2C00             CMP      R4,#+0
   \   00000064   0xD10C             BNE.N    ??MLMETestMode_4
    913            {
    914              mSmacPerformingPRBS9 = FALSE;
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable27
   \   0000006A   0x7800             LDRB     R0,[R0, #+0]
   \   0000006C   0xF010 0x00F7      ANDS     R0,R0,#0xF7
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable27
   \   00000074   0x7008             STRB     R0,[R1, #+0]
    915              smacState = mSmacStateIdle_c;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable27_1
   \   0000007C   0x7008             STRB     R0,[R1, #+0]
   \   0000007E   0xE03E             B.N      ??MLMETestMode_5
    916            }
    917             
    918            else if(gTestModeContinuousTxModulated_c == mode)
   \                     ??MLMETestMode_4: (+1)
   \   00000080   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000082   0x2C01             CMP      R4,#+1
   \   00000084   0xD10C             BNE.N    ??MLMETestMode_6
    919            {
    920              MC1324xDrv_IndirectAccessSPIWrite(TESTMODE_CTRL, 0x02);     //write_indirect(0xA3, 0x02);  TESTMODE_CTRL, CONTINUOUS_EN=1
   \   00000086   0x2102             MOVS     R1,#+2
   \   00000088   0x20A3             MOVS     R0,#+163
   \   0000008A   0x.... 0x....      BL       MC1324xDrv_IndirectAccessSPIWrite
    921              MC1324xDrv_IndirectAccessSPIWrite(TX_MODE_CTRL, 0x07);      //write_indirect(0x4E, 0x01);  TX_MODE_CTRL, DTS_MODE=ONES
   \   0000008E   0x2107             MOVS     R1,#+7
   \   00000090   0x204E             MOVS     R0,#+78
   \   00000092   0x.... 0x....      BL       MC1324xDrv_IndirectAccessSPIWrite
    922              MC1324xDrv_DirectAccessSPIWrite(PHY_CTRL1, 0x02);           //write_direct(0x03,0x02);     PHY_CTRL1, SEQUENCE T   
   \   00000096   0x2102             MOVS     R1,#+2
   \   00000098   0x2003             MOVS     R0,#+3
   \   0000009A   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
   \   0000009E   0xE02E             B.N      ??MLMETestMode_5
    923            } 
    924            
    925            else if(gTestModeContinuousTxUnmodulated_c == mode)
   \                     ??MLMETestMode_6: (+1)
   \   000000A0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A2   0x2C02             CMP      R4,#+2
   \   000000A4   0xD119             BNE.N    ??MLMETestMode_7
    926            {
    927              //MC1324xDrv_DirectAccessSPIMultiByteRead(PLL_FRAC0_LSB,au8TempPllFrac,2);
    928              //au8TempPllFrac[1] -= 0x04;
    929              //MC1324xDrv_DirectAccessSPIMultiByteWrite(PLL_FRAC0_LSB, au8TempPllFrac, 2);
    930              MC1324xDrv_DirectAccessSPIMultiByteWrite(PLL_FRAC0_LSB, (uint8_t *) &Local_pll_frac[smacCurrentChannel - 11], 2);
   \   000000A6   0x2202             MOVS     R2,#+2
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable27_13
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable27_5
   \   000000B0   0x7809             LDRB     R1,[R1, #+0]
   \   000000B2   0xEB10 0x0041      ADDS     R0,R0,R1, LSL #+1
   \   000000B6   0xF1B0 0x0116      SUBS     R1,R0,#+22
   \   000000BA   0x2021             MOVS     R0,#+33
   \   000000BC   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIMultiByteWrite
    931              
    932              MC1324xDrv_IndirectAccessSPIWrite(TESTMODE_CTRL, 0x02);     //write_indirect(0xA3, 0x02);  TESTMODE_CTRL, CONTINUOUS_EN=1
   \   000000C0   0x2102             MOVS     R1,#+2
   \   000000C2   0x20A3             MOVS     R0,#+163
   \   000000C4   0x.... 0x....      BL       MC1324xDrv_IndirectAccessSPIWrite
    933              MC1324xDrv_IndirectAccessSPIWrite(TX_MODE_CTRL, 0x01); 
   \   000000C8   0x2101             MOVS     R1,#+1
   \   000000CA   0x204E             MOVS     R0,#+78
   \   000000CC   0x.... 0x....      BL       MC1324xDrv_IndirectAccessSPIWrite
    934              MC1324xDrv_DirectAccessSPIWrite(PHY_CTRL1, 0x02);           //write_direct(0x03,0x02);     PHY_CTRL1, SEQUENCE T
   \   000000D0   0x2102             MOVS     R1,#+2
   \   000000D2   0x2003             MOVS     R0,#+3
   \   000000D4   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
   \   000000D8   0xE011             B.N      ??MLMETestMode_5
    935            } 
    936          
    937            else if(gTestModePRBS9_c == mode)
   \                     ??MLMETestMode_7: (+1)
   \   000000DA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000DC   0x2C03             CMP      R4,#+3
   \   000000DE   0xD10E             BNE.N    ??MLMETestMode_5
    938            {
    939              mSmacPerformingPRBS9 = TRUE;
   \   000000E0   0x.... 0x....      LDR.W    R0,??DataTable27
   \   000000E4   0x7800             LDRB     R0,[R0, #+0]
   \   000000E6   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   000000EA   0x.... 0x....      LDR.W    R1,??DataTable27
   \   000000EE   0x7008             STRB     R0,[R1, #+0]
    940              (void)PhyPdDataRequest(pTestPacket, gDataReq_NoAck_NoCca_Unslotted_c, NULL);
   \   000000F0   0x2200             MOVS     R2,#+0
   \   000000F2   0x2101             MOVS     R1,#+1
   \   000000F4   0x.... 0x....      LDR.W    R0,??DataTable27_12
   \   000000F8   0x6800             LDR      R0,[R0, #+0]
   \   000000FA   0x.... 0x....      BL       PhyPdDataRequest
    941            }
    942            return gErrorNoError_c;
   \                     ??MLMETestMode_5: (+1)
   \   000000FE   0x2000             MOVS     R0,#+0
   \                     ??MLMETestMode_1: (+1)
   \   00000100   0xBD10             POP      {R4,PC}          ;; return
    943          }
    944          
    945          
    946          
    947          
    948          /***********************************************************************************/
    949          /******************************** SMAC MCU primitives ******************************/
    950          /***********************************************************************************/
    951          
    952          
    953          /************************************************************************************
    954          * SMACEnableInterrupts
    955          * 
    956          * This function enables the interrupts that are used by SMAC.
    957          *
    958          ************************************************************************************/
    959          

   \                                 In section .text, align 2, keep-with-next
    960          void SMACEnableInterrupts(void)
    961          {
   \                     SMACEnableInterrupts: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    962            NVIC_EnableIRQ(Radio_Irq_Number);
   \   00000002   0x203C             MOVS     R0,#+60
   \   00000004   0x.... 0x....      BL       NVIC_EnableIRQ
    963          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    964          
    965          /************************************************************************************
    966          * SMACDisableInterrupts
    967          * 
    968          * This function disables the interrupts that are used by SMAC.
    969          *
    970          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    971          void SMACDisableInterrupts(void)
    972          {
   \                     SMACDisableInterrupts: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    973            NVIC_DisableIRQ(Radio_Irq_Number);
   \   00000002   0x203C             MOVS     R0,#+60
   \   00000004   0x.... 0x....      BL       NVIC_DisableIRQ
    974          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    975          
    976          
    977          /************************************************************************************
    978          *************************************************************************************
    979          * private functions
    980          *************************************************************************************
    981          ************************************************************************************/
    982          
    983          /***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    984          smacErrors_t SmacScanTheNextChannel(void)
    985          {
   \                     SmacScanTheNextChannel: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    986            uint8_t  u8PhyRes;
    987            uint16_t u16ChannelMask;
    988          
    989            /*Look for the next channel to scan*/
    990            u16ChannelMask = 0x0001 << (uint8_t)(smacScanCurrentChannel - gChannel11_c);
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable27_10
   \   00000008   0x7809             LDRB     R1,[R1, #+0]
   \   0000000A   0x390B             SUBS     R1,R1,#+11
   \   0000000C   0x4088             LSLS     R0,R0,R1
   \   0000000E   0x0005             MOVS     R5,R0
    991            while(!(u16ChannelMask & smacChannelsBeingScanned) && (u16ChannelMask))
   \                     ??SmacScanTheNextChannel_0: (+1)
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable27_9
   \   00000014   0x8800             LDRH     R0,[R0, #+0]
   \   00000016   0x4205             TST      R5,R0
   \   00000018   0xD10B             BNE.N    ??SmacScanTheNextChannel_1
   \   0000001A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD008             BEQ.N    ??SmacScanTheNextChannel_1
    992            {
    993              smacScanCurrentChannel++;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable27_10
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x1C40             ADDS     R0,R0,#+1
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable27_10
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
    994              u16ChannelMask<<=1;
   \   0000002E   0x006D             LSLS     R5,R5,#+1
   \   00000030   0xE7EE             B.N      ??SmacScanTheNextChannel_0
    995            }
    996          
    997            if(gTotalChannels_c == smacScanCurrentChannel)
   \                     ??SmacScanTheNextChannel_1: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable27_10
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0x281B             CMP      R0,#+27
   \   0000003A   0xD101             BNE.N    ??SmacScanTheNextChannel_2
    998            {
    999              return gErrorOutOfRange_c;
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0xE01A             B.N      ??SmacScanTheNextChannel_3
   1000            }
   1001            else
   1002            {
   1003              u8PhyRes = PhyPlmeSetCurrentChannelRequest(smacScanCurrentChannel);
   \                     ??SmacScanTheNextChannel_2: (+1)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable27_10
   \   00000044   0x7800             LDRB     R0,[R0, #+0]
   \   00000046   0x.... 0x....      BL       PhyPlmeSetCurrentChannelRequestPAN0
   \   0000004A   0x0004             MOVS     R4,R0
   1004              if(!u8PhyRes)
   \   0000004C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004E   0x2C00             CMP      R4,#+0
   \   00000050   0xD10F             BNE.N    ??SmacScanTheNextChannel_4
   1005              {
   1006                if(mSmacPerformingEDScan)
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0xF3C0 0x1080      UBFX     R0,R0,#+6,#+1
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD003             BEQ.N    ??SmacScanTheNextChannel_5
   1007                {
   1008                  return (smacErrors_t)PhyPlmeEdRequest();
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x.... 0x....      BL       PhyPlmeCcaEdRequest
   \   00000068   0xE005             B.N      ??SmacScanTheNextChannel_3
   1009                }
   1010                else
   1011                {
   1012                  return (smacErrors_t)PhyPlmeCcaRequest(gCcaCCA_MODE1_c);
   \                     ??SmacScanTheNextChannel_5: (+1)
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0x.... 0x....      BL       PhyPlmeCcaEdRequest
   \   00000070   0xE001             B.N      ??SmacScanTheNextChannel_3
   1013                }
   1014              }
   1015              else 
   1016              {
   1017                return (smacErrors_t)u8PhyRes;
   \                     ??SmacScanTheNextChannel_4: (+1)
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??SmacScanTheNextChannel_3: (+1)
   \   00000076   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1018              }
   1019            }
   1020          }
   1021           
   1022          /*********************************************************/

   \                                 In section .text, align 2, keep-with-next
   1023          void SmacSetRxTimeout(zbClock24_t timeoutSymbols)
   1024          {
   \                     SmacSetRxTimeout: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   1025            zbClock24_t time;
   1026            PhyTimeReadClock(&time);
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x.... 0x....      BL       PhyTimeReadClock
   1027            time += timeoutSymbols + 4;
   \   0000000C   0x9800             LDR      R0,[SP, #+0]
   \   0000000E   0x1D21             ADDS     R1,R4,#+4
   \   00000010   0x1808             ADDS     R0,R1,R0
   \   00000012   0x9000             STR      R0,[SP, #+0]
   1028            PhyTimeSetEventTimeout(&time);
   \   00000014   0xA800             ADD      R0,SP,#+0
   \   00000016   0x.... 0x....      BL       PhyTimeSetEventTimeout
   1029          }
   \   0000001A   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1030          
   1031          /*********************************************************/

   \                                 In section .text, align 2, keep-with-next
   1032          phyPacket_t * SmacFormatTxPacket(txPacket_t *psTxPacket)
   1033          {
   \                     SmacFormatTxPacket: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1034            phyPacket_t * packetToPhy;
   1035            
   1036            packetToPhy = (phyPacket_t *)psTxPacket;
   \   00000002   0x0008             MOVS     R0,R1
   1037          
   1038            if(FALSE == mPromiscuousModeEnabled)
   \   00000004   0x....             LDR.N    R2,??DataTable27
   \   00000006   0x7812             LDRB     R2,[R2, #+0]
   \   00000008   0xF012 0x0201      ANDS     R2,R2,#0x1
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xD108             BNE.N    ??SmacFormatTxPacket_0
   1039            {
   1040              packetToPhy = (phyPacket_t *)psTxPacket;
   \   00000010   0x0008             MOVS     R0,R1
   1041              packetToPhy->frameLength += 2; //Add 2 for Code bytes
   \   00000012   0x7802             LDRB     R2,[R0, #+0]
   \   00000014   0x1C92             ADDS     R2,R2,#+2
   \   00000016   0x7002             STRB     R2,[R0, #+0]
   1042              packetToPhy->data[0] = 0x7E;
   \   00000018   0x227E             MOVS     R2,#+126
   \   0000001A   0x7042             STRB     R2,[R0, #+1]
   1043              packetToPhy->data[1] = 0xFF;
   \   0000001C   0x22FF             MOVS     R2,#+255
   \   0000001E   0x7082             STRB     R2,[R0, #+2]
   \   00000020   0xE003             B.N      ??SmacFormatTxPacket_1
   1044            }
   1045            else
   1046            {
   1047              packetToPhy = (phyPacket_t *)&psTxPacket->smacPdu.reserved[1];
   \                     ??SmacFormatTxPacket_0: (+1)
   \   00000022   0x1C8A             ADDS     R2,R1,#+2
   \   00000024   0x0010             MOVS     R0,R2
   1048              packetToPhy->frameLength = psTxPacket->u8DataLength;
   \   00000026   0x780A             LDRB     R2,[R1, #+0]
   \   00000028   0x7002             STRB     R2,[R0, #+0]
   1049            }
   1050            
   1051            packetToPhy->frameLength += 2; //Add 2 for FCS
   \                     ??SmacFormatTxPacket_1: (+1)
   \   0000002A   0x7802             LDRB     R2,[R0, #+0]
   \   0000002C   0x1C92             ADDS     R2,R2,#+2
   \   0000002E   0x7002             STRB     R2,[R0, #+0]
   1052            
   1053            return packetToPhy;
   \   00000030   0x4770             BX       LR               ;; return
   1054          }
   1055           
   1056            
   1057             
   1058          /***********************************************************************************/
   1059          /****************************** PHY Callback Functions *****************************/
   1060          /***********************************************************************************/
   1061          /***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1062          void PhyPdDataConfirm(void)
   1063          {
   \                     PhyPdDataConfirm: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1064            if(mSmacStateTransmitting_c == smacState)
   \   00000002   0x....             LDR.N    R0,??DataTable27_1
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD111             BNE.N    ??PhyPdDataConfirm_0
   1065            {
   1066              if(!mPromiscuousModeEnabled){
   \   0000000A   0x....             LDR.N    R0,??DataTable27
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD104             BNE.N    ??PhyPdDataConfirm_1
   1067                smacProccesPacketPtr.smacTxPacketPointer->frameLength-=2;
   \   00000016   0x....             LDR.N    R0,??DataTable27_2
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x7801             LDRB     R1,[R0, #+0]
   \   0000001C   0x1E89             SUBS     R1,R1,#+2
   \   0000001E   0x7001             STRB     R1,[R0, #+0]
   1068              }
   1069              MCPSDataConfirm(txSuccessStatus_c);
   \                     ??PhyPdDataConfirm_1: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      BL       MCPSDataConfirm
   1070              smacState= mSmacStateIdle_c;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x....             LDR.N    R1,??DataTable27_1
   \   0000002A   0x7008             STRB     R0,[R1, #+0]
   \   0000002C   0xE013             B.N      ??PhyPdDataConfirm_2
   1071            }
   1072            else if(mSmacStatePerformingTest_c == smacState)
   \                     ??PhyPdDataConfirm_0: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable27_1
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x2804             CMP      R0,#+4
   \   00000034   0xD10F             BNE.N    ??PhyPdDataConfirm_2
   1073            {
   1074              if(TRUE == mSmacPerformingPRBS9)
   \   00000036   0x....             LDR.N    R0,??DataTable27
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0xF3C0 0x00C0      UBFX     R0,R0,#+3,#+1
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD008             BEQ.N    ??PhyPdDataConfirm_2
   1075              {
   1076                delayMs(9);
   \   00000044   0x2009             MOVS     R0,#+9
   \   00000046   0x.... 0x....      BL       delayMs
   1077                (void)PhyPdDataRequest(pTestPacket, gDataReq_NoAck_NoCca_Unslotted_c, NULL);
   \   0000004A   0x2200             MOVS     R2,#+0
   \   0000004C   0x2101             MOVS     R1,#+1
   \   0000004E   0x....             LDR.N    R0,??DataTable27_12
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x.... 0x....      BL       PhyPdDataRequest
   1078              }
   1079            }
   1080          }
   \                     ??PhyPdDataConfirm_2: (+1)
   \   00000056   0xBD01             POP      {R0,PC}          ;; return
   1081          
   1082          
   1083          /***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1084          void PhyPdDataIndication(void)
   1085          {
   \                     PhyPdDataIndication: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1086            uint8_t  u8PhyRes;
   1087          
   1088            if(!mPromiscuousModeEnabled){
   \   00000002   0x....             LDR.N    R0,??DataTable27
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD105             BNE.N    ??PhyPdDataIndication_0
   1089              smacProccesPacketPtr.smacRxPacketPointer->u8DataLength-=2;
   \   0000000E   0x....             LDR.N    R0,??DataTable27_2
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x7881             LDRB     R1,[R0, #+2]
   \   00000014   0x1E89             SUBS     R1,R1,#+2
   \   00000016   0x7081             STRB     R1,[R0, #+2]
   \   00000018   0xE005             B.N      ??PhyPdDataIndication_1
   1090          	}
   1091            else
   1092            {
   1093              smacProccesPacketPtr.smacRxPacketPointer->u8DataLength = ((smacProccesPacketPtr.smacRxPacketPointer->smacPdu.reserved[1]));
   \                     ??PhyPdDataIndication_0: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable27_2
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x....             LDR.N    R1,??DataTable27_2
   \   00000020   0x6809             LDR      R1,[R1, #+0]
   \   00000022   0x7909             LDRB     R1,[R1, #+4]
   \   00000024   0x7081             STRB     R1,[R0, #+2]
   1094            }
   1095            
   1096            if( ((!mPromiscuousModeEnabled) && (FALSE == areCodeBytesValid(smacProccesPacketPtr.smacRxPacketPointer)) )||
   1097              (smacProccesPacketPtr.smacRxPacketPointer->u8DataLength > smacProccesPacketPtr.smacRxPacketPointer->u8MaxDataLength))
   \                     ??PhyPdDataIndication_1: (+1)
   \   00000026   0x....             LDR.N    R0,??DataTable27
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD10F             BNE.N    ??PhyPdDataIndication_2
   \   00000032   0x....             LDR.N    R0,??DataTable27_2
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x78C0             LDRB     R0,[R0, #+3]
   \   00000038   0x287E             CMP      R0,#+126
   \   0000003A   0xD106             BNE.N    ??PhyPdDataIndication_3
   \   0000003C   0x....             LDR.N    R0,??DataTable27_2
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x7900             LDRB     R0,[R0, #+4]
   \   00000042   0x28FF             CMP      R0,#+255
   \   00000044   0xD101             BNE.N    ??PhyPdDataIndication_3
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xE000             B.N      ??PhyPdDataIndication_4
   \                     ??PhyPdDataIndication_3: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \                     ??PhyPdDataIndication_4: (+1)
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD007             BEQ.N    ??PhyPdDataIndication_5
   \                     ??PhyPdDataIndication_2: (+1)
   \   00000052   0x....             LDR.N    R0,??DataTable27_2
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0x....             LDR.N    R1,??DataTable27_2
   \   0000005A   0x6809             LDR      R1,[R1, #+0]
   \   0000005C   0x7889             LDRB     R1,[R1, #+2]
   \   0000005E   0x4288             CMP      R0,R1
   \   00000060   0xD223             BCS.N    ??PhyPdDataIndication_6
   1098            {
   1099              u8PhyRes = PhyPlmeRxRequest((phyPacket_t *)&(smacProccesPacketPtr.smacRxPacketPointer->u8DataLength), &smacLastDataRxParams);
   \                     ??PhyPdDataIndication_5: (+1)
   \   00000062   0x....             LDR.N    R1,??DataTable27_3
   \   00000064   0x....             LDR.N    R0,??DataTable27_2
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0x1C80             ADDS     R0,R0,#+2
   \   0000006A   0x.... 0x....      BL       PhyPlmeRxRequest
   \   0000006E   0x0004             MOVS     R4,R0
   1100              if(!u8PhyRes){
   \   00000070   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000072   0x2C00             CMP      R4,#+0
   \   00000074   0xD10B             BNE.N    ??PhyPdDataIndication_7
   1101                if(mSmacTimeoutAsked)
   \   00000076   0x....             LDR.N    R0,??DataTable27
   \   00000078   0x7800             LDRB     R0,[R0, #+0]
   \   0000007A   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \   0000007E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD01F             BEQ.N    ??PhyPdDataIndication_8
   1102                {
   1103                  SmacSetRxTimeout((zbClock24_t)smacTimeout);
   \   00000084   0x....             LDR.N    R0,??DataTable27_4
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x.... 0x....      BL       SmacSetRxTimeout
   \   0000008C   0xE01A             B.N      ??PhyPdDataIndication_8
   1104                }
   1105              }else{
   1106                smacProccesPacketPtr.smacRxPacketPointer->rxStatus = rxAbortedStatus_c;
   \                     ??PhyPdDataIndication_7: (+1)
   \   0000008E   0x2004             MOVS     R0,#+4
   \   00000090   0x....             LDR.N    R1,??DataTable27_2
   \   00000092   0x6809             LDR      R1,[R1, #+0]
   \   00000094   0x7048             STRB     R0,[R1, #+1]
   1107                PhyTimeDisableEventTimeout();
   \   00000096   0x.... 0x....      BL       PhyTimeDisableEventTimeout
   1108                MCPSDataIndication(smacProccesPacketPtr.smacRxPacketPointer);
   \   0000009A   0x....             LDR.N    R0,??DataTable27_2
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0x.... 0x....      BL       MCPSDataIndication
   1109                smacState = mSmacStateIdle_c;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x....             LDR.N    R1,??DataTable27_1
   \   000000A6   0x7008             STRB     R0,[R1, #+0]
   \   000000A8   0xE00C             B.N      ??PhyPdDataIndication_8
   1110              }
   1111            }
   1112            else
   1113            {
   1114                smacProccesPacketPtr.smacRxPacketPointer->rxStatus = rxSuccessStatus_c;
   \                     ??PhyPdDataIndication_6: (+1)
   \   000000AA   0x2002             MOVS     R0,#+2
   \   000000AC   0x....             LDR.N    R1,??DataTable27_2
   \   000000AE   0x6809             LDR      R1,[R1, #+0]
   \   000000B0   0x7048             STRB     R0,[R1, #+1]
   1115                PhyTimeDisableEventTimeout();
   \   000000B2   0x.... 0x....      BL       PhyTimeDisableEventTimeout
   1116                MCPSDataIndication(smacProccesPacketPtr.smacRxPacketPointer);
   \   000000B6   0x....             LDR.N    R0,??DataTable27_2
   \   000000B8   0x6800             LDR      R0,[R0, #+0]
   \   000000BA   0x.... 0x....      BL       MCPSDataIndication
   1117                smacState= mSmacStateIdle_c;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x....             LDR.N    R1,??DataTable27_1
   \   000000C2   0x7008             STRB     R0,[R1, #+0]
   1118            }
   1119          }
   \                     ??PhyPdDataIndication_8: (+1)
   \   000000C4   0xBD10             POP      {R4,PC}          ;; return
   1120          
   1121          /***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1122          void PhyPlmeCcaConfirm(bool_t channelInUse)
   1123          {
   \                     PhyPlmeCcaConfirm: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1124            smacErrors_t scanRes;
   1125            smacProccesPacketPtr.smacScanResultsPointer[smacScanCurrentChannel - gChannel11_c] = channelInUse;
   \   00000004   0x....             LDR.N    R0,??DataTable27_2
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x....             LDR.N    R1,??DataTable27_10
   \   0000000A   0x7809             LDRB     R1,[R1, #+0]
   \   0000000C   0x1808             ADDS     R0,R1,R0
   \   0000000E   0xF800 0x4C0B      STRB     R4,[R0, #-11]
   1126            smacScanCurrentChannel++;
   \   00000012   0x....             LDR.N    R0,??DataTable27_10
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0x....             LDR.N    R1,??DataTable27_10
   \   0000001A   0x7008             STRB     R0,[R1, #+0]
   1127            scanRes = SmacScanTheNextChannel();
   \   0000001C   0x.... 0x....      BL       SmacScanTheNextChannel
   \   00000020   0x0005             MOVS     R5,R0
   1128            
   1129            if(scanRes)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD014             BEQ.N    ??PhyPlmeCcaConfirm_0
   1130            {
   1131              smacClearestChann = gChannelOutOfRange_c; 
   \   00000028   0x201B             MOVS     R0,#+27
   \   0000002A   0x....             LDR.N    R1,??DataTable27_7
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
   1132              (void)PhyPlmeSetCurrentChannelRequest(smacCurrentChannel);
   \   0000002E   0x....             LDR.N    R0,??DataTable27_5
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x.... 0x....      BL       PhyPlmeSetCurrentChannelRequestPAN0
   \   00000036   0x0006             MOVS     R6,R0
   1133              MLMEScanConfirm(smacClearestChann);
   \   00000038   0x....             LDR.N    R0,??DataTable27_7
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x.... 0x....      BL       MLMEScanConfirm
   1134              mSmacPerformingCCAScan = FALSE;
   \   00000040   0x....             LDR.N    R0,??DataTable27
   \   00000042   0x7800             LDRB     R0,[R0, #+0]
   \   00000044   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   00000048   0x....             LDR.N    R1,??DataTable27
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
   1135              smacState= mSmacStateIdle_c;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x....             LDR.N    R1,??DataTable27_1
   \   00000050   0x7008             STRB     R0,[R1, #+0]
   1136            }
   1137          }
   \                     ??PhyPlmeCcaConfirm_0: (+1)
   \   00000052   0xBD70             POP      {R4-R6,PC}       ;; return
   1138          
   1139          /***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1140          void PhyPlmeEdConfirm(uint8_t energyLevel)
   1141          {
   \                     PhyPlmeEdConfirm: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1142            smacErrors_t scanRes;
   1143            
   1144            if(mSmacPerformingED)
   \   00000004   0x....             LDR.N    R0,??DataTable27
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x09C0             LSRS     R0,R0,#+7
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD008             BEQ.N    ??PhyPlmeEdConfirm_0
   1145            {
   1146              smacEdValue = energyLevel; 
   \   00000012   0x....             LDR.N    R0,??DataTable27_6
   \   00000014   0x7004             STRB     R4,[R0, #+0]
   1147              mSmacPerformingED = FALSE;
   \   00000016   0x....             LDR.N    R0,??DataTable27
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   0000001E   0x....             LDR.N    R1,??DataTable27
   \   00000020   0x7008             STRB     R0,[R1, #+0]
   \   00000022   0xE034             B.N      ??PhyPlmeEdConfirm_1
   1148            }
   1149            else if(mSmacPerformingEDScan)
   \                     ??PhyPlmeEdConfirm_0: (+1)
   \   00000024   0x....             LDR.N    R0,??DataTable27
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0xF3C0 0x1080      UBFX     R0,R0,#+6,#+1
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD02D             BEQ.N    ??PhyPlmeEdConfirm_1
   1150            {
   1151              if(energyLevel < smacEdValue)
   \   00000032   0x....             LDR.N    R0,??DataTable27_6
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD205             BCS.N    ??PhyPlmeEdConfirm_2
   1152              {
   1153                smacEdValue = energyLevel;
   \   0000003C   0x....             LDR.N    R0,??DataTable27_6
   \   0000003E   0x7004             STRB     R4,[R0, #+0]
   1154                smacClearestChann = smacScanCurrentChannel;
   \   00000040   0x....             LDR.N    R0,??DataTable27_10
   \   00000042   0x7800             LDRB     R0,[R0, #+0]
   \   00000044   0x....             LDR.N    R1,??DataTable27_7
   \   00000046   0x7008             STRB     R0,[R1, #+0]
   1155              }
   1156              smacProccesPacketPtr.smacScanResultsPointer[smacScanCurrentChannel - gChannel11_c] = energyLevel;//energyLevel/2; 
   \                     ??PhyPlmeEdConfirm_2: (+1)
   \   00000048   0x....             LDR.N    R0,??DataTable27_2
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x....             LDR.N    R1,??DataTable27_10
   \   0000004E   0x7809             LDRB     R1,[R1, #+0]
   \   00000050   0x1808             ADDS     R0,R1,R0
   \   00000052   0xF800 0x4C0B      STRB     R4,[R0, #-11]
   1157              smacScanCurrentChannel++;
   \   00000056   0x....             LDR.N    R0,??DataTable27_10
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x1C40             ADDS     R0,R0,#+1
   \   0000005C   0x....             LDR.N    R1,??DataTable27_10
   \   0000005E   0x7008             STRB     R0,[R1, #+0]
   1158              scanRes = SmacScanTheNextChannel();
   \   00000060   0x.... 0x....      BL       SmacScanTheNextChannel
   \   00000064   0x0005             MOVS     R5,R0
   1159              
   1160              if(scanRes)
   \   00000066   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000068   0x2D00             CMP      R5,#+0
   \   0000006A   0xD010             BEQ.N    ??PhyPlmeEdConfirm_1
   1161              {
   1162                MLMEScanConfirm(smacClearestChann);
   \   0000006C   0x....             LDR.N    R0,??DataTable27_7
   \   0000006E   0x7800             LDRB     R0,[R0, #+0]
   \   00000070   0x.... 0x....      BL       MLMEScanConfirm
   1163                (void)PhyPlmeSetCurrentChannelRequest(smacCurrentChannel);
   \   00000074   0x....             LDR.N    R0,??DataTable27_5
   \   00000076   0x7800             LDRB     R0,[R0, #+0]
   \   00000078   0x.... 0x....      BL       PhyPlmeSetCurrentChannelRequestPAN0
   1164                mSmacPerformingEDScan  = FALSE;
   \   0000007C   0x....             LDR.N    R1,??DataTable27
   \   0000007E   0x7809             LDRB     R1,[R1, #+0]
   \   00000080   0xF011 0x01BF      ANDS     R1,R1,#0xBF
   \   00000084   0x....             LDR.N    R2,??DataTable27
   \   00000086   0x7011             STRB     R1,[R2, #+0]
   1165                smacState= mSmacStateIdle_c;
   \   00000088   0x2100             MOVS     R1,#+0
   \   0000008A   0x....             LDR.N    R2,??DataTable27_1
   \   0000008C   0x7011             STRB     R1,[R2, #+0]
   1166              }
   1167            }
   1168          }
   \                     ??PhyPlmeEdConfirm_1: (+1)
   \   0000008E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1169          
   1170          /***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1171          void PhyPlmeSyncLossIndication(void)
   1172          {
   \                     PhyPlmeSyncLossIndication: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1173            uint8_t  u8PhyRes;
   1174            if(mSmacStateReceiving_c == smacState)
   \   00000002   0x....             LDR.N    R0,??DataTable27_1
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD117             BNE.N    ??PhyPlmeSyncLossIndication_0
   1175            {
   1176              u8PhyRes = PhyPlmeRxRequest((phyPacket_t *)&(smacProccesPacketPtr.smacRxPacketPointer->u8DataLength), &smacLastDataRxParams);
   \   0000000A   0x....             LDR.N    R1,??DataTable27_3
   \   0000000C   0x....             LDR.N    R0,??DataTable27_2
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x1C80             ADDS     R0,R0,#+2
   \   00000012   0x.... 0x....      BL       PhyPlmeRxRequest
   \   00000016   0x0004             MOVS     R4,R0
   1177              if(u8PhyRes)
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD034             BEQ.N    ??PhyPlmeSyncLossIndication_1
   1178              {
   1179                smacProccesPacketPtr.smacRxPacketPointer->rxStatus = rxAbortedStatus_c;
   \   0000001E   0x2004             MOVS     R0,#+4
   \   00000020   0x....             LDR.N    R1,??DataTable27_2
   \   00000022   0x6809             LDR      R1,[R1, #+0]
   \   00000024   0x7048             STRB     R0,[R1, #+1]
   1180                PhyTimeDisableEventTimeout();
   \   00000026   0x.... 0x....      BL       PhyTimeDisableEventTimeout
   1181                MCPSDataIndication(smacProccesPacketPtr.smacRxPacketPointer);
   \   0000002A   0x....             LDR.N    R0,??DataTable27_2
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x.... 0x....      BL       MCPSDataIndication
   1182                smacState= mSmacStateIdle_c;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x....             LDR.N    R1,??DataTable27_1
   \   00000036   0x7008             STRB     R0,[R1, #+0]
   \   00000038   0xE026             B.N      ??PhyPlmeSyncLossIndication_1
   1183              }
   1184            }
   1185            else if(mSmacStateTransmitting_c == smacState)
   \                     ??PhyPlmeSyncLossIndication_0: (+1)
   \   0000003A   0x....             LDR.N    R0,??DataTable27_1
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xD106             BNE.N    ??PhyPlmeSyncLossIndication_2
   1186            {
   1187              (void)PhyPdDataRequest(smacProccesPacketPtr.smacTxPacketPointer, gDataReq_NoAck_NoCca_Unslotted_c, NULL);
   \   00000042   0x2200             MOVS     R2,#+0
   \   00000044   0x2101             MOVS     R1,#+1
   \   00000046   0x....             LDR.N    R0,??DataTable27_2
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x.... 0x....      BL       PhyPdDataRequest
   \   0000004E   0xE01B             B.N      ??PhyPlmeSyncLossIndication_1
   1188            }
   1189            else if(mSmacStateScanningChannels_c == smacState)
   \                     ??PhyPlmeSyncLossIndication_2: (+1)
   \   00000050   0x....             LDR.N    R0,??DataTable27_1
   \   00000052   0x7800             LDRB     R0,[R0, #+0]
   \   00000054   0x2803             CMP      R0,#+3
   \   00000056   0xD102             BNE.N    ??PhyPlmeSyncLossIndication_3
   1190            {
   1191              (void)SmacScanTheNextChannel();
   \   00000058   0x.... 0x....      BL       SmacScanTheNextChannel
   \   0000005C   0xE014             B.N      ??PhyPlmeSyncLossIndication_1
   1192            }
   1193            else if(TRUE == mSmacPerformingED)
   \                     ??PhyPlmeSyncLossIndication_3: (+1)
   \   0000005E   0x....             LDR.N    R0,??DataTable27
   \   00000060   0x7800             LDRB     R0,[R0, #+0]
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000064   0x09C0             LSRS     R0,R0,#+7
   \   00000066   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD00D             BEQ.N    ??PhyPlmeSyncLossIndication_1
   1194            {
   1195              if(PhyPlmeEdRequest())
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x.... 0x....      BL       PhyPlmeCcaEdRequest
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD008             BEQ.N    ??PhyPlmeSyncLossIndication_1
   1196              {
   1197                smacEdValue = 0xFF;
   \   00000076   0x20FF             MOVS     R0,#+255
   \   00000078   0x....             LDR.N    R1,??DataTable27_6
   \   0000007A   0x7008             STRB     R0,[R1, #+0]
   1198                mSmacPerformingED = FALSE;
   \   0000007C   0x....             LDR.N    R0,??DataTable27
   \   0000007E   0x7800             LDRB     R0,[R0, #+0]
   \   00000080   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000084   0x....             LDR.N    R1,??DataTable27
   \   00000086   0x7008             STRB     R0,[R1, #+0]
   1199              }
   1200            }
   1201          }
   \                     ??PhyPlmeSyncLossIndication_1: (+1)
   \   00000088   0xBD10             POP      {R4,PC}          ;; return
   1202          
   1203          /***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1204          void PhyPlmeResetIndication(void)
   1205          {
   \                     PhyPlmeResetIndication: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1206            MLMEResetIndication();
   \   00000002   0x.... 0x....      BL       MLMEResetIndication
   1207          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
   1208          
   1209          /***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1210          void    PhyPlmeWakeConfirm(void)
   1211          {
   \                     PhyPlmeWakeConfirm: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1212            MLMEWakeConfirm();
   \   00000002   0x.... 0x....      BL       MLMEWakeConfirm
   1213          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
   1214          
   1215          /***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1216          void PhyTimeRxTimeoutIndication(void)
   1217          {
   \                     PhyTimeRxTimeoutIndication: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1218            smacProccesPacketPtr.smacRxPacketPointer->rxStatus = rxTimeOutStatus_c;
   \   00000002   0x2003             MOVS     R0,#+3
   \   00000004   0x....             LDR.N    R1,??DataTable27_2
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x7048             STRB     R0,[R1, #+1]
   1219            MCPSDataIndication(smacProccesPacketPtr.smacRxPacketPointer);
   \   0000000A   0x....             LDR.N    R0,??DataTable27_2
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x.... 0x....      BL       MCPSDataIndication
   1220            smacState= mSmacStateIdle_c;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x....             LDR.N    R1,??DataTable27_1
   \   00000016   0x7008             STRB     R0,[R1, #+0]
   1221          }
   \   00000018   0xBD01             POP      {R0,PC}          ;; return
   1222          
   1223          /***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1224          void PhyTimeStartEventIndication(void)
   1225          {
   1226            
   1227          }
   \                     PhyTimeStartEventIndication: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   0x........         DC32     smacFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \   00000000   0x........         DC32     smacState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_2:
   \   00000000   0x........         DC32     smacProccesPacketPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_3:
   \   00000000   0x........         DC32     smacLastDataRxParams

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_4:
   \   00000000   0x........         DC32     smacTimeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_5:
   \   00000000   0x........         DC32     smacCurrentChannel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_6:
   \   00000000   0x........         DC32     smacEdValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_7:
   \   00000000   0x........         DC32     smacClearestChann

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_8:
   \   00000000   0x........         DC32     au8SmacVersion

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_9:
   \   00000000   0x........         DC32     smacChannelsBeingScanned

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_10:
   \   00000000   0x........         DC32     smacScanCurrentChannel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_11:
   \   00000000   0x........         DC32     u8TestBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_12:
   \   00000000   0x........         DC32     pTestPacket

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_13:
   \   00000000   0x........         DC32     Local_pll_frac
   1228          
   1229          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   MCPSDataRequest
        16   -> PhyPdDataRequest
        16   -> SmacFormatTxPacket
       8   MLMEDozeRequest
         8   -> PhyPlmeDozeRequest
       8   MLMEEnergyDetect
         8   -> PhyPlmeCcaEdRequest
       8   MLMEFEGainAdjust
         8   -> PhyAdjustCcaOffsetCmpReg
       0   MLMEGetChannelRequest
       0   MLMEGetPromiscuousMode
      16   MLMEGetRficVersion
        16   -> PhyGetRfIcVersion
       8   MLMEHibernateRequest
         8   -> PhyHibernateRequest
       0   MLMELinkQuality
      16   MLMEPAOutputAdjust
        16   -> PhyPlmeSetPwrLevelRequest
       8   MLMERXDisableRequest
         8   -> PhyAbort
      24   MLMERXEnableRequest
        24   -> PhyPlmeRxRequest
        24   -> SmacSetRxTimeout
       8   MLMERadioInit
         8   -> MC1324xDrv_IRQ_Enable
         8   -> MC1324xDrv_IRQ_PortConfig
         8   -> MC1324xDrv_IsIrqPending
         8   -> MC1324xDrv_RST_B_Assert
         8   -> MC1324xDrv_RST_B_Deassert
         8   -> MC1324xDrv_RST_B_PortConfig
         8   -> MC1324xDrv_Set_CLK_OUT_Freq
         8   -> MCU_InitClock
         8   -> NVIC_EnableIRQ
         8   -> NVIC_SetPriority
         8   -> PhyInit
         8   -> PhyPpSetPromiscuous
         8   -> delayMs
      24   MLMEScanRequest
        24   -> SmacScanTheNextChannel
      16   MLMESetChannelRequest
        16   -> MC1324xDrv_IRQ_Clear
        16   -> NVIC_ClearPendingIRQ
        16   -> PhyPlmeSetCurrentChannelRequestPAN0
       8   MLMESetClockRate
         8   -> PhyPlmeSetClockOutRateReg
       0   MLMESetPromiscuousMode
       8   MLMESetTmrPrescale
         8   -> PhySetRadioTimerPrescalerReg
       8   MLMESoftReset
         8   -> MLMERadioInit
         8   -> PhyAbort
       8   MLMETestMode
         8   -> MC1324xDrv_DirectAccessSPIMultiByteWrite
         8   -> MC1324xDrv_DirectAccessSPIWrite
         8   -> MC1324xDrv_IndirectAccessSPIWrite
         8   -> PhyAbort
         8   -> PhyPdDataRequest
       8   MLMEWakeRequest
         8   -> PhyWakeRequest
       8   MLMEXtalAdjust
         8   -> PhyXtalAdjust
       8   PhyPdDataConfirm
         8   -> MCPSDataConfirm
         8   -> PhyPdDataRequest
         8   -> delayMs
       8   PhyPdDataIndication
         8   -> MCPSDataIndication
         8   -> PhyPlmeRxRequest
         8   -> PhyTimeDisableEventTimeout
         8   -> SmacSetRxTimeout
      16   PhyPlmeCcaConfirm
        16   -> MLMEScanConfirm
        16   -> PhyPlmeSetCurrentChannelRequestPAN0
        16   -> SmacScanTheNextChannel
      16   PhyPlmeEdConfirm
        16   -> MLMEScanConfirm
        16   -> PhyPlmeSetCurrentChannelRequestPAN0
        16   -> SmacScanTheNextChannel
       8   PhyPlmeResetIndication
         8   -> MLMEResetIndication
       8   PhyPlmeSyncLossIndication
         8   -> MCPSDataIndication
         8   -> PhyPdDataRequest
         8   -> PhyPlmeCcaEdRequest
         8   -> PhyPlmeRxRequest
         8   -> PhyTimeDisableEventTimeout
         8   -> SmacScanTheNextChannel
       8   PhyPlmeWakeConfirm
         8   -> MLMEWakeConfirm
       8   PhyTimeRxTimeoutIndication
         8   -> MCPSDataIndication
       0   PhyTimeStartEventIndication
       8   SMACDisableInterrupts
         8   -> NVIC_DisableIRQ
       8   SMACEnableInterrupts
         8   -> NVIC_EnableIRQ
       0   SmacFormatTxPacket
      16   SmacScanTheNextChannel
        16   -> PhyPlmeCcaEdRequest
        16   -> PhyPlmeSetCurrentChannelRequestPAN0
      16   SmacSetRxTimeout
        16   -> PhyTimeReadClock
        16   -> PhyTimeSetEventTimeout
       8   XCVRContReset
         8   -> MC1324xDrv_RST_B_Assert
       8   XCVRRestart
         8   -> MC1324xDrv_RST_B_Deassert


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_10
       4  ??DataTable27_11
       4  ??DataTable27_12
       4  ??DataTable27_13
       4  ??DataTable27_2
       4  ??DataTable27_3
       4  ??DataTable27_4
       4  ??DataTable27_5
       4  ??DataTable27_6
       4  ??DataTable27_7
       4  ??DataTable27_8
       4  ??DataTable27_9
      32  Local_pll_frac
     132  MCPSDataRequest
      36  MLMEDozeRequest
     104  MLMEEnergyDetect
      30  MLMEFEGainAdjust
      52  MLMEGetChannelRequest
      12  MLMEGetPromiscuousMode
      92  MLMEGetRficVersion
      52  MLMEHibernateRequest
      34  MLMELinkQuality
      88  MLMEPAOutputAdjust
      78  MLMERXDisableRequest
     198  MLMERXEnableRequest
     272  MLMERadioInit
     204  MLMEScanRequest
     104  MLMESetChannelRequest
      14  MLMESetClockRate
      18  MLMESetPromiscuousMode
      54  MLMESetTmrPrescale
      12  MLMESoftReset
     258  MLMETestMode
      54  MLMEWakeRequest
      40  MLMEXtalAdjust
      88  PhyPdDataConfirm
     198  PhyPdDataIndication
      84  PhyPlmeCcaConfirm
     144  PhyPlmeEdConfirm
       8  PhyPlmeResetIndication
     138  PhyPlmeSyncLossIndication
       8  PhyPlmeWakeConfirm
      26  PhyTimeRxTimeoutIndication
       2  PhyTimeStartEventIndication
      10  SMACDisableInterrupts
      10  SMACEnableInterrupts
      50  SmacFormatTxPacket
     120  SmacScanTheNextChannel
      28  SmacSetRxTimeout
       8  XCVRContReset
       8  XCVRRestart
       8  au8SmacVersion
       4  pTestPacket
       2  smacChannelsBeingScanned
       1  smacClearestChann
       1  smacCurrentChannel
       1  smacEdValue
       4  smacFlags
       8  smacLastDataRxParams
       4  smacProccesPacketPtr
       1  smacScanCurrentChannel
       1  smacState
       4  smacTimeout
      68  u8TestBuffer

 
    31 bytes in section .bss
    68 bytes in section .data
    40 bytes in section .rodata
 2 924 bytes in section .text
 
 2 924 bytes of CODE  memory
    40 bytes of CONST memory
    99 bytes of DATA  memory

Errors: none
Warnings: none
