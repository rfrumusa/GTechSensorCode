///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM       02/Sep/2018  13:33:18
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\NVM\NV_FlashHAL.c
//    Command line =  
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\NVM\NV_FlashHAL.c" -D IAR --preprocess "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\List\" -lC "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\List\" -lB "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\List\" --diag_suppress
//        Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\Debug\Obj\" --no_cse --no_unroll
//        --no_inline --no_code_motion --no_tbaa --no_clustering
//        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\APP\CDC\" -I "F:\Guardrail Work\Sensor Code\Git
//        Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\USB\APP\Descriptor\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Class\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Sys Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
//    List file    =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\Debug\List\NV_FlashHAL.s
//
///////////////////////////////////////////////////////////////////////////////

        #define SHT_PROGBITS 0x1
        #define SHF_WRITE 0x1
        #define SHF_EXECINSTR 0x4

        PUBLIC EffectiveWrBytesCnt
        PUBLIC NV_DEFlashPartition
        PUBLIC NV_DFlashGetProtection
        PUBLIC NV_DFlashSetProtection
        PUBLIC NV_EEEWrite
        PUBLIC NV_EERAMGetProtection
        PUBLIC NV_EERAMSetProtection
        PUBLIC NV_FlashCheckSum
        PUBLIC NV_FlashEraseAllBlock
        PUBLIC NV_FlashEraseBlock
        PUBLIC NV_FlashEraseResume
        PUBLIC NV_FlashEraseSector
        PUBLIC NV_FlashEraseSuspend
        PUBLIC NV_FlashGetInterruptEnable
        PUBLIC NV_FlashGetSecurityState
        PUBLIC NV_FlashInit
        PUBLIC NV_FlashProgramCheck
        PUBLIC NV_FlashProgramLongword
        PUBLIC NV_FlashProgramOnce
        PUBLIC NV_FlashProgramPhrase
        PUBLIC NV_FlashProgramUnalignedLongword
        PUBLIC NV_FlashRead
        PUBLIC NV_FlashReadOnce
        PUBLIC NV_FlashReadResource
        PUBLIC NV_FlashSecurityBypass
        PUBLIC NV_FlashSetInterruptEnable
        PUBLIC NV_FlashVerifyAllBlock
        PUBLIC NV_FlashVerifyBlock
        PUBLIC NV_FlashVerifySection
        PUBLIC NV_PFlashGetProtection
        PUBLIC NV_PFlashSetProtection
        PUBLIC NV_SetEEEEnable

// F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\NV_FlashHAL.c
//    1 /******************************************************************************
//    2 * Filename: NV_FlashHAL.c
//    3 *
//    4 * Description: Implementation of the non-volatile storage module flash
//    5 *              controller HAL for Cortex-M4 processor
//    6 *
//    7 * Copyright (c) 2014, Freescale Semiconductor, Inc.
//    8 * All rights reserved.
//    9 *
//   10 * Redistribution and use in source and binary forms, with or without modification,
//   11 * are permitted provided that the following conditions are met:
//   12 *
//   13 * o Redistributions of source code must retain the above copyright notice, this list
//   14 *   of conditions and the following disclaimer.
//   15 *
//   16 * o Redistributions in binary form must reproduce the above copyright notice, this
//   17 *   list of conditions and the following disclaimer in the documentation and/or
//   18 *   other materials provided with the distribution.
//   19 *
//   20 * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
//   21 *   contributors may be used to endorse or promote products derived from this
//   22 *   software without specific prior written permission.
//   23 *
//   24 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
//   25 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
//   26 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//   27 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
//   28 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//   29 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//   30 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
//   31 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//   32 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
//   33 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//   34 *
//   35 ***************************************************************************/
//   36 
//   37 #include "EmbeddedTypes.h"
//   38 #include "PortConfig.h"
//   39 #include "NV_FlashHAL.h"
//   40 #include "Interrupt.h"
//   41 
//   42 
//   43 /*****************************************************************************
//   44  *****************************************************************************
//   45  * Private memory definitions
//   46  *****************************************************************************
//   47  *****************************************************************************/
//   48 
//   49 /*****************************************************************************
//   50  ******************************************************************************
//   51  * Public memory definitions
//   52  ******************************************************************************
//   53  *****************************************************************************/
//   54 
//   55 /*
//   56  * Name: effective number of bytes written
//   57  * Description: EffectiveWrBytesCnt;
//   58  */

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   59 uint32_t EffectiveWrBytesCnt;
EffectiveWrBytesCnt:
        DS8 4
//   60 
//   61 /*****************************************************************************
//   62  *****************************************************************************
//   63  * Private prototypes
//   64  *****************************************************************************
//   65  *****************************************************************************/
//   66 
//   67 /************************************************************************
//   68  *
//   69  *  Function Name    : NvFlashCommandSequence
//   70  *  Description      : Perform command write sequence for flash operation
//   71  *  Arguments        : [IN] pConfig - pointer to NV configuration
//   72  *                     [IN] index - command index
//   73  *                     [IN] pCommandArray - command parameters
//   74  *  Return Value     : uint32_t
//   75  *
//   76  *************************************************************************/
//   77 static uint32_t NvFlashCommandSequence
//   78 (
//   79         pNvConfig_t pConfig,
//   80         uint8_t index,
//   81         uint8_t* pCommandArray
//   82 );
//   83 
//   84 /*****************************************************************************
//   85  *****************************************************************************
//   86  * Private functions
//   87  *****************************************************************************
//   88  *****************************************************************************/
//   89 
//   90 /************************************************************************
//   91  *
//   92  *  Function Name    : NvFlashCommandSequence
//   93  *  Description      : Perform command write sequence for flash operation
//   94  *  Arguments        : [IN] pConfig - pointer to NV configuration
//   95  *                     [IN] index - command index
//   96  *                     [IN] pCommandArray - command parameters
//   97  *  Return Value     : uint32_t
//   98  *
//   99  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  100 static uint32_t NvFlashCommandSequence
//  101 (
//  102         pNvConfig_t pConfig,
//  103         uint8_t index,
//  104         uint8_t* pCommandArray
//  105 )
//  106 {
NvFlashCommandSequence:
        PUSH     {R4-R7}
        MOVS     R3,R0
//  107     uint8_t  counter;          /* for loop counter variable */
//  108     uint8_t  registerValue;    /* store data read from flash register */
//  109     uint32_t returnCode;       /* return code variable */
//  110 #if gNvDisableIntCmdSeq_c
//  111     uint32_t iRet = 0;
//  112 #endif
//  113 
//  114 
//  115     /* set the default return as gNV_OK_c */
//  116     returnCode = gNV_OK_c;
        MOVS     R6,#+0
        MOVS     R0,R6
//  117 
//  118     /* check CCIF bit of the flash status register */
//  119     while(FALSE == (gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c)))
??NvFlashCommandSequence_0:
        LDR      R6,[R3, #+0]
        LDRB     R6,[R6, #+0]
        LSLS     R6,R6,#+24
        BPL.N    ??NvFlashCommandSequence_0
//  120     {
//  121         /* wait till CCIF bit is set */
//  122     };
//  123 
//  124     /* clear RDCOLERR & ACCERR & FPVIOL flag in flash status register */
//  125     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, \ 
//  126             (gNV_FSTAT_RDCOLERR_c | gNV_FSTAT_ACCERR_c | gNV_FSTAT_FPVIOL_c));
        MOVS     R6,#+112
        LDR      R7,[R3, #+0]
        STRB     R6,[R7, #+0]
//  127 
//  128     /* load FCCOB registers */
//  129     for(counter=0; counter<=index; counter++)
        MOVS     R6,#+0
        MOVS     R4,R6
??NvFlashCommandSequence_1:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R1,R4
        BCC.N    ??NvFlashCommandSequence_2
//  130     {
//  131         switch (counter)
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+0
        BEQ.N    ??NvFlashCommandSequence_3
        CMP      R4,#+2
        BEQ.N    ??NvFlashCommandSequence_4
        BCC.N    ??NvFlashCommandSequence_5
        CMP      R4,#+4
        BEQ.N    ??NvFlashCommandSequence_6
        BCC.N    ??NvFlashCommandSequence_7
        CMP      R4,#+6
        BEQ.N    ??NvFlashCommandSequence_8
        BCC.N    ??NvFlashCommandSequence_9
        CMP      R4,#+8
        BEQ.N    ??NvFlashCommandSequence_10
        BCC.N    ??NvFlashCommandSequence_11
        CMP      R4,#+10
        BEQ.N    ??NvFlashCommandSequence_12
        BCC.N    ??NvFlashCommandSequence_13
        CMP      R4,#+11
        BEQ.N    ??NvFlashCommandSequence_14
        B.N      ??NvFlashCommandSequence_15
//  132         {
//  133         case 0: gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB0_OFFSET_c, pCommandArray[counter]);
??NvFlashCommandSequence_3:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R6,[R4, R2]
        LDR      R7,[R3, #+0]
        STRB     R6,[R7, #+7]
//  134         break;
        B.N      ??NvFlashCommandSequence_16
//  135         case 1: gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB1_OFFSET_c, pCommandArray[counter]);
??NvFlashCommandSequence_5:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R6,[R4, R2]
        LDR      R7,[R3, #+0]
        STRB     R6,[R7, #+6]
//  136         break;
        B.N      ??NvFlashCommandSequence_16
//  137         case 2: gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB2_OFFSET_c, pCommandArray[counter]);
??NvFlashCommandSequence_4:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R6,[R4, R2]
        LDR      R7,[R3, #+0]
        STRB     R6,[R7, #+5]
//  138         break;
        B.N      ??NvFlashCommandSequence_16
//  139         case 3: gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB3_OFFSET_c, pCommandArray[counter]);
??NvFlashCommandSequence_7:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R6,[R4, R2]
        LDR      R7,[R3, #+0]
        STRB     R6,[R7, #+4]
//  140         break;
        B.N      ??NvFlashCommandSequence_16
//  141         case 4: gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB4_OFFSET_c, pCommandArray[counter]);
??NvFlashCommandSequence_6:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R6,[R4, R2]
        LDR      R7,[R3, #+0]
        STRB     R6,[R7, #+11]
//  142         break;
        B.N      ??NvFlashCommandSequence_16
//  143         case 5: gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB5_OFFSET_c, pCommandArray[counter]);
??NvFlashCommandSequence_9:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R6,[R4, R2]
        LDR      R7,[R3, #+0]
        STRB     R6,[R7, #+10]
//  144         break;
        B.N      ??NvFlashCommandSequence_16
//  145         case 6: gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB6_OFFSET_c, pCommandArray[counter]);
??NvFlashCommandSequence_8:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R6,[R4, R2]
        LDR      R7,[R3, #+0]
        STRB     R6,[R7, #+9]
//  146         break;
        B.N      ??NvFlashCommandSequence_16
//  147         case 7: gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB7_OFFSET_c, pCommandArray[counter]);
??NvFlashCommandSequence_11:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R6,[R4, R2]
        LDR      R7,[R3, #+0]
        STRB     R6,[R7, #+8]
//  148         break;
        B.N      ??NvFlashCommandSequence_16
//  149         case 8: gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB8_OFFSET_c, pCommandArray[counter]);
??NvFlashCommandSequence_10:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R6,[R4, R2]
        LDR      R7,[R3, #+0]
        STRB     R6,[R7, #+15]
//  150         break;
        B.N      ??NvFlashCommandSequence_16
//  151         case 9: gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB9_OFFSET_c, pCommandArray[counter]);
??NvFlashCommandSequence_13:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R6,[R4, R2]
        LDR      R7,[R3, #+0]
        STRB     R6,[R7, #+14]
//  152         break;
        B.N      ??NvFlashCommandSequence_16
//  153         case 10: gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOBA_OFFSET_c, pCommandArray[counter]);
??NvFlashCommandSequence_12:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R6,[R4, R2]
        LDR      R7,[R3, #+0]
        STRB     R6,[R7, #+13]
//  154         break;
        B.N      ??NvFlashCommandSequence_16
//  155         case 11: gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOBB_OFFSET_c, pCommandArray[counter]);
??NvFlashCommandSequence_14:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R6,[R4, R2]
        LDR      R7,[R3, #+0]
        STRB     R6,[R7, #+12]
//  156         break;
        B.N      ??NvFlashCommandSequence_16
//  157         default: break;
//  158         }
//  159     }
??NvFlashCommandSequence_15:
??NvFlashCommandSequence_16:
        ADDS     R4,R4,#+1
        B.N      ??NvFlashCommandSequence_1
//  160 #if gNvDisableIntCmdSeq_c    
//  161       /* disable interrupts */
//  162       iRet = IntDisableAll();   
//  163 #endif
//  164 
//  165     /* clear CCIF bit */
//  166     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c);
??NvFlashCommandSequence_2:
        MOVS     R6,#+128
        LDR      R7,[R3, #+0]
        STRB     R6,[R7, #+0]
//  167 
//  168     /* check CCIF bit */
//  169     while(FALSE == (gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c)))
??NvFlashCommandSequence_17:
        LDR      R6,[R3, #+0]
        LDRB     R6,[R6, #+0]
        LSLS     R6,R6,#+24
        BPL.N    ??NvFlashCommandSequence_17
//  170     {
//  171         /* wait till CCIF bit is set */
//  172     }
//  173     
//  174 #if gNvDisableIntCmdSeq_c
//  175       /* enable interrupts */
//  176       IntRestoreAll(iRet);  
//  177 #endif
//  178 
//  179     /* Check error bits */
//  180 
//  181     /* Get flash status register value */
//  182     registerValue = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c);
        LDR      R6,[R3, #+0]
        LDRB     R6,[R6, #+0]
        MOVS     R5,R6
//  183 
//  184     /* checking access error */
//  185     if(0 != (registerValue & gNV_FSTAT_ACCERR_c))
        LSLS     R6,R5,#+26
        BPL.N    ??NvFlashCommandSequence_18
//  186     {
//  187         /* return an error code gNV_ERR_ACCERR_c */
//  188         returnCode = gNV_ERR_ACCERR_c;
        MOVS     R6,#+4
        MOVS     R0,R6
        B.N      ??NvFlashCommandSequence_19
//  189     }
//  190     /* checking protection error */
//  191     else if(0 != (registerValue & gNV_FSTAT_FPVIOL_c))
??NvFlashCommandSequence_18:
        LSLS     R6,R5,#+27
        BPL.N    ??NvFlashCommandSequence_20
//  192     {
//  193         /* return an error code gNV_ERR_PVIOL_c */
//  194         returnCode = gNV_ERR_PVIOL_c;
        MOVS     R6,#+8
        MOVS     R0,R6
        B.N      ??NvFlashCommandSequence_19
//  195     }
//  196     /* checking MGSTAT0 non-correctable error */
//  197     else if(0 != (registerValue & gNV_FSTAT_MGSTAT0_c))
??NvFlashCommandSequence_20:
        LSLS     R6,R5,#+31
        BPL.N    ??NvFlashCommandSequence_19
//  198     {
//  199         /* return an error code gNV_ERR_MGSTAT0_c */
//  200         returnCode = gNV_ERR_MGSTAT0_c;
        MOVS     R6,#+16
        MOVS     R0,R6
//  201     }
//  202 
//  203     return(returnCode);
??NvFlashCommandSequence_19:
        POP      {R4-R7}
        BX       LR               ;; return
//  204 }
//  205 
//  206 
//  207 /*****************************************************************************
//  208  *****************************************************************************
//  209  * Public functions
//  210  *****************************************************************************
//  211  *****************************************************************************/
//  212 
//  213 /************************************************************************
//  214  *
//  215  *  Function Name    : NV_FlashInit
//  216  *  Description      : Initialize the Flash memory controller (FTFL)
//  217  *  Arguments        : [IN] pConfig - pointer to NV configuration
//  218  *  Return Value     : -
//  219  *
//  220  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  221 void NV_FlashInit
//  222 (
//  223         pNvConfig_t pConfig
//  224 )
//  225 {
//  226 #if (gNV_DEBLOCK_SIZE_c != 0)
//  227     uint8_t  EEEDataSetSize;     /* store EEE Data Set Size */
//  228     uint8_t  DEPartitionCode;    /* store D/E-Flash Partition Code */
//  229 #endif
//  230 
//  231     /* set the flash clock */
//  232     gFTFL_SIM_CLKDIV_c |= gSIM_CLKDIV_OUTDIV(gCLKDIV_VALUE_c);
NV_FlashInit:
        LDR.W    R1,??DataTable2  ;; 0x40048044
        LDR      R1,[R1, #+0]
        LDR.W    R2,??DataTable2  ;; 0x40048044
        STR      R1,[R2, #+0]
//  233     /* enable clock gating for the FTFL module */
//  234     gFTFL_SIM_SCGC_c |= gSIM_SCGC_FTFL_MASK_c;
        LDR.W    R1,??DataTable2_1  ;; 0x4004803c
        LDR      R1,[R1, #+0]
        ORRS     R1,R1,#0x1
        LDR.W    R2,??DataTable2_1  ;; 0x4004803c
        STR      R1,[R2, #+0]
//  235 
//  236 #if (gNV_DEBLOCK_SIZE_c != 0)
//  237     /* check CCIF bit of the flash status register */
//  238     while(FALSE == (gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c)))
//  239     {
//  240         /* wait till CCIF bit is set */
//  241     }
//  242 
//  243     /* clear RDCOLERR & ACCERR & FPVIOL flag in flash status register */
//  244     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, \ 
//  245             (gNV_FSTAT_RDCOLERR_c | gNV_FSTAT_ACCERR_c | gNV_FSTAT_FPVIOL_c));
//  246 
//  247     /* Write Command Code to FCCOB0 */
//  248     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB0_OFFSET_c, gNV_READ_RESOURCE_c);
//  249     /* Write address to FCCOB1/2/3 */
//  250     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB1_OFFSET_c, ((uint8_t)(gNV_DFLASH_IFR_READRESOURCE_ADDRESS_c >> 16)));
//  251     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB2_OFFSET_c, ((uint8_t)((gNV_DFLASH_IFR_READRESOURCE_ADDRESS_c >> 8) & 0xFF)));
//  252     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB3_OFFSET_c, ((uint8_t)(gNV_DFLASH_IFR_READRESOURCE_ADDRESS_c & 0xFF)));
//  253 
//  254     /* Write Resource Select Code of 0 to FCCOB8 to select IFR. Without this, */
//  255     /* an access error may occur if the register contains data from a previous command. */
//  256 #if (gNV_512K_512K_16K_4K_4K_c == gNV_Derivative_c)
//  257     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB4_OFFSET_c, 0);
//  258 #else
//  259     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB8_OFFSET_c, 0);
//  260 #endif
//  261     /* clear CCIF bit */
//  262     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c);
//  263 
//  264     /* check CCIF bit */
//  265     while((gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c)) == FALSE)
//  266     {
//  267         /* wait till CCIF bit is set */
//  268     }
//  269 
//  270     /* Read returned value of FCCOB6/7 or FCCOBA,B to the variables */
//  271 #if (gNV_512K_512K_16K_4K_4K_c == gNV_Derivative_c)
//  272     EEEDataSetSize = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOBA_OFFSET_c);
//  273     DEPartitionCode = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOBB_OFFSET_c);
//  274 #else
//  275     EEEDataSetSize = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB6_OFFSET_c);
//  276     DEPartitionCode = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB7_OFFSET_c);
//  277 #endif
//  278     /* Calculate D-Flash size and EEE size */
//  279     switch (DEPartitionCode & 0x0F)
//  280     {
//  281     case 0: pConfig->DFlashBlockSize = gNV_DEPART_0000_c; break;
//  282     case 1: pConfig->DFlashBlockSize = gNV_DEPART_0001_c; break;
//  283     case 2: pConfig->DFlashBlockSize = gNV_DEPART_0010_c; break;
//  284     case 3: pConfig->DFlashBlockSize = gNV_DEPART_0011_c; break;
//  285     case 4: pConfig->DFlashBlockSize = gNV_DEPART_0100_c; break;
//  286     case 5: pConfig->DFlashBlockSize = gNV_DEPART_0101_c; break;
//  287     case 6: pConfig->DFlashBlockSize = gNV_DEPART_0110_c; break;
//  288     case 7: pConfig->DFlashBlockSize = gNV_DEPART_0111_c; break;
//  289     case 8: pConfig->DFlashBlockSize = gNV_DEPART_1000_c; break;
//  290     case 9: pConfig->DFlashBlockSize = gNV_DEPART_1001_c; break;
//  291     case 10: pConfig->DFlashBlockSize = gNV_DEPART_1010_c; break;
//  292     case 11: pConfig->DFlashBlockSize = gNV_DEPART_1011_c; break;
//  293     case 12: pConfig->DFlashBlockSize = gNV_DEPART_1100_c; break;
//  294     case 13: pConfig->DFlashBlockSize = gNV_DEPART_1101_c; break;
//  295     case 14: pConfig->DFlashBlockSize = gNV_DEPART_1110_c; break;
//  296     case 15: pConfig->DFlashBlockSize = gNV_DEPART_1111_c; break;
//  297     default: break;
//  298     }
//  299 
//  300     switch (EEEDataSetSize & 0x0F)
//  301     {
//  302     case 0: pConfig->EEEBlockSize = gNV_EEESIZE_0000_c; break;
//  303     case 1: pConfig->EEEBlockSize = gNV_EEESIZE_0001_c; break;
//  304     case 2: pConfig->EEEBlockSize = gNV_EEESIZE_0010_c; break;
//  305     case 3: pConfig->EEEBlockSize = gNV_EEESIZE_0011_c; break;
//  306     case 4: pConfig->EEEBlockSize = gNV_EEESIZE_0100_c; break;
//  307     case 5: pConfig->EEEBlockSize = gNV_EEESIZE_0101_c; break;
//  308     case 6: pConfig->EEEBlockSize = gNV_EEESIZE_0110_c; break;
//  309     case 7: pConfig->EEEBlockSize = gNV_EEESIZE_0111_c; break;
//  310     case 8: pConfig->EEEBlockSize = gNV_EEESIZE_1000_c; break;
//  311     case 9: pConfig->EEEBlockSize = gNV_EEESIZE_1001_c; break;
//  312     case 10: pConfig->EEEBlockSize = gNV_EEESIZE_1010_c; break;
//  313     case 11: pConfig->EEEBlockSize = gNV_EEESIZE_1011_c; break;
//  314     case 12: pConfig->EEEBlockSize = gNV_EEESIZE_1100_c; break;
//  315     case 13: pConfig->EEEBlockSize = gNV_EEESIZE_1101_c; break;
//  316     case 14: pConfig->EEEBlockSize = gNV_EEESIZE_1110_c; break;
//  317     case 15: pConfig->EEEBlockSize = gNV_EEESIZE_1111_c; break;
//  318     default: break;
//  319     }
//  320 #else /* gNV_DEBLOCK_SIZE_c == 0 */
//  321 /* If size of D/E-Flash = 0 */
//  322     pConfig->DFlashBlockSize = 0;
        MOVS     R1,#+0
        STR      R1,[R0, #+16]
//  323     pConfig->EEEBlockSize = 0;
        MOVS     R1,#+0
        STR      R1,[R0, #+28]
//  324 #endif /* of gNV_DEBLOCK_SIZE_c */
//  325 }
        BX       LR               ;; return
//  326 
//  327 
//  328 /************************************************************************
//  329  *
//  330  *  Function Name    : NV_DEFlashPartition
//  331  *  Description      : This function prepares the D/E-Flash block for use
//  332  *                     as D-Flash, E-Flash or a combination of both and
//  333  *                     initializes the EERAM.
//  334  *  Arguments        : [IN] pConfig - pointer to NV configuration
//  335  *                   : [IN] EEEDataSizeCode - EEPROM data set size code
//  336  *                   : [IN] DEPartitionCode - FlexNVM partition code
//  337  *  Return Value     : see NV return codes
//  338  *
//  339  *************************************************************************/
//  340 #if (defined(__IAR_SYSTEMS_ICC__))

        SECTION `.textrw`:CODE:NOROOT(1)
        SECTION_TYPE SHT_PROGBITS, SHF_WRITE | SHF_EXECINSTR
        THUMB
//  341 __ramfunc uint32_t NV_DEFlashPartition
//  342 (
//  343         pNvConfig_t pConfig,
//  344         uint8_t EEEDataSizeCode,
//  345         uint8_t DEPartitionCode
//  346 )
//  347 #else
//  348 uint32_t NV_DEFlashPartition
//  349 (
//  350         pNvConfig_t pConfig,
//  351         uint8_t EEEDataSizeCode,
//  352         uint8_t DEPartitionCode
//  353 )
//  354 #endif
//  355 {
NV_DEFlashPartition:
        PUSH     {R4-R6}
        MOVS     R3,R0
//  356     uint32_t returnCode;      /* return code variable */
//  357     uint8_t registerValue;
//  358 
//  359     /* set the default return code as gNV_OK_c */
//  360     returnCode = gNV_OK_c;
        MOVS     R5,#+0
        MOVS     R0,R5
//  361 
//  362     /* check CCIF bit of the flash status register */
//  363     while(FALSE == (gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c)))
??NV_DEFlashPartition_0:
        LDR      R5,[R3, #+0]
        LDRB     R5,[R5, #+0]
        LSLS     R5,R5,#+24
        BPL.N    ??NV_DEFlashPartition_0
//  364     {
//  365         /* wait till CCIF bit is set */
//  366     };
//  367 
//  368     /* clear RDCOLERR & ACCERR & FPVIOL flag in flash status register */
//  369     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, \ 
//  370             (gNV_FSTAT_RDCOLERR_c | gNV_FSTAT_ACCERR_c | gNV_FSTAT_FPVIOL_c));
        MOVS     R5,#+112
        LDR      R6,[R3, #+0]
        STRB     R5,[R6, #+0]
//  371 
//  372     /* load the FCCOB registers */
//  373     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB0_OFFSET_c, gNV_PROGRAM_PARTITION_c);
        MOVS     R5,#+128
        LDR      R6,[R3, #+0]
        STRB     R5,[R6, #+7]
//  374     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB1_OFFSET_c, 0);
        MOVS     R5,#+0
        LDR      R6,[R3, #+0]
        STRB     R5,[R6, #+6]
//  375     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB2_OFFSET_c, 0);
        MOVS     R5,#+0
        LDR      R6,[R3, #+0]
        STRB     R5,[R6, #+5]
//  376     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB3_OFFSET_c, 0);
        MOVS     R5,#+0
        LDR      R6,[R3, #+0]
        STRB     R5,[R6, #+4]
//  377     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB4_OFFSET_c, EEEDataSizeCode);
        LDR      R5,[R3, #+0]
        STRB     R1,[R5, #+11]
//  378     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCCOB5_OFFSET_c, DEPartitionCode);
        LDR      R5,[R3, #+0]
        STRB     R2,[R5, #+10]
//  379 
//  380     /* clear CCIF bit */
//  381     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c);
        MOVS     R5,#+128
        LDR      R6,[R3, #+0]
        STRB     R5,[R6, #+0]
//  382 
//  383     /* check CCIF bit */
//  384     while(FALSE == (gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c)))
??NV_DEFlashPartition_1:
        LDR      R5,[R3, #+0]
        LDRB     R5,[R5, #+0]
        LSLS     R5,R5,#+24
        BPL.N    ??NV_DEFlashPartition_1
//  385     {
//  386         /* wait till CCIF bit is set */
//  387     };
//  388 
//  389     /* Check error bits */
//  390     /* Get flash status register value */
//  391     registerValue = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c);
        LDR      R5,[R3, #+0]
        LDRB     R5,[R5, #+0]
        MOVS     R4,R5
//  392 
//  393     /* checking access error */
//  394     if(0 != (registerValue & gNV_FSTAT_ACCERR_c))
        LSLS     R5,R4,#+26
        BPL.N    ??NV_DEFlashPartition_2
//  395     {
//  396         /* return an error code gNV_ERR_ACCERR_c */
//  397         returnCode = gNV_ERR_ACCERR_c;
        MOVS     R5,#+4
        MOVS     R0,R5
        B.N      ??NV_DEFlashPartition_3
//  398     }
//  399     /* checking protection error */
//  400     else if(0 != (registerValue & gNV_FSTAT_FPVIOL_c))
??NV_DEFlashPartition_2:
        LSLS     R5,R4,#+27
        BPL.N    ??NV_DEFlashPartition_4
//  401     {
//  402         /* return an error code gNV_ERR_PVIOL_c */
//  403         returnCode = gNV_ERR_PVIOL_c;
        MOVS     R5,#+8
        MOVS     R0,R5
        B.N      ??NV_DEFlashPartition_3
//  404     }
//  405     /* checking MGSTAT0 non-correctable error */
//  406     else if(0 != (registerValue & gNV_FSTAT_MGSTAT0_c))
??NV_DEFlashPartition_4:
        LSLS     R5,R4,#+31
        BPL.N    ??NV_DEFlashPartition_3
//  407     {
//  408         /* return an error code gNV_ERR_MGSTAT0_c */
//  409         returnCode = gNV_ERR_MGSTAT0_c;
        MOVS     R5,#+16
        MOVS     R0,R5
//  410     }
//  411 
//  412     return(returnCode);
??NV_DEFlashPartition_3:
        POP      {R4-R6}
        BX       LR               ;; return
//  413 }
//  414 
//  415 
//  416 /*************************************************************************
//  417  *
//  418  *  Function Name    : NV_DFlashGetProtection
//  419  *  Description      : This function retrieves current D-Flash protection status.
//  420  *  Arguments        : [IN] pConfig - pointer to NV configuration
//  421  *                   : [OUT] protectStatus - pointer to a memory location where
//  422  *                                           the protection status will be stored.
//  423  *  Return Value     : uint32_t
//  424  *
//  425  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  426 uint32_t NV_DFlashGetProtection
//  427 (
//  428         pNvConfig_t pConfig,
//  429         uint8_t* protectStatus
//  430 )
//  431 {
NV_DFlashGetProtection:
        MOVS     R2,R0
//  432     /* Check if size of DFlash = 0 */
//  433     if(pConfig->DFlashBlockSize == 0)
        LDR      R0,[R2, #+16]
        CMP      R0,#+0
        BNE.N    ??NV_DFlashGetProtection_0
//  434     {
//  435         return(gNV_ERR_EFLASHONLY_c);
        MOV      R0,#+1024
        B.N      ??NV_DFlashGetProtection_1
//  436     }
//  437 
//  438     *protectStatus = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FDPROT_OFFSET_c);
??NV_DFlashGetProtection_0:
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+23]
        STRB     R0,[R1, #+0]
//  439 
//  440     return(gNV_OK_c);
        MOVS     R0,#+0
??NV_DFlashGetProtection_1:
        BX       LR               ;; return
//  441 }
//  442 
//  443 
//  444 /************************************************************************
//  445  *
//  446  *  Function Name    : NV_DFlashSetProtection
//  447  *  Description      : This function sets the D-Flash protection to the
//  448  *                     intended protection status
//  449  *  Arguments        : [IN] pConfig - pointer to NV configuration
//  450  *                     [IN] protectStatus - protection status to be set
//  451  *  Return Value     : uint32_t
//  452  *
//  453  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  454 uint32_t NV_DFlashSetProtection
//  455 (
//  456         pNvConfig_t pConfig,
//  457         uint8_t protectStatus
//  458 )
//  459 {
NV_DFlashSetProtection:
        PUSH     {R4,R5}
        MOVS     R2,R0
//  460     uint8_t  registerValue;    /* store data read from flash register */
//  461     uint8_t  temp;
//  462 
//  463     /* check CCIF bit of the flash status register, it's impossible to write to DPROT if command is in progress */
//  464     if(FALSE == (gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c)))
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+24
        BMI.N    ??NV_DFlashSetProtection_0
//  465     {
//  466         return(gNV_ERR_CHANGEPROT_c);
        MOVS     R0,#+32
        B.N      ??NV_DFlashSetProtection_1
//  467     }
//  468     /* Check if size of DFlash = 0 */
//  469     if(pConfig->DFlashBlockSize == 0)
??NV_DFlashSetProtection_0:
        LDR      R0,[R2, #+16]
        CMP      R0,#+0
        BNE.N    ??NV_DFlashSetProtection_2
//  470     {
//  471         return(gNV_ERR_EFLASHONLY_c);
        MOV      R0,#+1024
        B.N      ??NV_DFlashSetProtection_1
//  472     }
//  473 
//  474     /* Read the value of FDPROT register */
//  475     registerValue = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FDPROT_OFFSET_c);
??NV_DFlashSetProtection_2:
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+23]
        MOVS     R3,R0
//  476 
//  477     /* Check if normal mode */
//  478     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FDPROT_OFFSET_c, 0xFF);
        MOVS     R0,#+255
        LDR      R5,[R2, #+0]
        STRB     R0,[R5, #+23]
//  479 
//  480     if(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FDPROT_OFFSET_c) != 0xFF)
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+23]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+255
        BEQ.N    ??NV_DFlashSetProtection_3
//  481     {
//  482         /* if normal mode */
//  483         temp = (uint8_t)(protectStatus ^ registerValue);
        EORS     R0,R3,R1
        MOVS     R4,R0
//  484         if(!(temp & protectStatus))
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        TST      R0,R1
        BNE.N    ??NV_DFlashSetProtection_4
//  485         {
//  486             gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FDPROT_OFFSET_c, protectStatus);
        LDR      R0,[R2, #+0]
        STRB     R1,[R0, #+23]
        B.N      ??NV_DFlashSetProtection_3
//  487         }
//  488         else
//  489         {
//  490             return(gNV_ERR_CHANGEPROT_c);
??NV_DFlashSetProtection_4:
        MOVS     R0,#+32
        B.N      ??NV_DFlashSetProtection_1
//  491         }
//  492     }
//  493     /* if unprotected or special mode */
//  494     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FDPROT_OFFSET_c, protectStatus);
??NV_DFlashSetProtection_3:
        LDR      R0,[R2, #+0]
        STRB     R1,[R0, #+23]
//  495 
//  496     return(gNV_OK_c);
        MOVS     R0,#+0
??NV_DFlashSetProtection_1:
        POP      {R4,R5}
        BX       LR               ;; return
//  497 }
//  498 
//  499 
//  500 /************************************************************************
//  501  *
//  502  *  Function Name    : NV_EEEWrite
//  503  *  Description      : This function is used to write data to EERAM
//  504  *                     when it is used as EEPROM emulator
//  505  *  Arguments        : [IN] pConfig - pointer to NV configuration
//  506  *                     [IN] source - source address
//  507  *                     [IN] destination - EERAM destination address
//  508  *                     [IN] size - how many bytes to be written
//  509  *
//  510  *  Return Value     : uint32_t
//  511  *
//  512  ************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  513 uint32_t NV_EEEWrite
//  514 (
//  515         pNvConfig_t pConfig,
//  516         uint32_t source,
//  517         uint32_t destination,
//  518         uint32_t size
//  519 )
//  520 {
NV_EEEWrite:
        PUSH     {R4-R6}
        MOVS     R4,R0
//  521     uint32_t returnCode;           /* Return code variable */
//  522     /* set the default return code as gNV_OK_c */
//  523     returnCode = gNV_OK_c;
        MOVS     R5,#+0
        MOVS     R0,R5
//  524     /* Check if EEE is enabled */
//  525     if(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCNFG_OFFSET_c) & gNV_FCNFG_EEERDY_c)
        LDR      R5,[R4, #+0]
        LDRB     R5,[R5, #+1]
        LSLS     R5,R5,#+31
        BPL.N    ??NV_EEEWrite_0
//  526     {
//  527         if(destination < pConfig->EERAMBlockBase || \ 
//  528                 ((destination + size) > (pConfig->EERAMBlockBase + pConfig->EEEBlockSize)))
        LDR      R5,[R4, #+20]
        CMP      R2,R5
        BCC.N    ??NV_EEEWrite_1
        LDR      R5,[R4, #+20]
        LDR      R6,[R4, #+28]
        ADDS     R5,R6,R5
        ADDS     R6,R3,R2
        CMP      R5,R6
        BCS.N    ??NV_EEEWrite_2
//  529         {
//  530             returnCode = gNV_ERR_RANGE_c;
??NV_EEEWrite_1:
        MOVS     R5,#+2
        MOVS     R0,R5
        B.N      ??NV_EEEWrite_3
//  531         }
//  532         else
//  533         {
//  534             while(size > 0)
??NV_EEEWrite_2:
        CMP      R3,#+0
        BEQ.N    ??NV_EEEWrite_3
//  535             {
//  536                 while(FALSE == gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FCNFG_OFFSET_c, gNV_FCNFG_EEERDY_c))
??NV_EEEWrite_4:
        LDR      R5,[R4, #+0]
        LDRB     R5,[R5, #+1]
        LSLS     R5,R5,#+31
        BPL.N    ??NV_EEEWrite_4
//  537                 {
//  538                     /* wait till EEERDY bit is set */
//  539                 }
//  540                 gNV_WRITE8(destination,gNV_READ8(source));
        LDRB     R5,[R1, #+0]
        STRB     R5,[R2, #+0]
//  541 
//  542                 /* Check for protection violation error */
//  543                 if(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c) & gNV_FSTAT_FPVIOL_c)
        LDR      R5,[R4, #+0]
        LDRB     R5,[R5, #+0]
        LSLS     R5,R5,#+27
        BPL.N    ??NV_EEEWrite_5
//  544                 {
//  545                     returnCode = gNV_ERR_PVIOL_c;
        MOVS     R5,#+8
        MOVS     R0,R5
//  546                     break;
        B.N      ??NV_EEEWrite_3
//  547                 }
//  548 
//  549                 /* update destination address for next iteration */
//  550                 destination += 1;
??NV_EEEWrite_5:
        ADDS     R2,R2,#+1
//  551                 /* update size for next iteration */
//  552                 size -= 1;
        SUBS     R3,R3,#+1
//  553                 /* increment the source address by 1 */
//  554                 source += 1;
        ADDS     R1,R1,#+1
        B.N      ??NV_EEEWrite_2
//  555             }
//  556         }
//  557     }
//  558     else
//  559     {
//  560         returnCode = gNV_ERR_NOEEE_c;
??NV_EEEWrite_0:
        MOV      R5,#+512
        MOVS     R0,R5
//  561     }
//  562 
//  563     return(returnCode);
??NV_EEEWrite_3:
        POP      {R4-R6}
        BX       LR               ;; return
//  564 }
//  565 
//  566 
//  567 /************************************************************************
//  568  *
//  569  *  Function Name    : NV_EERAMGetProtection.c
//  570  *  Description      : This function retrieves current EERAM protection status.
//  571  *  Arguments        : [IN] pConfig - pointer to NV configuration
//  572  *                     [IN] protectStatus - current protection status
//  573  *  Return Value     : uint32_t
//  574  *
//  575  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  576 uint32_t NV_EERAMGetProtection
//  577 (
//  578         pNvConfig_t pConfig,
//  579         uint8_t* protectStatus
//  580 )
//  581 {
NV_EERAMGetProtection:
        MOVS     R2,R0
//  582     /* Check if EERAM is set for EEE */
//  583     if(gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FCNFG_OFFSET_c, gNV_FCNFG_EEERDY_c))
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+1]
        LSLS     R0,R0,#+31
        BPL.N    ??NV_EERAMGetProtection_0
//  584     {
//  585         /* EERAM is set for EEE */
//  586         *protectStatus = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FEPROT_OFFSET_c);
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+22]
        STRB     R0,[R1, #+0]
//  587     }
//  588     else
//  589     {
//  590         return(gNV_ERR_NOEEE_c);
//  591     }
//  592 
//  593     return(gNV_OK_c);
        MOVS     R0,#+0
        B.N      ??NV_EERAMGetProtection_1
??NV_EERAMGetProtection_0:
        MOV      R0,#+512
??NV_EERAMGetProtection_1:
        BX       LR               ;; return
//  594 }
//  595 
//  596 
//  597 /************************************************************************
//  598  *
//  599  *  Function Name    : NV_EERAMSetProtection
//  600  *  Description      : This function sets EERAM protection status.
//  601  *  Arguments        : [IN] pConfig - pointer to NV configuration
//  602  *                     [IN] protectStatus - protection status to be set
//  603  *  Return Value     : uint32_t
//  604  *
//  605  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  606 uint32_t NV_EERAMSetProtection
//  607 (
//  608         pNvConfig_t pConfig,
//  609         uint8_t protectStatus
//  610 )
//  611 {
NV_EERAMSetProtection:
        PUSH     {R4-R6}
        MOVS     R2,R0
//  612     uint8_t  registerValue;    /* store data read from flash register */
//  613     uint32_t returnCode;       /* return code variable */
//  614     uint8_t  temp;
//  615 
//  616     /* set the default return as gNV_OK_c */
//  617     returnCode = gNV_OK_c;
        MOVS     R0,#+0
        MOVS     R4,R0
//  618 
//  619     /* check CCIF bit of the flash status register, it's impossible to write to FEPROT if command is in progress */
//  620     if(FALSE == (gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c)))
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+24
        BMI.N    ??NV_EERAMSetProtection_0
//  621     {
//  622         return(gNV_ERR_CHANGEPROT_c);
        MOVS     R0,#+32
        B.N      ??NV_EERAMSetProtection_1
//  623 
//  624     }
//  625     /* Check if EERAM is set for EEE */
//  626     if(!(gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FCNFG_OFFSET_c, gNV_FCNFG_EEERDY_c)))
??NV_EERAMSetProtection_0:
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+1]
        LSLS     R0,R0,#+31
        BMI.N    ??NV_EERAMSetProtection_2
//  627     {
//  628         /* EERAM is not set for EEE */
//  629         return(gNV_ERR_NOEEE_c);
        MOV      R0,#+512
        B.N      ??NV_EERAMSetProtection_1
//  630     }
//  631 
//  632     /* Read the value of FDPROT register */
//  633     registerValue = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FEPROT_OFFSET_c);
??NV_EERAMSetProtection_2:
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+22]
        MOVS     R3,R0
//  634 
//  635     /* Check if normal mode */
//  636     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FEPROT_OFFSET_c, 0xFF);
        MOVS     R0,#+255
        LDR      R6,[R2, #+0]
        STRB     R0,[R6, #+22]
//  637 
//  638     if(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FEPROT_OFFSET_c) != 0xFF)
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+22]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+255
        BEQ.N    ??NV_EERAMSetProtection_3
//  639     {
//  640         /* if normal mode */
//  641         temp = (uint8_t)(protectStatus ^ registerValue);
        EORS     R0,R3,R1
        MOVS     R5,R0
//  642         if(!(temp & protectStatus))
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        TST      R0,R1
        BNE.N    ??NV_EERAMSetProtection_4
//  643         {
//  644             gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FEPROT_OFFSET_c, protectStatus);
        LDR      R0,[R2, #+0]
        STRB     R1,[R0, #+22]
        B.N      ??NV_EERAMSetProtection_5
//  645         }
//  646         else
//  647         {
//  648             returnCode = gNV_ERR_CHANGEPROT_c;
??NV_EERAMSetProtection_4:
        MOVS     R0,#+32
        MOVS     R4,R0
//  649         }
//  650         return(returnCode);
??NV_EERAMSetProtection_5:
        MOVS     R0,R4
        B.N      ??NV_EERAMSetProtection_1
//  651     }
//  652     /* if unprotected or special mode */
//  653     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FEPROT_OFFSET_c, protectStatus);
??NV_EERAMSetProtection_3:
        LDR      R0,[R2, #+0]
        STRB     R1,[R0, #+22]
//  654 
//  655     return(returnCode);
        MOVS     R0,R4
??NV_EERAMSetProtection_1:
        POP      {R4-R6}
        BX       LR               ;; return
//  656 }
//  657 
//  658 
//  659 /***********************************************************************
//  660  *
//  661  *  Function Name    : NV_FlashCheckSum
//  662  *  Description      : This function is used to calculate checksum value
//  663  *                     for the specified flash range.
//  664  *  Arguments        : [IN] pConfig - pointer to NV configuration
//  665  *                     [IN] destination - destination address
//  666  *                     [IN] size - length of data
//  667  *                     [OUT] pSum - pointer to the location where the
//  668  *                                  calculated checksum will be place
//  669  *  Return Value     : uint32_t
//  670  *
//  671  ************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  672 uint32_t NV_FlashCheckSum
//  673 (
//  674         pNvConfig_t pConfig,
//  675         uint32_t destination,
//  676         uint32_t size,
//  677         uint32_t* pSum
//  678 )
//  679 {
NV_FlashCheckSum:
        PUSH     {R4-R7}
        MOVS     R4,R0
//  680     uint32_t data;             /* Data read from Flash address */
//  681     uint32_t endAddress;       /* P Flash end address */
//  682 
//  683     /* calculating Flash end address */
//  684     endAddress = destination + size;
        ADDS     R0,R2,R1
        MOVS     R6,R0
//  685 
//  686     /* check for valid range of the target addresses */
//  687     if((destination < pConfig->PFlashBlockBase) || \ 
//  688             (endAddress > (pConfig->PFlashBlockBase + pConfig->PFlashBlockSize)))
        LDR      R0,[R4, #+4]
        CMP      R1,R0
        BCC.N    ??NV_FlashCheckSum_0
        LDR      R0,[R4, #+4]
        LDR      R7,[R4, #+8]
        ADDS     R0,R7,R0
        CMP      R0,R6
        BCS.N    ??NV_FlashCheckSum_1
//  689     {
//  690         if((destination < pConfig->DFlashBlockBase) || \ 
//  691                 (endAddress > (pConfig->DFlashBlockBase + pConfig->DFlashBlockSize)))
??NV_FlashCheckSum_0:
        LDR      R0,[R4, #+12]
        CMP      R1,R0
        BCC.N    ??NV_FlashCheckSum_2
        LDR      R0,[R4, #+12]
        LDR      R7,[R4, #+16]
        ADDS     R0,R7,R0
        CMP      R0,R6
        BCS.N    ??NV_FlashCheckSum_1
//  692         {
//  693             /* return an error code gNV_ERR_RANGE_c */
//  694             return(gNV_ERR_RANGE_c);
??NV_FlashCheckSum_2:
        MOVS     R0,#+2
        B.N      ??NV_FlashCheckSum_3
//  695         }
//  696     }
//  697 
//  698     *pSum = 0;
??NV_FlashCheckSum_1:
        MOVS     R0,#+0
        STR      R0,[R3, #+0]
//  699     /* doing sum operation */
//  700     while(destination < endAddress)
??NV_FlashCheckSum_4:
        CMP      R1,R6
        BCS.N    ??NV_FlashCheckSum_5
//  701     {
//  702         data = gNV_READ8(destination);
        LDRB     R0,[R1, #+0]
        MOVS     R5,R0
//  703         *pSum += (uint32_t)data;
        LDR      R0,[R3, #+0]
        ADDS     R0,R5,R0
        STR      R0,[R3, #+0]
//  704         destination += 1;
        ADDS     R1,R1,#+1
//  705         size -= 1;
        SUBS     R2,R2,#+1
        B.N      ??NV_FlashCheckSum_4
//  706     }
//  707 
//  708     return(gNV_OK_c);
??NV_FlashCheckSum_5:
        MOVS     R0,#+0
??NV_FlashCheckSum_3:
        POP      {R4-R7}
        BX       LR               ;; return
//  709 }
//  710 
//  711 
//  712 /************************************************************************
//  713  *
//  714  *  Function Name    : NV_FlashEraseAllBlock
//  715  *  Description      : The Erase All Blocks operation will erase all Flash
//  716  *                     memory, initialize the EERAM, verify all memory
//  717  *                     contents, then release MCU security.
//  718  *  Arguments        : [IN] pConfig - pointer to NV configuration
//  719  *  Return Value     : uint32_t
//  720  *
//  721  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  722 uint32_t NV_FlashEraseAllBlock
//  723 (
//  724         pNvConfig_t pConfig
//  725 )
//  726 {
NV_FlashEraseAllBlock:
        PUSH     {R4,LR}
        SUB      SP,SP,#+8
        MOVS     R4,R0
//  727     uint8_t commandArray[1];     /* command sequence array */
//  728 
//  729     /* preparing passing parameter to erase all flash blocks */
//  730     /* 1st element for the FCCOB register */
//  731     commandArray[0] = gNV_ERASE_ALL_BLOCK_c;
        MOVS     R0,#+68
        STRB     R0,[SP, #+0]
//  732 
//  733     /* calling flash command sequence function to execute the command */
//  734     return(NvFlashCommandSequence(pConfig, 0, commandArray));
        ADD      R2,SP,#+0
        MOVS     R1,#+0
        MOVS     R0,R4
        BL       NvFlashCommandSequence
        POP      {R1,R2,R4,PC}    ;; return
//  735 }
//  736 
//  737 
//  738 /************************************************************************
//  739  *
//  740  *  Function Name    : NV_FlashEraseBlock
//  741  *  Description      : The Erase Flash Block operation will erase all
//  742  *                     addresses in a single P-Flash or D-Flash block.
//  743  *  Arguments        : [IN] pConfig - pointer to NV configuration
//  744  *                     [IN] destination - destination address
//  745  *  Return Value     : uint32_t
//  746  *
//  747  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  748 uint32_t NV_FlashEraseBlock
//  749 (
//  750         pNvConfig_t pConfig,
//  751         uint32_t destination
//  752 )
//  753 {
NV_FlashEraseBlock:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
        MOVS     R5,R1
//  754     uint8_t pCommandArray[4]; /* command sequence array */
//  755 
//  756     /* check if the destination is longword aligned or not */
//  757     if (0 != (destination % gNV_ERSBLK_ALIGN_SIZE_c))
        MOVS     R0,#+4
        UDIV     R1,R5,R0
        MLS      R1,R1,R0,R5
        CMP      R1,#+0
        BEQ.N    ??NV_FlashEraseBlock_0
//  758     {
//  759         /* return an error code gNV_ERR_ADDR */
//  760         return(gNV_ERR_ADDR_c);
        MOV      R0,#+256
        B.N      ??NV_FlashEraseBlock_1
//  761     }
//  762 
//  763     /* check for valid range of the target addresses */
//  764     if((destination < pConfig->PFlashBlockBase) || \ 
//  765             (destination >= (pConfig->PFlashBlockBase + pConfig->PFlashBlockSize)))
??NV_FlashEraseBlock_0:
        LDR      R0,[R4, #+4]
        CMP      R5,R0
        BCC.N    ??NV_FlashEraseBlock_2
        LDR      R0,[R4, #+4]
        LDR      R1,[R4, #+8]
        ADDS     R0,R1,R0
        CMP      R5,R0
        BCC.N    ??NV_FlashEraseBlock_3
//  766     {
//  767         if((destination < pConfig->DFlashBlockBase) || \ 
//  768                 (destination >= (pConfig->DFlashBlockBase + pConfig->DFlashBlockSize)))
??NV_FlashEraseBlock_2:
        LDR      R0,[R4, #+12]
        CMP      R5,R0
        BCC.N    ??NV_FlashEraseBlock_4
        LDR      R0,[R4, #+12]
        LDR      R1,[R4, #+16]
        ADDS     R0,R1,R0
        CMP      R5,R0
        BCC.N    ??NV_FlashEraseBlock_5
//  769         {
//  770             /* return an error code gNV_ERR_RANGE_c */
//  771             return(gNV_ERR_RANGE_c);
??NV_FlashEraseBlock_4:
        MOVS     R0,#+2
        B.N      ??NV_FlashEraseBlock_1
//  772         }
//  773         else
//  774         {
//  775             /* Convert System memory address to FTFx internal memory address */
//  776             destination = destination - pConfig->DFlashBlockBase + 0x800000;
??NV_FlashEraseBlock_5:
        LDR      R0,[R4, #+12]
        SUBS     R0,R5,R0
        ADDS     R5,R0,#+8388608
        B.N      ??NV_FlashEraseBlock_6
//  777         }
//  778     }
//  779     else
//  780     {
//  781         /* Convert System memory address to FTFx internal memory address */
//  782         destination -= pConfig->PFlashBlockBase;
??NV_FlashEraseBlock_3:
        LDR      R0,[R4, #+4]
        SUBS     R5,R5,R0
//  783     }
//  784 
//  785     /* preparing passing parameter to erase a flash block */
//  786     pCommandArray[0] = gNV_ERASE_BLOCK_c;
??NV_FlashEraseBlock_6:
        MOVS     R0,#+8
        STRB     R0,[SP, #+0]
//  787     pCommandArray[1] = (uint8_t)(destination >> 16);
        LSRS     R0,R5,#+16
        STRB     R0,[SP, #+1]
//  788     pCommandArray[2] = (uint8_t)((destination >> 8) & 0xFF);
        LSRS     R0,R5,#+8
        STRB     R0,[SP, #+2]
//  789     pCommandArray[3] = (uint8_t)(destination & 0xFF);
        MOVS     R0,R5
        STRB     R0,[SP, #+3]
//  790 
//  791     /* calling flash command sequence function to execute the command */
//  792     return(NvFlashCommandSequence(pConfig, 3, pCommandArray));
        ADD      R2,SP,#+0
        MOVS     R1,#+3
        MOVS     R0,R4
        BL       NvFlashCommandSequence
??NV_FlashEraseBlock_1:
        POP      {R1,R4,R5,PC}    ;; return
//  793 }
//  794 
//  795 
//  796 /************************************************************************
//  797  *
//  798  *  Function Name    : NV_FlashEraseSuspend
//  799  *  Description      : This function is used to suspend a current operation
//  800  *                     of flash erase sector command.
//  801  *  Arguments        : [IN] pConfig - pointer to NV configuration
//  802  *  Return Value     : uint32_t
//  803  *
//  804  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  805 uint32_t NV_FlashEraseSuspend
//  806 (
//  807         pNvConfig_t pConfig
//  808 )
//  809 {
NV_FlashEraseSuspend:
        MOVS     R1,R0
//  810 
//  811     /* check CCIF bit of the flash status register */
//  812     if(FALSE == (gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c)))
        LDR      R0,[R1, #+0]
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+24
        BMI.N    ??NV_FlashEraseSuspend_0
//  813     {
//  814         /* If the command write sequence in progressing, */
//  815         /* Set ERSSUSP bit in FCNFG register */
//  816         gNV_REG_BIT_SET(pConfig->ftfxRegBase + gNV_FCNFG_OFFSET_c, gNV_FCNFG_ERSSUSP_c);
        LDR      R0,[R1, #+0]
        LDRB     R0,[R0, #+1]
        ORRS     R0,R0,#0x10
        LDR      R2,[R1, #+0]
        STRB     R0,[R2, #+1]
//  817     }
//  818 
//  819     return(gNV_OK_c);
??NV_FlashEraseSuspend_0:
        MOVS     R0,#+0
        BX       LR               ;; return
//  820 }
//  821 
//  822 
//  823 /************************************************************************
//  824  *
//  825  *  Function Name    : NV_FlashEraseResume
//  826  *  Description      : This function is used to resume a previous suspended
//  827  *                     operation of flash erase sector command.
//  828  *  Arguments        : [IN] pConfig - pointer to NV configuration
//  829  *  Return Value     : uint32_t
//  830  *
//  831  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  832 uint32_t NV_FlashEraseResume
//  833 (
//  834         pNvConfig_t pConfig
//  835 )
//  836 {
NV_FlashEraseResume:
        MOVS     R1,R0
//  837 
//  838     /* check ERSSUSP bit of the flash configuration register */
//  839     if(TRUE == (gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FCNFG_OFFSET_c, gNV_FCNFG_ERSSUSP_c)))
        LDR      R0,[R1, #+0]
        LDRB     R2,[R0, #+1]
//  840     {
//  841         /* If the ERSSUSP bit is set, */
//  842         /* Clear CCIF bit to resumimg the previous suspended Erasing */
//  843         gNV_REG_BIT_CLEAR(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c);
//  844     }
//  845 
//  846     return(gNV_OK_c);
        MOVS     R0,#+0
        BX       LR               ;; return
//  847 }
//  848 
//  849 
//  850 /****************************************************************************
//  851  *
//  852  *  Function Name    : NV_FlashEraseSector
//  853  *  Description      : Perform erase operation on Flash
//  854  *  Arguments        : [IN] pConfig - pointer to NV configuration
//  855  *                     [IN] destination - destination address
//  856  *                     [IN] size - data size
//  857  *  Return Value     : uint32_t
//  858  *
//  859  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  860 uint32_t NV_FlashEraseSector
//  861 (
//  862         pNvConfig_t pConfig,
//  863         uint32_t destination,
//  864         uint32_t size
//  865 )
//  866 {
NV_FlashEraseSector:
        PUSH     {R3-R9,LR}
        MOVS     R4,R0
        MOV      R9,R1
        MOVS     R5,R2
//  867     uint8_t pCommandArray[4]; /* command sequence array */
//  868     uint32_t returnCode;      /* return code variable */
//  869     uint32_t endAddress;      /* storing end address */
//  870     uint32_t sectorSize;      /* size of one sector */
//  871         
//  872     /* set the default return code as gNV_OK_c */
//  873     returnCode = gNV_OK_c;
        MOVS     R0,#+0
        MOVS     R6,R0
//  874 
//  875     /* calculating Flash end address */
//  876     endAddress = destination + size;
        ADDS     R0,R5,R9
        MOVS     R7,R0
//  877 
//  878     /* check for valid range of the target addresses */
//  879     if((destination < pConfig->PFlashBlockBase) || \ 
//  880             (endAddress > (pConfig->PFlashBlockBase + pConfig->PFlashBlockSize)))
        LDR      R0,[R4, #+4]
        CMP      R9,R0
        BCC.N    ??NV_FlashEraseSector_0
        LDR      R0,[R4, #+4]
        LDR      R1,[R4, #+8]
        ADDS     R0,R1,R0
        CMP      R0,R7
        BCS.N    ??NV_FlashEraseSector_1
//  881     {
//  882         if((destination < pConfig->DFlashBlockBase) || \ 
//  883                 (endAddress > (pConfig->DFlashBlockBase + pConfig->DFlashBlockSize)))
??NV_FlashEraseSector_0:
        LDR      R0,[R4, #+12]
        CMP      R9,R0
        BCC.N    ??NV_FlashEraseSector_2
        LDR      R0,[R4, #+12]
        LDR      R1,[R4, #+16]
        ADDS     R0,R1,R0
        CMP      R0,R7
        BCS.N    ??NV_FlashEraseSector_3
//  884         {
//  885             /* return an error code gNV_ERR_RANGE_c */
//  886             return(gNV_ERR_RANGE_c);
??NV_FlashEraseSector_2:
        MOVS     R0,#+2
        B.N      ??NV_FlashEraseSector_4
//  887         }
//  888         else
//  889         {
//  890             /* Convert System memory address to FTFx internal memory address */
//  891             destination = destination - pConfig->DFlashBlockBase + 0x800000;
??NV_FlashEraseSector_3:
        LDR      R0,[R4, #+12]
        SUBS     R0,R9,R0
        ADDS     R9,R0,#+8388608
//  892             sectorSize = gNV_DSECTOR_SIZE_c;
        MOVS     R0,#+0
        MOV      R8,R0
        B.N      ??NV_FlashEraseSector_5
//  893         }
//  894     }
//  895     else
//  896     {
//  897         /* Convert System memory address to FTFx internal memory address */
//  898         destination -= pConfig->PFlashBlockBase;
??NV_FlashEraseSector_1:
        LDR      R0,[R4, #+4]
        SUBS     R9,R9,R0
//  899         sectorSize = gNV_PSECTOR_SIZE_c;
        MOV      R0,#+2048
        MOV      R8,R0
//  900     }
//  901 
//  902     /* check if the destination is sector aligned or not */
//  903     if (0 != (destination % sectorSize))
??NV_FlashEraseSector_5:
        UDIV     R0,R9,R8
        MLS      R0,R8,R0,R9
        CMP      R0,#+0
        BEQ.N    ??NV_FlashEraseSector_6
//  904     {
//  905         /* return an error code gNV_ERR_ADDR */
//  906         return(gNV_ERR_ADDR_c);
        MOV      R0,#+256
        B.N      ??NV_FlashEraseSector_4
//  907     }
//  908 
//  909     /* check if the size is sector alignment or not */
//  910     if(0 != (size % sectorSize))
??NV_FlashEraseSector_6:
        UDIV     R0,R5,R8
        MLS      R0,R8,R0,R5
        CMP      R0,#+0
        BEQ.N    ??NV_FlashEraseSector_7
//  911     {
//  912         /* return an error code gNV_ERR_SIZE */
//  913         return(gNV_ERR_SIZE_c);
        MOVS     R0,#+1
        B.N      ??NV_FlashEraseSector_4
//  914     }
//  915 
//  916     while(size > 0)
??NV_FlashEraseSector_7:
        CMP      R5,#+0
        BEQ.N    ??NV_FlashEraseSector_8
//  917     {
//  918         /* preparing passing parameter to erase a flash block */
//  919         pCommandArray[0] = gNV_ERASE_SECTOR_c;
        MOVS     R0,#+9
        STRB     R0,[SP, #+0]
//  920         pCommandArray[1] = (uint8_t)(destination >> 16);
        LSRS     R0,R9,#+16
        STRB     R0,[SP, #+1]
//  921         pCommandArray[2] = (uint8_t)((destination >> 8) & 0xFF);
        LSRS     R0,R9,#+8
        STRB     R0,[SP, #+2]
//  922         pCommandArray[3] = (uint8_t)(destination & 0xFF);
        MOV      R0,R9
        STRB     R0,[SP, #+3]
//  923                 
//  924         /* calling flash command sequence function to execute the command */
//  925         returnCode = NvFlashCommandSequence(pConfig, 3, pCommandArray);
        ADD      R2,SP,#+0
        MOVS     R1,#+3
        MOVS     R0,R4
        BL       NvFlashCommandSequence
        MOVS     R6,R0
//  926 
//  927         /* checking the success of command execution */
//  928         if(gNV_OK_c != returnCode)
        CMP      R6,#+0
        BNE.N    ??NV_FlashEraseSector_8
//  929         {
//  930             break;
//  931         }
//  932         else
//  933         {
//  934             /* update size and destination address */
//  935             size -= sectorSize;
??NV_FlashEraseSector_9:
        SUBS     R5,R5,R8
//  936             destination += sectorSize;
        ADDS     R9,R8,R9
        B.N      ??NV_FlashEraseSector_7
//  937         }
//  938     }
//  939 
//  940     return(returnCode);
??NV_FlashEraseSector_8:
        MOVS     R0,R6
??NV_FlashEraseSector_4:
        POP      {R1,R4-R9,PC}    ;; return
//  941 }
//  942 
//  943 
//  944 /************************************************************************
//  945  *
//  946  *  Function Name    : NV_FlashGetInterruptEnable
//  947  *  Description      : This function will read the FCNFG register and
//  948  *                     return the interrupt enable states for Flash
//  949  *                     interrupt types.
//  950  *  Arguments        : [IN] pConfig - pointer to NV configuration
//  951  *                     [OUT] interruptState - pointer to a memory location
//  952  *                           where the interrupt state shall be placed
//  953  *  Return Value     : uint32_t
//  954  *
//  955  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  956 uint32_t NV_FlashGetInterruptEnable
//  957 (
//  958         pNvConfig_t pConfig,
//  959         uint8_t* interruptState
//  960 )
//  961 {
NV_FlashGetInterruptEnable:
        PUSH     {R4}
        MOVS     R2,R0
//  962     /* store data read from flash register */
//  963     uint8_t  registerValue;
//  964 
//  965     /* Initial interrupt state value */
//  966     *interruptState = 0;
        MOVS     R0,#+0
        STRB     R0,[R1, #+0]
//  967 
//  968     /*Get flash configuration register value */
//  969     registerValue = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCNFG_OFFSET_c);
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+1]
        MOVS     R3,R0
//  970 
//  971     /* Add command complete interrupt enable bit value */
//  972     /* CCIE bit of the FCNFG register */
//  973     *interruptState |= (registerValue & (gNV_FCNFG_CCIE_c | gNV_FCNFG_RDCOLLIE_c));
        LDRB     R0,[R1, #+0]
        ANDS     R4,R3,#0xC0
        ORRS     R0,R4,R0
        STRB     R0,[R1, #+0]
//  974 
//  975     return(gNV_OK_c);
        MOVS     R0,#+0
        POP      {R4}
        BX       LR               ;; return
//  976 }
//  977 
//  978 
//  979 /************************************************************************
//  980  *
//  981  *  Function Name    : NV_FlashGetSecurityState
//  982  *  Description      : This function retrieves the current Flash security
//  983  *                     status, including the security enabling state and
//  984  *                     the backdoor key enabling state.
//  985  *  Arguments        : [IN] pConfig - pointer to NV configuration
//  986  *                     [OUT] securityState - pointer to a memory location
//  987  *                           where the security state will be placed
//  988  *  Return Value     : uint32_t
//  989  *
//  990  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  991 uint32_t NV_FlashGetSecurityState
//  992 (
//  993         pNvConfig_t pConfig,
//  994         uint8_t* securityState
//  995 )
//  996 {
NV_FlashGetSecurityState:
        MOVS     R2,R0
//  997     /* store data read from flash register */
//  998     uint8_t  registerValue;
//  999 
// 1000     /*Get flash security register value */
// 1001     registerValue = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FSEC_OFFSET_c);
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+2]
        MOVS     R3,R0
// 1002 
// 1003     /* check the status of the flash security bits in the security register */
// 1004     if(gNV_FLASH_SECURITY_STATE_UNSECURED_c == (registerValue & gNV_FSEC_SEC_c))
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        ANDS     R0,R3,#0x3
        CMP      R0,#+2
        BNE.N    ??NV_FlashGetSecurityState_0
// 1005     {
// 1006         /* Flash in unsecured state */
// 1007         *securityState = gNV_FLASH_NOT_SECURE_c;
        MOVS     R0,#+1
        STRB     R0,[R1, #+0]
        B.N      ??NV_FlashGetSecurityState_1
// 1008     }
// 1009     else
// 1010     {
// 1011         /* Flash in secured state */
// 1012         /* check for backdoor key security enable bit */
// 1013         if(gNV_FLASH_SECURITY_STATE_KEYEN_c == (registerValue & gNV_FSEC_KEYEN_c))
??NV_FlashGetSecurityState_0:
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        ANDS     R0,R3,#0xC0
        CMP      R0,#+128
        BNE.N    ??NV_FlashGetSecurityState_2
// 1014         {
// 1015             /* Backdoor key security enabled */
// 1016             *securityState = gNV_FLASH_SECURE_BACKDOOR_ENABLED_c;
        MOVS     R0,#+2
        STRB     R0,[R1, #+0]
        B.N      ??NV_FlashGetSecurityState_1
// 1017         }
// 1018         else
// 1019         {
// 1020             /* Backdoor key security disabled */
// 1021             *securityState = gNV_FLASH_SECURE_BACKDOOR_DISABLED_c;
??NV_FlashGetSecurityState_2:
        MOVS     R0,#+4
        STRB     R0,[R1, #+0]
// 1022         }
// 1023     }
// 1024 
// 1025     return(gNV_OK_c);
??NV_FlashGetSecurityState_1:
        MOVS     R0,#+0
        BX       LR               ;; return
// 1026 }
// 1027 
// 1028 
// 1029 /************************************************************************
// 1030  *
// 1031  *  Function Name    : NV_FlashProgramCheck
// 1032  *  Description      : The Program Check command tests a previously
// 1033  *                     programmed P-Flash or D-Flash longword to see
// 1034  *                     if it reads correctly at the specified margin level.
// 1035  *  Arguments        : [IN] pConfig - pointer to NV configuration
// 1036  *                     [IN] destination - destination address
// 1037  *                     [IN] size - block size to be checked
// 1038  *                     [IN] pExpectedData - pointer to a memory location where
// 1039  *                          the expected data is stored
// 1040  *                     [IN] pFailAddr - pointer to a memory location where the
// 1041  *                          failed address will be stored
// 1042  *                     [IN] pFailData - pointer to a memory location where
// 1043  *                          failed data will be stored
// 1044  *                     [IN] marginLevel - read margin level
// 1045  *
// 1046  *  Return Value     : uint32_t
// 1047  *
// 1048  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1049 uint32_t NV_FlashProgramCheck
// 1050 (
// 1051         pNvConfig_t pConfig,
// 1052         uint32_t  destination,
// 1053         uint32_t  size,
// 1054         uint8_t*  pExpectedData,
// 1055         uint8_t   marginLevel
// 1056 )
// 1057 {
NV_FlashProgramCheck:
        PUSH     {R1-R9,LR}
        MOVS     R5,R0
        MOV      R9,R1
        MOVS     R6,R2
        MOVS     R7,R3
        LDR      R4,[SP, #+40]
// 1058     uint8_t pCommandArray[12]; /* command sequence array */
// 1059     uint32_t returnCode;       /* return code variable */
// 1060 
// 1061     /* set the default return code as gNV_OK_c */
// 1062     returnCode = gNV_OK_c;
        MOVS     R0,#+0
        MOV      R8,R0
// 1063 
// 1064     /* check if the destination is Longword aligned or not */
// 1065     if (0 != (destination % gNV_PGMCHK_ALIGN_SIZE_c))
        MOVS     R0,#+4
        UDIV     R1,R9,R0
        MLS      R1,R1,R0,R9
        CMP      R1,#+0
        BEQ.N    ??NV_FlashProgramCheck_0
// 1066     {
// 1067         /* return an error code gNV_ERR_ADDR */
// 1068         return(gNV_ERR_ADDR_c);
        MOV      R0,#+256
        B.N      ??NV_FlashProgramCheck_1
// 1069     }
// 1070 
// 1071     /* check if the size is Longword aligned or not */
// 1072     if (0 != size % gNV_PGMCHK_ALIGN_SIZE_c)
??NV_FlashProgramCheck_0:
        MOVS     R0,#+4
        UDIV     R1,R6,R0
        MLS      R1,R1,R0,R6
        CMP      R1,#+0
        BEQ.N    ??NV_FlashProgramCheck_2
// 1073     {
// 1074         /* return an error code gNV_ERR_ADDR */
// 1075         return(gNV_ERR_SIZE_c);
        MOVS     R0,#+1
        B.N      ??NV_FlashProgramCheck_1
// 1076     }
// 1077 
// 1078     /* check for valid range of the target addresses */
// 1079     if((destination < pConfig->PFlashBlockBase) || \ 
// 1080             ((destination+size) > (pConfig->PFlashBlockBase + pConfig->PFlashBlockSize)))
??NV_FlashProgramCheck_2:
        LDR      R0,[R5, #+4]
        CMP      R9,R0
        BCC.N    ??NV_FlashProgramCheck_3
        LDR      R0,[R5, #+4]
        LDR      R1,[R5, #+8]
        ADDS     R0,R1,R0
        ADDS     R1,R6,R9
        CMP      R0,R1
        BCS.N    ??NV_FlashProgramCheck_4
// 1081     {
// 1082         if((destination < pConfig->DFlashBlockBase) || \ 
// 1083                 ((destination+size) > (pConfig->DFlashBlockBase + pConfig->DFlashBlockSize)))
??NV_FlashProgramCheck_3:
        LDR      R0,[R5, #+12]
        CMP      R9,R0
        BCC.N    ??NV_FlashProgramCheck_5
        LDR      R0,[R5, #+12]
        LDR      R1,[R5, #+16]
        ADDS     R0,R1,R0
        ADDS     R1,R6,R9
        CMP      R0,R1
        BCS.N    ??NV_FlashProgramCheck_6
// 1084         {
// 1085             /* return an error code gNV_ERR_RANGE_c */
// 1086             return(gNV_ERR_RANGE_c);
??NV_FlashProgramCheck_5:
        MOVS     R0,#+2
        B.N      ??NV_FlashProgramCheck_1
// 1087         }
// 1088         else
// 1089         {
// 1090             /* Convert System memory address to FTFx internal memory address */
// 1091             destination = destination - pConfig->DFlashBlockBase + 0x800000;
??NV_FlashProgramCheck_6:
        LDR      R0,[R5, #+12]
        SUBS     R0,R9,R0
        ADDS     R9,R0,#+8388608
        B.N      ??NV_FlashProgramCheck_7
// 1092         }
// 1093     }
// 1094     else
// 1095     {
// 1096         /* Convert System memory address to FTFx internal memory address */
// 1097         destination -= pConfig->PFlashBlockBase;
??NV_FlashProgramCheck_4:
        LDR      R0,[R5, #+4]
        SUBS     R9,R9,R0
// 1098     }
// 1099     while (size)
??NV_FlashProgramCheck_7:
        CMP      R6,#+0
        BEQ.N    ??NV_FlashProgramCheck_8
// 1100     {
// 1101 
// 1102         /* preparing passing parameter to program check the flash block */
// 1103         pCommandArray[0] = gNV_PROGRAM_CHECK_c;
        MOVS     R0,#+2
        STRB     R0,[SP, #+0]
// 1104         pCommandArray[1] = (uint8_t)(destination >> 16);
        LSRS     R0,R9,#+16
        STRB     R0,[SP, #+1]
// 1105         pCommandArray[2] = (uint8_t)((destination >> 8) & 0xFF);
        LSRS     R0,R9,#+8
        STRB     R0,[SP, #+2]
// 1106         pCommandArray[3] = (uint8_t)(destination & 0xFF);
        MOV      R0,R9
        STRB     R0,[SP, #+3]
// 1107         pCommandArray[4] = marginLevel;
        STRB     R4,[SP, #+4]
// 1108 
// 1109         pCommandArray[8] = *(pExpectedData+3);
        LDRB     R0,[R7, #+3]
        STRB     R0,[SP, #+8]
// 1110         pCommandArray[9] = *(pExpectedData+2);
        LDRB     R0,[R7, #+2]
        STRB     R0,[SP, #+9]
// 1111         pCommandArray[10] = *(pExpectedData+1);
        LDRB     R0,[R7, #+1]
        STRB     R0,[SP, #+10]
// 1112         pCommandArray[11] = *pExpectedData;
        LDRB     R0,[R7, #+0]
        STRB     R0,[SP, #+11]
// 1113 
// 1114         /* calling flash command sequence function to execute the command */
// 1115         returnCode = NvFlashCommandSequence(pConfig, 11, pCommandArray);
        ADD      R2,SP,#+0
        MOVS     R1,#+11
        MOVS     R0,R5
        BL       NvFlashCommandSequence
        MOV      R8,R0
// 1116 
// 1117         /* checking for the success of command execution */
// 1118         if(gNV_OK_c != returnCode)
        CMP      R8,#+0
        BEQ.N    ??NV_FlashProgramCheck_9
// 1119         {
// 1120             return(returnCode);
        MOV      R0,R8
        B.N      ??NV_FlashProgramCheck_1
// 1121         }
// 1122 
// 1123         size-=gNV_LONGWORD_SIZE_c;
??NV_FlashProgramCheck_9:
        SUBS     R6,R6,#+4
// 1124         pExpectedData+=gNV_LONGWORD_SIZE_c;
        ADDS     R7,R7,#+4
// 1125         destination+= gNV_LONGWORD_SIZE_c;
        ADDS     R9,R9,#+4
        B.N      ??NV_FlashProgramCheck_7
// 1126     }
// 1127 
// 1128     return(returnCode);
??NV_FlashProgramCheck_8:
        MOV      R0,R8
??NV_FlashProgramCheck_1:
        POP      {R1-R9,PC}       ;; return
// 1129 }
// 1130 
// 1131 
// 1132 /************************************************************************
// 1133  *
// 1134  *  Function Name    : NV_FlashProgramLongword
// 1135  *  Description      : Program data into Flash
// 1136  *  Arguments        : [IN] pConfig - pointer to NV configuration
// 1137  *                     [IN] destination - destination address
// 1138  *                     [IN] size - data set size
// 1139  *                     [IN] source - source address
// 1140  *  Return Value     : uint32_t
// 1141  *
// 1142  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1143 uint32_t NV_FlashProgramLongword
// 1144 (
// 1145         pNvConfig_t pConfig,
// 1146         uint32_t destination,
// 1147         uint32_t size,
// 1148         uint32_t source
// 1149 )
// 1150 {
NV_FlashProgramLongword:
        PUSH     {R1-R11,LR}
        MOVS     R4,R0
        MOV      R11,R1
        MOV      R10,R2
        MOVS     R5,R3
// 1151     uint8_t pCommandArray[8]; /* command sequence array */
// 1152     uint32_t returnCode;      /* return code variable */
// 1153     uint32_t endAddress;      /* storing end address */
// 1154     uint8_t loopCnt;          /* loop counter */
// 1155 
// 1156     uint8_t paddingBytes[4] = {0xFF, 0xFF, 0xFF, 0xFF};
        ADD      R0,SP,#+8
        LDR.N    R1,??DataTable2_2
        LDR      R2,[R1, #0]
        STR      R2,[R0, #+0]
// 1157     uint8_t paddingBytesCnt = 0;
        MOVS     R9,#+0
// 1158     
// 1159     /* set the default return code as gNV_OK_c */
// 1160     returnCode = gNV_OK_c;
        MOVS     R0,#+0
        MOVS     R6,R0
// 1161 
// 1162     /* calculating Flash end address */
// 1163     endAddress = destination + size;
        ADDS     R0,R10,R11
        MOVS     R7,R0
// 1164 
// 1165     /* check if the destination is longword aligned or not */
// 1166     if((destination & (~0x03uL)) != destination)
        LSRS     R0,R11,#+2
        LSLS     R0,R0,#+2
        CMP      R0,R11
        BEQ.N    ??NV_FlashProgramLongword_0
// 1167     {
// 1168         /* align to next 32 bit boundary */
// 1169         destination &= ~0x03uL;
        LSRS     R11,R11,#+2
        LSLS     R11,R11,#+2
// 1170         destination += gNV_LONGWORD_SIZE_c;
        ADDS     R11,R11,#+4
// 1171     }
// 1172 
// 1173     paddingBytesCnt = size % gNV_LONGWORD_SIZE_c;
??NV_FlashProgramLongword_0:
        MOVS     R0,#+4
        UDIV     R1,R10,R0
        MLS      R1,R1,R0,R10
        MOV      R9,R1
// 1174 
// 1175     /* check if the size is Longword alignment or not */
// 1176 
// 1177     if(0 != paddingBytesCnt)
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R9,#+0
        BEQ.N    ??NV_FlashProgramLongword_1
// 1178     {
// 1179         size -= paddingBytesCnt;
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        SUBS     R10,R10,R9
// 1180         EffectiveWrBytesCnt = size + gNV_LONGWORD_SIZE_c;
        ADDS     R0,R10,#+4
        LDR.N    R1,??DataTable2_3
        STR      R0,[R1, #+0]
        B.N      ??NV_FlashProgramLongword_2
// 1181     }
// 1182     else
// 1183     {
// 1184         EffectiveWrBytesCnt = size;
??NV_FlashProgramLongword_1:
        LDR.N    R0,??DataTable2_3
        STR      R10,[R0, #+0]
// 1185     }
// 1186 
// 1187     /* check for valid range of the target addresses */
// 1188     if((destination < pConfig->PFlashBlockBase) || \ 
// 1189             (endAddress > (pConfig->PFlashBlockBase + pConfig->PFlashBlockSize)))
??NV_FlashProgramLongword_2:
        LDR      R0,[R4, #+4]
        CMP      R11,R0
        BCC.N    ??NV_FlashProgramLongword_3
        LDR      R0,[R4, #+4]
        LDR      R1,[R4, #+8]
        ADDS     R0,R1,R0
        CMP      R0,R7
        BCS.N    ??NV_FlashProgramLongword_4
// 1190     {
// 1191         if((destination < pConfig->DFlashBlockBase) || \ 
// 1192                 (endAddress > (pConfig->DFlashBlockBase + pConfig->DFlashBlockSize)))
??NV_FlashProgramLongword_3:
        LDR      R0,[R4, #+12]
        CMP      R11,R0
        BCC.N    ??NV_FlashProgramLongword_5
        LDR      R0,[R4, #+12]
        LDR      R1,[R4, #+16]
        ADDS     R0,R1,R0
        CMP      R0,R7
        BCS.N    ??NV_FlashProgramLongword_6
// 1193         {
// 1194             /* return an error code gNV_ERR_RANGE_c */
// 1195             return(gNV_ERR_RANGE_c);
??NV_FlashProgramLongword_5:
        MOVS     R0,#+2
        B.N      ??NV_FlashProgramLongword_7
// 1196         }
// 1197         else
// 1198         {
// 1199             /* Convert System memory address to FTFx internal memory address */
// 1200             destination = destination - pConfig->DFlashBlockBase + 0x800000;
??NV_FlashProgramLongword_6:
        LDR      R0,[R4, #+12]
        SUBS     R0,R11,R0
        ADDS     R11,R0,#+8388608
        B.N      ??NV_FlashProgramLongword_8
// 1201         }
// 1202     }
// 1203     else
// 1204     {
// 1205         /* Convert System memory address to FTFx internal memory address */
// 1206         destination -= pConfig->PFlashBlockBase;
??NV_FlashProgramLongword_4:
        LDR      R0,[R4, #+4]
        SUBS     R11,R11,R0
// 1207     }
// 1208 
// 1209     while(size > 0)
??NV_FlashProgramLongword_8:
        CMP      R10,#+0
        BEQ.N    ??NV_FlashProgramLongword_9
// 1210     {
// 1211         /* preparing passing parameter to program the flash block */
// 1212         pCommandArray[0] = gNV_PROGRAM_LONGWORD_c;
        MOVS     R0,#+6
        STRB     R0,[SP, #+0]
// 1213         pCommandArray[1] = (uint8_t)(destination >> 16);
        LSRS     R0,R11,#+16
        STRB     R0,[SP, #+1]
// 1214         pCommandArray[2] = (uint8_t)((destination >> 8) & 0xFF);
        LSRS     R0,R11,#+8
        STRB     R0,[SP, #+2]
// 1215         pCommandArray[3] = (uint8_t)(destination & 0xFF);
        MOV      R0,R11
        STRB     R0,[SP, #+3]
// 1216 
// 1217         pCommandArray[4] = gNV_READ8(source + 3);
        LDRB     R0,[R5, #+3]
        STRB     R0,[SP, #+4]
// 1218         pCommandArray[5] = gNV_READ8(source + 2);
        LDRB     R0,[R5, #+2]
        STRB     R0,[SP, #+5]
// 1219         pCommandArray[6] = gNV_READ8(source + 1);
        LDRB     R0,[R5, #+1]
        STRB     R0,[SP, #+6]
// 1220         pCommandArray[7] = gNV_READ8(source);
        LDRB     R0,[R5, #+0]
        STRB     R0,[SP, #+7]
// 1221               
// 1222         /* calling flash command sequence function to execute the command */
// 1223         returnCode = NvFlashCommandSequence(pConfig, 7, pCommandArray);
        ADD      R2,SP,#+0
        MOVS     R1,#+7
        MOVS     R0,R4
        BL       NvFlashCommandSequence
        MOVS     R6,R0
// 1224 
// 1225         /* checking for the success of command execution */
// 1226         if(gNV_OK_c != returnCode)
        CMP      R6,#+0
        BNE.N    ??NV_FlashProgramLongword_9
// 1227         {
// 1228             break;
// 1229         }
// 1230         else
// 1231         {
// 1232             /* update destination address for next iteration */
// 1233             destination += gNV_LONGWORD_SIZE_c;
??NV_FlashProgramLongword_10:
        ADDS     R11,R11,#+4
// 1234             /* update size for next iteration */
// 1235             size -= gNV_LONGWORD_SIZE_c;
        SUBS     R10,R10,#+4
// 1236             /* increment the source address */
// 1237             source += gNV_LONGWORD_SIZE_c;
        ADDS     R5,R5,#+4
        B.N      ??NV_FlashProgramLongword_8
// 1238         }
// 1239     }
// 1240 
// 1241     if(0 != paddingBytesCnt)
??NV_FlashProgramLongword_9:
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R9,#+0
        BEQ.N    ??NV_FlashProgramLongword_11
// 1242     {
// 1243         /* add padding bytes */
// 1244 
// 1245         for(loopCnt = 0; loopCnt < paddingBytesCnt; loopCnt++)
        MOVS     R0,#+0
        MOV      R8,R0
??NV_FlashProgramLongword_12:
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R8,R9
        BCS.N    ??NV_FlashProgramLongword_13
// 1246         {
// 1247             paddingBytes[loopCnt] = gNV_READ8(source++);
        LDRB     R0,[R5, #+0]
        ADDS     R5,R5,#+1
        ADD      R1,SP,#+8
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRB     R0,[R8, R1]
// 1248         }
        ADDS     R8,R8,#+1
        B.N      ??NV_FlashProgramLongword_12
// 1249 
// 1250         /* preparing passing parameter to program the flash block */
// 1251         pCommandArray[0] = gNV_PROGRAM_LONGWORD_c;
??NV_FlashProgramLongword_13:
        MOVS     R0,#+6
        STRB     R0,[SP, #+0]
// 1252         pCommandArray[1] = (uint8_t)(destination >> 16);
        LSRS     R0,R11,#+16
        STRB     R0,[SP, #+1]
// 1253         pCommandArray[2] = (uint8_t)((destination >> 8) & 0xFF);
        LSRS     R0,R11,#+8
        STRB     R0,[SP, #+2]
// 1254         pCommandArray[3] = (uint8_t)(destination & 0xFF);
        MOV      R0,R11
        STRB     R0,[SP, #+3]
// 1255 
// 1256         pCommandArray[4] = paddingBytes[3];
        LDRB     R0,[SP, #+11]
        STRB     R0,[SP, #+4]
// 1257         pCommandArray[5] = paddingBytes[2];
        LDRB     R0,[SP, #+10]
        STRB     R0,[SP, #+5]
// 1258         pCommandArray[6] = paddingBytes[1];
        LDRB     R0,[SP, #+9]
        STRB     R0,[SP, #+6]
// 1259         pCommandArray[7] = paddingBytes[0];
        LDRB     R0,[SP, #+8]
        STRB     R0,[SP, #+7]
// 1260         
// 1261         /* calling flash command sequence function to execute the command */
// 1262         returnCode = NvFlashCommandSequence(pConfig, 7, pCommandArray);
        ADD      R2,SP,#+0
        MOVS     R1,#+7
        MOVS     R0,R4
        BL       NvFlashCommandSequence
        MOVS     R6,R0
// 1263     }
// 1264 
// 1265     return(returnCode);
??NV_FlashProgramLongword_11:
        MOVS     R0,R6
??NV_FlashProgramLongword_7:
        POP      {R1-R11,PC}      ;; return
// 1266 }
// 1267 
// 1268 /************************************************************************
// 1269  *
// 1270  *  Function Name    : NV_FlashProgramUnalignedLongword
// 1271  *  Description      : Program data into Flash. The address can be unaligned
// 1272  *  Arguments        : [IN] pConfig - pointer to NV configuration
// 1273  *                     [IN] destination - destination address
// 1274  *                     [IN] size - data set size
// 1275  *                     [IN] source - source address
// 1276  *  Return Value     : uint32_t
// 1277  *
// 1278  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1279 uint32_t NV_FlashProgramUnalignedLongword
// 1280 (
// 1281         pNvConfig_t pConfig,
// 1282         uint32_t destination,
// 1283         uint32_t size,
// 1284         uint32_t source
// 1285 )
// 1286 {
NV_FlashProgramUnalignedLongword:
        PUSH     {R3-R11,LR}
        MOVS     R4,R0
        MOV      R11,R1
        MOVS     R5,R2
        MOVS     R6,R3
// 1287   uint8_t i, bytes = destination & 0x03;
        ANDS     R8,R11,#0x3
// 1288   uint32_t tmp;
// 1289   uint8_t alignWord[4] = {0xFF, 0xFF, 0xFF, 0xFF};
        ADD      R0,SP,#+0
        LDR.N    R1,??DataTable2_4
        LDR      R2,[R1, #0]
        STR      R2,[R0, #+0]
// 1290 
// 1291   if (bytes)
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+0
        BEQ.N    ??NV_FlashProgramUnalignedLongword_0
// 1292   {
// 1293 	uint32_t *pAddress;  
// 1294 	  
// 1295     /* Go to previous aligned address */
// 1296     destination &= ~((uint32_t)0x03);
        LSRS     R11,R11,#+2
        LSLS     R11,R11,#+2
// 1297 
// 1298     /* Read LongWord from flash */
// 1299     pAddress = (uint32_t*)alignWord; 
        ADD      R0,SP,#+0
        MOV      R10,R0
// 1300     *pAddress = gNV_READ32(destination); // to suppress GCC compiler warning
        LDR      R0,[R11, #+0]
        STR      R0,[R10, #+0]
// 1301    
// 1302     /* Add the unaligned bytes */
// 1303     for (i = (gNV_LONGWORD_SIZE_c - bytes); i < gNV_LONGWORD_SIZE_c; i++)
        RSBS     R0,R8,#+4
        MOVS     R7,R0
??NV_FlashProgramUnalignedLongword_1:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+4
        BGE.N    ??NV_FlashProgramUnalignedLongword_2
// 1304       alignWord[i] = gNV_READ8(source++);
        LDRB     R0,[R6, #+0]
        ADDS     R6,R6,#+1
        ADD      R1,SP,#+0
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        STRB     R0,[R7, R1]
        ADDS     R7,R7,#+1
        B.N      ??NV_FlashProgramUnalignedLongword_1
// 1305 
// 1306     /* Write the new LongWord */
// 1307     tmp = NV_FlashProgramLongword(pConfig, destination, gNV_LONGWORD_SIZE_c, (uint32_t)&alignWord);
??NV_FlashProgramUnalignedLongword_2:
        ADD      R3,SP,#+0
        MOVS     R2,#+4
        MOV      R1,R11
        MOVS     R0,R4
        BL       NV_FlashProgramLongword
        MOV      R9,R0
// 1308 
// 1309     if (gNV_OK_c != tmp)
        CMP      R9,#+0
        BEQ.N    ??NV_FlashProgramUnalignedLongword_3
// 1310       return tmp;
        MOV      R0,R9
        B.N      ??NV_FlashProgramUnalignedLongword_4
// 1311 
// 1312     destination += gNV_LONGWORD_SIZE_c;
??NV_FlashProgramUnalignedLongword_3:
        ADDS     R11,R11,#+4
// 1313     size -= bytes;
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        SUBS     R5,R5,R8
// 1314   }
// 1315 
// 1316   return NV_FlashProgramLongword(pConfig, destination, size, source);
??NV_FlashProgramUnalignedLongword_0:
        MOVS     R3,R6
        MOVS     R2,R5
        MOV      R1,R11
        MOVS     R0,R4
        BL       NV_FlashProgramLongword
??NV_FlashProgramUnalignedLongword_4:
        POP      {R1,R4-R11,PC}   ;; return
// 1317 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2:
        DC32     0x40048044

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2_1:
        DC32     0x4004803c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2_2:
        DC32     ?_0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2_3:
        DC32     EffectiveWrBytesCnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2_4:
        DC32     ?_1
// 1318 
// 1319 /************************************************************************
// 1320  *
// 1321  *  Function Name    : NV_FlashRead
// 1322  *  Description      : Read data stored in flash memory
// 1323  *  Arguments        : [IN] address - flash memory address
// 1324  *                     [OUT] pData - pointer to a memory location
// 1325  *                                   where the data will be stored
// 1326  *                     [IN] len - data length to be read
// 1327  *  Return Value     : -
// 1328  *
// 1329  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1330 void NV_FlashRead
// 1331 (
// 1332         uint32_t address,
// 1333         uint8_t* pData,
// 1334         uint32_t len
// 1335 )
// 1336 {
// 1337     while(len--)
NV_FlashRead:
??NV_FlashRead_0:
        MOVS     R3,R2
        SUBS     R2,R3,#+1
        CMP      R3,#+0
        BEQ.N    ??NV_FlashRead_1
// 1338     {
// 1339         *pData++ = ((uint8_t)(*(vuint8_t*)(address++)));
        LDRB     R3,[R0, #+0]
        ADDS     R0,R0,#+1
        STRB     R3,[R1, #+0]
        ADDS     R1,R1,#+1
        B.N      ??NV_FlashRead_0
// 1340     }
// 1341 }
??NV_FlashRead_1:
        BX       LR               ;; return
// 1342 
// 1343 /************************************************************************
// 1344  *
// 1345  *  Function Name    : NV_FlashProgramOnce
// 1346  *  Description      : Program data into a dedicated 64 bytes region in
// 1347  *                     the P-Flash IFR which stores critical information
// 1348  *                     for the user
// 1349  *  Arguments        : [IN] pConfig - pointer to NV configuration
// 1350  *                     [IN] pDataArray - pointer to a memory location
// 1351  *                                       where the data is stored
// 1352  *  Return Value     : uint32_t
// 1353  *
// 1354  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1355 uint32_t NV_FlashProgramOnce
// 1356 (
// 1357         pNvConfig_t pConfig,
// 1358         uint8_t* pDataArray
// 1359 )
// 1360 {
NV_FlashProgramOnce:
        PUSH     {R2-R8,LR}
        MOVS     R4,R0
        MOVS     R5,R1
// 1361     uint8_t  counter;          /* outer loop counter */
// 1362     uint8_t  pCommandArray[8]; /* command sequence array */
// 1363     uint32_t returnCode;       /* return code variable */
// 1364     uint8_t i;                 /* variable to store record number index */
// 1365 
// 1366     /* set the default return code as gNV_OK_c */
// 1367     returnCode = gNV_OK_c;
        MOVS     R0,#+0
        MOVS     R7,R0
// 1368     /* set the counter value for 0 */
// 1369     counter = 0;
        MOVS     R0,#+0
        MOVS     R6,R0
// 1370     /* calculate record number index */
// 1371     i = (64 / (gNV_RDONCE_INDEX_MAX_c + 1));
        MOVS     R0,#+4
        MOV      R8,R0
// 1372 
// 1373     /* preparing passing parameter for program once command */
// 1374     /* 1st element for the FCCOB register */
// 1375     pCommandArray[0] = gNV_PROGRAM_ONCE_c;
        MOVS     R0,#+67
        STRB     R0,[SP, #+0]
// 1376 
// 1377     while (counter <= gNV_RDONCE_INDEX_MAX_c)
??NV_FlashProgramOnce_0:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+16
        BGE.N    ??NV_FlashProgramOnce_1
// 1378     {
// 1379         /* preparing the rest of the parameters to be passed for the FCCOB registers */
// 1380         pCommandArray[1] = counter;
        STRB     R6,[SP, #+1]
// 1381         pCommandArray[2] = 0x00;
        MOVS     R0,#+0
        STRB     R0,[SP, #+2]
// 1382         pCommandArray[3] = 0x00;
        MOVS     R0,#+0
        STRB     R0,[SP, #+3]
// 1383         pCommandArray[4] = pDataArray[counter*i];
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MLA      R0,R8,R6,R5
        LDRB     R0,[R0, #+0]
        STRB     R0,[SP, #+4]
// 1384         pCommandArray[5] = pDataArray[counter*i + 1];
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MLA      R0,R8,R6,R5
        LDRB     R0,[R0, #+1]
        STRB     R0,[SP, #+5]
// 1385         pCommandArray[6] = pDataArray[counter*i + 2];
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MLA      R0,R8,R6,R5
        LDRB     R0,[R0, #+2]
        STRB     R0,[SP, #+6]
// 1386         pCommandArray[7] = pDataArray[counter*i + 3];
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MLA      R0,R8,R6,R5
        LDRB     R0,[R0, #+3]
        STRB     R0,[SP, #+7]
// 1387 #if ((gNV_512K_512K_16K_4K_4K_c == gNV_Derivative_c) || (gNV_1024K_0K_16K_4K_0K_c == gNV_Derivative_c))                 
// 1388         pCommandArray[8] = pDataArray[counter*i + 4];
// 1389         pCommandArray[9] = pDataArray[counter*i + 5];
// 1390         pCommandArray[10] = pDataArray[counter*i + 6];
// 1391         pCommandArray[11] = pDataArray[counter*i + 7];
// 1392 #endif
// 1393 
// 1394         /* calling flash command sequence API to execute the command */
// 1395         returnCode = NvFlashCommandSequence(pConfig, i + 3, pCommandArray);
        ADD      R2,SP,#+0
        ADDS     R1,R8,#+3
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R4
        BL       NvFlashCommandSequence
        MOVS     R7,R0
// 1396 
// 1397         /* checking for the success of command execution */
// 1398         if(gNV_OK_c != returnCode)
        CMP      R7,#+0
        BNE.N    ??NV_FlashProgramOnce_1
// 1399         {
// 1400             break;
// 1401         }
// 1402 
// 1403         /* decrement the counter value */
// 1404         counter++;
??NV_FlashProgramOnce_2:
        ADDS     R6,R6,#+1
        B.N      ??NV_FlashProgramOnce_0
// 1405     }
// 1406 
// 1407     return(returnCode);
??NV_FlashProgramOnce_1:
        MOVS     R0,R7
        POP      {R1,R2,R4-R8,PC}  ;; return
// 1408 }
// 1409 
// 1410 
// 1411 /************************************************************************
// 1412  *
// 1413  *  Function Name    : NV_FlashProgramPhrase
// 1414  *  Description      : Program data into Flash
// 1415  *  Arguments        : [IN] pConfig - pointer to NV configuration
// 1416  *                     [IN] destination - destination address
// 1417  *                     [IN] size - size to be written
// 1418  *                     [IN] source - source address
// 1419  *  Return Value     : uint32_t
// 1420  *
// 1421  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1422 uint32_t NV_FlashProgramPhrase
// 1423 (
// 1424         pNvConfig_t pConfig,
// 1425         uint32_t destination,
// 1426         uint32_t size,
// 1427         uint32_t source
// 1428 )
// 1429 {
NV_FlashProgramPhrase:
        PUSH     {R1-R9,LR}
        MOVS     R4,R0
        MOV      R9,R1
        MOVS     R5,R2
        MOVS     R6,R3
// 1430     uint8_t pCommandArray[12]; /* command sequence array */
// 1431     uint32_t returnCode;       /* return code variable */
// 1432     uint32_t endAddress;       /* storing end address */
// 1433 
// 1434     /* set the default return code as gNV_OK_c */
// 1435     returnCode = gNV_OK_c;
        MOVS     R0,#+0
        MOVS     R7,R0
// 1436 
// 1437     /* calculating Flash end address */
// 1438     endAddress = destination + size;
        ADDS     R0,R5,R9
        MOV      R8,R0
// 1439 
// 1440     /* check if the destination is Longword aligned or not */
// 1441     if (0 != (destination % gNV_PHRASE_SIZE_c))
        MOVS     R0,#+8
        UDIV     R1,R9,R0
        MLS      R1,R1,R0,R9
        CMP      R1,#+0
        BEQ.N    ??NV_FlashProgramPhrase_0
// 1442     {
// 1443         /* return an error code gNV_ERR_ADDR */
// 1444         return(gNV_ERR_ADDR_c);
        MOV      R0,#+256
        B.N      ??NV_FlashProgramPhrase_1
// 1445     }
// 1446 
// 1447     /* check if the size is Longword alignment or not */
// 1448     if(0 != (size % gNV_PHRASE_SIZE_c))
??NV_FlashProgramPhrase_0:
        MOVS     R0,#+8
        UDIV     R1,R5,R0
        MLS      R1,R1,R0,R5
        CMP      R1,#+0
        BEQ.N    ??NV_FlashProgramPhrase_2
// 1449     {
// 1450         /* return an error code gNV_ERR_SIZE */
// 1451         return(gNV_ERR_SIZE_c);
        MOVS     R0,#+1
        B.N      ??NV_FlashProgramPhrase_1
// 1452     }
// 1453 
// 1454     /* check for valid range of the target addresses */
// 1455     if((destination < pConfig->PFlashBlockBase) || \ 
// 1456             (endAddress > (pConfig->PFlashBlockBase + pConfig->PFlashBlockSize)))
??NV_FlashProgramPhrase_2:
        LDR      R0,[R4, #+4]
        CMP      R9,R0
        BCC.N    ??NV_FlashProgramPhrase_3
        LDR      R0,[R4, #+4]
        LDR      R1,[R4, #+8]
        ADDS     R0,R1,R0
        CMP      R0,R8
        BCS.N    ??NV_FlashProgramPhrase_4
// 1457     {
// 1458         if((destination < pConfig->DFlashBlockBase) || \ 
// 1459                 (endAddress > (pConfig->DFlashBlockBase + pConfig->DFlashBlockSize)))
??NV_FlashProgramPhrase_3:
        LDR      R0,[R4, #+12]
        CMP      R9,R0
        BCC.N    ??NV_FlashProgramPhrase_5
        LDR      R0,[R4, #+12]
        LDR      R1,[R4, #+16]
        ADDS     R0,R1,R0
        CMP      R0,R8
        BCS.N    ??NV_FlashProgramPhrase_6
// 1460         {
// 1461             /* return an error code gNV_ERR_RANGE_c */
// 1462             return(gNV_ERR_RANGE_c);
??NV_FlashProgramPhrase_5:
        MOVS     R0,#+2
        B.N      ??NV_FlashProgramPhrase_1
// 1463         }
// 1464         else
// 1465         {
// 1466             /* Convert System memory address to FTFx internal memory address */
// 1467             destination = destination - pConfig->DFlashBlockBase + 0x800000;
??NV_FlashProgramPhrase_6:
        LDR      R0,[R4, #+12]
        SUBS     R0,R9,R0
        ADDS     R9,R0,#+8388608
        B.N      ??NV_FlashProgramPhrase_7
// 1468         }
// 1469     }
// 1470     else
// 1471     {
// 1472         /* Convert System memory address to FTFx internal memory address */
// 1473         destination -= pConfig->PFlashBlockBase;
??NV_FlashProgramPhrase_4:
        LDR      R0,[R4, #+4]
        SUBS     R9,R9,R0
// 1474     }
// 1475 
// 1476     while(size > 0)
??NV_FlashProgramPhrase_7:
        CMP      R5,#+0
        BEQ.N    ??NV_FlashProgramPhrase_8
// 1477     {
// 1478         /* preparing passing parameter to program the flash block */
// 1479         pCommandArray[0] = gNV_PROGRAM_PHRASE_c;
        MOVS     R0,#+7
        STRB     R0,[SP, #+0]
// 1480         pCommandArray[1] = (uint8_t)(destination >> 16);
        LSRS     R0,R9,#+16
        STRB     R0,[SP, #+1]
// 1481         pCommandArray[2] = (uint8_t)((destination >> 8) & 0xFF);
        LSRS     R0,R9,#+8
        STRB     R0,[SP, #+2]
// 1482         pCommandArray[3] = (uint8_t)(destination & 0xFF);
        MOV      R0,R9
        STRB     R0,[SP, #+3]
// 1483 
// 1484         pCommandArray[4] = gNV_READ8(source + 3);
        LDRB     R0,[R6, #+3]
        STRB     R0,[SP, #+4]
// 1485         pCommandArray[5] = gNV_READ8(source + 2);
        LDRB     R0,[R6, #+2]
        STRB     R0,[SP, #+5]
// 1486         pCommandArray[6] = gNV_READ8(source + 1);
        LDRB     R0,[R6, #+1]
        STRB     R0,[SP, #+6]
// 1487         pCommandArray[7] = gNV_READ8(source);
        LDRB     R0,[R6, #+0]
        STRB     R0,[SP, #+7]
// 1488         pCommandArray[8] = gNV_READ8(source + 7);
        LDRB     R0,[R6, #+7]
        STRB     R0,[SP, #+8]
// 1489         pCommandArray[9] = gNV_READ8(source + 6);
        LDRB     R0,[R6, #+6]
        STRB     R0,[SP, #+9]
// 1490         pCommandArray[10] = gNV_READ8(source + 5);
        LDRB     R0,[R6, #+5]
        STRB     R0,[SP, #+10]
// 1491         pCommandArray[11] = gNV_READ8(source + 4);
        LDRB     R0,[R6, #+4]
        STRB     R0,[SP, #+11]
// 1492 
// 1493         /* calling flash command sequence function to execute the command */
// 1494         returnCode = NvFlashCommandSequence(pConfig, 11, pCommandArray);
        ADD      R2,SP,#+0
        MOVS     R1,#+11
        MOVS     R0,R4
        BL       NvFlashCommandSequence
        MOVS     R7,R0
// 1495 
// 1496         /* checking for the success of command execution */
// 1497         if(gNV_OK_c != returnCode)
        CMP      R7,#+0
        BNE.N    ??NV_FlashProgramPhrase_8
// 1498         {
// 1499             break;
// 1500         }
// 1501 
// 1502         /* update destination address for next iteration */
// 1503         destination += gNV_PHRASE_SIZE_c;
??NV_FlashProgramPhrase_9:
        ADDS     R9,R9,#+8
// 1504         /* update size for next iteration */
// 1505         size -= gNV_PHRASE_SIZE_c;
        SUBS     R5,R5,#+8
// 1506         /* increment the source address by 1 */
// 1507         source += gNV_PHRASE_SIZE_c;
        ADDS     R6,R6,#+8
        B.N      ??NV_FlashProgramPhrase_7
// 1508     }
// 1509 
// 1510     return(returnCode);
??NV_FlashProgramPhrase_8:
        MOVS     R0,R7
??NV_FlashProgramPhrase_1:
        POP      {R1-R9,PC}       ;; return
// 1511 }
// 1512 
// 1513 
// 1514 /************************************************************************
// 1515  *
// 1516  *  Function Name    : NV_FlashReadOnce
// 1517  *  Description      : This function is used to read access to a reserved
// 1518  *                     64 byte field located in the P-Flash IFR.
// 1519  *  Arguments        : [IN] pConfig - pointer to NV configuration
// 1520  *                     [IN] pDataArray - pointer to location where read data
// 1521  *                                       will be placed
// 1522  *  Return Value     : uint32_t
// 1523  *
// 1524  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1525 uint32_t NV_FlashReadOnce
// 1526 (
// 1527         pNvConfig_t pConfig,
// 1528         uint8_t* pDataArray
// 1529 )
// 1530 {
NV_FlashReadOnce:
        PUSH     {R4-R8,LR}
        SUB      SP,SP,#+8
        MOVS     R4,R0
        MOVS     R5,R1
// 1531     uint8_t  counter;          /* outer loop counter */
// 1532     uint8_t  pCommandArray[2]; /* command sequence array */
// 1533     uint32_t returnCode;       /* return code variable */
// 1534     uint8_t  i;                /* variable to store record number index */
// 1535 
// 1536     /* initialize counter and returnCode */
// 1537     counter = 0;
        MOVS     R0,#+0
        MOVS     R6,R0
// 1538 
// 1539     /* set the default return code as gNV_OK_c */
// 1540     returnCode = gNV_OK_c;
        MOVS     R0,#+0
        MOVS     R7,R0
// 1541     /* calculate record number index */
// 1542     i = 64/(gNV_RDONCE_INDEX_MAX_c + 1);
        MOVS     R0,#+4
        MOV      R8,R0
// 1543     /* preparing passing parameter for read once command */
// 1544     /* 1st element for the FCCOB register */
// 1545     pCommandArray[0] = gNV_READ_ONCE_c;
        MOVS     R0,#+65
        STRB     R0,[SP, #+0]
// 1546 
// 1547     while (counter <= gNV_RDONCE_INDEX_MAX_c)
??NV_FlashReadOnce_0:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+16
        BGE.N    ??NV_FlashReadOnce_1
// 1548     {
// 1549         /* 2nd element for the FCCOB register */
// 1550         pCommandArray[1] = counter;
        STRB     R6,[SP, #+1]
// 1551 
// 1552         /* calling flash command sequence API to execute the command */
// 1553         returnCode = NvFlashCommandSequence(pConfig, 1, pCommandArray);
        ADD      R2,SP,#+0
        MOVS     R1,#+1
        MOVS     R0,R4
        BL       NvFlashCommandSequence
        MOVS     R7,R0
// 1554 
// 1555         /* checking for the success of command execution */
// 1556         if(gNV_OK_c != returnCode)
        CMP      R7,#+0
        BNE.N    ??NV_FlashReadOnce_1
// 1557         {
// 1558             break;
// 1559         }
// 1560 
// 1561         /* Read the data from the FCCOB registers into the pDataArray */
// 1562         pDataArray[counter*i] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB4_OFFSET_c);
??NV_FlashReadOnce_2:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MLA      R0,R8,R6,R5
        LDR      R1,[R4, #+0]
        LDRB     R1,[R1, #+11]
        STRB     R1,[R0, #+0]
// 1563         pDataArray[counter*i + 1] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB5_OFFSET_c);
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MLA      R0,R8,R6,R5
        LDR      R1,[R4, #+0]
        LDRB     R1,[R1, #+10]
        STRB     R1,[R0, #+1]
// 1564         pDataArray[counter*i + 2] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB6_OFFSET_c);
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MLA      R0,R8,R6,R5
        LDR      R1,[R4, #+0]
        LDRB     R1,[R1, #+9]
        STRB     R1,[R0, #+2]
// 1565         pDataArray[counter*i + 3] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB7_OFFSET_c);
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MLA      R0,R8,R6,R5
        LDR      R1,[R4, #+0]
        LDRB     R1,[R1, #+8]
        STRB     R1,[R0, #+3]
// 1566 #if ((gNV_512K_512K_16K_4K_4K_c == gNV_Derivative_c) || (gNV_1024K_0K_16K_4K_0K_c == gNV_Derivative_c))
// 1567         pDataArray[counter*i + 4] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB8_OFFSET_c);
// 1568         pDataArray[counter*i + 5] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB9_OFFSET_c);
// 1569         pDataArray[counter*i + 6] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOBA_OFFSET_c);
// 1570         pDataArray[counter*i + 7] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOBB_OFFSET_c);
// 1571 #endif
// 1572         counter++;
        ADDS     R6,R6,#+1
        B.N      ??NV_FlashReadOnce_0
// 1573     }
// 1574 
// 1575     return(returnCode);
??NV_FlashReadOnce_1:
        MOVS     R0,R7
        POP      {R1,R2,R4-R8,PC}  ;; return
// 1576 }
// 1577 
// 1578 
// 1579 /************************************************************************
// 1580  *
// 1581  *  Function Name    : NV_FlashReadResource
// 1582  *  Description      : This function is provided for the user to read data
// 1583  *                     from P-Flash IFR and D-Flash IFR space.
// 1584  *  Arguments        :[IN] pConfig - pointer to NV configuration
// 1585  *                    [IN] destination - destination address
// 1586  *                    [IN] pDataArray - pointer to location where read data
// 1587  *                                      will be placed
// 1588  *  Return Value     : uint32_t
// 1589  *
// 1590  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1591 uint32_t NV_FlashReadResource
// 1592 (
// 1593         pNvConfig_t pConfig,
// 1594         uint32_t destination,
// 1595         uint8_t* pDataArray
// 1596 )
// 1597 {
NV_FlashReadResource:
        PUSH     {R1-R7,LR}
        MOVS     R4,R0
        MOVS     R7,R1
        MOVS     R5,R2
// 1598     uint8_t  pCommandArray[9]; /* command sequence array */
// 1599     uint32_t returnCode;       /* return code variable */
// 1600 
// 1601     /* set the default return code as gNV_OK_c */
// 1602     returnCode = gNV_OK_c;
        MOVS     R0,#+0
        MOVS     R6,R0
// 1603 
// 1604     /* check if the destination is longword aligned or not */
// 1605     if (0 != destination % gNV_RDRSRC_ALIGN_SIZE_c)
        MOVS     R0,#+4
        UDIV     R1,R7,R0
        MLS      R1,R1,R0,R7
        CMP      R1,#+0
        BEQ.N    ??NV_FlashReadResource_0
// 1606     {
// 1607         /* return an error code gNV_ERR_ADDR */
// 1608         return(gNV_ERR_ADDR_c);
        MOV      R0,#+256
        B.N      ??NV_FlashReadResource_1
// 1609     }
// 1610 
// 1611     /* check for valid range of the target addresses */
// 1612     if((destination < ( pConfig->PFlashBlockBase + gNV_PFLASH_IFR_OFFSET_c )) || \ 
// 1613             (destination >= ( pConfig->PFlashBlockBase + gNV_PFLASH_IFR_SIZE_c )))
??NV_FlashReadResource_0:
        LDR      R0,[R4, #+4]
        CMP      R7,R0
        BCC.N    ??NV_FlashReadResource_2
        LDR      R0,[R4, #+4]
        ADDS     R0,R0,#+256
        CMP      R7,R0
        BCC.N    ??NV_FlashReadResource_3
// 1614     {
// 1615         if((destination < ( pConfig->DFlashBlockBase + gNV_DFLASH_IFR_OFFSET_c )) || \ 
// 1616                 (destination >= ( pConfig->DFlashBlockBase + gNV_DFLASH_IFR_SIZE_c )))
??NV_FlashReadResource_2:
        LDR      R0,[R4, #+12]
        SUBS     R0,R0,#+1
        CMP      R7,R0
        BCC.N    ??NV_FlashReadResource_4
        LDR      R0,[R4, #+12]
        SUBS     R0,R0,#+1
        CMP      R7,R0
        BCC.N    ??NV_FlashReadResource_5
// 1617         {
// 1618             /* return an error code gNV_ERR_RANGE_c */
// 1619             return(gNV_ERR_RANGE_c);
??NV_FlashReadResource_4:
        MOVS     R0,#+2
        B.N      ??NV_FlashReadResource_1
// 1620         }
// 1621         else
// 1622         {
// 1623             /* Convert System memory address to FTFx internal memory address */
// 1624             destination = destination - pConfig->DFlashBlockBase + 0x800000;
??NV_FlashReadResource_5:
        LDR      R0,[R4, #+12]
        SUBS     R0,R7,R0
        ADDS     R7,R0,#+8388608
        B.N      ??NV_FlashReadResource_6
// 1625         }
// 1626     }
// 1627     else
// 1628     {
// 1629         /* Convert System memory address to FTFx internal memory address */
// 1630         destination -= pConfig->PFlashBlockBase;
??NV_FlashReadResource_3:
        LDR      R0,[R4, #+4]
        SUBS     R7,R7,R0
// 1631     }
// 1632 
// 1633     /* preparing passing parameter for read resource command */
// 1634     /* 1st element for the FCCOB register */
// 1635     pCommandArray[0] = gNV_READ_RESOURCE_c;
??NV_FlashReadResource_6:
        MOVS     R0,#+3
        STRB     R0,[SP, #+0]
// 1636     pCommandArray[1] = (uint8_t)(destination >> 16);
        LSRS     R0,R7,#+16
        STRB     R0,[SP, #+1]
// 1637     pCommandArray[2] = (uint8_t)((destination >> 8) & 0xFF);
        LSRS     R0,R7,#+8
        STRB     R0,[SP, #+2]
// 1638     pCommandArray[3] = (uint8_t)(destination & 0xFF);
        MOVS     R0,R7
        STRB     R0,[SP, #+3]
// 1639 #if ((gNV_512K_512K_16K_4K_4K_c == gNV_Derivative_c) || (gNV_1024K_0K_16K_4K_0K_c == gNV_Derivative_c))
// 1640     pCommandArray[4] = 0x00;
// 1641     /* calling flash command sequence API to execute the command */
// 1642     returnCode = NvFlashCommandSequence(pConfig, 4, pCommandArray);
// 1643 #else
// 1644     pCommandArray[8] = 0x00;
        MOVS     R0,#+0
        STRB     R0,[SP, #+8]
// 1645     /* calling flash command sequence API to execute the command */
// 1646     returnCode = NvFlashCommandSequence(pConfig, 8, pCommandArray);
        ADD      R2,SP,#+0
        MOVS     R1,#+8
        MOVS     R0,R4
        BL       NvFlashCommandSequence
        MOVS     R6,R0
// 1647 #endif
// 1648 
// 1649     /* checking for the success of command execution */
// 1650     if(gNV_OK_c != returnCode)
        CMP      R6,#+0
        BEQ.N    ??NV_FlashReadResource_7
// 1651     {
// 1652         return(returnCode);
        MOVS     R0,R6
        B.N      ??NV_FlashReadResource_1
// 1653     }
// 1654 
// 1655     /* Read the data from the FCCOB registers into the pDataArray */
// 1656     pDataArray[0] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB4_OFFSET_c);
??NV_FlashReadResource_7:
        LDR      R0,[R4, #+0]
        LDRB     R0,[R0, #+11]
        STRB     R0,[R5, #+0]
// 1657     pDataArray[1] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB5_OFFSET_c);
        LDR      R0,[R4, #+0]
        LDRB     R0,[R0, #+10]
        STRB     R0,[R5, #+1]
// 1658     pDataArray[2] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB6_OFFSET_c);
        LDR      R0,[R4, #+0]
        LDRB     R0,[R0, #+9]
        STRB     R0,[R5, #+2]
// 1659     pDataArray[3] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB7_OFFSET_c);
        LDR      R0,[R4, #+0]
        LDRB     R0,[R0, #+8]
        STRB     R0,[R5, #+3]
// 1660 #if ((gNV_512K_512K_16K_4K_4K_c == gNV_Derivative_c) || (gNV_1024K_0K_16K_4K_0K_c == gNV_Derivative_c))
// 1661     pDataArray[4] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB8_OFFSET_c);
// 1662     pDataArray[5] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOB9_OFFSET_c);
// 1663     pDataArray[6] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOBA_OFFSET_c);
// 1664     pDataArray[7] = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCCOBB_OFFSET_c);
// 1665 #endif
// 1666 
// 1667     return(returnCode);
        MOVS     R0,R6
??NV_FlashReadResource_1:
        POP      {R1-R7,PC}       ;; return
// 1668 }
// 1669 
// 1670 
// 1671 /************************************************************************
// 1672  *
// 1673  *  Function Name    : NV_FlashSecurityBypass
// 1674  *  Description      : If the MCU is secured state, this function will
// 1675  *                     unsecure the MCU by comparing the provided backdoor
// 1676  *                     key with ones in the Flash Configuration Field.
// 1677  *  Arguments        : [IN] pConfig - pointer to NV configuration
// 1678  *                     [IN] keyBuffer - pointer to a location where the key
// 1679  *                                      is stored
// 1680  *  Return Value     : uint32_t
// 1681  *
// 1682  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1683 uint32_t NV_FlashSecurityBypass
// 1684 (
// 1685         pNvConfig_t pConfig,
// 1686         uint8_t* keyBuffer
// 1687 )
// 1688 {
NV_FlashSecurityBypass:
        PUSH     {R1-R7,LR}
        MOVS     R4,R0
        MOVS     R5,R1
// 1689     uint8_t pCommandArray[12]; /* command sequence array */
// 1690     uint8_t registerValue;    /* registerValue */
// 1691     uint32_t returnCode;      /* return code variable */
// 1692 
// 1693     /* set the default return code as gNV_OK_c */
// 1694     returnCode = gNV_OK_c;
        MOVS     R0,#+0
        MOVS     R7,R0
// 1695 
// 1696     /*Get flash security register value */
// 1697     registerValue = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FSEC_OFFSET_c);
        LDR      R0,[R4, #+0]
        LDRB     R0,[R0, #+2]
        MOVS     R6,R0
// 1698 
// 1699     if (0x02 != (registerValue & 0x03))
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        ANDS     R0,R6,#0x3
        CMP      R0,#+2
        BEQ.N    ??NV_FlashSecurityBypass_0
// 1700     {
// 1701         /* preparing passing parameter to erase a flash block */
// 1702         pCommandArray[0] = gNV_SECURITY_BY_PASS_c;
        MOVS     R0,#+69
        STRB     R0,[SP, #+0]
// 1703         pCommandArray[4] = keyBuffer[0];
        LDRB     R0,[R5, #+0]
        STRB     R0,[SP, #+4]
// 1704         pCommandArray[5] = keyBuffer[1];
        LDRB     R0,[R5, #+1]
        STRB     R0,[SP, #+5]
// 1705         pCommandArray[6] = keyBuffer[2];
        LDRB     R0,[R5, #+2]
        STRB     R0,[SP, #+6]
// 1706         pCommandArray[7] = keyBuffer[3];
        LDRB     R0,[R5, #+3]
        STRB     R0,[SP, #+7]
// 1707         pCommandArray[8] = keyBuffer[4];
        LDRB     R0,[R5, #+4]
        STRB     R0,[SP, #+8]
// 1708         pCommandArray[9] = keyBuffer[5];
        LDRB     R0,[R5, #+5]
        STRB     R0,[SP, #+9]
// 1709         pCommandArray[10] = keyBuffer[6];
        LDRB     R0,[R5, #+6]
        STRB     R0,[SP, #+10]
// 1710         pCommandArray[11] = keyBuffer[7];
        LDRB     R0,[R5, #+7]
        STRB     R0,[SP, #+11]
// 1711 
// 1712         /* calling flash command sequence function to execute the command */
// 1713         returnCode = NvFlashCommandSequence(pConfig, 11, pCommandArray);
        ADD      R2,SP,#+0
        MOVS     R1,#+11
        MOVS     R0,R4
        BL       NvFlashCommandSequence
        MOVS     R7,R0
// 1714     }
// 1715 
// 1716     return(returnCode);
??NV_FlashSecurityBypass_0:
        MOVS     R0,R7
        POP      {R1-R7,PC}       ;; return
// 1717 }
// 1718 
// 1719 
// 1720 /************************************************************************
// 1721  *
// 1722  *  Function Name    : NV_FlashSetInterruptEnable
// 1723  *  Description      : This function sets the Flash interrupt enable
// 1724  *                     bits in the Flash module configuration register.
// 1725  *                     Other bits in the FCNFG register wont be affected.
// 1726  *  Arguments        : [IN] pConfig - pointer to NV configuration
// 1727  *                     [IN] interruptState - interrupt state to be set
// 1728  *  Return Value     : uint32_t
// 1729  *
// 1730  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1731 uint32_t NV_FlashSetInterruptEnable
// 1732 (
// 1733         pNvConfig_t pConfig,
// 1734         uint8_t interruptState
// 1735 )
// 1736 {
NV_FlashSetInterruptEnable:
        MOVS     R2,R0
// 1737     /* store data read from flash register */
// 1738     uint8_t  registerValue;
// 1739 
// 1740     /* Mask off unused bits in interruptState */
// 1741     interruptState &= (gNV_FCNFG_CCIE_c | gNV_FCNFG_RDCOLLIE_c);
        ANDS     R1,R1,#0xC0
// 1742 
// 1743     /*Get flash configuration register value */
// 1744     registerValue = gNV_REG_READ(pConfig->ftfxRegBase + gNV_FCNFG_OFFSET_c);
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+1]
        MOVS     R3,R0
// 1745 
// 1746     /* Set register value with desired interrupt state */
// 1747     registerValue &= ~(gNV_FCNFG_CCIE_c | gNV_FCNFG_CCIE_c);
        ANDS     R3,R3,#0x7F
// 1748     registerValue |= interruptState;
        ORRS     R3,R1,R3
// 1749     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FCNFG_OFFSET_c, registerValue);
        LDR      R0,[R2, #+0]
        STRB     R3,[R0, #+1]
// 1750 
// 1751     return(gNV_OK_c);
        MOVS     R0,#+0
        BX       LR               ;; return
// 1752 }
// 1753 
// 1754 
// 1755 /************************************************************************
// 1756  *
// 1757  *  Function Name    : NV_FlashVerifyAllBlock
// 1758  *  Description      : This function will check to see if the P-Flash
// 1759  *                     and D-Flash blocks as well as EERAM, E-Flash records
// 1760  *                     and D-Flash IFR have been erased to the specified read
// 1761  *                     margin level, if applicable, and will release security
// 1762  *                     if the readout passes.
// 1763  *  Arguments        : [IN] pConfig - pointer to NV configuration
// 1764  *                     [IN] marginLevel - margin level
// 1765  *  Return Value     : uint32_t
// 1766  *
// 1767  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1768 uint32_t NV_FlashVerifyAllBlock
// 1769 (
// 1770         pNvConfig_t pConfig,
// 1771         uint8_t marginLevel
// 1772 )
// 1773 {
NV_FlashVerifyAllBlock:
        PUSH     {R4-R6,LR}
        SUB      SP,SP,#+8
        MOVS     R4,R0
        MOVS     R5,R1
// 1774     uint8_t pCommandArray[2]; /* command sequence array */
// 1775     uint32_t returnCode;      /* return code variable */
// 1776 
// 1777     /* set the default return code as gNV_OK_c */
// 1778     returnCode = gNV_OK_c;
        MOVS     R0,#+0
        MOVS     R6,R0
// 1779 
// 1780     /* preparing passing parameter to verify all block command*/
// 1781     pCommandArray[0] = gNV_VERIFY_ALL_BLOCK_c;
        MOVS     R0,#+64
        STRB     R0,[SP, #+0]
// 1782     pCommandArray[1] = marginLevel;
        STRB     R5,[SP, #+1]
// 1783 
// 1784     /* calling flash command sequence function to execute the command */
// 1785     returnCode = NvFlashCommandSequence(pConfig, 1, pCommandArray);
        ADD      R2,SP,#+0
        MOVS     R1,#+1
        MOVS     R0,R4
        BL       NvFlashCommandSequence
        MOVS     R6,R0
// 1786 
// 1787     return(returnCode);
        MOVS     R0,R6
        POP      {R1,R2,R4-R6,PC}  ;; return
// 1788 }
// 1789 
// 1790 
// 1791 /************************************************************************
// 1792  *
// 1793  *  Function Name    : NV_FlashVerifyBlock
// 1794  *  Description      : This function will check to see if an entire
// 1795  *                     P-Flash or D-Flash block has been erased to the
// 1796  *                     specified margin level.
// 1797  *  Arguments        : [IN] pConfig - pointer to NV configuration
// 1798  *                     [IN] destination - destination address
// 1799  *                     [IN] marginLevel - margin level
// 1800  *  Return Value     : uint32_t
// 1801  *
// 1802  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1803 uint32_t NV_FlashVerifyBlock
// 1804 (
// 1805         pNvConfig_t pConfig,
// 1806         uint32_t destination,
// 1807         uint8_t marginLevel
// 1808 )
// 1809 {
NV_FlashVerifyBlock:
        PUSH     {R4-R7,LR}
        SUB      SP,SP,#+12
        MOVS     R4,R0
        MOVS     R7,R1
        MOVS     R5,R2
// 1810     uint8_t pCommandArray[5]; /* command sequence array */
// 1811     uint32_t returnCode;      /* return code variable */
// 1812 
// 1813     /* set the default return code as gNV_OK_c */
// 1814     returnCode = gNV_OK_c;
        MOVS     R0,#+0
        MOVS     R6,R0
// 1815 
// 1816     /* check if the destination is longword aligned or not */
// 1817     if (0 != (destination % gNV_RD1BLK_ALIGN_SIZE_c))
        MOVS     R0,#+4
        UDIV     R1,R7,R0
        MLS      R1,R1,R0,R7
        CMP      R1,#+0
        BEQ.N    ??NV_FlashVerifyBlock_0
// 1818     {
// 1819         /* return an error code gNV_ERR_ADDR */
// 1820         return(gNV_ERR_ADDR_c);
        MOV      R0,#+256
        B.N      ??NV_FlashVerifyBlock_1
// 1821     }
// 1822 
// 1823     /* check for valid range of the target addresses */
// 1824     if((destination < pConfig->PFlashBlockBase) || \ 
// 1825             (destination >= (pConfig->PFlashBlockBase + pConfig->PFlashBlockSize)))
??NV_FlashVerifyBlock_0:
        LDR      R0,[R4, #+4]
        CMP      R7,R0
        BCC.N    ??NV_FlashVerifyBlock_2
        LDR      R0,[R4, #+4]
        LDR      R1,[R4, #+8]
        ADDS     R0,R1,R0
        CMP      R7,R0
        BCC.N    ??NV_FlashVerifyBlock_3
// 1826     {
// 1827         if((destination < pConfig->DFlashBlockBase) || \ 
// 1828                 (destination >= (pConfig->DFlashBlockBase + pConfig->DFlashBlockSize)))
??NV_FlashVerifyBlock_2:
        LDR      R0,[R4, #+12]
        CMP      R7,R0
        BCC.N    ??NV_FlashVerifyBlock_4
        LDR      R0,[R4, #+12]
        LDR      R1,[R4, #+16]
        ADDS     R0,R1,R0
        CMP      R7,R0
        BCC.N    ??NV_FlashVerifyBlock_5
// 1829         {
// 1830             /* return an error code gNV_ERR_RANGE_c */
// 1831             return(gNV_ERR_RANGE_c);
??NV_FlashVerifyBlock_4:
        MOVS     R0,#+2
        B.N      ??NV_FlashVerifyBlock_1
// 1832         }
// 1833         else
// 1834         {
// 1835             /* Convert System memory address to FTFx internal memory address */
// 1836             destination = destination - pConfig->DFlashBlockBase + 0x800000;
??NV_FlashVerifyBlock_5:
        LDR      R0,[R4, #+12]
        SUBS     R0,R7,R0
        ADDS     R7,R0,#+8388608
        B.N      ??NV_FlashVerifyBlock_6
// 1837         }
// 1838     }
// 1839     else
// 1840     {
// 1841         /* Convert System memory address to FTFx internal memory address */
// 1842         destination -= pConfig->PFlashBlockBase;
??NV_FlashVerifyBlock_3:
        LDR      R0,[R4, #+4]
        SUBS     R7,R7,R0
// 1843     }
// 1844 
// 1845     /* preparing passing parameter to verify block command */
// 1846     pCommandArray[0] = gNV_VERIFY_BLOCK_c;
??NV_FlashVerifyBlock_6:
        MOVS     R0,#+0
        STRB     R0,[SP, #+0]
// 1847     pCommandArray[1] = (uint8_t)(destination >> 16);
        LSRS     R0,R7,#+16
        STRB     R0,[SP, #+1]
// 1848     pCommandArray[2] = (uint8_t)((destination >> 8) & 0xFF);
        LSRS     R0,R7,#+8
        STRB     R0,[SP, #+2]
// 1849     pCommandArray[3] = (uint8_t)(destination & 0xFF);
        MOVS     R0,R7
        STRB     R0,[SP, #+3]
// 1850     pCommandArray[4] = marginLevel;
        STRB     R5,[SP, #+4]
// 1851 
// 1852     /* calling flash command sequence function to execute the command */
// 1853     returnCode = NvFlashCommandSequence(pConfig, 4, pCommandArray);
        ADD      R2,SP,#+0
        MOVS     R1,#+4
        MOVS     R0,R4
        BL       NvFlashCommandSequence
        MOVS     R6,R0
// 1854 
// 1855     return(returnCode);
        MOVS     R0,R6
??NV_FlashVerifyBlock_1:
        POP      {R1-R7,PC}       ;; return
// 1856 }
// 1857 
// 1858 
// 1859 /************************************************************************
// 1860  *
// 1861  *  Function Name    : NV_FlashVerifySection
// 1862  *  Description      : This function will check to see if a section of
// 1863  *                     P-Flash or D-Flash memory is erased to the specified
// 1864  *                     read margin level.
// 1865  *  Arguments        : [IN] pConfig - pointer to NV configuration
// 1866  *                     [IN] destination - destination address
// 1867  *                     [IN] Length - number of bytes to be verified
// 1868  *                     [IN] marginLevel - margin level
// 1869  *  Return Value     : uint32_t
// 1870  *
// 1871  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1872 uint32_t NV_FlashVerifySection
// 1873 (
// 1874         pNvConfig_t pConfig,
// 1875         uint32_t destination,
// 1876         uint16_t Length,
// 1877         uint8_t marginLevel
// 1878 )
// 1879 {
NV_FlashVerifySection:
        PUSH     {R1-R11,LR}
        MOVS     R4,R0
        MOV      R8,R1
        MOV      R10,R2
        MOVS     R5,R3
// 1880     uint8_t pCommandArray[7]; /* command sequence array */
// 1881     uint32_t returnCode;      /* return code variable */
// 1882     uint32_t endAddress;      /* storing end address. This is the starting point of the next block */
// 1883     uint8_t misalignedBytes;
// 1884     uint16_t Number;
// 1885     uint8_t alignSize;
// 1886 
// 1887     /* set the default return code as gNV_OK_c */
// 1888     returnCode = gNV_OK_c;
        MOVS     R0,#+0
        MOVS     R6,R0
// 1889 
// 1890     /* check for valid range of the destination */
// 1891     if((destination >= pConfig->PFlashBlockBase) && \ 
// 1892             (destination < (pConfig->PFlashBlockBase + pConfig->PFlashBlockSize)))
        LDR      R0,[R4, #+4]
        CMP      R8,R0
        BCC.N    ??NV_FlashVerifySection_0
        LDR      R0,[R4, #+4]
        LDR      R1,[R4, #+8]
        ADDS     R0,R1,R0
        CMP      R8,R0
        BCS.N    ??NV_FlashVerifySection_0
// 1893     {
// 1894         /* calculating Flash end address */
// 1895     	endAddress = destination + Length;
        UXTAH    R0,R8,R10
        MOV      R9,R0
// 1896         alignSize = gNV_PRD1SEC_ALIGN_SIZE_c;
        MOVS     R0,#+8
        MOVS     R7,R0
        B.N      ??NV_FlashVerifySection_1
// 1897     }
// 1898     else if((destination >= pConfig->DFlashBlockBase) && \ 
// 1899             (destination < (pConfig->DFlashBlockBase + pConfig->DFlashBlockSize)))
??NV_FlashVerifySection_0:
        LDR      R0,[R4, #+12]
        CMP      R8,R0
        BCC.N    ??NV_FlashVerifySection_2
        LDR      R0,[R4, #+12]
        LDR      R1,[R4, #+16]
        ADDS     R0,R1,R0
        CMP      R8,R0
        BCS.N    ??NV_FlashVerifySection_2
// 1900     {
// 1901         /* calculating Flash end address */
// 1902     	endAddress = destination + Length;
        UXTAH    R0,R8,R10
        MOV      R9,R0
// 1903         alignSize = gNV_DRD1SEC_ALIGN_SIZE_c;    	
        MOVS     R0,#+8
        MOVS     R7,R0
        B.N      ??NV_FlashVerifySection_1
// 1904     }
// 1905     else
// 1906     {
// 1907         /* return an error code gNV_ERR_RANGE_c */
// 1908         return(gNV_ERR_RANGE_c);
??NV_FlashVerifySection_2:
        MOVS     R0,#+2
        B.N      ??NV_FlashVerifySection_3
// 1909     }
// 1910 
// 1911     /* check for valid range of end address */
// 1912     if((endAddress >= pConfig->PFlashBlockBase) && \ 
// 1913             (endAddress <= (pConfig->PFlashBlockBase + pConfig->PFlashBlockSize)))
??NV_FlashVerifySection_1:
        LDR      R0,[R4, #+4]
        CMP      R9,R0
        BCC.N    ??NV_FlashVerifySection_4
        LDR      R0,[R4, #+4]
        LDR      R1,[R4, #+8]
        ADDS     R0,R1,R0
        CMP      R0,R9
        BCC.N    ??NV_FlashVerifySection_4
// 1914     {
// 1915         /* Convert System memory address to FTFx internal memory address */
// 1916         destination -= pConfig->PFlashBlockBase;
        LDR      R0,[R4, #+4]
        SUBS     R8,R8,R0
        B.N      ??NV_FlashVerifySection_5
// 1917     }
// 1918     else if((endAddress >= pConfig->DFlashBlockBase) || \ 
// 1919             (endAddress <= (pConfig->DFlashBlockBase + pConfig->DFlashBlockSize)))
??NV_FlashVerifySection_4:
        LDR      R0,[R4, #+12]
        CMP      R9,R0
        BCS.N    ??NV_FlashVerifySection_6
        LDR      R0,[R4, #+12]
        LDR      R1,[R4, #+16]
        ADDS     R0,R1,R0
        CMP      R0,R9
        BCC.N    ??NV_FlashVerifySection_7
// 1920     {
// 1921         /* Convert System memory address to FTFx internal memory address */
// 1922         destination = destination - pConfig->DFlashBlockBase + 0x800000;
??NV_FlashVerifySection_6:
        LDR      R0,[R4, #+12]
        SUBS     R0,R8,R0
        ADDS     R8,R0,#+8388608
        B.N      ??NV_FlashVerifySection_5
// 1923     }
// 1924     else
// 1925     {
// 1926         /* return an error code gNV_ERR_RANGE_c */
// 1927         return(gNV_ERR_RANGE_c);
??NV_FlashVerifySection_7:
        MOVS     R0,#+2
        B.N      ??NV_FlashVerifySection_3
// 1928     }
// 1929 
// 1930     /* align destination (if misaligned) and blank check the misaligned addresses */
// 1931     misalignedBytes = destination - (destination & (~0x07uL));
??NV_FlashVerifySection_5:
        ANDS     R0,R8,#0xF8
        SUBS     R0,R8,R0
        MOV      R11,R0
// 1932     while(misalignedBytes)
??NV_FlashVerifySection_8:
        UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
        CMP      R11,#+0
        BEQ.N    ??NV_FlashVerifySection_9
// 1933     {
// 1934       uint8_t pData;
// 1935       pData = ((uint8_t)(*(vuint8_t*)(destination)));
        LDRB     R0,[R8, #+0]
        MOVS     R1,R0
// 1936       if(pData != 0xFF)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+255
        BEQ.N    ??NV_FlashVerifySection_10
// 1937       {
// 1938         return(gNV_ERR_ACCERR_c);
        MOVS     R0,#+4
        B.N      ??NV_FlashVerifySection_3
// 1939       }
// 1940       destination++;
??NV_FlashVerifySection_10:
        ADDS     R8,R8,#+1
// 1941       Length--;
        SUBS     R10,R10,#+1
// 1942       misalignedBytes--;
        SUBS     R11,R11,#+1
        B.N      ??NV_FlashVerifySection_8
// 1943     }
// 1944 
// 1945     /* align end address (if misaligned) and blank check the misaligned addresses */
// 1946     misalignedBytes = endAddress - (endAddress & (~0x07uL));
??NV_FlashVerifySection_9:
        ANDS     R0,R9,#0xF8
        SUBS     R0,R9,R0
        MOV      R11,R0
// 1947     while(misalignedBytes)
??NV_FlashVerifySection_11:
        UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
        CMP      R11,#+0
        BEQ.N    ??NV_FlashVerifySection_12
// 1948     {
// 1949       uint8_t pData;
// 1950       pData = ((uint8_t)(*(vuint8_t*)(endAddress)));
        LDRB     R0,[R9, #+0]
        MOVS     R1,R0
// 1951       if(pData != 0xFF)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+255
        BEQ.N    ??NV_FlashVerifySection_13
// 1952       {
// 1953         return(gNV_ERR_ACCERR_c);
        MOVS     R0,#+4
        B.N      ??NV_FlashVerifySection_3
// 1954       }
// 1955       endAddress--;
??NV_FlashVerifySection_13:
        SUBS     R9,R9,#+1
// 1956       Length--;
        SUBS     R10,R10,#+1
// 1957       misalignedBytes--;
        SUBS     R11,R11,#+1
        B.N      ??NV_FlashVerifySection_11
// 1958     }
// 1959 
// 1960     /* calculate the number of phrases needed by the verify section command */
// 1961     Number = Length / alignSize;
??NV_FlashVerifySection_12:
        UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        SDIV     R0,R10,R7
        STRH     R0,[SP, #+8]
// 1962 
// 1963     /* preparing passing parameter to verify section command */
// 1964     pCommandArray[0] = gNV_VERIFY_SECTION_c;
        MOVS     R0,#+1
        STRB     R0,[SP, #+0]
// 1965     pCommandArray[1] = (uint8_t)(destination >> 16);
        LSRS     R0,R8,#+16
        STRB     R0,[SP, #+1]
// 1966     pCommandArray[2] = (uint8_t)((destination >> 8) & 0xFF);
        LSRS     R0,R8,#+8
        STRB     R0,[SP, #+2]
// 1967     pCommandArray[3] = (uint8_t)(destination & 0xFF);
        MOV      R0,R8
        STRB     R0,[SP, #+3]
// 1968     pCommandArray[4] = (uint8_t)(Number >> 8);
        LDRH     R0,[SP, #+8]
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        LSRS     R0,R0,#+8
        STRB     R0,[SP, #+4]
// 1969     pCommandArray[5] = (uint8_t)(Number & 0xFF);
        LDRH     R0,[SP, #+8]
        STRB     R0,[SP, #+5]
// 1970     pCommandArray[6] = marginLevel;
        STRB     R5,[SP, #+6]
// 1971 
// 1972     /* calling flash command sequence function to execute the command */
// 1973     returnCode = NvFlashCommandSequence(pConfig, 6, pCommandArray);
        ADD      R2,SP,#+0
        MOVS     R1,#+6
        MOVS     R0,R4
        BL       NvFlashCommandSequence
        MOVS     R6,R0
// 1974 
// 1975     return(returnCode);
        MOVS     R0,R6
??NV_FlashVerifySection_3:
        POP      {R1-R11,PC}      ;; return
// 1976 }
// 1977 
// 1978 
// 1979 /************************************************************************
// 1980  *
// 1981  *  Function Name    : NV_PFlashSetProtection
// 1982  *  Description      : This function sets the P-Flash protection to the
// 1983  *                     intended protection status
// 1984  *  Arguments        : [IN] pConfig - pointer to NV configuration
// 1985  *                     [IN] protectStatus - protection status to be set
// 1986  *  Return Value     : uint32_t
// 1987  *
// 1988  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1989 uint32_t NV_PFlashSetProtection
// 1990 (
// 1991         pNvConfig_t pConfig,
// 1992         uint32_t protectStatus
// 1993 )
// 1994 {
NV_PFlashSetProtection:
        PUSH     {R4-R10,LR}
        MOVS     R2,R0
// 1995     uint32_t registerValue;    /* store data read from flash register */
// 1996     uint32_t returnCode;       /* return code variable */
// 1997     uint32_t temp;
// 1998     uint32_t registerValue0;
// 1999     uint32_t registerValue1;
// 2000     uint32_t registerValue2;
// 2001     uint32_t registerValue3;
// 2002 
// 2003     /* set the default return as gNV_OK_c */
// 2004     returnCode = gNV_OK_c;
        MOVS     R0,#+0
        MOVS     R4,R0
// 2005     /* check CCIF bit of the flash status register, it's impossible to write to FPROT if command is in progress */
// 2006     if(FALSE == (gNV_REG_BIT_TEST(pConfig->ftfxRegBase + gNV_FSTAT_OFFSET_c, gNV_FSTAT_CCIF_c)))
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+24
        BMI.N    ??NV_PFlashSetProtection_0
// 2007     {
// 2008         return(gNV_ERR_CHANGEPROT_c);
        MOVS     R0,#+32
        B.N      ??NV_PFlashSetProtection_1
// 2009     }
// 2010     /* Read the value of FPPROT registers */
// 2011     registerValue0=(uint32_t)(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FPROT0_OFFSET_c));
??NV_PFlashSetProtection_0:
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+19]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R6,R0
// 2012     registerValue1=(uint32_t)(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FPROT1_OFFSET_c));
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+18]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R7,R0
// 2013     registerValue2=(uint32_t)(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FPROT2_OFFSET_c));
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+17]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOV      R12,R0
// 2014     registerValue3=(uint32_t)(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FPROT3_OFFSET_c));
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+16]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOV      LR,R0
// 2015 
// 2016     registerValue = ((registerValue0 << 24 ) | \ 
// 2017             (registerValue1 << 16 ) | \ 
// 2018             (registerValue2 << 8 ) | \ 
// 2019             registerValue3);
        LSLS     R0,R7,#+16
        ORRS     R0,R0,R6, LSL #+24
        ORRS     R0,R0,R12, LSL #+8
        ORRS     R0,LR,R0
        MOVS     R3,R0
// 2020 
// 2021     /* Check if normal mode */
// 2022     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FPROT0_OFFSET_c, 0xFF);
        MOVS     R0,#+255
        LDR      R8,[R2, #+0]
        STRB     R0,[R8, #+19]
// 2023     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FPROT1_OFFSET_c, 0xFF);
        MOVS     R0,#+255
        LDR      R8,[R2, #+0]
        STRB     R0,[R8, #+18]
// 2024     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FPROT2_OFFSET_c, 0xFF);
        MOVS     R0,#+255
        LDR      R8,[R2, #+0]
        STRB     R0,[R8, #+17]
// 2025     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FPROT3_OFFSET_c, 0xFF);
        MOVS     R0,#+255
        LDR      R8,[R2, #+0]
        STRB     R0,[R8, #+16]
// 2026 
// 2027     /* Read the value of FPPROT registers */
// 2028     registerValue0=(uint32_t)(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FPROT0_OFFSET_c));
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+19]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R6,R0
// 2029     registerValue1=(uint32_t)(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FPROT1_OFFSET_c));
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+18]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R7,R0
// 2030     registerValue2=(uint32_t)(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FPROT2_OFFSET_c));
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+17]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOV      R12,R0
// 2031     registerValue3=(uint32_t)(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FPROT3_OFFSET_c));
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+16]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOV      LR,R0
// 2032 
// 2033     if((registerValue0 != 0xFF) | (registerValue1 != 0xFF) | \ 
// 2034             (registerValue2 != 0xFF) | (registerValue3 != 0xFF))
        CMP      R6,#+255
        BEQ.N    ??NV_PFlashSetProtection_2
        MOVS     R8,#+1
        B.N      ??NV_PFlashSetProtection_3
??NV_PFlashSetProtection_2:
        MOVS     R8,#+0
??NV_PFlashSetProtection_3:
        CMP      R7,#+255
        BEQ.N    ??NV_PFlashSetProtection_4
        MOVS     R9,#+1
        B.N      ??NV_PFlashSetProtection_5
??NV_PFlashSetProtection_4:
        MOVS     R9,#+0
??NV_PFlashSetProtection_5:
        CMP      R12,#+255
        BEQ.N    ??NV_PFlashSetProtection_6
        MOVS     R10,#+1
        B.N      ??NV_PFlashSetProtection_7
??NV_PFlashSetProtection_6:
        MOVS     R10,#+0
??NV_PFlashSetProtection_7:
        CMP      LR,#+255
        BEQ.N    ??NV_PFlashSetProtection_8
        MOVS     R0,#+1
        B.N      ??NV_PFlashSetProtection_9
??NV_PFlashSetProtection_8:
        MOVS     R0,#+0
??NV_PFlashSetProtection_9:
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        ORRS     R8,R9,R8
        UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
        ORRS     R8,R10,R8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ORRS     R0,R0,R8
        CMP      R0,#+0
        BEQ.N    ??NV_PFlashSetProtection_10
// 2035     {
// 2036         /* if normal mode */
// 2037         temp = protectStatus ^ registerValue;
        EORS     R0,R3,R1
        MOVS     R5,R0
// 2038         if(!(temp & protectStatus))
        TST      R5,R1
        BNE.N    ??NV_PFlashSetProtection_11
// 2039         {
// 2040             gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FPROT0_OFFSET_c, (uint8_t)(protectStatus >> 24));
        LSRS     R0,R1,#+24
        LDR      R8,[R2, #+0]
        STRB     R0,[R8, #+19]
// 2041             gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FPROT1_OFFSET_c, (uint8_t)(protectStatus >> 16));
        LSRS     R0,R1,#+16
        LDR      R8,[R2, #+0]
        STRB     R0,[R8, #+18]
// 2042             gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FPROT2_OFFSET_c, (uint8_t)(protectStatus >> 8));
        LSRS     R0,R1,#+8
        LDR      R8,[R2, #+0]
        STRB     R0,[R8, #+17]
// 2043             gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FPROT3_OFFSET_c, (uint8_t)protectStatus);
        LDR      R0,[R2, #+0]
        STRB     R1,[R0, #+16]
        B.N      ??NV_PFlashSetProtection_12
// 2044         }
// 2045         else
// 2046         {
// 2047             returnCode = gNV_ERR_CHANGEPROT_c;
??NV_PFlashSetProtection_11:
        MOVS     R0,#+32
        MOVS     R4,R0
// 2048         }
// 2049         return(returnCode);
??NV_PFlashSetProtection_12:
        MOVS     R0,R4
        B.N      ??NV_PFlashSetProtection_1
// 2050     }
// 2051     /* if unprotected or special mode */
// 2052     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FPROT0_OFFSET_c, (uint8_t)(protectStatus >> 24));
??NV_PFlashSetProtection_10:
        LSRS     R0,R1,#+24
        LDR      R8,[R2, #+0]
        STRB     R0,[R8, #+19]
// 2053     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FPROT1_OFFSET_c, (uint8_t)(protectStatus >> 16));
        LSRS     R0,R1,#+16
        LDR      R8,[R2, #+0]
        STRB     R0,[R8, #+18]
// 2054     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FPROT2_OFFSET_c, (uint8_t)(protectStatus >> 8));
        LSRS     R0,R1,#+8
        LDR      R8,[R2, #+0]
        STRB     R0,[R8, #+17]
// 2055     gNV_REG_WRITE(pConfig->ftfxRegBase + gNV_FPROT3_OFFSET_c, (uint8_t)protectStatus);
        LDR      R0,[R2, #+0]
        STRB     R1,[R0, #+16]
// 2056 
// 2057     return(returnCode);
        MOVS     R0,R4
??NV_PFlashSetProtection_1:
        POP      {R4-R10,PC}      ;; return
// 2058 }
// 2059 
// 2060 
// 2061 /************************************************************************
// 2062  *
// 2063  *  Function Name    : NV_PFlashGetProtection
// 2064  *  Description      : This function retrieves current P-Flash protection status.
// 2065  *  Arguments        : [IN] pConfig - pointer to NV configuration
// 2066  *                     [IN] protectStatus - pointer to a memory location where
// 2067  *                          the protection status will be stored
// 2068  *
// 2069  *  Return Value     : uint32_t
// 2070  *
// 2071  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2072 uint32_t NV_PFlashGetProtection
// 2073 (
// 2074         pNvConfig_t pConfig,
// 2075         uint32_t* protectStatus
// 2076 )
// 2077 {
NV_PFlashGetProtection:
        PUSH     {R4-R6}
        MOVS     R2,R0
// 2078     uint32_t registerValue0;
// 2079     uint32_t registerValue1;
// 2080     uint32_t registerValue2;
// 2081     uint32_t registerValue3;
// 2082 
// 2083     registerValue0=(uint32_t)(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FPROT0_OFFSET_c));
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+19]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,R0
// 2084     registerValue1=(uint32_t)(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FPROT1_OFFSET_c));
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+18]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R4,R0
// 2085     registerValue2=(uint32_t)(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FPROT2_OFFSET_c));
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+17]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R5,R0
// 2086     registerValue3=(uint32_t)(gNV_REG_READ(pConfig->ftfxRegBase + gNV_FPROT3_OFFSET_c));
        LDR      R0,[R2, #+0]
        LDRB     R0,[R0, #+16]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R6,R0
// 2087 
// 2088     *protectStatus = ((registerValue0 << 24 ) | \ 
// 2089             (registerValue1 << 16 ) | \ 
// 2090             (registerValue2 << 8 ) | \ 
// 2091             registerValue3);
        LSLS     R0,R4,#+16
        ORRS     R0,R0,R3, LSL #+24
        ORRS     R0,R0,R5, LSL #+8
        ORRS     R0,R6,R0
        STR      R0,[R1, #+0]
// 2092 
// 2093     return(gNV_OK_c);
        MOVS     R0,#+0
        POP      {R4-R6}
        BX       LR               ;; return
// 2094 }
// 2095 
// 2096 
// 2097 /************************************************************************
// 2098  *
// 2099  *  Function Name    : NV_SetEEEEnable
// 2100  *  Description      : This function is used to change the function of
// 2101  *                     the EERAM. When not partitioned for EEE, the EERAM
// 2102  *                     is typically used as traditional RAM. When partitioned
// 2103  *                     for EEE, the EERAM is typically used to store EEE data.
// 2104  *  Arguments        : [IN] pConfig - pointer to NV configuration
// 2105  *                     [IN] EEEEnable - EERAM Enable
// 2106  *  Return Value     : uint32_t
// 2107  *
// 2108  *************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2109 uint32_t NV_SetEEEEnable
// 2110 (
// 2111         pNvConfig_t pConfig,
// 2112         uint8_t EEEEnable
// 2113 )
// 2114 {
NV_SetEEEEnable:
        PUSH     {R4-R6,LR}
        SUB      SP,SP,#+8
        MOVS     R4,R0
        MOVS     R5,R1
// 2115     uint8_t pCommandArray[2]; /* command sequence array */
// 2116     uint32_t returnCode;      /* return code variable */
// 2117 
// 2118     /* set the default return code as gNV_OK_c */
// 2119     returnCode = gNV_OK_c;
        MOVS     R0,#+0
        MOVS     R6,R0
// 2120 
// 2121     /* preparing passing parameter to set EEPROM Enabled command */
// 2122     pCommandArray[0] = gNV_SET_EERAM_c;
        MOVS     R0,#+129
        STRB     R0,[SP, #+0]
// 2123     pCommandArray[1] = EEEEnable;
        STRB     R5,[SP, #+1]
// 2124 
// 2125     /* calling flash command sequence function to execute the command */
// 2126     returnCode = NvFlashCommandSequence(pConfig, 1, pCommandArray);
        ADD      R2,SP,#+0
        MOVS     R1,#+1
        MOVS     R0,R4
        BL       NvFlashCommandSequence
        MOVS     R6,R0
// 2127 
// 2128     return(returnCode);
        MOVS     R0,R6
        POP      {R1,R2,R4-R6,PC}  ;; return
// 2129 }

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
?_0:
        DATA
        DC8 255, 255, 255, 255

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
?_1:
        DATA
        DC8 255, 255, 255, 255

        END
// 2130 
// 2131 
// 
//     4 bytes in section .bss
//     8 bytes in section .rodata
// 3 542 bytes in section .text
//   106 bytes in section .textrw
// 
// 3 648 bytes of CODE  memory
//     8 bytes of CONST memory
//     4 bytes of DATA  memory
//
//Errors: none
//Warnings: none
