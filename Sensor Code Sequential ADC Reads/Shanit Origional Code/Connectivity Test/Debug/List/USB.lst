###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        02/Sep/2018  14:19:42
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\Common\USB.c
#    Command line =  
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\Common\USB.c" -D IAR --preprocess "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\List\" -lC "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\List\" -lB "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\List\" --diag_suppress
#        Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\Obj\" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\CDC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\Descriptor\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\USB\Class\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Sys Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
#    List file    =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\List\USB.lst
#    Object file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\Obj\USB.o
#
###############################################################################

F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\USB.c
      1          /************************************************************************************
      2          * Source file of the application specific utility services
      3          *
      4          * (c) Copyright 2010, Freescale, Inc. All rights reserved.
      5          *
      6          *
      7          * No part of this document must be reproduced in any form - including copied,
      8          * transcribed, printed or by any electronic means - without specific written
      9          * permission from Freescale Semiconductor.
     10          *
     11          *****************************************************************************/
     12          
     13          #include "EmbeddedTypes.h"
     14          #include "USB_Class.h"
     15          #include "USB_Interface.h"
     16          #include "USB_Configuration.h"
     17          #include "USB_Framework.h"
     18          #include "Utilities_Interface.h"
     19          #include "USB.h"
     20          #include "Interrupt.h"
     21          #if gUsbHidEnabled_d
     22          #include "usb_hid.h"
     23          #endif
     24          #if(gUsbCdcEnabled_d == TRUE)
     25          #include "usb_cdc.h"    /* USB CDC Class Header File */
     26          #endif
     27          #include "UsbMsgQueue.h"
     28          #include "usb_sim_settings.h"
     29          #if gUsbIncluded_d
     30          /******************************************************************************
     31          *******************************************************************************
     32          * Private macros
     33          *******************************************************************************
     34          ******************************************************************************/
     35          /* Events for USB task */
     36          #define gUsbIrqEvent_c  (1<<0)
     37          
     38          
     39          /******************************************************************************
     40          *******************************************************************************
     41          * Private prototypes
     42          *******************************************************************************
     43          ******************************************************************************/
     44          static usbError_t USB_AddControllerUnprotected( const usbClassDescriptor_t* pUsbClassDescriptor, uint8_t controllerId);
     45          static usbError_t USB_RemoveControllerUnprotected(uint8_t controllerId);
     46          
     47          /******************************************************************************
     48          *******************************************************************************
     49          * Private type definitions
     50          *******************************************************************************
     51          ******************************************************************************/
     52          
     53          
     54          /******************************************************************************
     55          *******************************************************************************
     56          * Private memory declarations
     57          *******************************************************************************
     58          ******************************************************************************/
     59          /* Queue storing pending events from the USB ISR handler */

   \                                 In section .bss, align 1
     60          static uint8_t gUsbLockLevel = 0;
   \                     gUsbLockLevel:
   \   00000000                      DS8 1
     61          
     62          /******************************************************************************
     63          *******************************************************************************
     64          * Public memory declarations
     65          *******************************************************************************
     66          ******************************************************************************/
     67          /* Id for USB task */
     68          //tsTaskID_t gUsbTaskId; //@SMAC

   \                                 In section .bss, align 4
     69          const usbClassDescriptor_t* gpaUsbClassDescriptor[gNumUsbControllers_d];
   \                     gpaUsbClassDescriptor:
   \   00000000                      DS8 4
     70          

   \                                 In section .bss, align 4
     71          pfUsbToAppEventHandler_t gpfClassFrameworkCallback = NULL;
   \                     gpfClassFrameworkCallback:
   \   00000000                      DS8 4
     72          
     73          /******************************************************************************
     74          *******************************************************************************
     75          * Public functions
     76          *******************************************************************************
     77          ******************************************************************************/
     78          static void USB_Task(void);
     79          
     80          /************************************************************************************
     81          * Usb_Init - 
     82          *   
     83          * Return value:
     84          *    
     85          * 
     86          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     87          void USB_Init(void)
     88          {
   \                     USB_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     89            USB_SIM_Settings(); 
   \   00000002   0x.... 0x....      BL       USB_SIM_Settings
     90            /* Create the USB task */
     91            gUsbLockLevel = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x....             LDR.N    R1,??DataTable7
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
     92          //  gUsbTaskId = TS_CreateTask(gTsUsbTaskPriority_c, USB_Task); //@SMAC
     93            /* Init the queue storing events from ISR routine */
     94            UsbMsgQueue_Init();
   \   0000000C   0x.... 0x....      BL       UsbMsgQueue_Init
     95            /* Clear the table storing the class descriptor of each USB controller */
     96            MemorySet( gpaUsbClassDescriptor, 0, (uint16_t)sizeof(gpaUsbClassDescriptor));
   \   00000010   0x2204             MOVS     R2,#+4
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x....             LDR.N    R0,??DataTable7_1
   \   00000016   0x.... 0x....      BL       MemorySet
     97           }
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
     98          
     99          
    100          /************************************************************************************
    101          * USB_AddController - 
    102          *   
    103          * Return value:
    104          *    
    105          * 
    106          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    107          usbError_t USB_AddController( const usbClassDescriptor_t* pUsbClassDescriptor, uint8_t controllerId)
    108          {
   \                     USB_AddController: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    109            usbError_t  usbError;
    110            uint32_t ccr;
    111             //USB_Lock();
    112            ccr = IntDisableAll();
   \   00000006   0x.... 0x....      BL       IntDisableAll
   \   0000000A   0x0007             MOVS     R7,R0
    113            usbError = USB_AddControllerUnprotected(pUsbClassDescriptor,controllerId); 
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       USB_AddControllerUnprotected
   \   00000016   0x0006             MOVS     R6,R0
    114            // USB_UnLock();
    115            IntRestoreAll(ccr);
   \   00000018   0x0038             MOVS     R0,R7
   \   0000001A   0x.... 0x....      BL       IntRestoreAll
    116            return usbError;
   \   0000001E   0x0030             MOVS     R0,R6
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    117          }
    118          
    119          
    120          
    121          
    122          /************************************************************************************
    123          * USB_RemoveController - 
    124          *   
    125          * Return value:
    126          *    
    127          * 
    128          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    129          usbError_t USB_RemoveController(uint8_t controllerId) 
    130          {
   \                     USB_RemoveController: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    131            usbError_t  usbError;
    132            uint32_t ccr;
    133            //USB_Lock();
    134            ccr = IntDisableAll();
   \   00000004   0x.... 0x....      BL       IntDisableAll
   \   00000008   0x0006             MOVS     R6,R0
    135            usbError = USB_RemoveControllerUnprotected(controllerId); 
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x.... 0x....      BL       USB_RemoveControllerUnprotected
   \   00000012   0x0005             MOVS     R5,R0
    136            //USB_UnLock();
    137            IntRestoreAll(ccr);
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0x.... 0x....      BL       IntRestoreAll
    138            return usbError;
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0xBD70             POP      {R4-R6,PC}       ;; return
    139          }
    140          
    141          
    142          
    143          /************************************************************************************
    144          * USB_GetFirstFreeController
    145          *   
    146          * Return value:
    147          *    
    148          * 
    149          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    150          uint8_t USB_GetFirstAvailableController(void)
    151          {
    152            uint8_t ctrlNo;
    153            uint8_t firstAvailableController = gUsbInvalidControllerNumber_d;
   \                     USB_GetFirstAvailableController: (+1)
   \   00000000   0x20FF             MOVS     R0,#+255
    154            for(ctrlNo = 0 ; ctrlNo < gNumUsbControllers_d; ctrlNo++)
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x0011             MOVS     R1,R2
   \                     ??USB_GetFirstAvailableController_0: (+1)
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD109             BNE.N    ??USB_GetFirstAvailableController_1
    155            {
    156              if(gpaUsbClassDescriptor[ctrlNo]  ==  NULL)    
   \   0000000C   0x....             LDR.N    R2,??DataTable7_1
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0xF852 0x2021      LDR      R2,[R2, R1, LSL #+2]
   \   00000014   0x2A00             CMP      R2,#+0
   \   00000016   0xD101             BNE.N    ??USB_GetFirstAvailableController_2
    157              {
    158                firstAvailableController =  ctrlNo;
   \   00000018   0x0008             MOVS     R0,R1
    159                break;     
   \   0000001A   0xE001             B.N      ??USB_GetFirstAvailableController_1
    160              }
    161            }
   \                     ??USB_GetFirstAvailableController_2: (+1)
   \   0000001C   0x1C49             ADDS     R1,R1,#+1
   \   0000001E   0xE7F2             B.N      ??USB_GetFirstAvailableController_0
    162            return firstAvailableController;    
   \                     ??USB_GetFirstAvailableController_1: (+1)
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x4770             BX       LR               ;; return
    163          }
    164          
    165          
    166          
    167          /************************************************************************************
    168          * USB_IsrEvent - 
    169          *   
    170          * Return value:
    171          *    
    172          * 
    173          ************************************************************************************/
    174          

   \                                 In section .text, align 2, keep-with-next
    175          void USB_IsrEvent(usbMsg_t* pUsbMsg)
    176          {
   \                     USB_IsrEvent: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    177            /* Add the event in the queue */
    178            usbMsgQueueErr_t usbMsgQueueErr;
    179            usbMsgQueueErr = UsbMsgQueue_Push(pUsbMsg);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       UsbMsgQueue_Push
   \   0000000A   0x0005             MOVS     R5,R0
    180            if(usbMsgQueueErr == usbMsgQueueErr_NoError)
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD101             BNE.N    ??USB_IsrEvent_0
    181            {
    182              /* Send message to USB task to process the event */
    183          //    TS_SendEvent(gUsbTaskId, gUsbIrqEvent_c);  //@SMAC
    184              USB_Task();
   \   00000012   0x.... 0x....      BL       USB_Task
    185              
    186            }
    187            #ifdef gUSB_Debug_d 
    188            else
    189            {
    190             // asm bgnd;
    191              while(TRUE);
    192            }
    193            #endif  
    194          }          
   \                     ??USB_IsrEvent_0: (+1)
   \   00000016   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    195          
    196          /************************************************************************************
    197          * USB_IsDeviceConnected 
    198          *   
    199          * Return value:
    200          *    
    201          * 
    202          ************************************************************************************/
    203          

   \                                 In section .text, align 2, keep-with-next
    204          bool_t USB_IsDeviceConnected(uint8_t controllerId)
    205          {
   \                     USB_IsDeviceConnected: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    206            if( controllerId  >=  gNumUsbControllers_d )
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD001             BEQ.N    ??USB_IsDeviceConnected_0
    207            {
    208              return FALSE;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE008             B.N      ??USB_IsDeviceConnected_1
    209            }
    210            if(gpaUsbClassDescriptor[controllerId] == NULL) 
   \                     ??USB_IsDeviceConnected_0: (+1)
   \   0000000C   0x....             LDR.N    R0,??DataTable7_1
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD101             BNE.N    ??USB_IsDeviceConnected_2
    211            {
    212              return FALSE;     
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE000             B.N      ??USB_IsDeviceConnected_1
    213            }
    214            else
    215            {
    216              return TRUE;  
   \                     ??USB_IsDeviceConnected_2: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \                     ??USB_IsDeviceConnected_1: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
    217            }
    218          }          
    219          /************************************************************************************
    220          * USB_Lock 
    221          *   
    222          * Return value:
    223          *    
    224          * 
    225          ************************************************************************************/
    226          

   \                                 In section .text, align 2, keep-with-next
    227          void USB_Lock(void)
    228          {
   \                     USB_Lock: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    229            if(gUsbLockLevel==0)
   \   00000002   0x....             LDR.N    R0,??DataTable7
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD101             BNE.N    ??USB_Lock_0
    230            {
    231              USB_SIM_UsbIntDisable();
   \   0000000A   0x.... 0x....      BL       USB_SIM_UsbIntDisable
    232            }
    233            gUsbLockLevel++;
   \                     ??USB_Lock_0: (+1)
   \   0000000E   0x....             LDR.N    R0,??DataTable7
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   \   00000014   0x....             LDR.N    R1,??DataTable7
   \   00000016   0x7008             STRB     R0,[R1, #+0]
    234          }
   \   00000018   0xBD01             POP      {R0,PC}          ;; return
    235          /************************************************************************************
    236          * USB_Unlock 
    237          *   
    238          * Return value:
    239          *    
    240          * 
    241          ************************************************************************************/
    242          

   \                                 In section .text, align 2, keep-with-next
    243          void USB_UnLock(void)
    244          {
   \                     USB_UnLock: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    245            if(gUsbLockLevel)
   \   00000002   0x....             LDR.N    R0,??DataTable7
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD00A             BEQ.N    ??USB_UnLock_0
    246            {
    247              gUsbLockLevel--;
   \   0000000A   0x....             LDR.N    R0,??DataTable7
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0x....             LDR.N    R1,??DataTable7
   \   00000012   0x7008             STRB     R0,[R1, #+0]
    248              if(gUsbLockLevel == 0) 
   \   00000014   0x....             LDR.N    R0,??DataTable7
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD101             BNE.N    ??USB_UnLock_0
    249              {
    250                USB_SIM_UsbIntEnable();
   \   0000001C   0x.... 0x....      BL       USB_SIM_UsbIntEnable
    251              }
    252            }
    253          }
   \                     ??USB_UnLock_0: (+1)
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
    254          /******************************************************************************
    255          *******************************************************************************
    256          * Private functions
    257          *******************************************************************************
    258          *******************************************************************************/
    259          
    260          /************************************************************************************
    261          * USB_AddControllerUnprotected - 
    262          *   
    263          * Return value:
    264          *    
    265          * 
    266          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    267          static usbError_t USB_AddControllerUnprotected( const usbClassDescriptor_t* pUsbClassDescriptor, uint8_t controllerId)
    268          {
   \                     USB_AddControllerUnprotected: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    269            usbError_t  usbError = gUsbErr_NoError_c;
   \   00000006   0x2600             MOVS     R6,#+0
    270            if( controllerId  >=  gNumUsbControllers_d )
   \   00000008   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD001             BEQ.N    ??USB_AddControllerUnprotected_0
    271            {
    272              return gUsbErr_InvalidParam_c ;
   \   0000000E   0x20D0             MOVS     R0,#+208
   \   00000010   0xE029             B.N      ??USB_AddControllerUnprotected_1
    273            }
    274            if( gpaUsbClassDescriptor[controllerId]  !=  NULL)
   \                     ??USB_AddControllerUnprotected_0: (+1)
   \   00000012   0x....             LDR.N    R0,??DataTable7_1
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??USB_AddControllerUnprotected_2
    275            {
    276              return gUsbErr_InvalidParam_c ;
   \   0000001E   0x20D0             MOVS     R0,#+208
   \   00000020   0xE021             B.N      ??USB_AddControllerUnprotected_1
    277            }
    278            if(pUsbClassDescriptor == NULL)
   \                     ??USB_AddControllerUnprotected_2: (+1)
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD101             BNE.N    ??USB_AddControllerUnprotected_3
    279            {
    280              return gUsbErr_InvalidParam_c ;      
   \   00000026   0x20D0             MOVS     R0,#+208
   \   00000028   0xE01D             B.N      ??USB_AddControllerUnprotected_1
    281            }
    282            
    283            switch(pUsbClassDescriptor->classId)
   \                     ??USB_AddControllerUnprotected_3: (+1)
   \   0000002A   0x7820             LDRB     R0,[R4, #+0]
   \   0000002C   0x2802             CMP      R0,#+2
   \   0000002E   0xD002             BEQ.N    ??USB_AddControllerUnprotected_4
   \   00000030   0x2803             CMP      R0,#+3
   \   00000032   0xD00D             BEQ.N    ??USB_AddControllerUnprotected_5
   \   00000034   0xE00E             B.N      ??USB_AddControllerUnprotected_6
    284            {
    285              case gUsbClassId_Cdc_c:
    286              #if(gUsbCdcEnabled_d == FALSE)
    287                return gUsbErr_InvalidParam_c ;
    288              #else  
    289                gpaUsbClassDescriptor[controllerId] = pUsbClassDescriptor;
   \                     ??USB_AddControllerUnprotected_4: (+1)
   \   00000036   0x....             LDR.N    R0,??DataTable7_1
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0xF840 0x4025      STR      R4,[R0, R5, LSL #+2]
    290                usbError = USB_Class_CDC_Init(controllerId);                    
   \   0000003E   0x0028             MOVS     R0,R5
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0x.... 0x....      BL       USB_Class_CDC_Init
   \   00000046   0x0006             MOVS     R6,R0
    291              #endif
    292              break;
    293              
    294              case gUsbClassId_Hid_c:
    295              #if(gUsbHidEnabled_d == FALSE)
    296                return gUsbErr_InvalidParam_c ;
    297              #else
    298                gpaUsbClassDescriptor[controllerId] = pUsbClassDescriptor;
    299                usbError = USB_Class_HID_Init(controllerId);                    
    300              #endif
    301              break;
    302                
    303            default:
    304              return gUsbErr_InvalidParam_c ;
    305            }
    306            /* Check that controller 0 is a HUB. If not, return error as a new controller can only be added
    307            on a HUB */ 
    308             if(gUsbErr_NoError_c != usbError)
   \   00000048   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004A   0x2E00             CMP      R6,#+0
   \   0000004C   0xD104             BNE.N    ??USB_AddControllerUnprotected_7
   \   0000004E   0xE008             B.N      ??USB_AddControllerUnprotected_8
   \                     ??USB_AddControllerUnprotected_5: (+1)
   \   00000050   0x20D0             MOVS     R0,#+208
   \   00000052   0xE008             B.N      ??USB_AddControllerUnprotected_1
   \                     ??USB_AddControllerUnprotected_6: (+1)
   \   00000054   0x20D0             MOVS     R0,#+208
   \   00000056   0xE006             B.N      ??USB_AddControllerUnprotected_1
    309            {
    310              gpaUsbClassDescriptor[controllerId]  =  NULL ;
   \                     ??USB_AddControllerUnprotected_7: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x....             LDR.N    R1,??DataTable7_1
   \   0000005C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   0xF841 0x0025      STR      R0,[R1, R5, LSL #+2]
    311            }
    312          
    313            return usbError;
   \                     ??USB_AddControllerUnprotected_8: (+1)
   \   00000062   0x0030             MOVS     R0,R6
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_AddControllerUnprotected_1: (+1)
   \   00000066   0xBD70             POP      {R4-R6,PC}       ;; return
    314          }
    315          
    316          
    317          /************************************************************************************
    318          * USB_RemoveControllerUnprotected - 
    319          *   
    320          * Return value:
    321          *    
    322          * 
    323          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    324          static usbError_t USB_RemoveControllerUnprotected(uint8_t controllerId)
    325          {
   \                     USB_RemoveControllerUnprotected: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    326            usbError_t  usbError = gUsbErr_NoError_c;
   \   00000004   0x2500             MOVS     R5,#+0
    327            
    328            if( controllerId  >=  gNumUsbControllers_d )
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD001             BEQ.N    ??USB_RemoveControllerUnprotected_0
    329            {
    330              return gUsbErr_InvalidParam_c ;
   \   0000000C   0x20D0             MOVS     R0,#+208
   \   0000000E   0xE021             B.N      ??USB_RemoveControllerUnprotected_1
    331            }
    332            if( gpaUsbClassDescriptor[controllerId]  ==  NULL)
   \                     ??USB_RemoveControllerUnprotected_0: (+1)
   \   00000010   0x....             LDR.N    R0,??DataTable7_1
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD101             BNE.N    ??USB_RemoveControllerUnprotected_2
    333            {
    334              return gUsbErr_InvalidParam_c ;
   \   0000001C   0x20D0             MOVS     R0,#+208
   \   0000001E   0xE019             B.N      ??USB_RemoveControllerUnprotected_1
    335            }
    336          
    337            switch(gpaUsbClassDescriptor[controllerId]->classId)
   \                     ??USB_RemoveControllerUnprotected_2: (+1)
   \   00000020   0x....             LDR.N    R0,??DataTable7_1
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x2802             CMP      R0,#+2
   \   0000002C   0xD002             BEQ.N    ??USB_RemoveControllerUnprotected_3
   \   0000002E   0x2803             CMP      R0,#+3
   \   00000030   0xD00D             BEQ.N    ??USB_RemoveControllerUnprotected_4
   \   00000032   0xE00E             B.N      ??USB_RemoveControllerUnprotected_5
    338            {
    339              case gUsbClassId_Cdc_c:
    340                #if(gUsbCdcEnabled_d == TRUE)
    341                usbError = USB_Class_CDC_DeInit(controllerId);
   \                     ??USB_RemoveControllerUnprotected_3: (+1)
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x.... 0x....      BL       USB_Class_CDC_DeInit
   \   0000003C   0x0005             MOVS     R5,R0
    342                #else
    343                return gUsbErr_InvalidParam_c ;
    344                #endif
    345              break;
    346              case gUsbClassId_Hid_c:
    347               #if(gUsbHidEnabled_d == TRUE)
    348                usbError = USB_Class_HID_DeInit(controllerId);                    
    349               #else 
    350                return gUsbErr_InvalidParam_c ;
    351               #endif
    352              break;
    353              default:
    354              return gUsbErr_InvalidParam_c ;
    355              }
    356           
    357              gpaUsbClassDescriptor[controllerId] = NULL;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x....             LDR.N    R1,??DataTable7_1
   \   00000042   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000044   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
    358              return usbError;  
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0xE002             B.N      ??USB_RemoveControllerUnprotected_1
   \                     ??USB_RemoveControllerUnprotected_4: (+1)
   \   0000004E   0x20D0             MOVS     R0,#+208
   \   00000050   0xE000             B.N      ??USB_RemoveControllerUnprotected_1
   \                     ??USB_RemoveControllerUnprotected_5: (+1)
   \   00000052   0x20D0             MOVS     R0,#+208
   \                     ??USB_RemoveControllerUnprotected_1: (+1)
   \   00000054   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    359          }
    360          
    361          
    362          /************************************************************************************
    363          * USB_Task - 
    364          *   
    365          * Return value:
    366          *    
    367          * 
    368          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    369          static void USB_Task(void)  //@SMAC
    370          { 
   \                     USB_Task: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    371            usbMsg_t* pUsbMsg;
    372            pfUsbToAppEventHandler_t pfUsbToAppEventHandler = NULL;
   \   00000002   0x2500             MOVS     R5,#+0
    373            
    374            
    375            if(gUsbIrqEvent_c)
    376            {
    377              /* Check if there are pending events in the ISR queue */
    378              if(UsbMsgQueue_MsgPending())
   \   00000004   0x.... 0x....      BL       UsbMsgQueue_MsgPending
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD017             BEQ.N    ??USB_Task_0
    379              {
    380                /* Get event out of queue */
    381                pUsbMsg = UsbMsgQueue_GetFirstMsg();
   \   0000000C   0x.... 0x....      BL       UsbMsgQueue_GetFirstMsg
   \   00000010   0x0004             MOVS     R4,R0
    382                #ifdef gUSB_Debug_d 
    383                //debug start
    384                if(pUsbMsg->controllerId >= gNumUsbControllers_d)
    385                 {
    386                   while(TRUE);
    387                 }
    388                //debug end
    389                #endif
    390                if(gpaUsbClassDescriptor[pUsbMsg->controllerId] != NULL)
   \   00000012   0x....             LDR.N    R0,??DataTable7_1
   \   00000014   0x7821             LDRB     R1,[R4, #+0]
   \   00000016   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD005             BEQ.N    ??USB_Task_1
    391                {
    392                  pfUsbToAppEventHandler = gpaUsbClassDescriptor[pUsbMsg->controllerId]->pfUsbToAppEventHandler;
   \   0000001E   0x....             LDR.N    R0,??DataTable7_1
   \   00000020   0x7821             LDRB     R1,[R4, #+0]
   \   00000022   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000026   0x6840             LDR      R0,[R0, #+4]
   \   00000028   0x0005             MOVS     R5,R0
    393                }
    394                
    395                if(pfUsbToAppEventHandler != NULL)
   \                     ??USB_Task_1: (+1)
   \   0000002A   0x0028             MOVS     R0,R5
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD003             BEQ.N    ??USB_Task_2
    396                  {
    397                   pfUsbToAppEventHandler(pUsbMsg->controllerId , pUsbMsg->eventType , pUsbMsg ) ;
   \   00000030   0x0022             MOVS     R2,R4
   \   00000032   0x7861             LDRB     R1,[R4, #+1]
   \   00000034   0x7820             LDRB     R0,[R4, #+0]
   \   00000036   0x47A8             BLX      R5
    398                  }
    399                
    400                (void)UsbMsgQueue_Pop();
   \                     ??USB_Task_2: (+1)
   \   00000038   0x.... 0x....      BL       UsbMsgQueue_Pop
    401              }
    402            }
    403             
    404            /* If there are unprocessed events in the queue, send a message to the USB
    405            task to run again  */
    406            if(UsbMsgQueue_MsgPending())
   \                     ??USB_Task_0: (+1)
   \   0000003C   0x.... 0x....      BL       UsbMsgQueue_MsgPending
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD001             BEQ.N    ??USB_Task_3
    407            {
    408              //TS_SendEvent(gUsbTaskId, gUsbIrqEvent_c); //@SMAC
    409              USB_Task();
   \   00000044   0xF7FF 0xFFDC      BL       USB_Task
    410            }
    411          }
   \                     ??USB_Task_3: (+1)
   \   00000048   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     gUsbLockLevel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     gpaUsbClassDescriptor
    412          
    413          
    414          #endif // gUsbIncluded_d

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   USB_AddController
        24   -> IntDisableAll
        24   -> IntRestoreAll
        24   -> USB_AddControllerUnprotected
      16   USB_AddControllerUnprotected
        16   -> USB_Class_CDC_Init
       0   USB_GetFirstAvailableController
       8   USB_Init
         8   -> MemorySet
         8   -> USB_SIM_Settings
         8   -> UsbMsgQueue_Init
       0   USB_IsDeviceConnected
      16   USB_IsrEvent
        16   -> USB_Task
        16   -> UsbMsgQueue_Push
       8   USB_Lock
         8   -> USB_SIM_UsbIntDisable
      16   USB_RemoveController
        16   -> IntDisableAll
        16   -> IntRestoreAll
        16   -> USB_RemoveControllerUnprotected
      16   USB_RemoveControllerUnprotected
        16   -> USB_Class_CDC_DeInit
      16   USB_Task
        16   -- Indirect call
        16   -> USB_Task
        16   -> UsbMsgQueue_GetFirstMsg
        16   -> UsbMsgQueue_MsgPending
        16   -> UsbMsgQueue_Pop
       8   USB_UnLock
         8   -> USB_SIM_UsbIntEnable


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
      36  USB_AddController
     104  USB_AddControllerUnprotected
      36  USB_GetFirstAvailableController
      28  USB_Init
      32  USB_IsDeviceConnected
      24  USB_IsrEvent
      26  USB_Lock
      32  USB_RemoveController
      86  USB_RemoveControllerUnprotected
      74  USB_Task
      34  USB_UnLock
       1  gUsbLockLevel
       4  gpaUsbClassDescriptor
       4  gpfClassFrameworkCallback

 
   9 bytes in section .bss
 520 bytes in section .text
 
 520 bytes of CODE memory
   9 bytes of DATA memory

Errors: none
Warnings: none
