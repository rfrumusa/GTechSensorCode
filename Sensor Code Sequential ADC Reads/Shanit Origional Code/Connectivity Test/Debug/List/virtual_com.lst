###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        20/Mar/2018  09:41:56
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\CDC\virtual_com.c
#    Command line =  
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\CDC\virtual_com.c" -D IAR --preprocess
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Debug\List\" -lC
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Debug\List\" -lB
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Debug\List\"
#        --diag_suppress Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Debug\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\rfrum\OneDrive\2018
#        Spring Semester\Senior Design\Sensor Code\Shanit Origional
#        Code\Connectivity Test\PLM\Configure\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Environment\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Interface\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Generic
#        Services\Interface\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Uart\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\CDC\" -I "C:\Users\rfrum\OneDrive\2018 Spring
#        Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\Descriptor\" -I "C:\Users\rfrum\OneDrive\2018
#        Spring Semester\Senior Design\Sensor Code\Shanit Origional
#        Code\Connectivity Test\PLM\Source\USB\Class\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\"
#        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
#        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Radio\MC1324x\PHY\" -I "C:\Users\rfrum\OneDrive\2018
#        Spring Semester\Senior Design\Sensor Code\Shanit Origional
#        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\Sys Common\"
#        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Application\Source\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Application\Configure\"
#        -I "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -On
#    List file    =  
#        C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity
#        Test\Debug\List\virtual_com.lst
#    Object file  =  
#        C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\Debug\Obj\virtual_com.o
#
###############################################################################

C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor Code\Shanit Origional Code\Connectivity Test\PLM\Source\USB\APP\CDC\virtual_com.c
      1          /******************************************************************************
      2           * Virtual Com Application
      3           * Freescale Semiconductor Inc.
      4           * (c) Copyright 2012 Freescale Semiconductor, Inc.
      5           * ALL RIGHTS RESERVED.
      6           *
      7           *****************************************************************************/
      8           
      9           
     10          
     11          /******************************************************************************
     12           * Includes
     13           *****************************************************************************/
     14          #include "EmbeddedTypes.h"          /* User Defined Data Types */
     15          #include "Utilities_Interface.h"
     16          #include "Interrupt.h"
     17          #include "USB_Interface.h"   
     18          #include "USB.h"
     19          #include "usb_cdc.h"        /* USB CDC Class Header File */
     20          #include "CDC_Interface.h" 
     21          #include "PortConfig.h"
     22          #if gVirtualCOMPort_d
     23          /*****************************************************************************
     24           * Constant and Macro's - None
     25           *****************************************************************************/
     26          #define USB_Class_CDC_Interface_DIC_Send_Data( controller_ID, buff_ptr, size)  \
     27                   USB_ClassSendData( controller_ID , gCDC_DIC_BulkInEndpoint_d , buff_ptr , size)
     28          #define USB_Class_CDC_Interface_DIC_Recv_Data(controllerId, pBuff, size)  \
     29                  USB_DeviceRecvData(controllerId, gCDC_DIC_BulkOutEndpoint_d, pBuff, size);        
     30           
     31          #if(gUsbCdcEnabled_d == FALSE)
     32           #error "gUsbCdcEnabled_d in USB_Configuration.h must be TRUE"
     33          #endif
     34          
     35          #if (gUsbIncluded_d == FALSE)
     36           #error If gVirtualCOMPort_d == TRUE, gUsbIncluded_d must be TRUE
     37          #endif
     38          
     39          #if gCDC_RxFlowControlResume_d >= (gCDC_ReceiveBufferSize_c - gCDC_RxFlowControlSkew_d)
     40          #error Deassert flow control before it is asserted?
     41          #endif
     42          
     43          #if gCDC_RxFlowControlSkew_d < gUsbCdcBulkOutEpSize_d
     44          #error gCDC_RxFlowControlSkew_d must be >= gUsbCdcBulkOutEpSize_d
     45          #endif
     46          /*****************************************************************************
     47           * Global Functions Prototypes
     48           *****************************************************************************/
     49          bool_t CDC_CommOpen(void);
     50          
     51          /****************************************************************************
     52           * Global Variables
     53           ****************************************************************************/
     54           
     55          /*****************************************************************************
     56           * Local Types - None
     57           *****************************************************************************/
     58          typedef struct cdcTxBufRef_tag {
     59            unsigned char const *pBuf;
     60            void (*pfCallBack)(unsigned char const *pBuf);
     61          } cdcTxBufRef_t;
     62          
     63          /*****************************************************************************
     64           * Local Functions Prototypes
     65           *****************************************************************************/
     66          static void CDC_DicInServiceCallback(usbDeviceEvent_t* event);
     67          static void CDC_DicOutServiceCallback(usbDeviceEvent_t* event);
     68          static void CDC_App_Callback(uint8_t controller_ID,
     69                                  gUsbToAppEvent_t event_type, void* val);
     70          //static bool_t CDC_CommOpen(void);                         
     71          
     72          /*****************************************************************************
     73           * Local Variables
     74           *****************************************************************************/
     75          
     76          //Tx variables

   \                                 In section .bss, align 4
     77          static cdcTxBufRef_t maCDCTxBufRefTable[gCDC_TransmitBuffers_c];
   \                     maCDCTxBufRefTable:
   \   00000000                      DS8 24

   \                                 In section .bss, align 4
     78          static index_t maCDCTxBufLenTable[gCDC_TransmitBuffers_c];
   \                     maCDCTxBufLenTable:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     79          static index_t mCDCTxBufRefLeadingIndex;   /* Post-increment. */
   \                     mCDCTxBufRefLeadingIndex:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     80          static index_t mCDCTxPendingTxNum;
   \                     mCDCTxPendingTxNum:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     81          static index_t mCDCTxBufRefTrailingIndex;  /* Post-increment. */
   \                     mCDCTxBufRefTrailingIndex:
   \   00000000                      DS8 1
     82          
     83          //Rx variables

   \                                 In section .bss, align 4
     84          static   uint8_t maCDCRxBuf[gCDC_ReceiveBufferSize_c];
   \                     maCDCRxBuf:
   \   00000000                      DS8 64

   \                                 In section .bss, align 1
     85          static   index_t mCDCRxBufLeadingIndex;      /* Post-increment. */
   \                     mCDCRxBufLeadingIndex:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     86          static   index_t mCDCRxBufTrailingIndex;     /* Post-increment. */
   \                     mCDCRxBufTrailingIndex:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     87          volatile index_t gCDCRxBufferByteCount;      /* # of bytes in buffer. */
   \                     gCDCRxBufferByteCount:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     88          static void (*pfCDCRxCallBack)(void);
   \                     pfCDCRxCallBack:
   \   00000000                      DS8 4
     89          #if gUsbAppNotificationOnSuspend_d  
     90          static void (*pfUSBSuspendCallBack)(void);
     91          #endif

   \                                 In section .bss, align 1
     92          volatile static bool_t gCDCDicRxMsgInUsbOueue;
   \                     gCDCDicRxMsgInUsbOueue:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     93          volatile static bool_t gCDCDicTxMsgInUsbOueue;
   \                     gCDCDicTxMsgInUsbOueue:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     94          volatile static bool_t gCDCDicRxEnabled;
   \                     gCDCDicRxEnabled:
   \   00000000                      DS8 1
     95          

   \                                 In section .bss, align 1
     96          static volatile bool_t mCDCEnumerated;
   \                     mCDCEnumerated:
   \   00000000                      DS8 1
     97          #if gUSB_CDC_SendEventToAppOnCOMOpen_d 

   \                                 In section .bss, align 1
     98          static volatile bool_t mCDCChannelOpen;
   \                     mCDCChannelOpen:
   \   00000000                      DS8 1
     99          #endif 

   \                                 In section .rodata, align 4
    100          const usbClassDescriptor_t usbClassDescriptor_CDC= 
   \                     usbClassDescriptor_CDC:
   \   00000000   0x02 0x00          DC8 2, 0, 0, 0
   \              0x00 0x00    
   \   00000004   0x........         DC32 CDC_App_Callback, 0H, 0H, USB_CDC_Desc_GetDescriptor
   \              0x00000000   
   \              0x00000000   
   \              0x........   
   \   00000014   0x........         DC32 USB_CDC_Desc_GetInterface, USB_CDC_Desc_SetInterface
   \              0x........   
   \   0000001C   0x........         DC32 USB_CDC_Desc_ValidConfiguration, USB_CDC_Desc_ValidInterface
   \              0x........   
   \   00000024   0x........         DC32 USB_CDC_Desc_RemoteWakeup
   \   00000028   0x10 0x03          DC8 16, 3, 0, 0
   \              0x00 0x00    
   \   0000002C   0x........         DC32 usbCdcDescEp
    101          {
    102            gUsbClassId_Cdc_c, 
    103            CDC_App_Callback,
    104            NULL,
    105            NULL,
    106            USB_CDC_Desc_GetDescriptor,
    107            USB_CDC_Desc_GetInterface,
    108            USB_CDC_Desc_SetInterface,
    109            USB_CDC_Desc_ValidConfiguration,
    110            USB_CDC_Desc_ValidInterface,
    111            USB_CDC_Desc_RemoteWakeup,
    112            gUsbCdcControlEpSize_d,
    113            gNumUsbCdcNonControlEp_d,
    114            (usbEpStruct_t*)usbCdcDescEp
    115          } ;
    116          
    117          
    118          
    119          
    120          /*****************************************************************************
    121           * Global Functions
    122           *****************************************************************************/
    123          
    124          /*****************************************************************************/
    125          

   \                                 In section .text, align 2, keep-with-next
    126          bool_t CDC_ModuleInit(void)
    127          {  
   \                     CDC_ModuleInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    128            uint32_t ccr;
    129            uint8_t status = FALSE;
   \   00000002   0x2500             MOVS     R5,#+0
    130            ccr = IntDisableAll();
   \   00000004   0x.... 0x....      BL       IntDisableAll
   \   00000008   0x0004             MOVS     R4,R0
    131            if(USB_IsDeviceConnected(gUsbCdcControllerId_d) == FALSE)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      BL       USB_IsDeviceConnected
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD13C             BNE.N    ??CDC_ModuleInit_0
    132            {
    133              usbError_t usbErr;
    134              MemorySet( maCDCTxBufLenTable , 0 , sizeof(maCDCTxBufLenTable));
   \   00000014   0x2203             MOVS     R2,#+3
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable9
   \   0000001C   0x.... 0x....      BL       MemorySet
    135              mCDCTxBufRefLeadingIndex = mCDCTxBufRefTrailingIndex = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   00000026   0x7008             STRB     R0,[R1, #+0]
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable9_1
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable9_2
   \   00000032   0x7008             STRB     R0,[R1, #+0]
    136              mCDCTxPendingTxNum = 0;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \   0000003A   0x7008             STRB     R0,[R1, #+0]
    137              mCDCRxBufLeadingIndex = mCDCRxBufTrailingIndex = gCDCRxBufferByteCount = 0;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable9_4
   \   00000042   0x7008             STRB     R0,[R1, #+0]
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable9_5
   \   00000048   0x7008             STRB     R0,[R1, #+0]
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable9_6
   \   0000004E   0x7008             STRB     R0,[R1, #+0]
    138              gCDCDicRxMsgInUsbOueue = FALSE;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable9_7
   \   00000056   0x7008             STRB     R0,[R1, #+0]
    139              gCDCDicTxMsgInUsbOueue = FALSE;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable9_8
   \   0000005E   0x7008             STRB     R0,[R1, #+0]
    140              gCDCDicRxEnabled = TRUE;
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable9_9
   \   00000066   0x7008             STRB     R0,[R1, #+0]
    141              USB_Class_CDC_SetDicInServiceCallback(CDC_DicInServiceCallback);
   \   00000068   0x.... 0x....      ADR.W    R0,CDC_DicInServiceCallback
   \   0000006C   0x.... 0x....      BL       USB_Class_CDC_SetDicInServiceCallback
    142              USB_Class_CDC_SetDicOutServiceCallback(CDC_DicOutServiceCallback);
   \   00000070   0x.... 0x....      ADR.W    R0,CDC_DicOutServiceCallback
   \   00000074   0x.... 0x....      BL       USB_Class_CDC_SetDicOutServiceCallback
    143              usbErr =  USB_AddController(&usbClassDescriptor_CDC, gUsbCdcControllerId_d);   
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable9_10
   \   0000007E   0x.... 0x....      BL       USB_AddController
   \   00000082   0x0006             MOVS     R6,R0
    144              if(usbErr == gUsbErr_NoError_c)
   \   00000084   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000086   0x2E00             CMP      R6,#+0
   \   00000088   0xD101             BNE.N    ??CDC_ModuleInit_0
    145              {
    146                status = TRUE;   
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x0005             MOVS     R5,R0
    147              }
    148            } 
    149            IntRestoreAll(ccr);
   \                     ??CDC_ModuleInit_0: (+1)
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0x.... 0x....      BL       IntRestoreAll
    150            return status;                               
   \   00000094   0x0028             MOVS     R0,R5
   \   00000096   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000098   0xBD70             POP      {R4-R6,PC}       ;; return
    151          }
    152          
    153          /*****************************************************************************/
    154          

   \                                 In section .text, align 2, keep-with-next
    155          bool_t CDC_ModuleUninit(void)
    156          {
   \                     CDC_ModuleUninit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    157             uint32_t ccr;
    158             uint8_t status = FALSE;
   \   00000002   0x2500             MOVS     R5,#+0
    159             usbError_t usbErr;
    160             ccr = IntDisableAll();
   \   00000004   0x.... 0x....      BL       IntDisableAll
   \   00000008   0x0004             MOVS     R4,R0
    161             usbErr = USB_RemoveController(gUsbCdcControllerId_d);   
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      BL       USB_RemoveController
   \   00000010   0x0006             MOVS     R6,R0
    162             if(usbErr == gUsbErr_NoError_c)
   \   00000012   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD113             BNE.N    ??CDC_ModuleUninit_0
    163             {
    164               pfCDCRxCallBack = NULL;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable9_11
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    165          #if gUsbAppNotificationOnSuspend_d  
    166               pfUSBSuspendCallBack=NULL;
    167          #endif     
    168               USB_Class_CDC_SetDicInServiceCallback(NULL);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      BL       USB_Class_CDC_SetDicInServiceCallback
    169               USB_Class_CDC_SetDicOutServiceCallback(NULL);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x.... 0x....      BL       USB_Class_CDC_SetDicOutServiceCallback
    170               mCDCEnumerated = FALSE;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable9_12
   \   00000032   0x7008             STRB     R0,[R1, #+0]
    171          #if gUSB_CDC_SendEventToAppOnCOMOpen_d            
    172               mCDCChannelOpen = FALSE;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable9_13
   \   0000003A   0x7008             STRB     R0,[R1, #+0]
    173          #endif      
    174               status = TRUE;   
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x0005             MOVS     R5,R0
    175             }
    176             IntRestoreAll(ccr);
   \                     ??CDC_ModuleUninit_0: (+1)
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       IntRestoreAll
    177             return status;
   \   00000046   0x0028             MOVS     R0,R5
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0xBD70             POP      {R4-R6,PC}       ;; return
    178          }
    179          
    180          /*****************************************************************************/
    181          

   \                                 In section .text, align 2, keep-with-next
    182          bool_t CDC_Transmit(unsigned char const *pBuf, index_t bufLen, void (*pfCallBack)(unsigned char const *pBuf))
    183          {
   \                     CDC_Transmit: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x4693             MOV      R11,R2
    184          
    185            bool_t transmit = FALSE;
   \   0000000A   0x2600             MOVS     R6,#+0
    186            bool_t status = FALSE;
   \   0000000C   0x2700             MOVS     R7,#+0
    187            uint32_t ccr;
    188            unsigned char const *pUncalledBuf;
    189          
    190            void (*pfUncalledCallBack)(unsigned char const*) = NULL;
   \   0000000E   0xF05F 0x0A00      MOVS     R10,#+0
    191            /* Handle empty buffers. */
    192            if (!bufLen) 
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD106             BNE.N    ??CDC_Transmit_0
    193            {
    194              if(pfCallBack)
   \   00000018   0x4658             MOV      R0,R11
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??CDC_Transmit_1
    195                (*pfCallBack)(pBuf);
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x47D8             BLX      R11
    196              return TRUE;
   \                     ??CDC_Transmit_1: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE073             B.N      ??CDC_Transmit_2
    197            }
    198            
    199            if(CDC_CommOpen() == FALSE)
   \                     ??CDC_Transmit_0: (+1)
   \   00000026   0x.... 0x....      BL       CDC_CommOpen
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD106             BNE.N    ??CDC_Transmit_3
    200            {
    201               if(pfCallBack)
   \   0000002E   0x4658             MOV      R0,R11
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD001             BEQ.N    ??CDC_Transmit_4
    202                (*pfCallBack)(pBuf);
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x47D8             BLX      R11
    203             return TRUE;    
   \                     ??CDC_Transmit_4: (+1)
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xE068             B.N      ??CDC_Transmit_2
    204            }
    205            ccr = IntDisableAll();
   \                     ??CDC_Transmit_3: (+1)
   \   0000003C   0x.... 0x....      BL       IntDisableAll
   \   00000040   0x4680             MOV      R8,R0
    206              /* Room for one more? */
    207            if(maCDCTxBufLenTable[mCDCTxBufRefLeadingIndex] == 0)
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable9_2
   \   0000004A   0x7809             LDRB     R1,[R1, #+0]
   \   0000004C   0x5C08             LDRB     R0,[R1, R0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD146             BNE.N    ??CDC_Transmit_5
    208            {
    209              pfUncalledCallBack = maCDCTxBufRefTable[mCDCTxBufRefLeadingIndex].pfCallBack ; 
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable9_14
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable9_2
   \   0000005A   0x7809             LDRB     R1,[R1, #+0]
   \   0000005C   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000060   0x6840             LDR      R0,[R0, #+4]
   \   00000062   0x4682             MOV      R10,R0
    210              pUncalledBuf = maCDCTxBufRefTable[mCDCTxBufRefLeadingIndex].pBuf;
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable9_14
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable9_2
   \   0000006C   0x7809             LDRB     R1,[R1, #+0]
   \   0000006E   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   00000072   0x4681             MOV      R9,R0
    211              maCDCTxBufRefTable[mCDCTxBufRefLeadingIndex].pBuf = pBuf;
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable9_14
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable9_2
   \   0000007C   0x7809             LDRB     R1,[R1, #+0]
   \   0000007E   0xF840 0x4031      STR      R4,[R0, R1, LSL #+3]
    212              maCDCTxBufRefTable[mCDCTxBufRefLeadingIndex].pfCallBack = pfCallBack;
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable9_14
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable9_2
   \   0000008A   0x7809             LDRB     R1,[R1, #+0]
   \   0000008C   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000090   0xF8C0 0xB004      STR      R11,[R0, #+4]
    213              maCDCTxBufLenTable[mCDCTxBufRefLeadingIndex] = bufLen;
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable9_2
   \   0000009C   0x7809             LDRB     R1,[R1, #+0]
   \   0000009E   0x540D             STRB     R5,[R1, R0]
    214              if (++mCDCTxBufRefLeadingIndex >= NumberOfElements(maCDCTxBufRefTable)) 
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable9_2
   \   000000A4   0x7800             LDRB     R0,[R0, #+0]
   \   000000A6   0x1C40             ADDS     R0,R0,#+1
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable9_2
   \   000000AC   0x7008             STRB     R0,[R1, #+0]
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable9_2
   \   000000B2   0x7800             LDRB     R0,[R0, #+0]
   \   000000B4   0x2803             CMP      R0,#+3
   \   000000B6   0xD303             BCC.N    ??CDC_Transmit_6
    215              {
    216                mCDCTxBufRefLeadingIndex = 0;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable9_2
   \   000000BE   0x7008             STRB     R0,[R1, #+0]
    217              }
    218              mCDCTxPendingTxNum++;
   \                     ??CDC_Transmit_6: (+1)
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   000000C4   0x7800             LDRB     R0,[R0, #+0]
   \   000000C6   0x1C40             ADDS     R0,R0,#+1
   \   000000C8   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \   000000CC   0x7008             STRB     R0,[R1, #+0]
    219              if(mCDCTxPendingTxNum == 1)
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   000000D2   0x7800             LDRB     R0,[R0, #+0]
   \   000000D4   0x2801             CMP      R0,#+1
   \   000000D6   0xD101             BNE.N    ??CDC_Transmit_7
    220              {
    221                transmit = TRUE;
   \   000000D8   0x2001             MOVS     R0,#+1
   \   000000DA   0x0006             MOVS     R6,R0
    222              }
    223              status = TRUE;
   \                     ??CDC_Transmit_7: (+1)
   \   000000DC   0x2001             MOVS     R0,#+1
   \   000000DE   0x0007             MOVS     R7,R0
    224            }
    225            IntRestoreAll(ccr);
   \                     ??CDC_Transmit_5: (+1)
   \   000000E0   0x4640             MOV      R0,R8
   \   000000E2   0x.... 0x....      BL       IntRestoreAll
    226            if(transmit)
   \   000000E6   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000E8   0x2E00             CMP      R6,#+0
   \   000000EA   0xD009             BEQ.N    ??CDC_Transmit_8
    227            {
    228              (void)USB_Class_CDC_Interface_DIC_Send_Data(gUsbCdcControllerId_d,(uint8_t*)pBuf, bufLen);    
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0x9000             STR      R0,[SP, #+0]
   \   000000F0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000F2   0x002B             MOVS     R3,R5
   \   000000F4   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000F6   0x0022             MOVS     R2,R4
   \   000000F8   0x2101             MOVS     R1,#+1
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0x.... 0x....      BL       USB_ClassSendData_
    229            }
    230            if(pfUncalledCallBack != NULL)
   \                     ??CDC_Transmit_8: (+1)
   \   00000100   0x4650             MOV      R0,R10
   \   00000102   0x2800             CMP      R0,#+0
   \   00000104   0xD001             BEQ.N    ??CDC_Transmit_9
    231            {
    232              pfUncalledCallBack(pUncalledBuf);
   \   00000106   0x4648             MOV      R0,R9
   \   00000108   0x47D0             BLX      R10
    233            }
    234            return status; 
   \                     ??CDC_Transmit_9: (+1)
   \   0000010A   0x0038             MOVS     R0,R7
   \   0000010C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??CDC_Transmit_2: (+1)
   \   0000010E   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    235              
    236          }
    237          
    238          /*****************************************************************************/
    239          

   \                                 In section .text, align 2, keep-with-next
    240          bool_t CDC_IsTxActive(void)
    241          {
    242            return (maCDCTxBufLenTable[mCDCTxBufRefTrailingIndex] != 0);
   \                     CDC_IsTxActive: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   00000008   0x7809             LDRB     R1,[R1, #+0]
   \   0000000A   0x5C08             LDRB     R0,[R1, R0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD001             BEQ.N    ??CDC_IsTxActive_0
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xE000             B.N      ??CDC_IsTxActive_1
   \                     ??CDC_IsTxActive_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \                     ??CDC_IsTxActive_1: (+1)
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x4770             BX       LR               ;; return
    243          }
    244          
    245          
    246          
    247          
    248          /*****************************************************************************/
    249          

   \                                 In section .text, align 2, keep-with-next
    250          void CDC_SetRxCallBack(void (*pfCallBack)(void))
    251          {
   \                     CDC_SetRxCallBack: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    252            uint32_t ccr;
    253            ccr = IntDisableAll();
   \   00000004   0x.... 0x....      BL       IntDisableAll
   \   00000008   0x0005             MOVS     R5,R0
    254            pfCDCRxCallBack = pfCallBack;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable9_11
   \   0000000E   0x6004             STR      R4,[R0, #+0]
    255            if (pfCDCRxCallBack == NULL) 
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable9_11
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD109             BNE.N    ??CDC_SetRxCallBack_0
    256            {
    257              mCDCRxBufLeadingIndex = mCDCRxBufTrailingIndex = gCDCRxBufferByteCount = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable9_4
   \   00000020   0x7008             STRB     R0,[R1, #+0]
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable9_5
   \   00000026   0x7008             STRB     R0,[R1, #+0]
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable9_6
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
    258            } 
    259            IntRestoreAll(ccr);
   \                     ??CDC_SetRxCallBack_0: (+1)
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0x.... 0x....      BL       IntRestoreAll
    260          }
   \   00000034   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    261          /*****************************************************************************/
    262          

   \                                 In section .text, align 2, keep-with-next
    263          void CDC_SetUsbSuspendCallBack(void (*pfCallBack)(void))
    264          {
    265          #if gUsbAppNotificationOnSuspend_d  
    266            pfUSBSuspendCallBack = pfCallBack;
    267          #else
    268            (void)pfCallBack;
    269          #endif  
    270          }
   \                     CDC_SetUsbSuspendCallBack: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    271          
    272          /*****************************************************************************/
    273          

   \                                 In section .text, align 2, keep-with-next
    274           bool_t CDC_GetByteFromRxBuffer(unsigned char *pDst)
    275           {
   \                     CDC_GetByteFromRxBuffer: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    276            uint32_t ccr;
    277            if (!gCDCRxBufferByteCount)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??CDC_GetByteFromRxBuffer_0
    278            {
    279              return FALSE;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE038             B.N      ??CDC_GetByteFromRxBuffer_1
    280            }
    281            ccr = IntDisableAll();
   \                     ??CDC_GetByteFromRxBuffer_0: (+1)
   \   00000012   0x.... 0x....      BL       IntDisableAll
   \   00000016   0x0005             MOVS     R5,R0
    282            *pDst = maCDCRxBuf[mCDCRxBufTrailingIndex];
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable9_15
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable9_5
   \   00000020   0x7809             LDRB     R1,[R1, #+0]
   \   00000022   0x5C08             LDRB     R0,[R1, R0]
   \   00000024   0x7020             STRB     R0,[R4, #+0]
    283            if (++mCDCRxBufTrailingIndex >= sizeof(maCDCRxBuf)) 
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable9_5
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable9_5
   \   00000032   0x7008             STRB     R0,[R1, #+0]
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable9_5
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x2840             CMP      R0,#+64
   \   0000003C   0xD303             BCC.N    ??CDC_GetByteFromRxBuffer_2
    284            {
    285              mCDCRxBufTrailingIndex = 0;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable9_5
   \   00000044   0x7008             STRB     R0,[R1, #+0]
    286            }
    287            --gCDCRxBufferByteCount;
   \                     ??CDC_GetByteFromRxBuffer_2: (+1)
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x1E40             SUBS     R0,R0,#+1
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable9_4
   \   00000052   0x7008             STRB     R0,[R1, #+0]
    288          #if gCDC_EnableFlowControl_d
    289            if ((gCDCDicRxEnabled == FALSE) && (gCDCRxBufferByteCount <= gCDC_RxFlowControlResume_d)) 
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable9_9
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD10E             BNE.N    ??CDC_GetByteFromRxBuffer_3
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   00000062   0x7800             LDRB     R0,[R0, #+0]
   \   00000064   0x2809             CMP      R0,#+9
   \   00000066   0xDA09             BGE.N    ??CDC_GetByteFromRxBuffer_3
    290            {
    291              gCDCDicRxEnabled = TRUE;
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable9_9
   \   0000006E   0x7008             STRB     R0,[R1, #+0]
    292              (void)USB_Class_CDC_Interface_DIC_Recv_Data(gUsbCdcControllerId_d, NULL, 0);
   \   00000070   0x2300             MOVS     R3,#+0
   \   00000072   0x2200             MOVS     R2,#+0
   \   00000074   0x2102             MOVS     R1,#+2
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x.... 0x....      BL       USB_DeviceRecvData
    293            }
    294          #endif
    295            IntRestoreAll(ccr);
   \                     ??CDC_GetByteFromRxBuffer_3: (+1)
   \   0000007C   0x0028             MOVS     R0,R5
   \   0000007E   0x.... 0x....      BL       IntRestoreAll
    296            return TRUE;
   \   00000082   0x2001             MOVS     R0,#+1
   \                     ??CDC_GetByteFromRxBuffer_1: (+1)
   \   00000084   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    297           }
    298          
    299          /*****************************************************************************
    300          * Local Functions
    301          *****************************************************************************/
    302          
    303           /*****************************************************************************/
    304          //static bool_t CDC_CommOpen(void)  @SMAC

   \                                 In section .text, align 2, keep-with-next
    305          bool_t CDC_CommOpen(void) 
    306            {
    307              if(mCDCEnumerated 
    308          #if gUSB_CDC_SendEventToAppOnCOMOpen_d     
    309                 && mCDCChannelOpen
    310          #endif       
    311                )
   \                     CDC_CommOpen: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable9_12
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD006             BEQ.N    ??CDC_CommOpen_0
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable9_13
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD001             BEQ.N    ??CDC_CommOpen_0
    312                {
    313                  return TRUE;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE000             B.N      ??CDC_CommOpen_1
    314                }
    315              return FALSE;  
   \                     ??CDC_CommOpen_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \                     ??CDC_CommOpen_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    316            }
    317           
    318          
    319          /*****************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    320          static void CDC_DicInServiceCallback(usbDeviceEvent_t* event)
    321          {
   \                     CDC_DicInServiceCallback: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x0004             MOVS     R4,R0
    322            void (*pfCallBack)(unsigned char const *pBuf);
    323            uint32_t ccr;
    324            
    325            if(event->errors != 0)
   \   00000008   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD159             BNE.N    ??CDC_DicInServiceCallback_0
    326            {
    327              return;    
    328            }
    329          
    330              /* Mark this one as done, and call the callback. */
    331            pfCallBack = maCDCTxBufRefTable[mCDCTxBufRefTrailingIndex].pfCallBack;
   \                     ??CDC_DicInServiceCallback_1: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable9_14
   \   00000012   0x....             LDR.N    R1,??DataTable9_1
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   0000001A   0x6840             LDR      R0,[R0, #+4]
   \   0000001C   0x0005             MOVS     R5,R0
    332            ccr = IntDisableAll();
   \   0000001E   0x.... 0x....      BL       IntDisableAll
   \   00000022   0x0006             MOVS     R6,R0
    333            mCDCTxPendingTxNum--;
   \   00000024   0x....             LDR.N    R0,??DataTable9_3
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x1E40             SUBS     R0,R0,#+1
   \   0000002A   0x....             LDR.N    R1,??DataTable9_3
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
    334            IntRestoreAll(ccr);
   \   0000002E   0x0030             MOVS     R0,R6
   \   00000030   0x.... 0x....      BL       IntRestoreAll
    335            if (pfCallBack)
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD017             BEQ.N    ??CDC_DicInServiceCallback_2
    336            {
    337              if(gCDCDicTxMsgInUsbOueue == FALSE)
   \   0000003A   0x....             LDR.N    R0,??DataTable9_8
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD113             BNE.N    ??CDC_DicInServiceCallback_2
    338              {
    339                usbMsg_t usbMsg;
    340                usbMsg.controllerId = event->controllerId;
   \   00000042   0x7820             LDRB     R0,[R4, #+0]
   \   00000044   0xF88D 0x0004      STRB     R0,[SP, #+4]
    341                usbMsg.eventType = gUsbToAppEvent_SendComplete_c;
   \   00000048   0x2003             MOVS     R0,#+3
   \   0000004A   0xF88D 0x0005      STRB     R0,[SP, #+5]
    342                usbMsg.eventParam.sendCompleteEvent.epNum = event->epNum;
   \   0000004E   0x7860             LDRB     R0,[R4, #+1]
   \   00000050   0xF88D 0x0008      STRB     R0,[SP, #+8]
    343                usbMsg.eventParam.sendCompleteEvent.pBuffer = event->pBuffer;
   \   00000054   0x6860             LDR      R0,[R4, #+4]
   \   00000056   0x9003             STR      R0,[SP, #+12]
    344                usbMsg.eventParam.sendCompleteEvent.len = event->len;
   \   00000058   0x8920             LDRH     R0,[R4, #+8]
   \   0000005A   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    345                USB_IsrEvent(&usbMsg);
   \   0000005E   0xA801             ADD      R0,SP,#+4
   \   00000060   0x.... 0x....      BL       USB_IsrEvent
    346                gCDCDicTxMsgInUsbOueue = TRUE;
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0x....             LDR.N    R1,??DataTable9_8
   \   00000068   0x7008             STRB     R0,[R1, #+0]
    347              }
    348            }
    349            maCDCTxBufLenTable[mCDCTxBufRefTrailingIndex] = 0;
   \                     ??CDC_DicInServiceCallback_2: (+1)
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x....             LDR.N    R1,??DataTable9
   \   0000006E   0x....             LDR.N    R2,??DataTable9_1
   \   00000070   0x7812             LDRB     R2,[R2, #+0]
   \   00000072   0x5450             STRB     R0,[R2, R1]
    350                /* Increment to the next buffer. */
    351            if (++mCDCTxBufRefTrailingIndex >= NumberOfElements(maCDCTxBufRefTable)) 
   \   00000074   0x....             LDR.N    R0,??DataTable9_1
   \   00000076   0x7800             LDRB     R0,[R0, #+0]
   \   00000078   0x1C40             ADDS     R0,R0,#+1
   \   0000007A   0x....             LDR.N    R1,??DataTable9_1
   \   0000007C   0x7008             STRB     R0,[R1, #+0]
   \   0000007E   0x....             LDR.N    R0,??DataTable9_1
   \   00000080   0x7800             LDRB     R0,[R0, #+0]
   \   00000082   0x2803             CMP      R0,#+3
   \   00000084   0xD302             BCC.N    ??CDC_DicInServiceCallback_3
    352            {
    353              mCDCTxBufRefTrailingIndex = 0;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x....             LDR.N    R1,??DataTable9_1
   \   0000008A   0x7008             STRB     R0,[R1, #+0]
    354            }
    355          
    356            /* If there is no more data to send, turn off the transmit interrupt. */
    357            if (maCDCTxBufLenTable[mCDCTxBufRefTrailingIndex]) 
   \                     ??CDC_DicInServiceCallback_3: (+1)
   \   0000008C   0x....             LDR.N    R0,??DataTable9
   \   0000008E   0x....             LDR.N    R1,??DataTable9_1
   \   00000090   0x7809             LDRB     R1,[R1, #+0]
   \   00000092   0x5C08             LDRB     R0,[R1, R0]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD014             BEQ.N    ??CDC_DicInServiceCallback_4
    358            {
    359               uint8_t* pBuf = (uint8_t*)maCDCTxBufRefTable[mCDCTxBufRefTrailingIndex].pBuf;
   \   00000098   0x....             LDR.N    R0,??DataTable9_14
   \   0000009A   0x....             LDR.N    R1,??DataTable9_1
   \   0000009C   0x7809             LDRB     R1,[R1, #+0]
   \   0000009E   0xF850 0x7031      LDR      R7,[R0, R1, LSL #+3]
    360               index_t bufLen = maCDCTxBufLenTable[mCDCTxBufRefTrailingIndex]; 
   \   000000A2   0x....             LDR.N    R0,??DataTable9
   \   000000A4   0x....             LDR.N    R1,??DataTable9_1
   \   000000A6   0x7809             LDRB     R1,[R1, #+0]
   \   000000A8   0xF811 0x8000      LDRB     R8,[R1, R0]
    361               (void)USB_Class_CDC_Interface_DIC_Send_Data(gUsbCdcControllerId_d,pBuf, bufLen); 
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x9000             STR      R0,[SP, #+0]
   \   000000B0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000B4   0x4643             MOV      R3,R8
   \   000000B6   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000B8   0x003A             MOVS     R2,R7
   \   000000BA   0x2101             MOVS     R1,#+1
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x.... 0x....      BL       USB_ClassSendData_
    362            }
    363          }
   \                     ??CDC_DicInServiceCallback_4: (+1)
   \                     ??CDC_DicInServiceCallback_0: (+1)
   \   000000C2   0xB006             ADD      SP,SP,#+24
   \   000000C4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    364          /*****************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    365          static void CDC_DicOutServiceCallback(usbDeviceEvent_t* event)
    366          {
   \                     CDC_DicOutServiceCallback: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
    367            uint8_t *pSrc;
    368            usbPacketSize_t  len;
    369            uint32_t ccr;
    370            if(pfCDCRxCallBack != NULL)
   \   00000006   0x....             LDR.N    R0,??DataTable9_11
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD065             BEQ.N    ??CDC_DicOutServiceCallback_0
    371            {
    372              pSrc = event->pBuffer;
   \   0000000E   0x6860             LDR      R0,[R4, #+4]
   \   00000010   0x0006             MOVS     R6,R0
    373              len = event->len;
   \   00000012   0x8920             LDRH     R0,[R4, #+8]
   \   00000014   0x0007             MOVS     R7,R0
    374              while(len)
   \                     ??CDC_DicOutServiceCallback_1: (+1)
   \   00000016   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000018   0x2F00             CMP      R7,#+0
   \   0000001A   0xD02F             BEQ.N    ??CDC_DicOutServiceCallback_2
    375              {
    376                ccr = IntDisableAll();
   \   0000001C   0x.... 0x....      BL       IntDisableAll
   \   00000020   0x0005             MOVS     R5,R0
    377                maCDCRxBuf[mCDCRxBufLeadingIndex] = *pSrc++;
   \   00000022   0x7830             LDRB     R0,[R6, #+0]
   \   00000024   0x....             LDR.N    R1,??DataTable9_15
   \   00000026   0x....             LDR.N    R2,??DataTable9_6
   \   00000028   0x7812             LDRB     R2,[R2, #+0]
   \   0000002A   0x5450             STRB     R0,[R2, R1]
   \   0000002C   0x1C76             ADDS     R6,R6,#+1
    378                if (++mCDCRxBufLeadingIndex >= sizeof(maCDCRxBuf)) 
   \   0000002E   0x....             LDR.N    R0,??DataTable9_6
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x1C40             ADDS     R0,R0,#+1
   \   00000034   0x....             LDR.N    R1,??DataTable9_6
   \   00000036   0x7008             STRB     R0,[R1, #+0]
   \   00000038   0x....             LDR.N    R0,??DataTable9_6
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x2840             CMP      R0,#+64
   \   0000003E   0xD302             BCC.N    ??CDC_DicOutServiceCallback_3
    379                {
    380                  mCDCRxBufLeadingIndex = 0;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x....             LDR.N    R1,??DataTable9_6
   \   00000044   0x7008             STRB     R0,[R1, #+0]
    381                }
    382                if (gCDCRxBufferByteCount < sizeof(maCDCRxBuf)) 
   \                     ??CDC_DicOutServiceCallback_3: (+1)
   \   00000046   0x....             LDR.N    R0,??DataTable9_4
   \   00000048   0x7800             LDRB     R0,[R0, #+0]
   \   0000004A   0x2840             CMP      R0,#+64
   \   0000004C   0xD205             BCS.N    ??CDC_DicOutServiceCallback_4
    383                {
    384                  ++gCDCRxBufferByteCount;
   \   0000004E   0x....             LDR.N    R0,??DataTable9_4
   \   00000050   0x7800             LDRB     R0,[R0, #+0]
   \   00000052   0x1C40             ADDS     R0,R0,#+1
   \   00000054   0x....             LDR.N    R1,??DataTable9_4
   \   00000056   0x7008             STRB     R0,[R1, #+0]
   \   00000058   0xE00B             B.N      ??CDC_DicOutServiceCallback_5
    385                }
    386                else 
    387                { 
    388                  /* A new character was received while the buffer is already full. 
    389                  * The oldest character in the buffer has been overwritten. 
    390                  * The trailing index must be also incremented to compensate the overwritten characters
    391                  */
    392                  #ifdef gUSB_Debug_d  
    393                  // debug start
    394                  while(TRUE);  
    395                  //debug end
    396                  #endif 
    397                  if(++mCDCRxBufTrailingIndex >= sizeof(maCDCRxBuf)) 
   \                     ??CDC_DicOutServiceCallback_4: (+1)
   \   0000005A   0x....             LDR.N    R0,??DataTable9_5
   \   0000005C   0x7800             LDRB     R0,[R0, #+0]
   \   0000005E   0x1C40             ADDS     R0,R0,#+1
   \   00000060   0x....             LDR.N    R1,??DataTable9_5
   \   00000062   0x7008             STRB     R0,[R1, #+0]
   \   00000064   0x....             LDR.N    R0,??DataTable9_5
   \   00000066   0x7800             LDRB     R0,[R0, #+0]
   \   00000068   0x2840             CMP      R0,#+64
   \   0000006A   0xD302             BCC.N    ??CDC_DicOutServiceCallback_5
    398                  {
    399                    mCDCRxBufTrailingIndex = 0;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x....             LDR.N    R1,??DataTable9_5
   \   00000070   0x7008             STRB     R0,[R1, #+0]
    400                  }
    401                }
    402                IntRestoreAll(ccr);
   \                     ??CDC_DicOutServiceCallback_5: (+1)
   \   00000072   0x0028             MOVS     R0,R5
   \   00000074   0x.... 0x....      BL       IntRestoreAll
    403                len--;                                           
   \   00000078   0x1E7F             SUBS     R7,R7,#+1
   \   0000007A   0xE7CC             B.N      ??CDC_DicOutServiceCallback_1
    404              }
    405              #if gCDC_EnableFlowControl_d
    406              ccr = IntDisableAll();
   \                     ??CDC_DicOutServiceCallback_2: (+1)
   \   0000007C   0x.... 0x....      BL       IntDisableAll
   \   00000080   0x0005             MOVS     R5,R0
    407              if (sizeof(maCDCRxBuf) - gCDCRxBufferByteCount >= gCDC_RxFlowControlSkew_d) 
   \   00000082   0x....             LDR.N    R0,??DataTable9_4
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0xF1D0 0x0040      RSBS     R0,R0,#+64
   \   0000008A   0x2810             CMP      R0,#+16
   \   0000008C   0xD306             BCC.N    ??CDC_DicOutServiceCallback_6
    408              {
    409                (void)USB_Class_CDC_Interface_DIC_Recv_Data(event->controllerId, NULL, 0);
   \   0000008E   0x2300             MOVS     R3,#+0
   \   00000090   0x2200             MOVS     R2,#+0
   \   00000092   0x2102             MOVS     R1,#+2
   \   00000094   0x7820             LDRB     R0,[R4, #+0]
   \   00000096   0x.... 0x....      BL       USB_DeviceRecvData
   \   0000009A   0xE002             B.N      ??CDC_DicOutServiceCallback_7
    410              }
    411              else
    412              {
    413                gCDCDicRxEnabled = FALSE;
   \                     ??CDC_DicOutServiceCallback_6: (+1)
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x....             LDR.N    R1,??DataTable9_9
   \   000000A0   0x7008             STRB     R0,[R1, #+0]
    414              }
    415              IntRestoreAll(ccr);
   \                     ??CDC_DicOutServiceCallback_7: (+1)
   \   000000A2   0x0028             MOVS     R0,R5
   \   000000A4   0x.... 0x....      BL       IntRestoreAll
    416              #else
    417              (void)USB_Class_CDC_Interface_DIC_Recv_Data(event->controllerId, NULL, 0);
    418              #endif
    419              if(event->len)
   \   000000A8   0x8920             LDRH     R0,[R4, #+8]
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD01B             BEQ.N    ??CDC_DicOutServiceCallback_8
    420              {
    421                /* Let the application know a byte has been received. */
    422                if(gCDCDicRxMsgInUsbOueue == FALSE)
   \   000000AE   0x....             LDR.N    R0,??DataTable9_7
   \   000000B0   0x7800             LDRB     R0,[R0, #+0]
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD117             BNE.N    ??CDC_DicOutServiceCallback_8
    423                {
    424                  usbMsg_t usbMsg;
    425                  usbMsg.controllerId = event->controllerId;
   \   000000B6   0x7820             LDRB     R0,[R4, #+0]
   \   000000B8   0xF88D 0x0000      STRB     R0,[SP, #+0]
    426                  usbMsg.eventType = gUsbToAppEvent_DataReceived_c;
   \   000000BC   0x2004             MOVS     R0,#+4
   \   000000BE   0xF88D 0x0001      STRB     R0,[SP, #+1]
    427                  usbMsg.eventParam.dataReceivedEvent.epNum = event->epNum;
   \   000000C2   0x7860             LDRB     R0,[R4, #+1]
   \   000000C4   0xF88D 0x0004      STRB     R0,[SP, #+4]
    428                  usbMsg.eventParam.dataReceivedEvent.pBuffer = event->pBuffer;
   \   000000C8   0x6860             LDR      R0,[R4, #+4]
   \   000000CA   0x9002             STR      R0,[SP, #+8]
    429                  usbMsg.eventParam.dataReceivedEvent.len = event->len;
   \   000000CC   0x8920             LDRH     R0,[R4, #+8]
   \   000000CE   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    430                  USB_IsrEvent(&usbMsg); 
   \   000000D2   0xA800             ADD      R0,SP,#+0
   \   000000D4   0x.... 0x....      BL       USB_IsrEvent
   \   000000D8   0xE005             B.N      ??CDC_DicOutServiceCallback_8
    431                  //gCDCDicRxMsgInUsbOueue = TRUE; //@SMAC
    432                }
    433              }
    434            }
    435            else //(pfCDCRxCallBack == NULL)
    436            {
    437              (void)USB_Class_CDC_Interface_DIC_Recv_Data(event->controllerId, NULL, 0); 
   \                     ??CDC_DicOutServiceCallback_0: (+1)
   \   000000DA   0x2300             MOVS     R3,#+0
   \   000000DC   0x2200             MOVS     R2,#+0
   \   000000DE   0x2102             MOVS     R1,#+2
   \   000000E0   0x7820             LDRB     R0,[R4, #+0]
   \   000000E2   0x.... 0x....      BL       USB_DeviceRecvData
    438            }
    439          }
   \                     ??CDC_DicOutServiceCallback_8: (+1)
   \   000000E6   0xB005             ADD      SP,SP,#+20
   \   000000E8   0xBDF0             POP      {R4-R7,PC}       ;; return
    440          
    441          /*****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    442          static void CDC_App_Callback (
    443              uint8_t controller_ID,   /* [IN] Controller ID */
    444              gUsbToAppEvent_t event_type,      /* [IN] value of the event */
    445              void* val               /* [IN] gives the configuration value */
    446          )
    447          {
   \                     CDC_App_Callback: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    448          
    449            usbMsg_t* pUsbMsg = val;
   \   0000000A   0x0037             MOVS     R7,R6
    450            (void)(val);
    451            (void)(controller_ID);
    452              
    453            switch(event_type)
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0x0028             MOVS     R0,R5
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD023             BEQ.N    ??CDC_App_Callback_0
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD028             BEQ.N    ??CDC_App_Callback_1
   \   00000018   0x2802             CMP      R0,#+2
   \   0000001A   0xD02D             BEQ.N    ??CDC_App_Callback_2
   \   0000001C   0x2803             CMP      R0,#+3
   \   0000001E   0xD02F             BEQ.N    ??CDC_App_Callback_3
   \   00000020   0x2804             CMP      R0,#+4
   \   00000022   0xD076             BEQ.N    ??CDC_App_Callback_4
   \   00000024   0x2805             CMP      R0,#+5
   \   00000026   0xF000 0x8089      BEQ.W    ??CDC_App_Callback_5
   \   0000002A   0x2806             CMP      R0,#+6
   \   0000002C   0xF000 0x8087      BEQ.W    ??CDC_App_Callback_6
   \   00000030   0x2807             CMP      R0,#+7
   \   00000032   0xF000 0x8085      BEQ.W    ??CDC_App_Callback_7
   \   00000036   0x2808             CMP      R0,#+8
   \   00000038   0xF000 0x8083      BEQ.W    ??CDC_App_Callback_8
   \   0000003C   0x2809             CMP      R0,#+9
   \   0000003E   0xF000 0x8081      BEQ.W    ??CDC_App_Callback_9
   \   00000042   0x280A             CMP      R0,#+10
   \   00000044   0xD079             BEQ.N    ??CDC_App_Callback_10
   \   00000046   0x280B             CMP      R0,#+11
   \   00000048   0xD076             BEQ.N    ??CDC_App_Callback_11
   \   0000004A   0x280C             CMP      R0,#+12
   \   0000004C   0xD073             BEQ.N    ??CDC_App_Callback_12
   \   0000004E   0x280D             CMP      R0,#+13
   \   00000050   0xD070             BEQ.N    ??CDC_App_Callback_13
   \   00000052   0x2825             CMP      R0,#+37
   \   00000054   0xD077             BEQ.N    ??CDC_App_Callback_14
   \   00000056   0x2826             CMP      R0,#+38
   \   00000058   0xD079             BEQ.N    ??CDC_App_Callback_15
   \   0000005A   0xE07B             B.N      ??CDC_App_Callback_16
    454            {
    455              case gUsbToAppEvent_BusReset_c :
    456                     mCDCEnumerated = FALSE;
   \                     ??CDC_App_Callback_0: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x....             LDR.N    R1,??DataTable9_12
   \   00000060   0x7008             STRB     R0,[R1, #+0]
    457          #if gUSB_CDC_SendEventToAppOnCOMOpen_d            
    458                     mCDCChannelOpen = FALSE;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x....             LDR.N    R1,??DataTable9_13
   \   00000066   0x7008             STRB     R0,[R1, #+0]
    459          #endif           
    460              break;
   \   00000068   0xE074             B.N      ??CDC_App_Callback_16
    461                  
    462              case gUsbToAppEvent_ConfigChanged_c: 
    463                     if(pUsbMsg->eventParam.configEvent.configValue == 0)
   \                     ??CDC_App_Callback_1: (+1)
   \   0000006A   0x88B8             LDRH     R0,[R7, #+4]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD102             BNE.N    ??CDC_App_Callback_17
    464                     {
    465                       mCDCEnumerated = FALSE;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x....             LDR.N    R1,??DataTable9_12
   \   00000074   0x7008             STRB     R0,[R1, #+0]
    466                     }
    467                     
    468              break;
   \                     ??CDC_App_Callback_17: (+1)
   \   00000076   0xE06D             B.N      ??CDC_App_Callback_16
    469                  
    470              case gUsbToAppEvent_EnumComplete_c: 
    471                     mCDCEnumerated = TRUE;
   \                     ??CDC_App_Callback_2: (+1)
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x....             LDR.N    R1,??DataTable9_12
   \   0000007C   0x7008             STRB     R0,[R1, #+0]
    472              break;
   \   0000007E   0xE069             B.N      ??CDC_App_Callback_16
    473                  
    474              case gUsbToAppEvent_SendComplete_c:
    475                     if(pUsbMsg->eventParam.sendCompleteEvent.epNum == gCDC_DIC_BulkInEndpoint_d)
   \                     ??CDC_App_Callback_3: (+1)
   \   00000080   0x7938             LDRB     R0,[R7, #+4]
   \   00000082   0x2801             CMP      R0,#+1
   \   00000084   0xD144             BNE.N    ??CDC_App_Callback_18
    476                     {
    477                         void (*pfCallBack)(unsigned char const *pBuf);    
    478                         unsigned char const *pBuf;
    479                         uint32_t ccr;
    480                         index_t txBufRefTableIndex;
    481                         gCDCDicTxMsgInUsbOueue = FALSE;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x....             LDR.N    R1,??DataTable9_8
   \   0000008A   0x7008             STRB     R0,[R1, #+0]
    482                         txBufRefTableIndex = mCDCTxBufRefLeadingIndex;
   \   0000008C   0x....             LDR.N    R0,??DataTable9_2
   \   0000008E   0x7800             LDRB     R0,[R0, #+0]
   \   00000090   0x4683             MOV      R11,R0
    483                         do
    484                         {
    485                           pfCallBack = NULL; 
   \                     ??CDC_App_Callback_19: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x4680             MOV      R8,R0
    486                           ccr = IntDisableAll();
   \   00000096   0x.... 0x....      BL       IntDisableAll
   \   0000009A   0x4682             MOV      R10,R0
    487                           if((maCDCTxBufLenTable[txBufRefTableIndex] == 0) && (maCDCTxBufRefTable[txBufRefTableIndex].pfCallBack != NULL))
   \   0000009C   0x....             LDR.N    R0,??DataTable9
   \   0000009E   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000A2   0xF81B 0x0000      LDRB     R0,[R11, R0]
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD11B             BNE.N    ??CDC_App_Callback_20
   \   000000AA   0x....             LDR.N    R0,??DataTable9_14
   \   000000AC   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000B0   0xEB10 0x00CB      ADDS     R0,R0,R11, LSL #+3
   \   000000B4   0x6840             LDR      R0,[R0, #+4]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD013             BEQ.N    ??CDC_App_Callback_20
    488                           {
    489                             pfCallBack = maCDCTxBufRefTable[txBufRefTableIndex].pfCallBack;
   \   000000BA   0x....             LDR.N    R0,??DataTable9_14
   \   000000BC   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000C0   0xEB10 0x00CB      ADDS     R0,R0,R11, LSL #+3
   \   000000C4   0x6840             LDR      R0,[R0, #+4]
   \   000000C6   0x4680             MOV      R8,R0
    490                             pBuf= maCDCTxBufRefTable[txBufRefTableIndex].pBuf;
   \   000000C8   0x....             LDR.N    R0,??DataTable9_14
   \   000000CA   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000CE   0xF850 0x003B      LDR      R0,[R0, R11, LSL #+3]
   \   000000D2   0x4681             MOV      R9,R0
    491                             maCDCTxBufRefTable[txBufRefTableIndex].pfCallBack = NULL;
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0x....             LDR.N    R1,??DataTable9_14
   \   000000D8   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000DC   0xEB11 0x01CB      ADDS     R1,R1,R11, LSL #+3
   \   000000E0   0x6048             STR      R0,[R1, #+4]
    492                           } 
    493                           IntRestoreAll(ccr);
   \                     ??CDC_App_Callback_20: (+1)
   \   000000E2   0x4650             MOV      R0,R10
   \   000000E4   0x.... 0x....      BL       IntRestoreAll
    494                           if (++txBufRefTableIndex >= NumberOfElements(maCDCTxBufRefTable)) 
   \   000000E8   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   000000EC   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000F0   0xF1BB 0x0F03      CMP      R11,#+3
   \   000000F4   0xD301             BCC.N    ??CDC_App_Callback_21
    495                           {
    496                             txBufRefTableIndex = 0;
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0x4683             MOV      R11,R0
    497                           }
    498                           if(pfCallBack != NULL)
   \                     ??CDC_App_Callback_21: (+1)
   \   000000FA   0x4640             MOV      R0,R8
   \   000000FC   0x2800             CMP      R0,#+0
   \   000000FE   0xD001             BEQ.N    ??CDC_App_Callback_22
    499                           {
    500                             pfCallBack(pBuf);
   \   00000100   0x4648             MOV      R0,R9
   \   00000102   0x47C0             BLX      R8
    501                           }
    502                         }
    503                         while(txBufRefTableIndex != mCDCTxBufRefTrailingIndex);
   \                     ??CDC_App_Callback_22: (+1)
   \   00000104   0x....             LDR.N    R0,??DataTable9_1
   \   00000106   0x7800             LDRB     R0,[R0, #+0]
   \   00000108   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000010C   0x4583             CMP      R11,R0
   \   0000010E   0xD1C0             BNE.N    ??CDC_App_Callback_19
    504                    
    505                     }
    506                     
    507              break;
   \                     ??CDC_App_Callback_18: (+1)
   \   00000110   0xE020             B.N      ??CDC_App_Callback_16
    508                   
    509              case gUsbToAppEvent_DataReceived_c:
    510                     gCDCDicRxMsgInUsbOueue = FALSE;
   \                     ??CDC_App_Callback_4: (+1)
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0x....             LDR.N    R1,??DataTable9_7
   \   00000116   0x7008             STRB     R0,[R1, #+0]
    511                     {
    512                       uint32_t ccr;
    513                       void (*pfRxCallBack)(void);
    514                       ccr = IntDisableAll();
   \   00000118   0x.... 0x....      BL       IntDisableAll
   \   0000011C   0x4680             MOV      R8,R0
    515                       pfRxCallBack = pfCDCRxCallBack;
   \   0000011E   0x....             LDR.N    R0,??DataTable9_11
   \   00000120   0x6800             LDR      R0,[R0, #+0]
   \   00000122   0x4681             MOV      R9,R0
    516                       IntRestoreAll(ccr);
   \   00000124   0x4640             MOV      R0,R8
   \   00000126   0x.... 0x....      BL       IntRestoreAll
    517                       if(pfRxCallBack != NULL)
   \   0000012A   0x4648             MOV      R0,R9
   \   0000012C   0x2800             CMP      R0,#+0
   \   0000012E   0xD000             BEQ.N    ??CDC_App_Callback_23
    518                       {
    519                         pfRxCallBack();  
   \   00000130   0x47C8             BLX      R9
    520                       }
    521                     }
    522              break;
   \                     ??CDC_App_Callback_23: (+1)
   \   00000132   0xE00F             B.N      ??CDC_App_Callback_16
    523                  
    524              case gUsbToAppEvent_Resume_c:
    525              break;
   \                     ??CDC_App_Callback_13: (+1)
   \   00000134   0xE00E             B.N      ??CDC_App_Callback_16
    526              case gUsbToAppEvent_Suspend_c:
    527              break;
   \                     ??CDC_App_Callback_12: (+1)
   \   00000136   0xE00D             B.N      ??CDC_App_Callback_16
    528              case gUsbToAppEvent_ShortSendComplete_c:
    529              break;
   \                     ??CDC_App_Callback_11: (+1)
   \   00000138   0xE00C             B.N      ??CDC_App_Callback_16
    530              case gUsbToAppEvent_RequestPending_c:
    531              break;
   \                     ??CDC_App_Callback_10: (+1)
   \   0000013A   0xE00B             B.N      ??CDC_App_Callback_16
    532              case gUsbToAppEvent_Error_c:
    533              break;
   \                     ??CDC_App_Callback_5: (+1)
   \   0000013C   0xE00A             B.N      ??CDC_App_Callback_16
    534              case gUsbToAppEvent_GetDataBuff_c:
    535              break;
   \                     ??CDC_App_Callback_6: (+1)
   \   0000013E   0xE009             B.N      ??CDC_App_Callback_16
    536              case gUsbToAppEvent_EpStalled_c:
    537              break;
   \                     ??CDC_App_Callback_7: (+1)
   \   00000140   0xE008             B.N      ??CDC_App_Callback_16
    538              case gUsbToAppEvent_EpUnstalled_c:
    539              break;
   \                     ??CDC_App_Callback_8: (+1)
   \   00000142   0xE007             B.N      ??CDC_App_Callback_16
    540              case gUsbToAppEvent_GetTransferSize_c:
    541              break;
   \                     ??CDC_App_Callback_9: (+1)
   \   00000144   0xE006             B.N      ??CDC_App_Callback_16
    542          #if gUSB_CDC_SendEventToAppOnCOMOpen_d     
    543              case gUsbToAppEvent_CDC_COM_Open_c:
    544                     mCDCChannelOpen = TRUE;
   \                     ??CDC_App_Callback_14: (+1)
   \   00000146   0x2001             MOVS     R0,#+1
   \   00000148   0x....             LDR.N    R1,??DataTable9_13
   \   0000014A   0x7008             STRB     R0,[R1, #+0]
    545              break;
   \   0000014C   0xE002             B.N      ??CDC_App_Callback_16
    546              case gUsbToAppEvent_CDC_COM_Closed_c:
    547                     mCDCChannelOpen = FALSE;
   \                     ??CDC_App_Callback_15: (+1)
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0x....             LDR.N    R1,??DataTable9_13
   \   00000152   0x7008             STRB     R0,[R1, #+0]
    548              break;
    549          #endif 
    550          #if gUsbAppNotificationOnSuspend_d    
    551              case gUsbToAppEvent_Suspend_c:
    552                if(mCDCEnumerated)
    553                {
    554                  uint32_t ccr;
    555                  void (*pfSuspendCallBack)(void);
    556                  ccr = IntDisableAll();
    557                  pfSuspendCallBack = pfUSBSuspendCallBack;
    558                   IntRestoreAll(ccr);
    559                  if(pfSuspendCallBack != NULL)
    560                  {
    561                    pfSuspendCallBack();  
    562                  }
    563                }
    564                
    565                     
    566              break;   
    567          #endif      
    568              
    569            }
    570          }
   \                     ??CDC_App_Callback_16: (+1)
   \   00000154   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     maCDCTxBufLenTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     mCDCTxBufRefTrailingIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     mCDCTxBufRefLeadingIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     mCDCTxPendingTxNum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     gCDCRxBufferByteCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     mCDCRxBufTrailingIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     mCDCRxBufLeadingIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     gCDCDicRxMsgInUsbOueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x........         DC32     gCDCDicTxMsgInUsbOueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x........         DC32     gCDCDicRxEnabled

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x........         DC32     usbClassDescriptor_CDC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x........         DC32     pfCDCRxCallBack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x........         DC32     mCDCEnumerated

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0x........         DC32     mCDCChannelOpen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   0x........         DC32     maCDCTxBufRefTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \   00000000   0x........         DC32     maCDCRxBuf
    571          
    572          #endif //gVirtualCOMPort_d
    573          /* EOF */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   CDC_App_Callback
        40   -- Indirect call
        40   -> IntDisableAll
        40   -> IntRestoreAll
       0   CDC_CommOpen
      48   CDC_DicInServiceCallback
        48   -> IntDisableAll
        48   -> IntRestoreAll
        48   -> USB_ClassSendData_
        48   -> USB_IsrEvent
      40   CDC_DicOutServiceCallback
        40   -> IntDisableAll
        40   -> IntRestoreAll
        40   -> USB_DeviceRecvData
        40   -> USB_IsrEvent
      16   CDC_GetByteFromRxBuffer
        16   -> IntDisableAll
        16   -> IntRestoreAll
        16   -> USB_DeviceRecvData
       0   CDC_IsTxActive
      16   CDC_ModuleInit
        16   -> IntDisableAll
        16   -> IntRestoreAll
        16   -> MemorySet
        16   -> USB_AddController
        16   -> USB_Class_CDC_SetDicInServiceCallback
        16   -> USB_Class_CDC_SetDicOutServiceCallback
        16   -> USB_IsDeviceConnected
      16   CDC_ModuleUninit
        16   -> IntDisableAll
        16   -> IntRestoreAll
        16   -> USB_Class_CDC_SetDicInServiceCallback
        16   -> USB_Class_CDC_SetDicOutServiceCallback
        16   -> USB_RemoveController
      16   CDC_SetRxCallBack
        16   -> IntDisableAll
        16   -> IntRestoreAll
       0   CDC_SetUsbSuspendCallBack
      40   CDC_Transmit
        40   -- Indirect call
        40   -> CDC_CommOpen
        40   -> IntDisableAll
        40   -> IntRestoreAll
        40   -> USB_ClassSendData_


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
     344  CDC_App_Callback
      28  CDC_CommOpen
     200  CDC_DicInServiceCallback
     234  CDC_DicOutServiceCallback
     134  CDC_GetByteFromRxBuffer
      26  CDC_IsTxActive
     154  CDC_ModuleInit
      76  CDC_ModuleUninit
      54  CDC_SetRxCallBack
       2  CDC_SetUsbSuspendCallBack
     274  CDC_Transmit
       1  gCDCDicRxEnabled
       1  gCDCDicRxMsgInUsbOueue
       1  gCDCDicTxMsgInUsbOueue
       1  gCDCRxBufferByteCount
       1  mCDCChannelOpen
       1  mCDCEnumerated
       1  mCDCRxBufLeadingIndex
       1  mCDCRxBufTrailingIndex
       1  mCDCTxBufRefLeadingIndex
       1  mCDCTxBufRefTrailingIndex
       1  mCDCTxPendingTxNum
      64  maCDCRxBuf
       4  maCDCTxBufLenTable
      24  maCDCTxBufRefTable
       4  pfCDCRxCallBack
      48  usbClassDescriptor_CDC

 
   107 bytes in section .bss
    48 bytes in section .rodata
 1 590 bytes in section .text
 
 1 590 bytes of CODE  memory
    48 bytes of CONST memory
   107 bytes of DATA  memory

Errors: none
Warnings: none
