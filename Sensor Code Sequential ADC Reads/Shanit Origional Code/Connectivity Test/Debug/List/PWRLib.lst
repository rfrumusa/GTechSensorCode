###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        02/Sep/2018  13:33:19
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\PWRLib.c
#    Command line =  
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\PWRLib.c"
#        -D IAR --preprocess "F:\Guardrail Work\Sensor Code\Git Repo\Sensor
#        Code Sequential ADC Reads\Shanit Origional Code\Connectivity
#        Test\Debug\List\" -lC "F:\Guardrail Work\Sensor Code\Git Repo\Sensor
#        Code Sequential ADC Reads\Shanit Origional Code\Connectivity
#        Test\Debug\List\" -lB "F:\Guardrail Work\Sensor Code\Git Repo\Sensor
#        Code Sequential ADC Reads\Shanit Origional Code\Connectivity
#        Test\Debug\List\" --diag_suppress
#        Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\Debug\Obj\" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\APP\CDC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\USB\APP\Descriptor\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\USB\Class\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\USB\Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity
#        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
#        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
#        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I "F:\Guardrail
#        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
#        Origional Code\Connectivity Test\PLM\Source\Sys Common\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
#        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
#        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
#        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
#        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
#    List file    =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\List\PWRLib.lst
#    Object file  =  
#        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
#        Reads\Shanit Origional Code\Connectivity Test\Debug\Obj\PWRLib.o
#
###############################################################################

F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\PWRLib.c
      1          /************************************************************************************
      2          *
      3          * (c) Copyright 2012, Freescale, Inc.  All rights reserved.
      4          *
      5          * No part of this document may be reproduced in any form - including copied,
      6          * transcribed, printed or by any electronic means - without specific written
      7          * permission from Freescale Semiconductor.
      8          *
      9          ************************************************************************************/
     10          /*****************************************************************************
     11           *                               INCLUDED HEADERS                            *
     12           *---------------------------------------------------------------------------*
     13           * Add to this section all the headers that this module needs to include.    *
     14           *---------------------------------------------------------------------------*
     15           *****************************************************************************/
     16          #include "EmbeddedTypes.h"
     17          #include "PortConfig.h"
     18          #include "Interrupt.h"
     19          #include "PWRLib.h"
     20          #include "PWR_Configuration.h"
     21          #include "TMR_Interface.h"
     22          #include "Keyboard.h"
     23          #include "TransceiverDrv.h"
     24          #include "TransceiverReg.h"
     25          
     26          /*****************************************************************************
     27           *                               PRIVATE VARIABLES                           *
     28           *---------------------------------------------------------------------------*
     29           * Add to this section all the variables and constants that have local       *
     30           * (file) scope.                                                             *
     31           * Each of this declarations shall be preceded by the 'static' keyword.      *
     32           * These variables / constants cannot be accessed outside this module.       *
     33           *---------------------------------------------------------------------------*
     34           *****************************************************************************/
     35          
     36          
     37          
     38          /* LPTMR/RTC variables */
     39          #if (cPWR_UsePowerDownMode==1)

   \                                 In section .bss, align 4
     40          static uint32_t mPWRLib_RTIRemainingTicks;
   \                     mPWRLib_RTIRemainingTicks:
   \   00000000                      DS8 4
     41          #endif /* #if (cPWR_UsePowerDownMode==1) */
     42          
     43          #if (cPWR_UsePowerDownMode==1)
     44          /* RTC variables*/
     45          #if gTMR_Enabled_d

   \                                 In section .bss, align 1
     46          static tmrTimerID_t mPWRLib_RTC_OscInitTmrID;
   \                     mPWRLib_RTC_OscInitTmrID:
   \   00000000                      DS8 1
     47          #endif
     48          #endif /* #if (cPWR_UsePowerDownMode==1) */
     49          

   \                                 In section .bss, align 1
     50          static volatile bool_t mPWRLib_RTC_IsOscStarted = FALSE;
   \                     mPWRLib_RTC_IsOscStarted:
   \   00000000                      DS8 1
     51          
     52          /* For LVD function */ 
     53          #if ((cPWR_LVD_Enable == 1) || (cPWR_LVD_Enable == 2))
     54            #if (cPWR_LVD_Enable == 2)
     55              uint16_t                   PWRLib_LVD_CollectCounter;
     56              tmrTimerID_t               PWRLib_LVD_PollIntervalTmrID;
     57            #endif  /* #if (cPWR_LVD_Enable == 2) */
     58            PWRLib_LVD_VoltageLevel_t    PWRLib_LVD_SavedLevel;
     59          #endif /* #if ((cPWR_LVD_Enable == 1) || (cPWR_LVD_Enable == 2)) */
     60          
     61          
     62          
     63          /*****************************************************************************
     64           *                               PUBLIC VARIABLES                            *
     65           *---------------------------------------------------------------------------*
     66           * Add to this section all the variables and constants that have global      *
     67           * (project) scope.                                                          *
     68           * These variables / constants can be accessed outside this module.          *
     69           * These variables / constants shall be preceded by the 'extern' keyword in  *
     70           * the interface header.                                                     *
     71           *---------------------------------------------------------------------------*
     72           *****************************************************************************/
     73          
     74          /* Zigbee STACK status */ 

   \                                 In section .bss, align 1
     75            PWRLib_StackPS_t PWRLib_StackPS;
   \                     PWRLib_StackPS:
   \   00000000                      DS8 1
     76            
     77            /*--- Chip status ---*/
     78          #if (cPWR_UseMCUStatus)
     79            PWRLib_MCUStatus_t PWRLib_MCUStatus;
     80          #endif  /* #if (cPWR_UseMCUStatus) */
     81            
     82          #if (cPWR_UseRADIOStatus)
     83            PWRLib_RADIOStatus_t PWRLib_RADIOStatus;
     84          #endif  /* #if (cPWR_UseRADIOStatus) */
     85          

   \                                 In section .bss, align 4
     86          volatile PWRLib_WakeupReason_t PWRLib_MCU_WakeupReason;
   \                     PWRLib_MCU_WakeupReason:
   \   00000000                      DS8 4
     87          
     88          #if (cPWR_UsePowerDownMode==1)
     89          
     90          /*****************************************************************************
     91           *                           PRIVATE FUNCTIONS PROTOTYPES                    *
     92           *---------------------------------------------------------------------------*
     93           * Add to this section all the functions prototypes that have local (file)   *
     94           * scope.                                                                    *
     95           * These functions cannot be accessed outside this module.                   *
     96           * These declarations shall be preceded by the 'static' keyword.             *
     97           *---------------------------------------------------------------------------*
     98           *****************************************************************************/
     99          
    100          /******************************************************************************
    101           * Name: PWRLib_RTC_OscInitCallback
    102           * Description:
    103           *
    104           * Parameter(s): -
    105           * Return: -
    106           ******************************************************************************/
    107          #if gTMR_Enabled_d
    108          static void PWRLib_RTC_OscInitCallback
    109          (
    110           tmrTimerID_t tmrID
    111          );
    112          #endif
    113          
    114          void PWRLib_DelayMs
    115          (
    116            uint16_t val
    117          );
    118          
    119          /*****************************************************************************
    120           *                                PRIVATE FUNCTIONS                          *
    121           *---------------------------------------------------------------------------*
    122           * Add to this section all the functions that have local (file) scope.       *
    123           * These functions cannot be accessed outside this module.                   *
    124           * These definitions shall be preceded by the 'static' keyword.              *
    125           *---------------------------------------------------------------------------*
    126          *****************************************************************************/
    127          
    128          /*****************************************************************************
    129           *                             PUBLIC FUNCTIONS                              *
    130           *---------------------------------------------------------------------------*
    131           * Add to this section all the functions that have global (project) scope.   *
    132           * These functions can be accessed outside this module.                      *
    133           * These functions shall have their declarations (prototypes) within the     *
    134           * interface header file and shall be preceded by the 'extern' keyword.      *
    135           *---------------------------------------------------------------------------*
    136           *****************************************************************************/
    137          
    138          /*---------------------------------------------------------------------------
    139           * Name: PWRLib_MCU_Enter_WAIT
    140           * Description: WAIT mode entry routine. Puts the processor into wait mode.
    141           *              In this mode the core clock is disabled (no code executing), but 
    142           *              bus clocks are enabled (peripheral modules are operational). 
    143           * Parameters: -
    144           * Return: -
    145           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 4, keep-with-next
    146           void PWRLib_MCU_Enter_WAIT
    147          (
    148            void
    149          )
    150          {
    151            /* Clear the SLEEPDEEP bit to enable cortex M4 WAIT (sleep) mode */
    152            SCB_SCR &= ~SCB_SCR_SLEEPDEEP_MASK;
   \                     PWRLib_MCU_Enter_WAIT: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable29  ;; 0xe000ed10
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF030 0x0004      BICS     R0,R0,#0x4
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable29  ;; 0xe000ed10
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    153            /* WFI instruction will start entry into WAIT (sleep) mode */
    154            asm("WFI");
   \   00000010   0xBF30             WFI
    155          }
   \   00000012   0x4770             BX       LR               ;; return
    156             
    157          
    158          /*---------------------------------------------------------------------------
    159           * Name: PWRLib_MCUEnter_STOP
    160           * Description: Puts the processor into normal stop mode.
    161          
    162                          Places chip in static state. Lowest power mode that retains all 
    163                          registers while maintaining LVD protection. NVIC is disabled;
    164                          AWIC is used to wake up from interrupt; peripheral clocks are stopped.
    165          
    166                          Mode of operation details:
    167                           - ARM core enters DeepSleep Mode
    168                           - ARM core is clock gated (HCLK = OFF)
    169                           - NVIC is disable (FCLK = OFF)
    170                           - WIC is used to wake up from interruptions
    171                           - Platform and peripheral clock are stopped
    172                           - MCG module can be configured to leave reference clocks running
    173                           - All SRAM is operating (content retained and I/O states held)
    174          
    175                          STOP mode is exited into RUN mode using any enabled interrupt or RESET.
    176          
    177           * Parameters: -
    178           * Return: -
    179           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 4, keep-with-next
    180          void PWRLib_MCU_Enter_STOP
    181          (
    182            void
    183          )
    184          {
    185            /*  Set the LPLLSM to 0b000, normal sop mode */
    186          #if (MCU_MK60N512VMD100 == 1)
    187            MC_PMCTRL = (MC_PMCTRL & (MC_PMCTRL_RUNM_MASK | MC_PMCTRL_LPWUI_MASK)) |
    188                         MC_PMCTRL_LPLLSM(0x0) ;
    189          #elif ((MCU_MK60D10 == 1) || (MCU_MK21DN512 == 1) || (MCU_MK21DX256 == 1))
    190            SMC_PMCTRL = (SMC_PMCTRL & (SMC_PMCTRL_RUNM_MASK | SMC_PMCTRL_LPWUI_MASK)) |
    191                         SMC_PMCTRL_STOPM(0x0) ;
   \                     PWRLib_MCU_Enter_STOP: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable29_1  ;; 0x4007e001
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF010 0x00E0      ANDS     R0,R0,#0xE0
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable29_1  ;; 0x4007e001
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
    192          #endif
    193            
    194            /* Set the SLEEPDEEP bit to enable CORTEX M4 deep sleep mode */
    195            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;	
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable29  ;; 0xe000ed10
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable29  ;; 0xe000ed10
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    196          
    197            /* WFI instruction will start entry into deep sleep mode */
    198            asm("WFI");
   \   00000020   0xBF30             WFI
    199          }
   \   00000022   0x4770             BX       LR               ;; return
    200          
    201          /*---------------------------------------------------------------------------
    202           * Name: PWRLib_MCUEnter_VLPS
    203           * Description: Puts the processor into VLPS (Very Low Power Stop).
    204          
    205                          Mode of operation details:
    206                           - ARM core enters DeepSleep Mode
    207                           - ARM core is clock gated (HCLK = OFF)
    208                           - NVIC is disable (FCLK = OFF)
    209                           - WIC is used to wake up from interruptions
    210                           - Platform and peripheral clock are stopped
    211                           - MCG module can be configured to leave reference clocks running
    212                           - On chip voltage regulator is in a mode that supplies only enough
    213                             power to run the MCU in a reduced frequency
    214                           - All SRAM is operating (content retained and I/O states held)
    215          
    216                          VLPS mode is exited into RUN mode using any enabled interrupt (with LPWUI =1) or RESET.
    217                          
    218                          The AVLP must be set to 0b1 in MC_PMPROT register in order to allow VPLS mode.
    219          
    220           * Parameters: -
    221           * Return: -
    222           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 4, keep-with-next
    223          void PWRLib_MCU_Enter_VLPS
    224          (
    225            void
    226          )
    227          {
    228            /*  Set the LPLLSM to 0b000, very low power stop (VLPS) */
    229            /*  Set the LPWUI to 0b1, The voltage regulator exits stop regulation on an interrupt*/
    230          #if (MCU_MK60N512VMD100 == 1)
    231            MC_PMCTRL = (MC_PMCTRL & (MC_PMCTRL_RUNM_MASK | MC_PMCTRL_LPWUI_MASK)) |
    232                         MC_PMCTRL_LPLLSM(0x2) | 
    233                         MC_PMCTRL_LPWUI_MASK ;
    234          #elif ((MCU_MK60D10 == 1) || (MCU_MK21DN512 == 1) || (MCU_MK21DX256 == 1))
    235            SMC_PMCTRL = (SMC_PMCTRL & (SMC_PMCTRL_RUNM_MASK | SMC_PMCTRL_LPWUI_MASK)) |
    236                         SMC_PMCTRL_STOPM(0x2) | 
    237                         SMC_PMCTRL_LPWUI_MASK ;
   \                     PWRLib_MCU_Enter_VLPS: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable29_1  ;; 0x4007e001
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF010 0x00E0      ANDS     R0,R0,#0xE0
   \   0000000A   0xF050 0x0082      ORRS     R0,R0,#0x82
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable29_1  ;; 0x4007e001
   \   00000012   0x7008             STRB     R0,[R1, #+0]
    238          #endif
    239            
    240            /* Set the SLEEPDEEP bit to enable CORTEX M4 deep sleep mode */
    241            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;	
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable29  ;; 0xe000ed10
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable29  ;; 0xe000ed10
   \   00000022   0x6008             STR      R0,[R1, #+0]
    242          
    243            /* WFI instruction will start entry into deep sleep mode */
    244            asm("WFI");
   \   00000024   0xBF30             WFI
    245          }
   \   00000026   0x4770             BX       LR               ;; return
    246          
    247          /*---------------------------------------------------------------------------
    248           * Name: PWRLib_MCUEnter_LLS
    249           * Description: Puts the processor into LLS (Low Leakage Stop).
    250          
    251                          Mode of operation details:
    252                           - ARM core enters Deep Sleep Mode
    253                           - ARM core is clock gated (HCLK = OFF)
    254                           - NVIC is disable (FCLK = OFF)
    255                           - LLWU is used to wake up from interruptions
    256                           - Platform and peripheral clock are stopped
    257                           - MCG module can be configured to leave reference clocks running
    258                           - On chip voltage regulator is in a mode that supplies only enough 
    259                             power to run the MCU in a reduced frequency
    260                           - All SRAM is operating (content retained and I/O states held)
    261                           - Most of peripherals are in state retention mode (cannot operate)
    262          
    263                          LLS mode is exited into RUN mode using LLWU module or RESET.
    264          
    265                          The ALLP must be set to 0b1 in MC_PMPROT register in order to allow LLS mode.
    266          
    267           * Parameters: -
    268           * Return: -
    269           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 4, keep-with-next
    270          void PWRLib_MCU_Enter_LLS
    271          (
    272            void
    273          )
    274          {
    275          
    276            /* Set the LPLLSM field to 0b011 for LLS mode  */
    277          #if (MCU_MK60N512VMD100 == 1)
    278            MC_PMCTRL = (MC_PMCTRL & (MC_PMCTRL_RUNM_MASK | MC_PMCTRL_LPWUI_MASK)) |
    279                         MC_PMCTRL_LPLLSM(0x3) ;
    280          #elif ((MCU_MK60D10 == 1) || (MCU_MK21DN512 == 1) || (MCU_MK21DX256 == 1))
    281            SMC_PMCTRL = (SMC_PMCTRL & (SMC_PMCTRL_RUNM_MASK | SMC_PMCTRL_LPWUI_MASK)) |
    282                         SMC_PMCTRL_STOPM(0x3) ;  
   \                     PWRLib_MCU_Enter_LLS: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable29_1  ;; 0x4007e001
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF010 0x00E0      ANDS     R0,R0,#0xE0
   \   0000000A   0xF050 0x0003      ORRS     R0,R0,#0x3
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable29_1  ;; 0x4007e001
   \   00000012   0x7008             STRB     R0,[R1, #+0]
    283          #endif
    284          
    285            /* Set the SLEEPDEEP bit to enable CORTEX M4 deep sleep mode */
    286            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;	
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable29  ;; 0xe000ed10
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable29  ;; 0xe000ed10
   \   00000022   0x6008             STR      R0,[R1, #+0]
    287            
    288            /* WFI instruction will start entry into deep sleep mode */
    289            asm("WFI");
   \   00000024   0xBF30             WFI
    290          }
   \   00000026   0x4770             BX       LR               ;; return
    291          
    292          /*---------------------------------------------------------------------------
    293           * Name: PWRLib_MCUEnter_VLLS3
    294           * Description: Puts the processor into VLLS3 (Very Low Leakage Stop3).
    295          
    296                          Mode of operation details:
    297                           - ARM core enters SleepDeep Mode
    298                           - ARM core is clock gated (HCLK = OFF)
    299                           - NVIC is disable (FCLK = OFF)
    300                           - LLWU should configure by user to enable the desire wake up source
    301                           - Platform and peripheral clock are stopped
    302                           - MCG module can be configured to leave reference clocks running
    303                           - On chip voltage regulator is in a mode that supplies only enough
    304                             power to run the MCU in a reduced frequency
    305                           - All SRAM is operating (content retained and I/O states held)
    306                           - Most modules are disabled
    307          
    308                          VLLS3 mode is exited into RUN mode using LLWU module or RESET.
    309                          All wakeup goes through Reset sequence.
    310          
    311                          The AVLLS3 must be set to 0b1 in MC_PMPROT register in order to allow VLLS3 mode.
    312          
    313           * Parameters: -
    314           * Return: -
    315           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 4, keep-with-next
    316          void PWRLib_MCU_Enter_VLLS3
    317          (
    318            void
    319          )
    320          {
    321            /* Set the LPLLSM field to 0b101 for VLLS3 mode */
    322          #if (MCU_MK60N512VMD100 == 1)
    323            MC_PMCTRL = (MC_PMCTRL & (MC_PMCTRL_RUNM_MASK | MC_PMCTRL_LPWUI_MASK)) |
    324                         MC_PMCTRL_LPLLSM(0x5) ;
    325          #elif ((MCU_MK60D10 == 1)  || (MCU_MK21DN512 == 1) || (MCU_MK21DX256 == 1))
    326            SMC_PMCTRL = (SMC_PMCTRL & (SMC_PMCTRL_RUNM_MASK | SMC_PMCTRL_LPWUI_MASK)) |
    327                         SMC_PMCTRL_STOPM(0x4) ;
   \                     PWRLib_MCU_Enter_VLLS3: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable29_1  ;; 0x4007e001
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF010 0x00E0      ANDS     R0,R0,#0xE0
   \   0000000A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable29_1  ;; 0x4007e001
   \   00000012   0x7008             STRB     R0,[R1, #+0]
    328            SMC_VLLSCTRL = SMC_VLLSCTRL_VLLSM(0x3);
   \   00000014   0x2003             MOVS     R0,#+3
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable29_2  ;; 0x4007e002
   \   0000001A   0x7008             STRB     R0,[R1, #+0]
    329          #endif
    330            
    331            /* Set the SLEEPDEEP bit to enable CORTEX M4 deep sleep mode */
    332            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;	
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable29  ;; 0xe000ed10
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable29  ;; 0xe000ed10
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    333            
    334            /* WFI instruction will start entry into deep sleep mode */
    335            asm("WFI");
   \   0000002C   0xBF30             WFI
    336          }
   \   0000002E   0x4770             BX       LR               ;; return
    337          
    338          /*---------------------------------------------------------------------------
    339           * Name: PWRLib_MCUEnter_VLLS2
    340           * Description: Puts the processor into VLLS2 (Very Low Leakage Stop2).
    341          
    342                          Mode of operation details:
    343                           - ARM core enters SleepDeep Mode
    344                           - ARM core is clock gated (HCLK = OFF)
    345                           - NVIC is disable (FCLK = OFF)
    346                           - LLWU should configure by user to enable the desire wake up source
    347                           - Platform and peripheral clock are stopped
    348                           - MCG module can be configured to leave reference clocks running
    349                           - On chip voltage regulator is in a mode that supplies only enough
    350                             power to run the MCU in a reduced frequency
    351                           - SRAM_L is powered off. A portion of SRAM_U remains powered on (content retained and I/O state held).
    352                           - Most modules are disabled
    353          
    354                          VLLS2 mode is exited into RUN mode using LLWU module or RESET.
    355                          All wakeup goes through Reset sequence.
    356          
    357                          The AVLLS2 must be set to 0b1 in MC_PMPROT register in order to allow VLLS2 mode.
    358          
    359           * Parameters: -
    360           * Return: -
    361           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 4, keep-with-next
    362          void PWRLib_MCU_Enter_VLLS2
    363          (
    364            void
    365          )
    366          {
    367            /* Set the LPLLSM field to 0b110 for VLLS2 mode */
    368          #if (MCU_MK60N512VMD100 == 1)
    369            MC_PMCTRL = (MC_PMCTRL & (MC_PMCTRL_RUNM_MASK | MC_PMCTRL_LPWUI_MASK)) |
    370                         MC_PMCTRL_LPLLSM(0x6) ;
    371          #elif ((MCU_MK60D10 == 1)  || (MCU_MK21DN512 == 1) || (MCU_MK21DX256 == 1))
    372            SMC_PMCTRL = (SMC_PMCTRL & (SMC_PMCTRL_RUNM_MASK | SMC_PMCTRL_LPWUI_MASK)) |
    373                         SMC_PMCTRL_STOPM(0x4) ;
   \                     PWRLib_MCU_Enter_VLLS2: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable29_1  ;; 0x4007e001
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF010 0x00E0      ANDS     R0,R0,#0xE0
   \   0000000A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable29_1  ;; 0x4007e001
   \   00000012   0x7008             STRB     R0,[R1, #+0]
    374            SMC_VLLSCTRL = (SMC_VLLSCTRL_VLLSM(0x2) | cPWR_RAM2PowerOption );
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable29_2  ;; 0x4007e002
   \   0000001A   0x7008             STRB     R0,[R1, #+0]
    375          #endif
    376            
    377            /* Set the SLEEPDEEP bit to enable CORTEX M4 deep sleep mode */
    378            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;	
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable29  ;; 0xe000ed10
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable29  ;; 0xe000ed10
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    379            
    380            /* WFI instruction will start entry into deep sleep mode */
    381            asm("WFI");
   \   0000002C   0xBF30             WFI
    382          }
   \   0000002E   0x4770             BX       LR               ;; return
    383          
    384          /*---------------------------------------------------------------------------
    385           * Name: PWRLib_MCUEnter_VLLS1
    386           * Description: Puts the processor into VLLS1 (Very Low Leakage Stop2).
    387          
    388                          Mode of operation details:
    389                           - ARM core enters SleepDeep Mode
    390                           - ARM core is clock gated (HCLK = OFF)
    391                           - NVIC is disable (FCLK = OFF)
    392                           - LLWU should configure by user to enable the desire wake up source
    393                           - Platform and peripheral clock are stopped
    394                           - MCG module can be configured to leave reference clocks running
    395                           - On chip voltage regulator is in a mode that supplies only enough
    396                             power to run the MCU in a reduced frequency
    397                           - SRAM_L and SRAM_H is powered off.
    398                           - Most modules are disabled
    399          
    400                          VLLS1 mode is exited into RUN mode using LLWU module or RESET.
    401                          All wakeup goes through Reset sequence.
    402          
    403                          The AVLLS1 must be set to 0b1 in MC_PMPROT register in order to allow VLLS2 mode.
    404          
    405           * Parameters: -
    406           * Return: -
    407           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 4, keep-with-next
    408          void PWRLib_MCU_Enter_VLLS1
    409          (
    410            void
    411          )
    412          {
    413            /* Set the LPLLSM field to 0b110 for VLLS1 mode */
    414          #if (MCU_MK60N512VMD100 == 1)
    415            MC_PMCTRL = (MC_PMCTRL & (MC_PMCTRL_RUNM_MASK | MC_PMCTRL_LPWUI_MASK)) |
    416                         MC_PMCTRL_LPLLSM(0x7) ;
    417          #elif ((MCU_MK60D10 == 1)  || (MCU_MK21DN512 == 1) || (MCU_MK21DX256 == 1))
    418            SMC_PMCTRL = (SMC_PMCTRL & (SMC_PMCTRL_RUNM_MASK | SMC_PMCTRL_LPWUI_MASK)) |
    419                         SMC_PMCTRL_STOPM(0x4) ;
   \                     PWRLib_MCU_Enter_VLLS1: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable29_1  ;; 0x4007e001
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF010 0x00E0      ANDS     R0,R0,#0xE0
   \   0000000A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable29_1  ;; 0x4007e001
   \   00000012   0x7008             STRB     R0,[R1, #+0]
    420            SMC_VLLSCTRL = SMC_VLLSCTRL_VLLSM(0x1);
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable29_2  ;; 0x4007e002
   \   0000001A   0x7008             STRB     R0,[R1, #+0]
    421          #endif
    422            
    423            /* Set the SLEEPDEEP bit to enable CORTEX M4 deep sleep mode */
    424            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;	
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable29  ;; 0xe000ed10
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable29  ;; 0xe000ed10
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    425            
    426            /* WFI instruction will start entry into deep sleep mode */
    427            asm("WFI");
   \   0000002C   0xBF30             WFI
    428          }
   \   0000002E   0x4770             BX       LR               ;; return
    429          
    430          /*---------------------------------------------------------------------------
    431           * Name: PWRLib_MCUEnter_VLLS0
    432           * Description: Puts the processor into VLLS0 (Very Low Leakage Stop0).
    433          
    434                          Mode of operation details:
    435                           - ARM core enters SleepDeep Mode
    436                           - ARM core is clock gated (HCLK = OFF)
    437                           - NVIC is disable (FCLK = OFF)
    438                           - LLWU should configure by user to enable the desire wake up source
    439                           - Platform and peripheral clock are stopped
    440                           - MCG module can be configured to leave reference clocks running
    441                           - On chip voltage regulator is in a mode that supplies only enough
    442                             power to run the MCU in a reduced frequency
    443                           - SRAM_L and SRAM_H is powered off.
    444                           - Most modules are disabled
    445          
    446                          VLLS1 mode is exited into RUN mode using LLWU module or RESET.
    447                          All wakeup goes through Reset sequence.
    448          
    449                          The AVLLS1 must be set to 0b1 in MC_PMPROT register in order to allow VLLS2 mode.
    450          
    451           * Parameters: -
    452           * Return: -
    453           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 4, keep-with-next
    454          void PWRLib_MCU_Enter_VLLS0
    455          (
    456            void
    457          )
    458          {
    459            /* Set the LPLLSM field to 0b110 for VLLS0 mode */
    460          #if (MCU_MK60N512VMD100 == 1)
    461            MC_PMCTRL = (MC_PMCTRL & (MC_PMCTRL_RUNM_MASK | MC_PMCTRL_LPWUI_MASK)) |
    462                         MC_PMCTRL_LPLLSM(0x8) ;
    463          #elif ((MCU_MK60D10 == 1)  || (MCU_MK21DN512 == 1) || (MCU_MK21DX256 == 1))
    464            SMC_PMCTRL = (SMC_PMCTRL & (SMC_PMCTRL_RUNM_MASK | SMC_PMCTRL_LPWUI_MASK)) |
    465                         SMC_PMCTRL_STOPM(0x4) ;
   \                     PWRLib_MCU_Enter_VLLS0: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable29_1  ;; 0x4007e001
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF010 0x00E0      ANDS     R0,R0,#0xE0
   \   0000000A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable29_1  ;; 0x4007e001
   \   00000012   0x7008             STRB     R0,[R1, #+0]
    466            SMC_VLLSCTRL = SMC_VLLSCTRL_VLLSM(0x0) ;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable29_2  ;; 0x4007e002
   \   0000001A   0x7008             STRB     R0,[R1, #+0]
    467          #endif
    468            
    469            /* Set the SLEEPDEEP bit to enable CORTEX M4 deep sleep mode */
    470            SCB_SCR |=( SCB_SCR_SLEEPDEEP_MASK | 0x20 );	
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable29  ;; 0xe000ed10
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF050 0x0024      ORRS     R0,R0,#0x24
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable29  ;; 0xe000ed10
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    471            
    472            /* WFI instruction will start entry into deep sleep mode */
    473            asm("WFI");
   \   0000002C   0xBF30             WFI
    474          }
   \   0000002E   0x4770             BX       LR               ;; return
    475          
    476          /*---------------------------------------------------------------------------
    477           * Name: PWRLib_Radio_Enter_Doze
    478           * Description: -
    479           * Parameters: -
    480           * Return: -
    481           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    482          void PWRLib_Radio_Enter_Doze
    483          (
    484            void
    485          )
    486          {
   \                     PWRLib_Radio_Enter_Doze: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    487            uint32_t irqMaskRegister;
    488            uint8_t phyCtrl1Reg, irqSts1Reg, pwrModesReg;
    489            irqMaskRegister = IntDisableAll();
   \   00000002   0x.... 0x....      BL       IntDisableAll
   \   00000006   0x0004             MOVS     R4,R0
    490          
    491            pwrModesReg = MC1324xDrv_DirectAccessSPIRead( (uint8_t) PWR_MODES);
   \   00000008   0x203D             MOVS     R0,#+61
   \   0000000A   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   0000000E   0x0007             MOVS     R7,R0
    492            /* disable autodoze mode. sets PMC in low-power mode */
    493            pwrModesReg &= (uint8_t) ~( cPWR_MODES_AUTODOZE | cPWR_MODES_PMC_MODE );
   \   00000010   0xF017 0x07FC      ANDS     R7,R7,#0xFC
    494            /* check if 32 MHz crystal oscillator is enabled (current state is hibernate mode) */
    495            if( (pwrModesReg & cPWR_MODES_XTALEN ) != cPWR_MODES_XTALEN )
   \   00000014   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000016   0x06F8             LSLS     R0,R7,#+27
   \   00000018   0xD417             BMI.N    ??PWRLib_Radio_Enter_Doze_0
    496            {
    497              /* enable 32 MHz crystal oscillator */
    498              pwrModesReg |= (uint8_t) cPWR_MODES_XTALEN;
   \   0000001A   0xF057 0x0710      ORRS     R7,R7,#0x10
    499              MC1324xDrv_DirectAccessSPIWrite( (uint8_t) PWR_MODES, pwrModesReg);
   \   0000001E   0x0039             MOVS     R1,R7
   \   00000020   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   0x203D             MOVS     R0,#+61
   \   00000024   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    500              /* wait for crystal oscillator to complet its warmup */
    501              while( ( MC1324xDrv_DirectAccessSPIRead( (uint8_t) PWR_MODES) & cPWR_MODES_XTAL_READY ) != cPWR_MODES_XTAL_READY);
   \                     ??PWRLib_Radio_Enter_Doze_1: (+1)
   \   00000028   0x203D             MOVS     R0,#+61
   \   0000002A   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   0000002E   0x0680             LSLS     R0,R0,#+26
   \   00000030   0xD5FA             BPL.N    ??PWRLib_Radio_Enter_Doze_1
    502              /* wait for radio wakeup from hibernate interrupt */
    503              while( ( MC1324xDrv_DirectAccessSPIRead( (uint8_t) IRQSTS2) & (cIRQSTS2_WAKE_IRQ | cIRQSTS2_TMRSTATUS) ) != (cIRQSTS2_WAKE_IRQ | cIRQSTS2_TMRSTATUS) );
   \                     ??PWRLib_Radio_Enter_Doze_2: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   00000038   0xF010 0x0009      ANDS     R0,R0,#0x9
   \   0000003C   0x2809             CMP      R0,#+9
   \   0000003E   0xD1F8             BNE.N    ??PWRLib_Radio_Enter_Doze_2
    504              MC1324xDrv_DirectAccessSPIWrite((uint8_t) IRQSTS2, (uint8_t) (cIRQSTS2_WAKE_IRQ));
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
   \   00000048   0xE02F             B.N      ??PWRLib_Radio_Enter_Doze_3
    505            }
    506            else
    507            {
    508              /* checks if packet processor is in idle state. otherwise abort any ongoing sequence */
    509              phyCtrl1Reg = MC1324xDrv_DirectAccessSPIRead( (uint8_t) PHY_CTRL1 );
   \                     ??PWRLib_Radio_Enter_Doze_0: (+1)
   \   0000004A   0x2003             MOVS     R0,#+3
   \   0000004C   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   00000050   0x0005             MOVS     R5,R0
    510              if( (phyCtrl1Reg & cPHY_CTRL1_XCVSEQ) != 0x00 )
   \   00000052   0x2007             MOVS     R0,#+7
   \   00000054   0x4205             TST      R5,R0
   \   00000056   0xD023             BEQ.N    ??PWRLib_Radio_Enter_Doze_4
    511              {
    512                /* abort any ongoing sequence */
    513                /* make sure that we abort in HW only if the sequence was actually started (tmr triggered) */
    514                if( ( 0 != ( MC1324xDrv_DirectAccessSPIRead( (uint8_t) PHY_CTRL1) & cPHY_CTRL1_XCVSEQ ) ) && ((MC1324xDrv_DirectAccessSPIRead(SEQ_STATE)&0x1F) != 0))
   \   00000058   0x2003             MOVS     R0,#+3
   \   0000005A   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   0000005E   0x2107             MOVS     R1,#+7
   \   00000060   0x4208             TST      R0,R1
   \   00000062   0xD012             BEQ.N    ??PWRLib_Radio_Enter_Doze_5
   \   00000064   0x2024             MOVS     R0,#+36
   \   00000066   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   0000006A   0x211F             MOVS     R1,#+31
   \   0000006C   0x4208             TST      R0,R1
   \   0000006E   0xD00C             BEQ.N    ??PWRLib_Radio_Enter_Doze_5
    515                {
    516                  phyCtrl1Reg &= (uint8_t) ~(cPHY_CTRL1_XCVSEQ);
   \   00000070   0xF015 0x05F8      ANDS     R5,R5,#0xF8
    517                  MC1324xDrv_DirectAccessSPIWrite(PHY_CTRL1, phyCtrl1Reg);
   \   00000074   0x0029             MOVS     R1,R5
   \   00000076   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000078   0x2003             MOVS     R0,#+3
   \   0000007A   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    518                  while ((MC1324xDrv_DirectAccessSPIRead(SEQ_STATE) & 0x1F) != 0);
   \                     ??PWRLib_Radio_Enter_Doze_6: (+1)
   \   0000007E   0x2024             MOVS     R0,#+36
   \   00000080   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   00000084   0x211F             MOVS     R1,#+31
   \   00000086   0x4208             TST      R0,R1
   \   00000088   0xD1F9             BNE.N    ??PWRLib_Radio_Enter_Doze_6
    519                }
    520                /* clear sequence-end interrupt */ 
    521                irqSts1Reg = MC1324xDrv_DirectAccessSPIRead( (uint8_t) IRQSTS1);
   \                     ??PWRLib_Radio_Enter_Doze_5: (+1)
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   00000090   0x0006             MOVS     R6,R0
    522                irqSts1Reg |= (uint8_t) cIRQSTS1_SEQIRQ;
   \   00000092   0xF056 0x0601      ORRS     R6,R6,#0x1
    523                MC1324xDrv_DirectAccessSPIWrite( (uint8_t) IRQSTS1, irqSts1Reg);
   \   00000096   0x0031             MOVS     R1,R6
   \   00000098   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    524              }
    525              MC1324xDrv_DirectAccessSPIWrite( (uint8_t) PWR_MODES, pwrModesReg);
   \                     ??PWRLib_Radio_Enter_Doze_4: (+1)
   \   000000A0   0x0039             MOVS     R1,R7
   \   000000A2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A4   0x203D             MOVS     R0,#+61
   \   000000A6   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    526            }
    527            
    528            IntRestoreAll(irqMaskRegister);
   \                     ??PWRLib_Radio_Enter_Doze_3: (+1)
   \   000000AA   0x0020             MOVS     R0,R4
   \   000000AC   0x.... 0x....      BL       IntRestoreAll
    529          }
   \   000000B0   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    530          
    531          /*---------------------------------------------------------------------------
    532           * Name: PWRLib_Radio_Enter_AutoDoze
    533           * Description: -
    534           * Parameters: -
    535           * Return: -
    536           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    537          void PWRLib_Radio_Enter_AutoDoze
    538          (
    539            void
    540          )
    541          {
   \                     PWRLib_Radio_Enter_AutoDoze: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    542            uint32_t irqMaskRegister;
    543            uint8_t pwrModesReg;
    544            irqMaskRegister = IntDisableAll();
   \   00000002   0x.... 0x....      BL       IntDisableAll
   \   00000006   0x0004             MOVS     R4,R0
    545          
    546            pwrModesReg = MC1324xDrv_DirectAccessSPIRead( (uint8_t) PWR_MODES);
   \   00000008   0x203D             MOVS     R0,#+61
   \   0000000A   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   0000000E   0x0005             MOVS     R5,R0
    547            /* enable autodoze mode. */
    548            pwrModesReg |= (uint8_t) cPWR_MODES_AUTODOZE;
   \   00000010   0xF055 0x0502      ORRS     R5,R5,#0x2
    549            /* check if 32 MHz crystal oscillator is enabled (current state is hibernate mode) */
    550            if( (pwrModesReg & cPWR_MODES_XTALEN ) != cPWR_MODES_XTALEN )
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0x06E8             LSLS     R0,R5,#+27
   \   00000018   0xD417             BMI.N    ??PWRLib_Radio_Enter_AutoDoze_0
    551            {
    552              /* enable 32 MHz crystal oscillator */
    553              pwrModesReg |= (uint8_t) cPWR_MODES_XTALEN;
   \   0000001A   0xF055 0x0510      ORRS     R5,R5,#0x10
    554              MC1324xDrv_DirectAccessSPIWrite( (uint8_t) PWR_MODES, pwrModesReg);
   \   0000001E   0x0029             MOVS     R1,R5
   \   00000020   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   0x203D             MOVS     R0,#+61
   \   00000024   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    555              /* wait for crystal oscillator to complet its warmup */
    556              while( ( MC1324xDrv_DirectAccessSPIRead( (uint8_t) PWR_MODES) & cPWR_MODES_XTAL_READY ) != cPWR_MODES_XTAL_READY);
   \                     ??PWRLib_Radio_Enter_AutoDoze_1: (+1)
   \   00000028   0x203D             MOVS     R0,#+61
   \   0000002A   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   0000002E   0x0680             LSLS     R0,R0,#+26
   \   00000030   0xD5FA             BPL.N    ??PWRLib_Radio_Enter_AutoDoze_1
    557              /* wait for radio wakeup from hibernate interrupt */
    558              while( ( MC1324xDrv_DirectAccessSPIRead( (uint8_t) IRQSTS2) & (cIRQSTS2_WAKE_IRQ | cIRQSTS2_TMRSTATUS) ) != (cIRQSTS2_WAKE_IRQ | cIRQSTS2_TMRSTATUS) );
   \                     ??PWRLib_Radio_Enter_AutoDoze_2: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   00000038   0xF010 0x0009      ANDS     R0,R0,#0x9
   \   0000003C   0x2809             CMP      R0,#+9
   \   0000003E   0xD1F8             BNE.N    ??PWRLib_Radio_Enter_AutoDoze_2
    559              MC1324xDrv_DirectAccessSPIWrite((uint8_t) IRQSTS2, (uint8_t) (cIRQSTS2_WAKE_IRQ));
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
   \   00000048   0xE004             B.N      ??PWRLib_Radio_Enter_AutoDoze_3
    560            }
    561            else
    562            {
    563              MC1324xDrv_DirectAccessSPIWrite( (uint8_t) PWR_MODES, pwrModesReg);
   \                     ??PWRLib_Radio_Enter_AutoDoze_0: (+1)
   \   0000004A   0x0029             MOVS     R1,R5
   \   0000004C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004E   0x203D             MOVS     R0,#+61
   \   00000050   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    564            }
    565            
    566            IntRestoreAll(irqMaskRegister);
   \                     ??PWRLib_Radio_Enter_AutoDoze_3: (+1)
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x.... 0x....      BL       IntRestoreAll
    567          }
   \   0000005A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    568          
    569          /*---------------------------------------------------------------------------
    570           * Name: PWRLib_Radio_Enter_Idle
    571           * Description: -
    572           * Parameters: -
    573           * Return: -
    574           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    575          void PWRLib_Radio_Enter_Idle
    576          (
    577            void
    578          )
    579          {
   \                     PWRLib_Radio_Enter_Idle: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    580            uint32_t irqMaskRegister;
    581            uint8_t phyCtrl1Reg, irqSts1Reg, pwrModesReg;
    582            irqMaskRegister = IntDisableAll();
   \   00000002   0x.... 0x....      BL       IntDisableAll
   \   00000006   0x0004             MOVS     R4,R0
    583          
    584            pwrModesReg = MC1324xDrv_DirectAccessSPIRead( (uint8_t) PWR_MODES);
   \   00000008   0x203D             MOVS     R0,#+61
   \   0000000A   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   0000000E   0x0007             MOVS     R7,R0
    585            /* disable autodoze mode. sets PMC in high-power mode */
    586            pwrModesReg &= (uint8_t) ~( cPWR_MODES_AUTODOZE );
   \   00000010   0xF017 0x07FD      ANDS     R7,R7,#0xFD
    587            pwrModesReg |= (uint8_t) cPWR_MODES_PMC_MODE;
   \   00000014   0xF057 0x0701      ORRS     R7,R7,#0x1
    588            /* check if 32 MHz crystal oscillator is enabled (current state is hibernate mode) */
    589            if( (pwrModesReg & cPWR_MODES_XTALEN ) != cPWR_MODES_XTALEN )
   \   00000018   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000001A   0x06F8             LSLS     R0,R7,#+27
   \   0000001C   0xD417             BMI.N    ??PWRLib_Radio_Enter_Idle_0
    590            {
    591              /* enable 32 MHz crystal oscillator */
    592              pwrModesReg |= (uint8_t) cPWR_MODES_XTALEN;
   \   0000001E   0xF057 0x0710      ORRS     R7,R7,#0x10
    593              MC1324xDrv_DirectAccessSPIWrite( (uint8_t) PWR_MODES, pwrModesReg);
   \   00000022   0x0039             MOVS     R1,R7
   \   00000024   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000026   0x203D             MOVS     R0,#+61
   \   00000028   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    594              /* wait for crystal oscillator to complet its warmup */
    595              while( ( MC1324xDrv_DirectAccessSPIRead( (uint8_t) PWR_MODES) & cPWR_MODES_XTAL_READY ) != cPWR_MODES_XTAL_READY);
   \                     ??PWRLib_Radio_Enter_Idle_1: (+1)
   \   0000002C   0x203D             MOVS     R0,#+61
   \   0000002E   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   00000032   0x0680             LSLS     R0,R0,#+26
   \   00000034   0xD5FA             BPL.N    ??PWRLib_Radio_Enter_Idle_1
    596              /* wait for radio wakeup from hibernate interrupt */
    597              while( ( MC1324xDrv_DirectAccessSPIRead( (uint8_t) IRQSTS2) & (cIRQSTS2_WAKE_IRQ | cIRQSTS2_TMRSTATUS) ) != (cIRQSTS2_WAKE_IRQ | cIRQSTS2_TMRSTATUS) );
   \                     ??PWRLib_Radio_Enter_Idle_2: (+1)
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   0000003C   0xF010 0x0009      ANDS     R0,R0,#0x9
   \   00000040   0x2809             CMP      R0,#+9
   \   00000042   0xD1F8             BNE.N    ??PWRLib_Radio_Enter_Idle_2
    598              MC1324xDrv_DirectAccessSPIWrite((uint8_t) IRQSTS2, (uint8_t) (cIRQSTS2_WAKE_IRQ));
   \   00000044   0x2101             MOVS     R1,#+1
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
   \   0000004C   0xE02F             B.N      ??PWRLib_Radio_Enter_Idle_3
    599            }
    600            else
    601            {
    602              /* checks if packet processor is in idle state. otherwise abort any ongoing sequence */
    603              phyCtrl1Reg = MC1324xDrv_DirectAccessSPIRead( (uint8_t) PHY_CTRL1 );
   \                     ??PWRLib_Radio_Enter_Idle_0: (+1)
   \   0000004E   0x2003             MOVS     R0,#+3
   \   00000050   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   00000054   0x0005             MOVS     R5,R0
    604              if( (phyCtrl1Reg & cPHY_CTRL1_XCVSEQ) != 0x00 )
   \   00000056   0x2007             MOVS     R0,#+7
   \   00000058   0x4205             TST      R5,R0
   \   0000005A   0xD023             BEQ.N    ??PWRLib_Radio_Enter_Idle_4
    605              {
    606                /* abort any ongoing sequence */
    607                /* make sure that we abort in HW only if the sequence was actually started (tmr triggered) */
    608                if( ( 0 != ( MC1324xDrv_DirectAccessSPIRead( (uint8_t) PHY_CTRL1) & cPHY_CTRL1_XCVSEQ ) ) && ((MC1324xDrv_DirectAccessSPIRead(SEQ_STATE)&0x1F) != 0))
   \   0000005C   0x2003             MOVS     R0,#+3
   \   0000005E   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   00000062   0x2107             MOVS     R1,#+7
   \   00000064   0x4208             TST      R0,R1
   \   00000066   0xD012             BEQ.N    ??PWRLib_Radio_Enter_Idle_5
   \   00000068   0x2024             MOVS     R0,#+36
   \   0000006A   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   0000006E   0x211F             MOVS     R1,#+31
   \   00000070   0x4208             TST      R0,R1
   \   00000072   0xD00C             BEQ.N    ??PWRLib_Radio_Enter_Idle_5
    609                {
    610                  phyCtrl1Reg &= (uint8_t) ~(cPHY_CTRL1_XCVSEQ);
   \   00000074   0xF015 0x05F8      ANDS     R5,R5,#0xF8
    611                  MC1324xDrv_DirectAccessSPIWrite(PHY_CTRL1, phyCtrl1Reg);
   \   00000078   0x0029             MOVS     R1,R5
   \   0000007A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007C   0x2003             MOVS     R0,#+3
   \   0000007E   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    612                  while ((MC1324xDrv_DirectAccessSPIRead(SEQ_STATE) & 0x1F) != 0);
   \                     ??PWRLib_Radio_Enter_Idle_6: (+1)
   \   00000082   0x2024             MOVS     R0,#+36
   \   00000084   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   00000088   0x211F             MOVS     R1,#+31
   \   0000008A   0x4208             TST      R0,R1
   \   0000008C   0xD1F9             BNE.N    ??PWRLib_Radio_Enter_Idle_6
    613                }
    614                /* clear sequence-end interrupt */ 
    615                irqSts1Reg = MC1324xDrv_DirectAccessSPIRead( (uint8_t) IRQSTS1);
   \                     ??PWRLib_Radio_Enter_Idle_5: (+1)
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   00000094   0x0006             MOVS     R6,R0
    616                irqSts1Reg |= (uint8_t) cIRQSTS1_SEQIRQ;
   \   00000096   0xF056 0x0601      ORRS     R6,R6,#0x1
    617                MC1324xDrv_DirectAccessSPIWrite( (uint8_t) IRQSTS1, irqSts1Reg);
   \   0000009A   0x0031             MOVS     R1,R6
   \   0000009C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    618              }
    619              MC1324xDrv_DirectAccessSPIWrite( (uint8_t) PWR_MODES, pwrModesReg);
   \                     ??PWRLib_Radio_Enter_Idle_4: (+1)
   \   000000A4   0x0039             MOVS     R1,R7
   \   000000A6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A8   0x203D             MOVS     R0,#+61
   \   000000AA   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    620            }
    621            
    622            IntRestoreAll(irqMaskRegister);
   \                     ??PWRLib_Radio_Enter_Idle_3: (+1)
   \   000000AE   0x0020             MOVS     R0,R4
   \   000000B0   0x.... 0x....      BL       IntRestoreAll
    623          }
   \   000000B4   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    624          
    625          /*---------------------------------------------------------------------------
    626           * Name: PWRLib_Radio_Enter_Hibernate
    627           * Description: -
    628           * Parameters: -
    629           * Return: -
    630           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    631          void PWRLib_Radio_Enter_Hibernate
    632          (
    633            void
    634          )
    635          {
   \                     PWRLib_Radio_Enter_Hibernate: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    636            uint32_t irqMaskRegister;
    637            uint8_t phyCtrl1Reg, irqSts1Reg, pwrModesReg;
    638            irqMaskRegister = IntDisableAll();
   \   00000002   0x.... 0x....      BL       IntDisableAll
   \   00000006   0x0004             MOVS     R4,R0
    639            
    640            /* checks if packet processor is in idle state. otherwise abort any ongoing sequence */
    641            phyCtrl1Reg = MC1324xDrv_DirectAccessSPIRead( (uint8_t) PHY_CTRL1 );
   \   00000008   0x2003             MOVS     R0,#+3
   \   0000000A   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   0000000E   0x0005             MOVS     R5,R0
    642            if( (phyCtrl1Reg & cPHY_CTRL1_XCVSEQ) != 0x00 )
   \   00000010   0x2007             MOVS     R0,#+7
   \   00000012   0x4205             TST      R5,R0
   \   00000014   0xD023             BEQ.N    ??PWRLib_Radio_Enter_Hibernate_0
    643            {
    644                /* abort any ongoing sequence */
    645                /* make sure that we abort in HW only if the sequence was actually started (tmr triggered) */
    646                if( ( 0 != ( MC1324xDrv_DirectAccessSPIRead( (uint8_t) PHY_CTRL1) & cPHY_CTRL1_XCVSEQ ) ) && ((MC1324xDrv_DirectAccessSPIRead(SEQ_STATE)&0x1F) != 0))
   \   00000016   0x2003             MOVS     R0,#+3
   \   00000018   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   0000001C   0x2107             MOVS     R1,#+7
   \   0000001E   0x4208             TST      R0,R1
   \   00000020   0xD012             BEQ.N    ??PWRLib_Radio_Enter_Hibernate_1
   \   00000022   0x2024             MOVS     R0,#+36
   \   00000024   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   00000028   0x211F             MOVS     R1,#+31
   \   0000002A   0x4208             TST      R0,R1
   \   0000002C   0xD00C             BEQ.N    ??PWRLib_Radio_Enter_Hibernate_1
    647                {
    648                  phyCtrl1Reg &= (uint8_t) ~(cPHY_CTRL1_XCVSEQ);
   \   0000002E   0xF015 0x05F8      ANDS     R5,R5,#0xF8
    649                  MC1324xDrv_DirectAccessSPIWrite(PHY_CTRL1, phyCtrl1Reg);
   \   00000032   0x0029             MOVS     R1,R5
   \   00000034   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000036   0x2003             MOVS     R0,#+3
   \   00000038   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    650                  while ((MC1324xDrv_DirectAccessSPIRead(SEQ_STATE) & 0x1F) != 0);
   \                     ??PWRLib_Radio_Enter_Hibernate_2: (+1)
   \   0000003C   0x2024             MOVS     R0,#+36
   \   0000003E   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   00000042   0x211F             MOVS     R1,#+31
   \   00000044   0x4208             TST      R0,R1
   \   00000046   0xD1F9             BNE.N    ??PWRLib_Radio_Enter_Hibernate_2
    651                }
    652                /* clear sequence-end interrupt */ 
    653                irqSts1Reg = MC1324xDrv_DirectAccessSPIRead( (uint8_t) IRQSTS1);
   \                     ??PWRLib_Radio_Enter_Hibernate_1: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   0000004E   0x0006             MOVS     R6,R0
    654                irqSts1Reg |= (uint8_t) cIRQSTS1_SEQIRQ;
   \   00000050   0xF056 0x0601      ORRS     R6,R6,#0x1
    655                MC1324xDrv_DirectAccessSPIWrite( (uint8_t) IRQSTS1, irqSts1Reg);
   \   00000054   0x0031             MOVS     R1,R6
   \   00000056   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    656            }
    657            
    658            pwrModesReg = MC1324xDrv_DirectAccessSPIRead( (uint8_t) PWR_MODES);
   \                     ??PWRLib_Radio_Enter_Hibernate_0: (+1)
   \   0000005E   0x203D             MOVS     R0,#+61
   \   00000060   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIRead
   \   00000064   0x0007             MOVS     R7,R0
    659            /* disable autodoze mode. disable 32 MHz crystal oscillator. sets PMC in low-power mode */
    660            pwrModesReg &= (uint8_t) ~( cPWR_MODES_AUTODOZE | cPWR_MODES_XTALEN | cPWR_MODES_PMC_MODE );
   \   00000066   0xF017 0x07EC      ANDS     R7,R7,#0xEC
    661          
    662            MC1324xDrv_DirectAccessSPIWrite( (uint8_t) PWR_MODES, pwrModesReg);
   \   0000006A   0x0039             MOVS     R1,R7
   \   0000006C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006E   0x203D             MOVS     R0,#+61
   \   00000070   0x.... 0x....      BL       MC1324xDrv_DirectAccessSPIWrite
    663            
    664            IntRestoreAll(irqMaskRegister);
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       IntRestoreAll
    665          }
   \   0000007A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    666          
    667          /*---------------------------------------------------------------------------
    668           * Name: PWRLib_LLWU_WakeupPinEnable
    669           * Description: -
    670           * Parameters: -
    671           * Return: -
    672           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    673          void PWRLib_LLWU_WakeupPinEnable
    674          (
    675            PWRLib_LLWU_WakeupPin_t       wakeupPin,
    676            PWRLib_LLWU_WakeupPinConfig_t edgeDetection
    677          )
    678          {
   \                     PWRLib_LLWU_WakeupPinEnable: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    679            volatile uint8_t * pinEnableRegBase = (volatile uint8_t *) &LLWU_PE1;
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable29_3  ;; 0x4007c000
    680            uint8_t regIdx, pinIdx;
    681            
    682            regIdx = (uint8_t)((uint8_t) wakeupPin >> 2);
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x0885             LSRS     R5,R0,#+2
   \   0000000A   0x002B             MOVS     R3,R5
    683            pinIdx = (uint8_t)(((uint8_t) wakeupPin & 3) << 1);
   \   0000000C   0xF010 0x0503      ANDS     R5,R0,#0x3
   \   00000010   0x006D             LSLS     R5,R5,#+1
   \   00000012   0x002C             MOVS     R4,R5
    684            
    685            pinEnableRegBase[regIdx] &= (uint8_t) ~(0x03 << pinIdx);
   \   00000014   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000016   0x5C9D             LDRB     R5,[R3, R2]
   \   00000018   0x2603             MOVS     R6,#+3
   \   0000001A   0x40A6             LSLS     R6,R6,R4
   \   0000001C   0x43B5             BICS     R5,R5,R6
   \   0000001E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000020   0x549D             STRB     R5,[R3, R2]
    686            pinEnableRegBase[regIdx] |= (uint8_t) ((uint8_t) edgeDetection << pinIdx);
   \   00000022   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000024   0x5C9D             LDRB     R5,[R3, R2]
   \   00000026   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000028   0xFA11 0xF604      LSLS     R6,R1,R4
   \   0000002C   0x4335             ORRS     R5,R6,R5
   \   0000002E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000030   0x549D             STRB     R5,[R3, R2]
    687            
    688          }
   \   00000032   0xBC70             POP      {R4-R6}
   \   00000034   0x4770             BX       LR               ;; return
    689            
    690          /*---------------------------------------------------------------------------
    691           * Name: PWRLib_LLWU_WakeupModuleEnable
    692           * Description: -
    693           * Parameters: -
    694           * Return: -
    695           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    696          void PWRLib_LLWU_WakeupModuleEnable
    697          (
    698            PWRLib_LLWU_WakeupModule_t wakeupModule
    699          )
    700          {
    701            LLWU_ME |= (uint8_t)(0x01 << (uint8_t) wakeupModule);
   \                     PWRLib_LLWU_WakeupModuleEnable: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable29_4  ;; 0x4007c004
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x4082             LSLS     R2,R2,R0
   \   0000000A   0x4311             ORRS     R1,R2,R1
   \   0000000C   0x.... 0x....      LDR.W    R2,??DataTable29_4  ;; 0x4007c004
   \   00000010   0x7011             STRB     R1,[R2, #+0]
    702          }
   \   00000012   0x4770             BX       LR               ;; return
    703          
    704          /*---------------------------------------------------------------------------
    705           * Name: PWRLib_LLWU_WakeupPinDisable
    706           * Description: -
    707           * Parameters: -
    708           * Return: -
    709           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    710          void PWRLib_LLWU_WakeupPinDisable
    711          (
    712            PWRLib_LLWU_WakeupPin_t wakeupPin
    713          )
    714          {
   \                     PWRLib_LLWU_WakeupPinDisable: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    715            volatile uint8_t * pinEnableRegBase = (volatile uint8_t *) &LLWU_PE1;
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable29_3  ;; 0x4007c000
    716            uint8_t regIdx, pinIdx;
    717            
    718            regIdx = (uint8_t)((uint8_t) wakeupPin >> 2);
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x0884             LSRS     R4,R0,#+2
   \   0000000A   0x0022             MOVS     R2,R4
    719            pinIdx = (uint8_t)(((uint8_t) wakeupPin & 3) << 1);
   \   0000000C   0xF010 0x0403      ANDS     R4,R0,#0x3
   \   00000010   0x0064             LSLS     R4,R4,#+1
   \   00000012   0x0023             MOVS     R3,R4
    720            
    721            pinEnableRegBase[regIdx] &= (uint8_t) ~(0x03 << pinIdx); 
   \   00000014   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000016   0x5C54             LDRB     R4,[R2, R1]
   \   00000018   0x2503             MOVS     R5,#+3
   \   0000001A   0x409D             LSLS     R5,R5,R3
   \   0000001C   0x43AC             BICS     R4,R4,R5
   \   0000001E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000020   0x5454             STRB     R4,[R2, R1]
    722          }
   \   00000022   0xBC30             POP      {R4,R5}
   \   00000024   0x4770             BX       LR               ;; return
    723          
    724          /*---------------------------------------------------------------------------
    725           * Name: PWRLib_LLWU_WakeupModuleDisable
    726           * Description: -
    727           * Parameters: -
    728           * Return: -
    729           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    730          void PWRLib_LLWU_WakeupModuleDisable
    731          (
    732            PWRLib_LLWU_WakeupModule_t wakeupModule
    733          )
    734          {
    735            LLWU_ME &= (uint8_t) ~(0x01 << (uint8_t) wakeupModule);
   \                     PWRLib_LLWU_WakeupModuleDisable: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable29_4  ;; 0x4007c004
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x4082             LSLS     R2,R2,R0
   \   0000000A   0x4391             BICS     R1,R1,R2
   \   0000000C   0x.... 0x....      LDR.W    R2,??DataTable29_4  ;; 0x4007c004
   \   00000010   0x7011             STRB     R1,[R2, #+0]
    736          }
   \   00000012   0x4770             BX       LR               ;; return
    737          
    738          /*---------------------------------------------------------------------------
    739           * Name: PWRLib_LLWU_IsLPTMRWakeUpSource
    740           * Description: -
    741           * Parameters: -
    742           * Return: -
    743           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    744          bool_t PWRLib_LLWU_IsLPTMRWakeUpSource
    745          (
    746            void
    747          )
    748          {
    749            /* low power timer wakeup */
    750            if( (LLWU_ME & ( (uint8_t) (1 << gPWRLib_LLWU_WakeupModule_LPTMR_c ) )) == ( (uint8_t) (1 << gPWRLib_LLWU_WakeupModule_LPTMR_c ) ) )
   \                     PWRLib_LLWU_IsLPTMRWakeUpSource: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable29_4  ;; 0x4007c004
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x07C0             LSLS     R0,R0,#+31
   \   0000000A   0xD507             BPL.N    ??PWRLib_LLWU_IsLPTMRWakeUpSource_0
    751            {
    752              if( (LLWU_F3 & ( (uint8_t) (1 << gPWRLib_LLWU_WakeupModule_LPTMR_c ) )) == ( (uint8_t) (1 << gPWRLib_LLWU_WakeupModule_LPTMR_c ) ) )
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable29_5  ;; 0x4007c007
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x07C0             LSLS     R0,R0,#+31
   \   00000016   0xD501             BPL.N    ??PWRLib_LLWU_IsLPTMRWakeUpSource_0
    753              {
    754                return TRUE;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE000             B.N      ??PWRLib_LLWU_IsLPTMRWakeUpSource_1
    755              }
    756            }
    757            return FALSE;
   \                     ??PWRLib_LLWU_IsLPTMRWakeUpSource_0: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \                     ??PWRLib_LLWU_IsLPTMRWakeUpSource_1: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
    758          }
    759          
    760          /*---------------------------------------------------------------------------
    761           * Name: PWRLib_LLWU_IsRTCWakeUpSource
    762           * Description: -
    763           * Parameters: -
    764           * Return: -
    765           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    766          bool_t PWRLib_LLWU_IsRTCWakeUpSource
    767          (
    768            void
    769          )
    770          {
    771            /* real time counter wakeup */
    772            if( (LLWU_ME & ( (uint8_t) (1 << gPWRLib_LLWU_WakeupModule_RTC_Alarm_c ) )) == ( (uint8_t) (1 << gPWRLib_LLWU_WakeupModule_RTC_Alarm_c ) ) )
   \                     PWRLib_LLWU_IsRTCWakeUpSource: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable29_4  ;; 0x4007c004
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x0680             LSLS     R0,R0,#+26
   \   0000000A   0xD507             BPL.N    ??PWRLib_LLWU_IsRTCWakeUpSource_0
    773            {
    774              if( (LLWU_F3 & ( (uint8_t) (1 << gPWRLib_LLWU_WakeupModule_RTC_Alarm_c ) )) == ( (uint8_t) (1 << gPWRLib_LLWU_WakeupModule_RTC_Alarm_c ) ) )
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable29_5  ;; 0x4007c007
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x0680             LSLS     R0,R0,#+26
   \   00000016   0xD501             BPL.N    ??PWRLib_LLWU_IsRTCWakeUpSource_0
    775              {
    776                return TRUE;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE000             B.N      ??PWRLib_LLWU_IsRTCWakeUpSource_1
    777              }
    778            }
    779            return FALSE;
   \                     ??PWRLib_LLWU_IsRTCWakeUpSource_0: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \                     ??PWRLib_LLWU_IsRTCWakeUpSource_1: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
    780          }
    781          
    782          /*---------------------------------------------------------------------------
    783           * Name: PWRLib_LLWU_IsTSIWakeUpSource
    784           * Description: -
    785           * Parameters: -
    786           * Return: -
    787           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    788          bool_t PWRLib_LLWU_IsTSIWakeUpSource
    789          (
    790            void
    791          )
    792          {
    793          #if (MCU_MK60D10 == 1) || (MCU_MK20D5 == 1) || (MCU_MK60N512VMD100 == 1)
    794            /* TSI wakeup */
    795            if( (LLWU_ME & ( (uint8_t) (1 << gPWRLib_LLWU_WakeupModule_TSI_c ) )) == ( (uint8_t) (1 << gPWRLib_LLWU_WakeupModule_TSI_c ) ) )
    796            {
    797              if( (LLWU_F3 & ( (uint8_t) (1 << gPWRLib_LLWU_WakeupModule_TSI_c ) )) == ( (uint8_t) (1 << gPWRLib_LLWU_WakeupModule_TSI_c ) ) )
    798              {
    799                return TRUE;
    800              }
    801            }
    802          #endif
    803            return FALSE;
   \                     PWRLib_LLWU_IsTSIWakeUpSource: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    804          }
    805          
    806          /*---------------------------------------------------------------------------
    807           * Name: PWRLib_LLWU_IsGPIOWakeUpSource
    808           * Description: -
    809           * Parameters: -
    810           * Return: -
    811           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    812          bool_t PWRLib_LLWU_IsGPIOWakeUpSource
    813          (
    814            uint8_t pinNumber
    815          )
    816          {
   \                     PWRLib_LLWU_IsGPIOWakeUpSource: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0001             MOVS     R1,R0
    817            uint32_t llwuPinEnableReg;
    818            uint16_t llwuFlagReg;
    819          
    820            llwuPinEnableReg = (uint32_t) (LLWU_PE1 << 0);
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable29_3  ;; 0x4007c000
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x0002             MOVS     R2,R0
    821            llwuPinEnableReg |= (uint32_t) (LLWU_PE2 << 8);
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable29_6  ;; 0x4007c001
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0xEA52 0x2200      ORRS     R2,R2,R0, LSL #+8
    822            llwuPinEnableReg |= (uint32_t) (LLWU_PE3 << 16);
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable29_7  ;; 0x4007c002
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0xEA52 0x4200      ORRS     R2,R2,R0, LSL #+16
    823            llwuPinEnableReg |= (uint32_t) (LLWU_PE4 << 24);
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable29_8  ;; 0x4007c003
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0xEA52 0x6200      ORRS     R2,R2,R0, LSL #+24
    824          
    825            llwuFlagReg = (uint32_t) (LLWU_F1 << 0);
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable29_9  ;; 0x4007c005
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x0003             MOVS     R3,R0
    826            llwuFlagReg |= (uint32_t) (LLWU_F2 << 8);
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable29_10  ;; 0x4007c006
   \   00000040   0x7800             LDRB     R0,[R0, #+0]
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0xEA53 0x2300      ORRS     R3,R3,R0, LSL #+8
    827            if( ( llwuPinEnableReg & (uint32_t) (0x3 << ( pinNumber << 1 ) ) ) != 0)
   \   00000048   0x2003             MOVS     R0,#+3
   \   0000004A   0x004C             LSLS     R4,R1,#+1
   \   0000004C   0x40A0             LSLS     R0,R0,R4
   \   0000004E   0x4202             TST      R2,R0
   \   00000050   0xD007             BEQ.N    ??PWRLib_LLWU_IsGPIOWakeUpSource_0
    828            {
    829              if( (llwuFlagReg & (uint16_t) (1 << pinNumber) ) != 0)
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x4088             LSLS     R0,R0,R1
   \   00000056   0x001C             MOVS     R4,R3
   \   00000058   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000005A   0x4204             TST      R4,R0
   \   0000005C   0xD001             BEQ.N    ??PWRLib_LLWU_IsGPIOWakeUpSource_0
    830              {
    831                 return TRUE;
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xE000             B.N      ??PWRLib_LLWU_IsGPIOWakeUpSource_1
    832              }
    833            }
    834            return FALSE;
   \                     ??PWRLib_LLWU_IsGPIOWakeUpSource_0: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \                     ??PWRLib_LLWU_IsGPIOWakeUpSource_1: (+1)
   \   00000064   0xBC10             POP      {R4}
   \   00000066   0x4770             BX       LR               ;; return
    835          }
    836          
    837          
    838          /*---------------------------------------------------------------------------
    839           * Name: PWRLib_LPTMR_ClockStart
    840           * Description: -
    841           * Parameters: -
    842           * Return: -
    843           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    844          void PWRLib_LPTMR_ClockStart
    845          (
    846            uint8_t  ClkMode,
    847            uint32_t Ticks
    848          )
    849          {
   \                     PWRLib_LPTMR_ClockStart: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    850            uint32_t irqMaskRegister;
    851            
    852            irqMaskRegister = IntDisableAll();
   \   00000006   0x.... 0x....      BL       IntDisableAll
   \   0000000A   0x0006             MOVS     R6,R0
    853            /* Turn on clock to LPTMR module */
    854            SIM_SCGC5 |= SIM_SCGC5_LPTIMER_MASK;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable29_11  ;; 0x40048038
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable29_11  ;; 0x40048038
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    855            
    856            /* Disable LPTMR */
    857            LPTMR0_CSR &= ~(LPTMR_CSR_TEN_MASK);
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable29_12  ;; 0x40040000
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x0840             LSRS     R0,R0,#+1
   \   00000024   0x0040             LSLS     R0,R0,#+1
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable29_12  ;; 0x40040000
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    858            
    859            /* Set compare value */
    860            if(Ticks != 0)
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD006             BEQ.N    ??PWRLib_LPTMR_ClockStart_0
    861            {
    862              LPTMR0_CMR = (uint16_t) (Ticks - 1);
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0x1E40             SUBS     R0,R0,#+1
   \   00000034   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable29_13  ;; 0x40040008
   \   0000003A   0x6008             STR      R0,[R1, #+0]
   \   0000003C   0xE004             B.N      ??PWRLib_LPTMR_ClockStart_1
    863            }
    864            else
    865            {
    866              LPTMR0_CMR = (uint16_t) Ticks;
   \                     ??PWRLib_LPTMR_ClockStart_0: (+1)
   \   0000003E   0x0028             MOVS     R0,R5
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable29_13  ;; 0x40040008
   \   00000046   0x6008             STR      R0,[R1, #+0]
    867            }
    868            
    869            /* Use specified tick count */
    870            mPWRLib_RTIRemainingTicks = Ticks;
   \                     ??PWRLib_LPTMR_ClockStart_1: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable29_14
   \   0000004C   0x6005             STR      R5,[R0, #+0]
    871            
    872            /* Configure prescaler, bypass prescaler and clck source */
    873            LPTMR0_PSR = (ClkMode | cPWR_LPTMRClockSource);
   \   0000004E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000050   0xF054 0x0001      ORRS     R0,R4,#0x1
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable29_15  ;; 0x40040004
   \   00000058   0x6008             STR      R0,[R1, #+0]
    874            
    875            /* Start counting */
    876            LPTMR0_CSR = ( LPTMR_CSR_TCF_MASK |
    877                           LPTMR_CSR_TIE_MASK | 
    878                           LPTMR_CSR_TFC_MASK);
   \   0000005A   0x20C4             MOVS     R0,#+196
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable29_12  ;; 0x40040000
   \   00000060   0x6008             STR      R0,[R1, #+0]
    879            LPTMR0_CSR |= LPTMR_CSR_TEN_MASK;
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable29_12  ;; 0x40040000
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable29_12  ;; 0x40040000
   \   00000070   0x6008             STR      R0,[R1, #+0]
    880            
    881            IntRestoreAll(irqMaskRegister);
   \   00000072   0x0030             MOVS     R0,R6
   \   00000074   0x.... 0x....      BL       IntRestoreAll
    882          }
   \   00000078   0xBD70             POP      {R4-R6,PC}       ;; return
    883          
    884          /*---------------------------------------------------------------------------
    885           * Name: PWRLib_LPTMR_ClockCheck
    886           * Description: -
    887           * Parameters: -
    888           * Return: -
    889           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    890          uint32_t PWRLib_LPTMR_ClockCheck
    891          (
    892            void
    893          )
    894          {
   \                     PWRLib_LPTMR_ClockCheck: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    895            uint32_t irqMaskRegister;
    896            uint32_t remTicks;
    897            
    898            irqMaskRegister = IntDisableAll();
   \   00000002   0x.... 0x....      BL       IntDisableAll
   \   00000006   0x0004             MOVS     R4,R0
    899            
    900            remTicks = mPWRLib_RTIRemainingTicks;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable29_14
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x0005             MOVS     R5,R0
    901            
    902            /* LPTMR is still running */
    903            if(LPTMR0_CSR & LPTMR_CSR_TEN_MASK)
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable29_12  ;; 0x40040000
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x07C0             LSLS     R0,R0,#+31
   \   00000018   0xD514             BPL.N    ??PWRLib_LPTMR_ClockCheck_0
    904            {
    905              /* timer compare flag is set */
    906              if(LPTMR0_CSR & LPTMR_CSR_TCF_MASK)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable29_12  ;; 0x40040000
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x0600             LSLS     R0,R0,#+24
   \   00000022   0xD502             BPL.N    ??PWRLib_LPTMR_ClockCheck_1
    907              {
    908                remTicks = 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x0005             MOVS     R5,R0
   \   00000028   0xE00C             B.N      ??PWRLib_LPTMR_ClockCheck_0
    909              }
    910              else
    911              {
    912                LPTMR0_CNR = LPTMR0_CNR;
   \                     ??PWRLib_LPTMR_ClockCheck_1: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable29_16  ;; 0x4004000c
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable29_16  ;; 0x4004000c
   \   00000034   0x6008             STR      R0,[R1, #+0]
    913                remTicks = mPWRLib_RTIRemainingTicks - LPTMR0_CNR;
   \   00000036   0x....             LDR.N    R0,??DataTable29_14
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable29_16  ;; 0x4004000c
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0x1A40             SUBS     R0,R0,R1
   \   00000042   0x0005             MOVS     R5,R0
    914              }
    915            }
    916           
    917            IntRestoreAll(irqMaskRegister);
   \                     ??PWRLib_LPTMR_ClockCheck_0: (+1)
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       IntRestoreAll
    918            return remTicks;
   \   0000004A   0x0028             MOVS     R0,R5
   \   0000004C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    919          }
    920          
    921          /*---------------------------------------------------------------------------
    922           * Name: PWRLib_LPTMR_ResetTicks
    923           * Description: -
    924           * Parameters: -
    925           * Return: -
    926           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    927          void PWRLib_LPTMR_ResetTicks
    928          (
    929            void
    930          )
    931          {
   \                     PWRLib_LPTMR_ResetTicks: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    932            uint32_t irqMaskRegister;
    933            irqMaskRegister = IntDisableAll();
   \   00000002   0x.... 0x....      BL       IntDisableAll
   \   00000006   0x0004             MOVS     R4,R0
    934            mPWRLib_RTIRemainingTicks = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x....             LDR.N    R1,??DataTable29_14
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    935            IntRestoreAll(irqMaskRegister);
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       IntRestoreAll
    936          }
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    937          
    938          /*---------------------------------------------------------------------------
    939           * Name: PWRLib_LPTMR_ClockStop
    940           * Description: -
    941           * Parameters: -
    942           * Return: -
    943           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    944          void PWRLib_LPTMR_ClockStop
    945          (
    946            void
    947          )
    948          {
   \                     PWRLib_LPTMR_ClockStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    949            uint32_t irqMaskRegister;
    950            irqMaskRegister = IntDisableAll();
   \   00000002   0x.... 0x....      BL       IntDisableAll
   \   00000006   0x0004             MOVS     R4,R0
    951            
    952            /* LPTMR is still running */
    953            if(LPTMR0_CSR & LPTMR_CSR_TEN_MASK)
   \   00000008   0x....             LDR.N    R0,??DataTable29_12  ;; 0x40040000
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x07C0             LSLS     R0,R0,#+31
   \   0000000E   0xD512             BPL.N    ??PWRLib_LPTMR_ClockStop_0
    954            {
    955              /* timer compare flag is set */
    956              if(LPTMR0_CSR & LPTMR_CSR_TCF_MASK)
   \   00000010   0x....             LDR.N    R0,??DataTable29_12  ;; 0x40040000
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x0600             LSLS     R0,R0,#+24
   \   00000016   0xD503             BPL.N    ??PWRLib_LPTMR_ClockStop_1
    957              {
    958                mPWRLib_RTIRemainingTicks = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x....             LDR.N    R1,??DataTable29_14
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   \   0000001E   0xE00A             B.N      ??PWRLib_LPTMR_ClockStop_0
    959              }
    960              else
    961              {
    962                LPTMR0_CNR = LPTMR0_CNR;
   \                     ??PWRLib_LPTMR_ClockStop_1: (+1)
   \   00000020   0x....             LDR.N    R0,??DataTable29_16  ;; 0x4004000c
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x....             LDR.N    R1,??DataTable29_16  ;; 0x4004000c
   \   00000026   0x6008             STR      R0,[R1, #+0]
    963                mPWRLib_RTIRemainingTicks = mPWRLib_RTIRemainingTicks - LPTMR0_CNR;
   \   00000028   0x....             LDR.N    R0,??DataTable29_14
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x....             LDR.N    R1,??DataTable29_16  ;; 0x4004000c
   \   0000002E   0x6809             LDR      R1,[R1, #+0]
   \   00000030   0x1A40             SUBS     R0,R0,R1
   \   00000032   0x....             LDR.N    R1,??DataTable29_14
   \   00000034   0x6008             STR      R0,[R1, #+0]
    964              }
    965            }
    966            /* Stop LPTMR */
    967            LPTMR0_CSR &= ~(LPTMR_CSR_TEN_MASK);
   \                     ??PWRLib_LPTMR_ClockStop_0: (+1)
   \   00000036   0x....             LDR.N    R0,??DataTable29_12  ;; 0x40040000
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x0840             LSRS     R0,R0,#+1
   \   0000003C   0x0040             LSLS     R0,R0,#+1
   \   0000003E   0x....             LDR.N    R1,??DataTable29_12  ;; 0x40040000
   \   00000040   0x6008             STR      R0,[R1, #+0]
    968            
    969            IntRestoreAll(irqMaskRegister);
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       IntRestoreAll
    970          }
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
    971          
    972          /*---------------------------------------------------------------------------
    973           * Name: PWRLib_RTC_Init
    974           * Description: -
    975           * Parameters: -
    976           * Return: -
    977           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    978          void PWRLib_RTC_Init
    979          (
    980           void
    981          )
    982          {
   \                     PWRLib_RTC_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    983            uint32_t irqMaskRegister;
    984            
    985            irqMaskRegister = IntDisableAll();
   \   00000002   0x.... 0x....      BL       IntDisableAll
   \   00000006   0x0004             MOVS     R4,R0
    986            
    987            /* Turn on clock to RTC module */
    988            SIM_SCGC6 |= SIM_SCGC6_RTC_MASK;
   \   00000008   0x....             LDR.N    R0,??DataTable29_17  ;; 0x4004803c
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \   00000010   0x....             LDR.N    R1,??DataTable29_17  ;; 0x4004803c
   \   00000012   0x6008             STR      R0,[R1, #+0]
    989            /* Reset RTC register */
    990            RTC_CR |= RTC_CR_SWR_MASK;
   \   00000014   0x....             LDR.N    R0,??DataTable29_18  ;; 0x4003d010
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000001C   0x....             LDR.N    R1,??DataTable29_18  ;; 0x4003d010
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    991            RTC_CR &= ~(RTC_CR_SWR_MASK);
   \   00000020   0x....             LDR.N    R0,??DataTable29_18  ;; 0x4003d010
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x0840             LSRS     R0,R0,#+1
   \   00000026   0x0040             LSLS     R0,R0,#+1
   \   00000028   0x....             LDR.N    R1,??DataTable29_18  ;; 0x4003d010
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    992            /* Disable RTC */
    993            RTC_SR &=  ~(RTC_SR_TCE_MASK);
   \   0000002C   0x....             LDR.N    R0,??DataTable29_19  ;; 0x4003d014
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF030 0x0010      BICS     R0,R0,#0x10
   \   00000034   0x....             LDR.N    R1,??DataTable29_19  ;; 0x4003d014
   \   00000036   0x6008             STR      R0,[R1, #+0]
    994            /* Allow non-supervisor mode access*/
    995            RTC_CR |= RTC_CR_SUP_MASK;
   \   00000038   0x....             LDR.N    R0,??DataTable29_18  ;; 0x4003d010
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000040   0x....             LDR.N    R1,??DataTable29_18  ;; 0x4003d010
   \   00000042   0x6008             STR      R0,[R1, #+0]
    996            /* Clear all pending interrupts */
    997            RTC_TAR = 0;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x....             LDR.N    R1,??DataTable29_20  ;; 0x4003d008
   \   00000048   0x6008             STR      R0,[R1, #+0]
    998            RTC_TSR = 0;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x....             LDR.N    R1,??DataTable29_21  ;; 0x4003d000
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    999            /* Disable all RTC interrupts */
   1000            RTC_IER &= ~(RTC_IER_TAIE_MASK |
   1001                         RTC_IER_TSIE_MASK |
   1002                         RTC_IER_TOIE_MASK |
   1003                         RTC_IER_TIIE_SHIFT);
   \   00000050   0x....             LDR.N    R0,??DataTable29_22  ;; 0x4003d01c
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0xF030 0x0016      BICS     R0,R0,#0x16
   \   00000058   0x....             LDR.N    R1,??DataTable29_22  ;; 0x4003d01c
   \   0000005A   0x6008             STR      R0,[R1, #+0]
   1004            /* Enable 32 KHz oscillator */
   1005            RTC_CR |= RTC_CR_OSCE_MASK;
   \   0000005C   0x....             LDR.N    R0,??DataTable29_18  ;; 0x4003d010
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000064   0x....             LDR.N    R1,??DataTable29_18  ;; 0x4003d010
   \   00000066   0x6008             STR      R0,[R1, #+0]
   1006            
   1007            mPWRLib_RTC_IsOscStarted = FALSE;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x....             LDR.N    R1,??DataTable29_23
   \   0000006C   0x7008             STRB     R0,[R1, #+0]
   1008          #if gTMR_Enabled_d
   1009            /* Allocate a platform timer */
   1010            mPWRLib_RTC_OscInitTmrID = TMR_AllocateTimer();	
   \   0000006E   0x.... 0x....      BL       TMR_AllocateTimer
   \   00000072   0x....             LDR.N    R1,??DataTable29_24
   \   00000074   0x7008             STRB     R0,[R1, #+0]
   1011            
   1012            if(gTmrInvalidTimerID_c != mPWRLib_RTC_OscInitTmrID)
   \   00000076   0x....             LDR.N    R0,??DataTable29_24
   \   00000078   0x7800             LDRB     R0,[R0, #+0]
   \   0000007A   0x28FF             CMP      R0,#+255
   \   0000007C   0xD008             BEQ.N    ??PWRLib_RTC_Init_0
   1013            {	
   1014              TMR_StartTimer(mPWRLib_RTC_OscInitTmrID, gTmrSingleShotTimer_c, 1000, PWRLib_RTC_OscInitCallback);
   \   0000007E   0x.... 0x....      ADR.W    R3,PWRLib_RTC_OscInitCallback
   \   00000082   0xF44F 0x727A      MOV      R2,#+1000
   \   00000086   0x2101             MOVS     R1,#+1
   \   00000088   0x....             LDR.N    R0,??DataTable29_24
   \   0000008A   0x7800             LDRB     R0,[R0, #+0]
   \   0000008C   0x.... 0x....      BL       TMR_StartTimer
   1015            }	
   1016          //  else
   1017          #else
   1018            {
   1019              /* Wait the oscilator startup time */
   1020              PWRLib_DelayMs(cRTC_OSC_STARTUP_TIME);
   1021              mPWRLib_RTC_IsOscStarted = TRUE;
   1022            }
   1023          #endif
   1024              
   1025            IntRestoreAll(irqMaskRegister);
   \                     ??PWRLib_RTC_Init_0: (+1)
   \   00000090   0x0020             MOVS     R0,R4
   \   00000092   0x.... 0x....      BL       IntRestoreAll
   1026          }
   \   00000096   0xBD10             POP      {R4,PC}          ;; return
   1027          
   1028          /*---------------------------------------------------------------------------
   1029           * Name: PWRLib_RTC_IsOscStarted
   1030           * Description: -
   1031           * Parameters: -
   1032           * Return: -
   1033           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1034          bool_t PWRLib_RTC_IsOscStarted
   1035          (
   1036           void
   1037          )
   1038          {
   \                     PWRLib_RTC_IsOscStarted: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1039            uint32_t irqMaskRegister;
   1040            bool_t isOscStarted = FALSE;
   \   00000002   0x2500             MOVS     R5,#+0
   1041            
   1042            irqMaskRegister = IntDisableAll();
   \   00000004   0x.... 0x....      BL       IntDisableAll
   \   00000008   0x0004             MOVS     R4,R0
   1043            
   1044            isOscStarted = mPWRLib_RTC_IsOscStarted;
   \   0000000A   0x....             LDR.N    R0,??DataTable29_23
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x0005             MOVS     R5,R0
   1045            
   1046            IntRestoreAll(irqMaskRegister);
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       IntRestoreAll
   1047            
   1048            return isOscStarted;
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1049          }
   1050          
   1051          /*---------------------------------------------------------------------------
   1052           * Name: PWRLib_RTC_ClockStart
   1053           * Description: -
   1054           * Parameters: -
   1055           * Return: -
   1056           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1057          void PWRLib_RTC_ClockStart
   1058          (
   1059            uint32_t Ticks
   1060          )
   1061          {
   \                     PWRLib_RTC_ClockStart: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1062            uint32_t irqMaskRegister;
   1063            
   1064            irqMaskRegister = IntDisableAll();
   \   00000004   0x.... 0x....      BL       IntDisableAll
   \   00000008   0x0005             MOVS     R5,R0
   1065          
   1066            /* Disable RTC */
   1067            RTC_SR &=  ~(RTC_SR_TCE_MASK);
   \   0000000A   0x....             LDR.N    R0,??DataTable29_19  ;; 0x4003d014
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF030 0x0010      BICS     R0,R0,#0x10
   \   00000012   0x....             LDR.N    R1,??DataTable29_19  ;; 0x4003d014
   \   00000014   0x6008             STR      R0,[R1, #+0]
   1068            
   1069            /* Set compare value and clear alaram interrupt*/
   1070            if(Ticks != 0)
   \   00000016   0x2C00             CMP      R4,#+0
   \   00000018   0xD003             BEQ.N    ??PWRLib_RTC_ClockStart_0
   1071            {
   1072              RTC_TAR = Ticks - 1;
   \   0000001A   0x1E60             SUBS     R0,R4,#+1
   \   0000001C   0x....             LDR.N    R1,??DataTable29_20  ;; 0x4003d008
   \   0000001E   0x6008             STR      R0,[R1, #+0]
   \   00000020   0xE001             B.N      ??PWRLib_RTC_ClockStart_1
   1073            }
   1074            else
   1075            {
   1076              RTC_TAR = Ticks;
   \                     ??PWRLib_RTC_ClockStart_0: (+1)
   \   00000022   0x....             LDR.N    R0,??DataTable29_20  ;; 0x4003d008
   \   00000024   0x6004             STR      R4,[R0, #+0]
   1077            }
   1078            
   1079            RTC_TSR = 0;
   \                     ??PWRLib_RTC_ClockStart_1: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x....             LDR.N    R1,??DataTable29_21  ;; 0x4003d000
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   1080            
   1081            /* Enable alarm interrupt*/
   1082            RTC_IER |= RTC_IER_TAIE_MASK;
   \   0000002C   0x....             LDR.N    R0,??DataTable29_22  ;; 0x4003d01c
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000034   0x....             LDR.N    R1,??DataTable29_22  ;; 0x4003d01c
   \   00000036   0x6008             STR      R0,[R1, #+0]
   1083            /* Enable RTC */
   1084            RTC_SR |=  RTC_SR_TCE_MASK;
   \   00000038   0x....             LDR.N    R0,??DataTable29_19  ;; 0x4003d014
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000040   0x....             LDR.N    R1,??DataTable29_19  ;; 0x4003d014
   \   00000042   0x6008             STR      R0,[R1, #+0]
   1085            
   1086            IntRestoreAll(irqMaskRegister);
   \   00000044   0x0028             MOVS     R0,R5
   \   00000046   0x.... 0x....      BL       IntRestoreAll
   1087          }
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1088          
   1089          /*---------------------------------------------------------------------------
   1090           * Name: PWRLib_RTC_ClockCheck
   1091           * Description: -
   1092           * Parameters: -
   1093           * Return: -
   1094           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1095          uint32_t PWRLib_RTC_ClockCheck
   1096          (
   1097            void
   1098          )
   1099          {
   \                     PWRLib_RTC_ClockCheck: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1100            uint32_t irqMaskRegister;
   1101            uint32_t remTicks;
   1102            
   1103            irqMaskRegister = IntDisableAll();
   \   00000002   0x.... 0x....      BL       IntDisableAll
   \   00000006   0x0004             MOVS     R4,R0
   1104            
   1105            remTicks = mPWRLib_RTIRemainingTicks;
   \   00000008   0x....             LDR.N    R0,??DataTable29_14
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0005             MOVS     R5,R0
   1106            
   1107            /* RTC is still running */
   1108            if(RTC_SR & RTC_SR_TCE_MASK)
   \   0000000E   0x....             LDR.N    R0,??DataTable29_19  ;; 0x4003d014
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x06C0             LSLS     R0,R0,#+27
   \   00000014   0xD50C             BPL.N    ??PWRLib_RTC_ClockCheck_0
   1109            {
   1110              /* Time Alarm Flag */
   1111              if(RTC_SR & RTC_SR_TAF_MASK)
   \   00000016   0x....             LDR.N    R0,??DataTable29_19  ;; 0x4003d014
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x0740             LSLS     R0,R0,#+29
   \   0000001C   0xD502             BPL.N    ??PWRLib_RTC_ClockCheck_1
   1112              {
   1113                remTicks = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x0005             MOVS     R5,R0
   \   00000022   0xE005             B.N      ??PWRLib_RTC_ClockCheck_0
   1114              }
   1115              else
   1116              {
   1117                remTicks = mPWRLib_RTIRemainingTicks - RTC_TSR;
   \                     ??PWRLib_RTC_ClockCheck_1: (+1)
   \   00000024   0x....             LDR.N    R0,??DataTable29_14
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x....             LDR.N    R1,??DataTable29_21  ;; 0x4003d000
   \   0000002A   0x6809             LDR      R1,[R1, #+0]
   \   0000002C   0x1A40             SUBS     R0,R0,R1
   \   0000002E   0x0005             MOVS     R5,R0
   1118              }
   1119            }
   1120            
   1121            IntRestoreAll(irqMaskRegister);
   \                     ??PWRLib_RTC_ClockCheck_0: (+1)
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       IntRestoreAll
   1122            return remTicks;
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1123          }
   1124          
   1125          /*---------------------------------------------------------------------------
   1126           * Name: PWRLib_RTC_ResetTicks
   1127           * Description: -
   1128           * Parameters: -
   1129           * Return: -
   1130           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1131          void PWRLib_RTC_ResetTicks
   1132          (
   1133            void
   1134          )
   1135          {
   \                     PWRLib_RTC_ResetTicks: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1136            uint32_t irqMaskRegister;
   1137            irqMaskRegister = IntDisableAll();
   \   00000002   0x.... 0x....      BL       IntDisableAll
   \   00000006   0x0004             MOVS     R4,R0
   1138            mPWRLib_RTIRemainingTicks = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x....             LDR.N    R1,??DataTable29_14
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   1139            IntRestoreAll(irqMaskRegister);
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       IntRestoreAll
   1140          }
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
   1141          
   1142          /*---------------------------------------------------------------------------
   1143           * Name: PWRLib_RTC_ClockStop
   1144           * Description: -
   1145           * Parameters: -
   1146           * Return: -
   1147           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1148          void PWRLib_RTC_ClockStop
   1149          (
   1150            void
   1151          )
   1152          {
   \                     PWRLib_RTC_ClockStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1153            uint32_t irqMaskRegister;
   1154            irqMaskRegister = IntDisableAll();
   \   00000002   0x.... 0x....      BL       IntDisableAll
   \   00000006   0x0004             MOVS     R4,R0
   1155            
   1156            /* RTC is still running */
   1157            if(RTC_SR & RTC_SR_TCE_MASK)
   \   00000008   0x....             LDR.N    R0,??DataTable29_19  ;; 0x4003d014
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x06C0             LSLS     R0,R0,#+27
   \   0000000E   0xD50E             BPL.N    ??PWRLib_RTC_ClockStop_0
   1158            {
   1159              /* Time Alarm Flag */
   1160              if(RTC_SR & RTC_SR_TAF_MASK)
   \   00000010   0x....             LDR.N    R0,??DataTable29_19  ;; 0x4003d014
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x0740             LSLS     R0,R0,#+29
   \   00000016   0xD503             BPL.N    ??PWRLib_RTC_ClockStop_1
   1161              {
   1162                mPWRLib_RTIRemainingTicks = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x....             LDR.N    R1,??DataTable29_14
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   \   0000001E   0xE006             B.N      ??PWRLib_RTC_ClockStop_0
   1163              }
   1164              else
   1165              {
   1166                mPWRLib_RTIRemainingTicks = mPWRLib_RTIRemainingTicks - RTC_TSR;
   \                     ??PWRLib_RTC_ClockStop_1: (+1)
   \   00000020   0x....             LDR.N    R0,??DataTable29_14
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x....             LDR.N    R1,??DataTable29_21  ;; 0x4003d000
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0x1A40             SUBS     R0,R0,R1
   \   0000002A   0x....             LDR.N    R1,??DataTable29_14
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   1167              }
   1168            }
   1169            /* Stop RTC */
   1170            RTC_SR &=  ~(RTC_SR_TCE_MASK);
   \                     ??PWRLib_RTC_ClockStop_0: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable29_19  ;; 0x4003d014
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF030 0x0010      BICS     R0,R0,#0x10
   \   00000036   0x....             LDR.N    R1,??DataTable29_19  ;; 0x4003d014
   \   00000038   0x6008             STR      R0,[R1, #+0]
   1171            /* Disable alarm interrupt*/
   1172            RTC_IER &= ~(RTC_IER_TAIE_MASK);
   \   0000003A   0x....             LDR.N    R0,??DataTable29_22  ;; 0x4003d01c
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000042   0x....             LDR.N    R1,??DataTable29_22  ;; 0x4003d01c
   \   00000044   0x6008             STR      R0,[R1, #+0]
   1173            /* Clear all pending interrupts */
   1174            RTC_TAR = 0;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x....             LDR.N    R1,??DataTable29_20  ;; 0x4003d008
   \   0000004A   0x6008             STR      R0,[R1, #+0]
   1175            RTC_TSR = 0;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x....             LDR.N    R1,??DataTable29_21  ;; 0x4003d000
   \   00000050   0x6008             STR      R0,[R1, #+0]
   1176            
   1177            IntRestoreAll(irqMaskRegister);
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       IntRestoreAll
   1178          }
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
   1179          
   1180          /******************************************************************************
   1181           * Name: PWRLib_RTC_OscInitCallback
   1182           * Description:
   1183           *
   1184           * Parameter(s): -
   1185           * Return: -
   1186           ******************************************************************************/
   1187          #if gTMR_Enabled_d

   \                                 In section .text, align 4, keep-with-next
   1188          static void PWRLib_RTC_OscInitCallback
   1189          (
   1190           tmrTimerID_t tmrID
   1191          )
   1192          {
   \                     PWRLib_RTC_OscInitCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1193            if(tmrID == mPWRLib_RTC_OscInitTmrID)
   \   00000004   0x....             LDR.N    R0,??DataTable29_24
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD106             BNE.N    ??PWRLib_RTC_OscInitCallback_0
   1194            {
   1195              /* RTC OSC is started */
   1196              mPWRLib_RTC_IsOscStarted = TRUE;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x....             LDR.N    R1,??DataTable29_23
   \   00000012   0x7008             STRB     R0,[R1, #+0]
   1197              
   1198              /* free timer */
   1199              TMR_FreeTimer(tmrID);			
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x.... 0x....      BL       TMR_FreeTimer
   1200            }		
   1201          }
   \                     ??PWRLib_RTC_OscInitCallback_0: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
   1202          #endif
   1203          

   \                                 In section .text, align 2, keep-with-next
   1204          void PWRLib_DelayMs
   1205          (
   1206            uint16_t val
   1207          )
   1208          {
   1209              /* Turn on clock to LPTMR module */
   1210              SIM_SCGC5 |= SIM_SCGC5_LPTIMER_MASK;
   \                     PWRLib_DelayMs: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable29_11  ;; 0x40048038
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000008   0x....             LDR.N    R2,??DataTable29_11  ;; 0x40048038
   \   0000000A   0x6011             STR      R1,[R2, #+0]
   1211              
   1212                /* Disable LPTMR */
   1213              LPTMR0_CSR &= ~(LPTMR_CSR_TEN_MASK);
   \   0000000C   0x....             LDR.N    R1,??DataTable29_12  ;; 0x40040000
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   \   00000010   0x0849             LSRS     R1,R1,#+1
   \   00000012   0x0049             LSLS     R1,R1,#+1
   \   00000014   0x....             LDR.N    R2,??DataTable29_12  ;; 0x40040000
   \   00000016   0x6011             STR      R1,[R2, #+0]
   1214              
   1215              /* Set compare value */
   1216              LPTMR0_CMR = val;
   \   00000018   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001A   0x....             LDR.N    R1,??DataTable29_13  ;; 0x40040008
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   1217              
   1218              /* Use 1Khz LPO clock and bypass prescaler */
   1219              LPTMR0_PSR = LPTMR_PSR_PCS(1)|LPTMR_PSR_PBYP_MASK;
   \   0000001E   0x2105             MOVS     R1,#+5
   \   00000020   0x....             LDR.N    R2,??DataTable29_15  ;; 0x40040004
   \   00000022   0x6011             STR      R1,[R2, #+0]
   1220              
   1221              /* Start counting */
   1222              LPTMR0_CSR |= LPTMR_CSR_TEN_MASK;
   \   00000024   0x....             LDR.N    R1,??DataTable29_12  ;; 0x40040000
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   0000002C   0x....             LDR.N    R2,??DataTable29_12  ;; 0x40040000
   \   0000002E   0x6011             STR      R1,[R2, #+0]
   1223              
   1224              /* Wait for counter to reach compare value */
   1225              while (!(LPTMR0_CSR & LPTMR_CSR_TCF_MASK)) {}
   \                     ??PWRLib_DelayMs_0: (+1)
   \   00000030   0x....             LDR.N    R1,??DataTable29_12  ;; 0x40040000
   \   00000032   0x6809             LDR      R1,[R1, #+0]
   \   00000034   0x0609             LSLS     R1,R1,#+24
   \   00000036   0xD5FB             BPL.N    ??PWRLib_DelayMs_0
   1226              
   1227              /* Clear Timer Compare Flag */
   1228              LPTMR0_CSR &= ~LPTMR_CSR_TEN_MASK;
   \   00000038   0x....             LDR.N    R1,??DataTable29_12  ;; 0x40040000
   \   0000003A   0x6809             LDR      R1,[R1, #+0]
   \   0000003C   0x0849             LSRS     R1,R1,#+1
   \   0000003E   0x0049             LSLS     R1,R1,#+1
   \   00000040   0x....             LDR.N    R2,??DataTable29_12  ;; 0x40040000
   \   00000042   0x6011             STR      R1,[R2, #+0]
   1229              
   1230              /* Turn off clock to LPTMR module */
   1231              SIM_SCGC5 &= ~SIM_SCGC5_LPTIMER_MASK;	
   \   00000044   0x....             LDR.N    R1,??DataTable29_11  ;; 0x40048038
   \   00000046   0x6809             LDR      R1,[R1, #+0]
   \   00000048   0x0849             LSRS     R1,R1,#+1
   \   0000004A   0x0049             LSLS     R1,R1,#+1
   \   0000004C   0x....             LDR.N    R2,??DataTable29_11  ;; 0x40048038
   \   0000004E   0x6011             STR      R1,[R2, #+0]
   1232          }
   \   00000050   0x4770             BX       LR               ;; return
   1233          
   1234          #if (cPWR_UsePowerModuleStandAlone == 0)
   1235          
   1236          /******************************************************************************
   1237           * Name: PWRLib_GetMacStateReq
   1238           * Description: Get status from MAC. Functions just as Asp_GetMacStateReq().
   1239           *
   1240           * Parameter(s): - none
   1241           * Return: - gAspMacStateIdle_c     : MAC ready for Sleep or DeepSleep
   1242           *           gAspMacStateBusy_c     : Don't sleep
   1243           *           gAspMacStateNotEmpty_c : MAC allows Wait
   1244           ******************************************************************************/
   1245          uint8_t PWRLib_GetMacStateReq
   1246          (
   1247            void
   1248          )
   1249          {
   1250            return Asp_GetMacStateReq();
   1251          }
   1252          
   1253          #endif /* (cPWR_UsePowerModuleStandAlone == 0) */
   1254          
   1255          #endif /* #if (cPWR_UsePowerDownMode==1) */
   1256          
   1257          /*---------------------------------------------------------------------------
   1258           * Name: PWRLib_LLWU_Isr
   1259           * Description: -
   1260           * Parameters: -
   1261           * Return: -
   1262           *---------------------------------------------------------------------------*/
   1263          #if defined(__IAR_SYSTEMS_ICC__)
   1264          #pragma location = ".isr_handler"
   1265          #endif 

   \                                 In section .isr_handler, align 2, keep-with-next
   1266          void PWRLib_LLWU_Isr
   1267          (
   1268            void
   1269          )
   1270          {
   1271          
   1272          #if (MCU_MK60N512VMD100 == 1)
   1273            SIM_SCGC4 |= SIM_SCGC4_LLWU_MASK;
   1274          #elif (MCU_MK60D10 == 1)
   1275            SIM_SCGC4 |= (uint32_t) (1 << 28);
   1276          #endif
   1277          
   1278          #if  (MCU_MK21DN512 == 1) || (MCU_MK21DX256 == 1)
   1279            if (LLWU_F2 & LLWU_F2_WUF8_MASK)
   \                     PWRLib_LLWU_Isr: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable62  ;; 0x4007c006
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x07C0             LSLS     R0,R0,#+31
   \   00000006   0xD511             BPL.N    ??PWRLib_LLWU_Isr_0
   1280            {
   1281              PORTC_PCR4 |= PORT_PCR_ISF_MASK; //PTC4 
   \   00000008   0x....             LDR.N    R0,??DataTable62_1  ;; 0x4004b010
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \   00000010   0x....             LDR.N    R1,??DataTable62_1  ;; 0x4004b010
   \   00000012   0x6008             STR      R0,[R1, #+0]
   1282              LLWU_F2 |= LLWU_F2_WUF8_MASK;   // write one to clear the flag
   \   00000014   0x....             LDR.N    R0,??DataTable62  ;; 0x4007c006
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000001C   0x....             LDR.N    R1,??DataTable62  ;; 0x4007c006
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
   1283                  PWRLib_MCU_WakeupReason.Bits.FromKeyBoard = 1;
   \   00000020   0x....             LDR.N    R0,??DataTable62_2
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000028   0x....             LDR.N    R1,??DataTable62_2
   \   0000002A   0x7008             STRB     R0,[R1, #+0]
   1284            }
   1285            if (LLWU_F2 & LLWU_F2_WUF9_MASK)
   \                     ??PWRLib_LLWU_Isr_0: (+1)
   \   0000002C   0x....             LDR.N    R0,??DataTable62  ;; 0x4007c006
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x0780             LSLS     R0,R0,#+30
   \   00000032   0xD511             BPL.N    ??PWRLib_LLWU_Isr_1
   1286            {
   1287              PORTC_PCR5 |= PORT_PCR_ISF_MASK;
   \   00000034   0x....             LDR.N    R0,??DataTable62_3  ;; 0x4004b014
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \   0000003C   0x....             LDR.N    R1,??DataTable62_3  ;; 0x4004b014
   \   0000003E   0x6008             STR      R0,[R1, #+0]
   1288              LLWU_F2 |= LLWU_F2_WUF9_MASK;   // write one to clear the flag
   \   00000040   0x....             LDR.N    R0,??DataTable62  ;; 0x4007c006
   \   00000042   0x7800             LDRB     R0,[R0, #+0]
   \   00000044   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000048   0x....             LDR.N    R1,??DataTable62  ;; 0x4007c006
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
   1289          	PWRLib_MCU_WakeupReason.Bits.FromKeyBoard = 1;
   \   0000004C   0x....             LDR.N    R0,??DataTable62_2
   \   0000004E   0x7800             LDRB     R0,[R0, #+0]
   \   00000050   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000054   0x....             LDR.N    R1,??DataTable62_2
   \   00000056   0x7008             STRB     R0,[R1, #+0]
   1290            }
   1291            if (LLWU_F2 & LLWU_F2_WUF10_MASK)
   \                     ??PWRLib_LLWU_Isr_1: (+1)
   \   00000058   0x....             LDR.N    R0,??DataTable62  ;; 0x4007c006
   \   0000005A   0x7800             LDRB     R0,[R0, #+0]
   \   0000005C   0x0740             LSLS     R0,R0,#+29
   \   0000005E   0xD511             BPL.N    ??PWRLib_LLWU_Isr_2
   1292            {
   1293              PORTC_PCR6 |= PORT_PCR_ISF_MASK;
   \   00000060   0x....             LDR.N    R0,??DataTable62_4  ;; 0x4004b018
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \   00000068   0x....             LDR.N    R1,??DataTable62_4  ;; 0x4004b018
   \   0000006A   0x6008             STR      R0,[R1, #+0]
   1294              LLWU_F2 |= LLWU_F2_WUF10_MASK;   // write one to clear the flag
   \   0000006C   0x....             LDR.N    R0,??DataTable62  ;; 0x4007c006
   \   0000006E   0x7800             LDRB     R0,[R0, #+0]
   \   00000070   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000074   0x....             LDR.N    R1,??DataTable62  ;; 0x4007c006
   \   00000076   0x7008             STRB     R0,[R1, #+0]
   1295          	PWRLib_MCU_WakeupReason.Bits.FromKeyBoard = 1;
   \   00000078   0x....             LDR.N    R0,??DataTable62_2
   \   0000007A   0x7800             LDRB     R0,[R0, #+0]
   \   0000007C   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000080   0x....             LDR.N    R1,??DataTable62_2
   \   00000082   0x7008             STRB     R0,[R1, #+0]
   1296            }
   1297          #endif
   1298            
   1299            /* Clear external pins wakeup interrupts */
   1300            LLWU_F1 = LLWU_F1;
   \                     ??PWRLib_LLWU_Isr_2: (+1)
   \   00000084   0x....             LDR.N    R0,??DataTable62_5  ;; 0x4007c005
   \   00000086   0x7800             LDRB     R0,[R0, #+0]
   \   00000088   0x....             LDR.N    R1,??DataTable62_5  ;; 0x4007c005
   \   0000008A   0x7008             STRB     R0,[R1, #+0]
   1301            LLWU_F2 = LLWU_F2;
   \   0000008C   0x....             LDR.N    R0,??DataTable62  ;; 0x4007c006
   \   0000008E   0x7800             LDRB     R0,[R0, #+0]
   \   00000090   0x....             LDR.N    R1,??DataTable62  ;; 0x4007c006
   \   00000092   0x7008             STRB     R0,[R1, #+0]
   1302            
   1303            /* Clear wakeup from error interrupt */
   1304            LLWU_F3 |= LLWU_F3_MWUF7_MASK;
   \   00000094   0x....             LDR.N    R0,??DataTable62_6  ;; 0x4007c007
   \   00000096   0x7800             LDRB     R0,[R0, #+0]
   \   00000098   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000009C   0x....             LDR.N    R1,??DataTable62_6  ;; 0x4007c007
   \   0000009E   0x7008             STRB     R0,[R1, #+0]
   1305          
   1306          #if (MCU_MK60D10 == 1) || (MCU_MK20D5 == 1) || (MCU_MK60N512VMD100 == 1)
   1307            /* TSI is wakeup source */
   1308            if(LLWU_F3 & LLWU_F3_MWUF4_MASK)
   1309            {
   1310              /* Clear OUT OF RANGE, END OF SCAN flags */
   1311              //gTSI_GENCS_REG |= ( gTSI_OUT_OF_RANGE_MASK_c | gTSI_EOS_FLAG_MASK_c );
   1312              TSI0_GENCS |= (TSI_GENCS_OUTRGF_MASK | TSI_GENCS_EOSF_MASK); 
   1313              
   1314              /* Clear touch sensing error flags */
   1315          #if (MCU_MK60N512VMD100 == 1)
   1316              TSI0_STATUS = 0xFFFFFFFF;
   1317          #elif (MCU_MK60D10 == 1)
   1318                     
   1319          #endif
   1320              PWRLib_MCU_WakeupReason.Bits.FromKeyBoard = 1;
   1321            }
   1322          #endif
   1323            
   1324            /* LPTMR is wakeup source */
   1325            if(LLWU_F3 & LLWU_F3_MWUF0_MASK)
   \   000000A0   0x....             LDR.N    R0,??DataTable62_6  ;; 0x4007c007
   \   000000A2   0x7800             LDRB     R0,[R0, #+0]
   \   000000A4   0x07C0             LSLS     R0,R0,#+31
   \   000000A6   0xD50B             BPL.N    ??PWRLib_LLWU_Isr_3
   1326            {
   1327              /* Clear LPTMR interrupt */
   1328              LPTMR0_CSR |= LPTMR_CSR_TCF_MASK;
   \   000000A8   0x....             LDR.N    R0,??DataTable62_7  ;; 0x40040000
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000B0   0x....             LDR.N    R1,??DataTable62_7  ;; 0x40040000
   \   000000B2   0x6008             STR      R0,[R1, #+0]
   1329              PWRLib_MCU_WakeupReason.Bits.FromLPTMR = 1;
   \   000000B4   0x....             LDR.N    R0,??DataTable62_2
   \   000000B6   0x7800             LDRB     R0,[R0, #+0]
   \   000000B8   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   000000BC   0x....             LDR.N    R1,??DataTable62_2
   \   000000BE   0x7008             STRB     R0,[R1, #+0]
   1330            }
   1331            
   1332            /* RTC alarm is wakeup source */
   1333            if(LLWU_F3 & LLWU_F3_MWUF5_MASK)
   \                     ??PWRLib_LLWU_Isr_3: (+1)
   \   000000C0   0x....             LDR.N    R0,??DataTable62_6  ;; 0x4007c007
   \   000000C2   0x7800             LDRB     R0,[R0, #+0]
   \   000000C4   0x0680             LSLS     R0,R0,#+26
   \   000000C6   0xD517             BPL.N    ??PWRLib_LLWU_Isr_4
   1334            {
   1335              /* Stop RTC */
   1336              RTC_SR &=  ~(RTC_SR_TCE_MASK);
   \   000000C8   0x....             LDR.N    R0,??DataTable62_8  ;; 0x4003d014
   \   000000CA   0x6800             LDR      R0,[R0, #+0]
   \   000000CC   0xF030 0x0010      BICS     R0,R0,#0x10
   \   000000D0   0x....             LDR.N    R1,??DataTable62_8  ;; 0x4003d014
   \   000000D2   0x6008             STR      R0,[R1, #+0]
   1337              /* Disable alarm interrupt*/
   1338              RTC_IER &= ~(RTC_IER_TAIE_MASK);
   \   000000D4   0x....             LDR.N    R0,??DataTable62_9  ;; 0x4003d01c
   \   000000D6   0x6800             LDR      R0,[R0, #+0]
   \   000000D8   0xF030 0x0004      BICS     R0,R0,#0x4
   \   000000DC   0x....             LDR.N    R1,??DataTable62_9  ;; 0x4003d01c
   \   000000DE   0x6008             STR      R0,[R1, #+0]
   1339              /* Clear all pending interrupts */
   1340              RTC_TAR = 0;
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x....             LDR.N    R1,??DataTable62_10  ;; 0x4003d008
   \   000000E4   0x6008             STR      R0,[R1, #+0]
   1341              RTC_TSR = 0;
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0x....             LDR.N    R1,??DataTable62_11  ;; 0x4003d000
   \   000000EA   0x6008             STR      R0,[R1, #+0]
   1342              PWRLib_MCU_WakeupReason.Bits.FromRTC = 1;
   \   000000EC   0x....             LDR.N    R0,??DataTable62_2
   \   000000EE   0x7800             LDRB     R0,[R0, #+0]
   \   000000F0   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   000000F4   0x....             LDR.N    R1,??DataTable62_2
   \   000000F6   0x7008             STRB     R0,[R1, #+0]
   1343            }
   1344            
   1345          }
   \                     ??PWRLib_LLWU_Isr_4: (+1)
   \   000000F8   0x4770             BX       LR               ;; return
   1346          
   1347          /*---------------------------------------------------------------------------
   1348           * Name: PWRLib_LPTMR_Isr
   1349           * Description: -
   1350           * Parameters: -
   1351           * Return: -
   1352           *---------------------------------------------------------------------------*/
   1353          #if defined(__IAR_SYSTEMS_ICC__)
   1354          #pragma location = ".isr_handler"
   1355          #endif

   \                                 In section .isr_handler, align 2, keep-with-next
   1356           void PWRLib_LPTMR_Isr
   1357          (
   1358            void
   1359          )
   1360          {
   1361            /* Stop LPTMR */
   1362            LPTMR0_CSR &= ~(LPTMR_CSR_TEN_MASK);
   \                     PWRLib_LPTMR_Isr: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable62_7  ;; 0x40040000
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0840             LSRS     R0,R0,#+1
   \   00000006   0x0040             LSLS     R0,R0,#+1
   \   00000008   0x....             LDR.N    R1,??DataTable62_7  ;; 0x40040000
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   1363            /* Clear LPTMR interrupt */
   1364            LPTMR0_CSR |= LPTMR_CSR_TCF_MASK;
   \   0000000C   0x....             LDR.N    R0,??DataTable62_7  ;; 0x40040000
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000014   0x....             LDR.N    R1,??DataTable62_7  ;; 0x40040000
   \   00000016   0x6008             STR      R0,[R1, #+0]
   1365          #if (cPWR_UsePowerDownMode==1)  
   1366            mPWRLib_RTIRemainingTicks = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x....             LDR.N    R1,??DataTable62_12
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   1367          #endif /* #if (cPWR_UsePowerDownMode==1) */
   1368          }
   \   0000001E   0x4770             BX       LR               ;; return
   1369          
   1370          /*---------------------------------------------------------------------------
   1371           * Name: PWRLib_LVD_CollectLevel
   1372           * Description: -
   1373           * Parameters: -
   1374           * Return: -
   1375           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1376          PWRLib_LVD_VoltageLevel_t PWRLib_LVD_CollectLevel
   1377          (
   1378            void
   1379          )
   1380          {
   1381          #if ((cPWR_LVD_Enable == 1) || (cPWR_LVD_Enable == 2))
   1382            
   1383            /* Check low detect voltage 1.6V */
   1384            PMC_LVDSC1 = PMC_LVDSC1_LVDV(0);
   1385            PMC_LVDSC2 = PMC_LVDSC2_LVWV(0);
   1386            PMC_LVDSC1 = PMC_LVDSC1_LVDACK_MASK;
   1387            if(PMC_LVDSC1 & PMC_LVDSC1_LVDF_MASK)
   1388            {
   1389              /* Low detect voltage reached */
   1390              PMC_LVDSC1 = PMC_LVDSC1_LVDACK_MASK;
   1391              return(PWR_LEVEL_CRITICAL);
   1392            }
   1393            
   1394            /* Check low trip voltage 1.8V */
   1395            PMC_LVDSC1 = PMC_LVDSC1_LVDV(0);
   1396            PMC_LVDSC2 = PMC_LVDSC2_LVWV(0);
   1397            PMC_LVDSC2 |= PMC_LVDSC2_LVWACK_MASK;
   1398            if(PMC_LVDSC2 & PMC_LVDSC2_LVWF_MASK)
   1399            {
   1400              /* Low trip voltage reached */
   1401              PMC_LVDSC2 = PMC_LVDSC2_LVWACK_MASK; /* Clear flag (and set low trip voltage) */
   1402              PMC_LVDSC1 = PMC_LVDSC1_LVDV(0); /* Set low trip voltage */
   1403              return(PWR_BELOW_LEVEL_1_8V);
   1404            }
   1405            
   1406            /* Check low trip voltage 1.9V */
   1407            PMC_LVDSC1 = PMC_LVDSC1_LVDV(0);
   1408            PMC_LVDSC2 = PMC_LVDSC2_LVWV(1);
   1409            PMC_LVDSC2 |= PMC_LVDSC2_LVWACK_MASK;
   1410            if(PMC_LVDSC2 & PMC_LVDSC2_LVWF_MASK)
   1411            {
   1412              /* Low trip voltage reached */
   1413              PMC_LVDSC2 = PMC_LVDSC2_LVWACK_MASK; /* Clear flag (and set low trip voltage) */
   1414              PMC_LVDSC1 = PMC_LVDSC1_LVDV(0); /* Set low trip voltage */
   1415              return(PWR_BELOW_LEVEL_1_9V);
   1416            }
   1417            /* Check low trip voltage 2.0V */
   1418            PMC_LVDSC1 = PMC_LVDSC1_LVDV(0);
   1419            PMC_LVDSC2 = PMC_LVDSC2_LVWV(2);
   1420            PMC_LVDSC2 |= PMC_LVDSC2_LVWACK_MASK;
   1421            if(PMC_LVDSC2 & PMC_LVDSC2_LVWF_MASK)
   1422            {
   1423              /* Low trip voltage reached */
   1424              PMC_LVDSC2 = PMC_LVDSC2_LVWACK_MASK; /* Clear flag (and set low trip voltage) */
   1425              PMC_LVDSC1 = PMC_LVDSC1_LVDV(0); /* Set low trip voltage */
   1426              return(PWR_BELOW_LEVEL_2_0V);
   1427            }
   1428            
   1429            /* Check low trip voltage 2.1V */
   1430            PMC_LVDSC1 = PMC_LVDSC1_LVDV(0);
   1431            PMC_LVDSC2 = PMC_LVDSC2_LVWV(3);
   1432            PMC_LVDSC2 |= PMC_LVDSC2_LVWACK_MASK;
   1433            if(PMC_LVDSC2 & PMC_LVDSC2_LVWF_MASK)
   1434            {
   1435              /* Low trip voltage reached */
   1436              PMC_LVDSC2 = PMC_LVDSC2_LVWACK_MASK; /* Clear flag (and set low trip voltage) */
   1437              PMC_LVDSC1 = PMC_LVDSC1_LVDV(0); /* Set low trip voltage */
   1438              return(PWR_BELOW_LEVEL_2_1V);
   1439            }
   1440            
   1441            /* Check low detect voltage (high range) 2.56V */
   1442            PMC_LVDSC1 = PMC_LVDSC1_LVDV(1); /* Set high trip voltage and clear warning flag */
   1443            PMC_LVDSC2 = PMC_LVDSC2_LVWV(0);
   1444            PMC_LVDSC1 |= PMC_LVDSC1_LVDACK_MASK;
   1445            if(PMC_LVDSC1 & PMC_LVDSC1_LVDF_MASK)
   1446            {
   1447              /* Low detect voltage reached */
   1448              PMC_LVDSC1 = PMC_LVDSC1_LVDACK_MASK; /* Set low trip voltage and clear warning flag */
   1449              PMC_LVDSC1 = PMC_LVDSC1_LVDV(0); /* Set low trip voltage */
   1450              return(PWR_BELOW_LEVEL_2_56V);
   1451            }
   1452            
   1453            /* Check high trip voltage 2.7V */
   1454            PMC_LVDSC1 = PMC_LVDSC1_LVDV(1);
   1455            PMC_LVDSC2 = PMC_LVDSC2_LVWV(0);
   1456            PMC_LVDSC2 |= PMC_LVDSC2_LVWACK_MASK;
   1457            if(PMC_LVDSC2 & PMC_LVDSC2_LVWF_MASK)
   1458            {
   1459              /* Low trip voltage reached */
   1460              PMC_LVDSC2 = PMC_LVDSC2_LVWACK_MASK; /* Clear flag (and set low trip voltage) */
   1461              PMC_LVDSC1 = PMC_LVDSC1_LVDV(0); /* Set low trip voltage */
   1462              return(PWR_BELOW_LEVEL_2_7V);
   1463            }
   1464            
   1465            /* Check high trip voltage 2.8V */
   1466            PMC_LVDSC1 = PMC_LVDSC1_LVDV(1);
   1467            PMC_LVDSC2 = PMC_LVDSC2_LVWV(1);
   1468            PMC_LVDSC2 |= PMC_LVDSC2_LVWACK_MASK;
   1469            if(PMC_LVDSC2 & PMC_LVDSC2_LVWF_MASK)
   1470            {
   1471              /* Low trip voltage reached */
   1472              PMC_LVDSC2 = PMC_LVDSC2_LVWACK_MASK; /* Clear flag (and set low trip voltage) */
   1473              PMC_LVDSC1 = PMC_LVDSC1_LVDV(0); /* Set low trip voltage */
   1474              return(PWR_BELOW_LEVEL_2_8V);
   1475            }
   1476            
   1477            /* Check high trip voltage 2.9V */
   1478            PMC_LVDSC1 = PMC_LVDSC1_LVDV(1);
   1479            PMC_LVDSC2 = PMC_LVDSC2_LVWV(2);
   1480            PMC_LVDSC2 |= PMC_LVDSC2_LVWACK_MASK;
   1481            if(PMC_LVDSC2 & PMC_LVDSC2_LVWF_MASK)
   1482            {
   1483              /* Low trip voltage reached */
   1484              PMC_LVDSC2 = PMC_LVDSC2_LVWACK_MASK; /* Clear flag (and set low trip voltage) */
   1485              PMC_LVDSC1 = PMC_LVDSC1_LVDV(0); /* Set low trip voltage */
   1486              return(PWR_BELOW_LEVEL_2_9V);
   1487            }
   1488            
   1489            /* Check high trip voltage 3.0V */
   1490            PMC_LVDSC1 = PMC_LVDSC1_LVDV(1);
   1491            PMC_LVDSC2 = PMC_LVDSC2_LVWV(3);
   1492            PMC_LVDSC2 |= PMC_LVDSC2_LVWACK_MASK;
   1493            if(PMC_LVDSC2 & PMC_LVDSC2_LVWF_MASK)
   1494            {
   1495              /* Low trip voltage reached */
   1496              PMC_LVDSC2 = PMC_LVDSC2_LVWACK_MASK; /* Clear flag (and set low trip voltage) */
   1497              PMC_LVDSC1 = PMC_LVDSC1_LVDV(0); /* Set low trip voltage */
   1498              return(PWR_BELOW_LEVEL_3_0V);
   1499            }
   1500            
   1501            PMC_LVDSC2 = PMC_LVDSC2_LVWV(0);
   1502            PMC_LVDSC1 = PMC_LVDSC1_LVDV(0); /* Set low trip voltage */
   1503          #endif  /* #if ((cPWR_LVD_Enable == 1) || (cPWR_LVD_Enable == 2)) */
   1504          
   1505            /*--- Voltage level is okay > 3.0V */
   1506            return(PWR_ABOVE_LEVEL_3_0V);
   \                     PWRLib_LVD_CollectLevel: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
   1507          }
   1508          
   1509          /******************************************************************************
   1510           * Name: PWRLib_LVD_PollIntervalCallback
   1511           * Description:
   1512           *
   1513           * Parameter(s): -
   1514           * Return: -
   1515           ******************************************************************************/
   1516          #if (cPWR_LVD_Enable == 2)
   1517          static void PWRLib_LVD_PollIntervalCallback
   1518          (
   1519            tmrTimerID_t tmrID
   1520          )
   1521          {
   1522            if(tmrID == PWRLib_LVD_PollIntervalTmrID)
   1523            {
   1524              PWRLib_LVD_SavedLevel = PWRLib_LVD_CollectLevel();
   1525              /* re-start the timer */
   1526              //TMR_StartMinuteTimer(PWRLib_LVD_PollIntervalTmrID, PWRLib_LVD_CollectCounter, PWRLib_LVD_PollIntervalCallback);
   1527              TMR_StartLowPowerTimer(PWRLib_LVD_PollIntervalTmrID, gTmrLowPowerMinuteTimer_c, PWRLib_LVD_CollectCounter, PWRLib_LVD_PollIntervalCallback);
   1528            }
   1529          }
   1530          #endif
   1531          
   1532          /*---------------------------------------------------------------------------
   1533           * Name: PWRLib_RTC_Isr
   1534           * Description: -
   1535           * Parameters: -
   1536           * Return: -
   1537           *---------------------------------------------------------------------------*/
   1538          #if defined(__IAR_SYSTEMS_ICC__)
   1539          #pragma location = ".isr_handler"
   1540          #endif 

   \                                 In section .isr_handler, align 2, keep-with-next
   1541          void PWRLib_RTC_Isr
   1542          (
   1543            void
   1544          )
   1545          {
   1546            /* Stop RTC */
   1547            RTC_SR &=  ~(RTC_SR_TCE_MASK);
   \                     PWRLib_RTC_Isr: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable62_8  ;; 0x4003d014
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF030 0x0010      BICS     R0,R0,#0x10
   \   00000008   0x....             LDR.N    R1,??DataTable62_8  ;; 0x4003d014
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   1548            /* Disable alarm interrupt*/
   1549            RTC_IER &= ~(RTC_IER_TAIE_MASK);
   \   0000000C   0x....             LDR.N    R0,??DataTable62_9  ;; 0x4003d01c
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000014   0x....             LDR.N    R1,??DataTable62_9  ;; 0x4003d01c
   \   00000016   0x6008             STR      R0,[R1, #+0]
   1550            /* Clear all pending interrupts */
   1551            RTC_TAR = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x....             LDR.N    R1,??DataTable62_10  ;; 0x4003d008
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   1552            RTC_TSR = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x....             LDR.N    R1,??DataTable62_11  ;; 0x4003d000
   \   00000022   0x6008             STR      R0,[R1, #+0]
   1553          #if (cPWR_UsePowerDownMode==1)
   1554            mPWRLib_RTIRemainingTicks = 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x....             LDR.N    R1,??DataTable62_12
   \   00000028   0x6008             STR      R0,[R1, #+0]
   1555          #endif /* #if (cPWR_UsePowerDownMode==1) */
   1556          }
   \   0000002A   0x4770             BX       LR               ;; return
   1557          
   1558          /*---------------------------------------------------------------------------
   1559           * Name: PWRLib_GetSystemResetStatus
   1560           * Description: -
   1561           * Parameters: -
   1562           * Return: -
   1563           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1564          uint16_t PWRLib_GetSystemResetStatus
   1565          (
   1566            void
   1567          )
   1568          {
   1569            uint16_t resetStatus = 0;
   \                     PWRLib_GetSystemResetStatus: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   1570          #if (MCU_MK60N512VMD100 == 1)
   1571            resetStatus = (uint16_t) (MC_SRSL);
   1572            resetStatus |= (uint16_t)(MC_SRSH << 8);
   1573          #elif ((MCU_MK60D10 == 1) || (MCU_MK20D5 == 1) || (MCU_MK21DN512 == 1) || (MCU_MK21DX256 == 1))
   1574            resetStatus = (uint16_t) (RCM_SRS0);
   \   00000002   0x....             LDR.N    R1,??DataTable29_25  ;; 0x4007f000
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x0008             MOVS     R0,R1
   1575            resetStatus |= (uint16_t)(RCM_SRS1 << 8);
   \   0000000A   0x....             LDR.N    R1,??DataTable29_26  ;; 0x4007f001
   \   0000000C   0x7809             LDRB     R1,[R1, #+0]
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   1576          #endif
   1577            return resetStatus;
   \   00000014   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000016   0x4770             BX       LR               ;; return
   1578          }
   1579          
   1580          /*---------------------------------------------------------------------------
   1581           * Name: PWRLib_Init
   1582           * Description: -
   1583           * Parameters: -
   1584           * Return: -
   1585           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1586          void PWRLib_Init
   1587          (
   1588            void
   1589          )
   1590          {
   \                     PWRLib_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1591          
   1592          #if (cPWR_UsePowerDownMode == 1)
   1593            /* enable clock to LLWU module */
   1594          #if (MCU_MK60N512VMD100 == 1)	
   1595            SIM_SCGC4 |= SIM_SCGC4_LLWU_MASK;
   1596          #elif (MCU_MK60D10 == 1)
   1597            SIM_SCGC4 |= (uint32_t) (1 << 28);
   1598          #endif
   1599          
   1600          #if ( (cPWR_DeepSleepMode == 4) || (cPWR_DeepSleepMode == 7) || (cPWR_DeepSleepMode == 11) )
   1601            PWRLib_RTC_Init();
   1602            /* configure NVIC for RTC alarm Isr */
   1603            NVIC_EnableIRQ(gRTC_IRQ_Number_c);
   1604            /* enable RTC as wakeup source for LLWU module */
   1605            PWRLib_LLWU_WakeupModuleEnable(gPWRLib_LLWU_WakeupModule_RTC_Alarm_c);
   1606          #endif
   1607          
   1608          #if ( (cPWR_DeepSleepMode == 2) || (cPWR_DeepSleepMode == 3) || (cPWR_DeepSleepMode == 5) || (cPWR_DeepSleepMode == 6) || (cPWR_DeepSleepMode == 8) || (cPWR_DeepSleepMode == 9) || (cPWR_DeepSleepMode == 10) || (cPWR_DeepSleepMode == 12) )  
   1609            /* configure NVIC for LPTMR Isr */
   1610            //NVIC_EnableIRQ(gLPTMR_IRQ_Number_c);
   1611            /* enable LPTMR as wakeup source for LLWU module */
   1612            //PWRLib_LLWU_WakeupModuleEnable(gPWRLib_LLWU_WakeupModule_LPTMR_c);
   1613          #endif
   1614          
   1615          #if ( (cPWR_DeepSleepMode != 0) && (cPWR_DeepSleepMode != 2) && (cPWR_DeepSleepMode != 3) && (cPWR_DeepSleepMode != 4) )
   1616          
   1617          #if ((MCU_MK21DN512 == 1) || (MCU_MK21DX256 == 1))
   1618            /* enable GPIO as wakeup source for LLWU module */
   1619            PWRLib_LLWU_WakeupPinEnable( (PWRLib_LLWU_WakeupPin_t) gLLWU_WakeUp_PIN_Number_c, gPWRLib_LLWU_WakeupPin_AnyEdge_c);
   \   00000002   0x2103             MOVS     R1,#+3
   \   00000004   0x2008             MOVS     R0,#+8
   \   00000006   0x.... 0x....      BL       PWRLib_LLWU_WakeupPinEnable
   1620          #elif (MCU_MK60D10 == 1)
   1621            /* enable TSI as wakeup source for LLWU module */
   1622            PWRLib_LLWU_WakeupModuleEnable(gPWRLib_LLWU_WakeupModule_TSI_c);
   1623          #endif
   1624          
   1625          #endif
   1626            
   1627          #if ( (cPWR_DeepSleepMode != 0) && (cPWR_DeepSleepMode != 13) )
   1628            /* configure NVIC for LLWU Isr */
   1629            NVIC_EnableIRQ(gLLWU_IRQ_Number_c);
   \   0000000A   0x2015             MOVS     R0,#+21
   \   0000000C   0x.... 0x....      BL       NVIC_EnableIRQ
   1630          #endif
   1631            
   1632          #if ( (cPWR_DeepSleepMode == 3) || (cPWR_DeepSleepMode == 6) || (cPWR_DeepSleepMode == 10) )
   1633            
   1634          #if (MCU_MK60N512VMD100 == 1)	
   1635            SIM_SOPT1 |= SIM_SOPT1_OSC32KSEL_MASK;
   1636          #elif ((MCU_MK60D10 == 1)  || (MCU_MK21DN512 == 1) || (MCU_MK21DX256 == 1))
   1637            SIM_SOPT1 &= ~SIM_SOPT1_OSC32KSEL_MASK;
   1638            SIM_SOPT1 |= SIM_SOPT1_OSC32KSEL(2);
   1639          #endif // (MCU_MK60N512VMD100 == 1)	
   1640            PWRLib_RTC_Init();
   1641          
   1642          #endif
   1643          
   1644          #endif /* #if (cPWR_UsePowerDownMode==1) */
   1645              
   1646            /* LVD_Init TODO */
   1647          #if (cPWR_LVD_Enable == 0)
   1648          //  PMC_LVDSC1 &= (uint32_t) ~( PMC_LVDSC1_LVDRE_MASK | PMC_LVDSC1_LVDIE_MASK );
   1649            PMC_LVDSC1 &= (uint32_t) ~( PMC_LVDSC1_LVDIE_MASK );
   \   00000010   0x....             LDR.N    R0,??DataTable29_27  ;; 0x4007d000
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   00000018   0x....             LDR.N    R1,??DataTable29_27  ;; 0x4007d000
   \   0000001A   0x7008             STRB     R0,[R1, #+0]
   1650            PMC_LVDSC2 &= (uint32_t) ~( PMC_LVDSC2_LVWIE_MASK );
   \   0000001C   0x....             LDR.N    R0,??DataTable29_28  ;; 0x4007d001
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   00000024   0x....             LDR.N    R1,??DataTable29_28  ;; 0x4007d001
   \   00000026   0x7008             STRB     R0,[R1, #+0]
   1651          #elif ((cPWR_LVD_Enable == 1) || (cPWR_LVD_Enable == 2))
   1652          //  PMC_LVDSC1 &= (uint32_t) ~( PMC_LVDSC1_LVDRE_MASK | PMC_LVDSC1_LVDIE_MASK );
   1653            PMC_LVDSC1 &= (uint32_t) ~( PMC_LVDSC1_LVDIE_MASK );
   1654            PMC_LVDSC2 &= (uint32_t) ~( PMC_LVDSC2_LVWIE_MASK );
   1655          #elif (cPWR_LVD_Enable==3)
   1656            PMC_LVDSC1 &= (uint32_t) ~( PMC_LVDSC1_LVDIE_MASK );
   1657            PMC_LVDSC2 &= (uint32_t) ~( PMC_LVDSC2_LVWIE_MASK );
   1658            PMC_LVDSC1 |= (uint32_t) ( PMC_LVDSC1_LVDRE_MASK );
   1659          #endif /* #if (cPWR_LVD_Enable) */
   1660            
   1661          #if ((cPWR_LVD_Enable == 1) || (cPWR_LVD_Enable == 2))
   1662            PWRLib_LVD_SavedLevel = PWR_ABOVE_LEVEL_3_0V;
   1663          #endif  /* #if ((cPWR_LVD_Enable == 1) || (cPWR_LVD_Enable == 2)) */
   1664          #if (cPWR_LVD_Enable == 2)
   1665            PWRLib_LVD_CollectCounter = cPWR_LVD_Ticks;
   1666          #endif  /* #if (cPWR_LVD_Enable==2) */
   1667            
   1668          #if (cPWR_LVD_Enable == 2)
   1669            
   1670            /* Allocate a platform timer */
   1671            PWRLib_LVD_PollIntervalTmrID = TMR_AllocateTimer();	
   1672            
   1673            if(gTmrInvalidTimerID_c != PWRLib_LVD_PollIntervalTmrID)
   1674            {	
   1675              /* start the timer */
   1676              TMR_StartLowPowerTimer(PWRLib_LVD_PollIntervalTmrID, gTmrLowPowerMinuteTimer_c, PWRLib_LVD_CollectCounter, PWRLib_LVD_PollIntervalCallback);
   1677            }
   1678          #endif  /* #if (cPWR_LVD_Enable==2) */
   1679            
   1680          }
   \   00000028   0xBD01             POP      {R0,PC}          ;; return
   1681          
   1682          /*---------------------------------------------------------------------------
   1683           * Name: PWRLib_Reset
   1684           * Description: -
   1685           * Parameters: -
   1686           * Return: -
   1687           *---------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1688          void PWRLib_Reset
   1689          (
   1690            void
   1691          )
   1692          {
   1693            SCB_AIRCR = (uint32_t) (SCB_AIRCR_VECTKEY(0x5FA) | SCB_AIRCR_SYSRESETREQ_MASK);
   \                     PWRLib_Reset: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable29_29  ;; 0x5fa0004
   \   00000002   0x....             LDR.N    R1,??DataTable29_30  ;; 0xe000ed0c
   \   00000004   0x6008             STR      R0,[R1, #+0]
   1694            while(1);
   \                     ??PWRLib_Reset_0: (+1)
   \   00000006   0xE7FE             B.N      ??PWRLib_Reset_0
   1695          }

   \                                 In section .isr_handler, align 4, keep-with-next
   \                     ??DataTable62:
   \   00000000   0x4007C006         DC32     0x4007c006

   \                                 In section .isr_handler, align 4, keep-with-next
   \                     ??DataTable62_1:
   \   00000000   0x4004B010         DC32     0x4004b010

   \                                 In section .isr_handler, align 4, keep-with-next
   \                     ??DataTable62_2:
   \   00000000   0x........         DC32     PWRLib_MCU_WakeupReason

   \                                 In section .isr_handler, align 4, keep-with-next
   \                     ??DataTable62_3:
   \   00000000   0x4004B014         DC32     0x4004b014

   \                                 In section .isr_handler, align 4, keep-with-next
   \                     ??DataTable62_4:
   \   00000000   0x4004B018         DC32     0x4004b018

   \                                 In section .isr_handler, align 4, keep-with-next
   \                     ??DataTable62_5:
   \   00000000   0x4007C005         DC32     0x4007c005

   \                                 In section .isr_handler, align 4, keep-with-next
   \                     ??DataTable62_6:
   \   00000000   0x4007C007         DC32     0x4007c007

   \                                 In section .isr_handler, align 4, keep-with-next
   \                     ??DataTable62_7:
   \   00000000   0x40040000         DC32     0x40040000

   \                                 In section .isr_handler, align 4, keep-with-next
   \                     ??DataTable62_8:
   \   00000000   0x4003D014         DC32     0x4003d014

   \                                 In section .isr_handler, align 4, keep-with-next
   \                     ??DataTable62_9:
   \   00000000   0x4003D01C         DC32     0x4003d01c

   \                                 In section .isr_handler, align 4, keep-with-next
   \                     ??DataTable62_10:
   \   00000000   0x4003D008         DC32     0x4003d008

   \                                 In section .isr_handler, align 4, keep-with-next
   \                     ??DataTable62_11:
   \   00000000   0x4003D000         DC32     0x4003d000

   \                                 In section .isr_handler, align 4, keep-with-next
   \                     ??DataTable62_12:
   \   00000000   0x........         DC32     mPWRLib_RTIRemainingTicks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   0xE000ED10         DC32     0xe000ed10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_1:
   \   00000000   0x4007E001         DC32     0x4007e001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_2:
   \   00000000   0x4007E002         DC32     0x4007e002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_3:
   \   00000000   0x4007C000         DC32     0x4007c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_4:
   \   00000000   0x4007C004         DC32     0x4007c004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_5:
   \   00000000   0x4007C007         DC32     0x4007c007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_6:
   \   00000000   0x4007C001         DC32     0x4007c001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_7:
   \   00000000   0x4007C002         DC32     0x4007c002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_8:
   \   00000000   0x4007C003         DC32     0x4007c003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_9:
   \   00000000   0x4007C005         DC32     0x4007c005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_10:
   \   00000000   0x4007C006         DC32     0x4007c006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_11:
   \   00000000   0x40048038         DC32     0x40048038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_12:
   \   00000000   0x40040000         DC32     0x40040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_13:
   \   00000000   0x40040008         DC32     0x40040008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_14:
   \   00000000   0x........         DC32     mPWRLib_RTIRemainingTicks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_15:
   \   00000000   0x40040004         DC32     0x40040004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_16:
   \   00000000   0x4004000C         DC32     0x4004000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_17:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_18:
   \   00000000   0x4003D010         DC32     0x4003d010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_19:
   \   00000000   0x4003D014         DC32     0x4003d014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_20:
   \   00000000   0x4003D008         DC32     0x4003d008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_21:
   \   00000000   0x4003D000         DC32     0x4003d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_22:
   \   00000000   0x4003D01C         DC32     0x4003d01c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_23:
   \   00000000   0x........         DC32     mPWRLib_RTC_IsOscStarted

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_24:
   \   00000000   0x........         DC32     mPWRLib_RTC_OscInitTmrID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_25:
   \   00000000   0x4007F000         DC32     0x4007f000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_26:
   \   00000000   0x4007F001         DC32     0x4007f001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_27:
   \   00000000   0x4007D000         DC32     0x4007d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_28:
   \   00000000   0x4007D001         DC32     0x4007d001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_29:
   \   00000000   0x05FA0004         DC32     0x5fa0004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_30:
   \   00000000   0xE000ED0C         DC32     0xe000ed0c

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   PWRLib_DelayMs
       0   PWRLib_GetSystemResetStatus
       8   PWRLib_Init
         8   -> NVIC_EnableIRQ
         8   -> PWRLib_LLWU_WakeupPinEnable
       4   PWRLib_LLWU_IsGPIOWakeUpSource
       0   PWRLib_LLWU_IsLPTMRWakeUpSource
       0   PWRLib_LLWU_IsRTCWakeUpSource
       0   PWRLib_LLWU_IsTSIWakeUpSource
       0   PWRLib_LLWU_Isr
       0   PWRLib_LLWU_WakeupModuleDisable
       0   PWRLib_LLWU_WakeupModuleEnable
       8   PWRLib_LLWU_WakeupPinDisable
      12   PWRLib_LLWU_WakeupPinEnable
      16   PWRLib_LPTMR_ClockCheck
        16   -> IntDisableAll
        16   -> IntRestoreAll
      16   PWRLib_LPTMR_ClockStart
        16   -> IntDisableAll
        16   -> IntRestoreAll
       8   PWRLib_LPTMR_ClockStop
         8   -> IntDisableAll
         8   -> IntRestoreAll
       0   PWRLib_LPTMR_Isr
       8   PWRLib_LPTMR_ResetTicks
         8   -> IntDisableAll
         8   -> IntRestoreAll
       0   PWRLib_LVD_CollectLevel
       0   PWRLib_MCU_Enter_LLS
       0   PWRLib_MCU_Enter_STOP
       0   PWRLib_MCU_Enter_VLLS0
       0   PWRLib_MCU_Enter_VLLS1
       0   PWRLib_MCU_Enter_VLLS2
       0   PWRLib_MCU_Enter_VLLS3
       0   PWRLib_MCU_Enter_VLPS
       0   PWRLib_MCU_Enter_WAIT
      16   PWRLib_RTC_ClockCheck
        16   -> IntDisableAll
        16   -> IntRestoreAll
      16   PWRLib_RTC_ClockStart
        16   -> IntDisableAll
        16   -> IntRestoreAll
       8   PWRLib_RTC_ClockStop
         8   -> IntDisableAll
         8   -> IntRestoreAll
       8   PWRLib_RTC_Init
         8   -> IntDisableAll
         8   -> IntRestoreAll
         8   -> TMR_AllocateTimer
         8   -> TMR_StartTimer
      16   PWRLib_RTC_IsOscStarted
        16   -> IntDisableAll
        16   -> IntRestoreAll
       0   PWRLib_RTC_Isr
       8   PWRLib_RTC_OscInitCallback
         8   -> TMR_FreeTimer
       8   PWRLib_RTC_ResetTicks
         8   -> IntDisableAll
         8   -> IntRestoreAll
      16   PWRLib_Radio_Enter_AutoDoze
        16   -> IntDisableAll
        16   -> IntRestoreAll
        16   -> MC1324xDrv_DirectAccessSPIRead
        16   -> MC1324xDrv_DirectAccessSPIWrite
      24   PWRLib_Radio_Enter_Doze
        24   -> IntDisableAll
        24   -> IntRestoreAll
        24   -> MC1324xDrv_DirectAccessSPIRead
        24   -> MC1324xDrv_DirectAccessSPIWrite
      24   PWRLib_Radio_Enter_Hibernate
        24   -> IntDisableAll
        24   -> IntRestoreAll
        24   -> MC1324xDrv_DirectAccessSPIRead
        24   -> MC1324xDrv_DirectAccessSPIWrite
      24   PWRLib_Radio_Enter_Idle
        24   -> IntDisableAll
        24   -> IntRestoreAll
        24   -> MC1324xDrv_DirectAccessSPIRead
        24   -> MC1324xDrv_DirectAccessSPIWrite
       0   PWRLib_Reset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable29_10
       4  ??DataTable29_11
       4  ??DataTable29_12
       4  ??DataTable29_13
       4  ??DataTable29_14
       4  ??DataTable29_15
       4  ??DataTable29_16
       4  ??DataTable29_17
       4  ??DataTable29_18
       4  ??DataTable29_19
       4  ??DataTable29_2
       4  ??DataTable29_20
       4  ??DataTable29_21
       4  ??DataTable29_22
       4  ??DataTable29_23
       4  ??DataTable29_24
       4  ??DataTable29_25
       4  ??DataTable29_26
       4  ??DataTable29_27
       4  ??DataTable29_28
       4  ??DataTable29_29
       4  ??DataTable29_3
       4  ??DataTable29_30
       4  ??DataTable29_4
       4  ??DataTable29_5
       4  ??DataTable29_6
       4  ??DataTable29_7
       4  ??DataTable29_8
       4  ??DataTable29_9
       4  ??DataTable62
       4  ??DataTable62_1
       4  ??DataTable62_10
       4  ??DataTable62_11
       4  ??DataTable62_12
       4  ??DataTable62_2
       4  ??DataTable62_3
       4  ??DataTable62_4
       4  ??DataTable62_5
       4  ??DataTable62_6
       4  ??DataTable62_7
       4  ??DataTable62_8
       4  ??DataTable62_9
      82  PWRLib_DelayMs
      24  PWRLib_GetSystemResetStatus
      42  PWRLib_Init
     104  PWRLib_LLWU_IsGPIOWakeUpSource
      32  PWRLib_LLWU_IsLPTMRWakeUpSource
      32  PWRLib_LLWU_IsRTCWakeUpSource
       4  PWRLib_LLWU_IsTSIWakeUpSource
     250  PWRLib_LLWU_Isr
      20  PWRLib_LLWU_WakeupModuleDisable
      20  PWRLib_LLWU_WakeupModuleEnable
      38  PWRLib_LLWU_WakeupPinDisable
      54  PWRLib_LLWU_WakeupPinEnable
      78  PWRLib_LPTMR_ClockCheck
     122  PWRLib_LPTMR_ClockStart
      74  PWRLib_LPTMR_ClockStop
      32  PWRLib_LPTMR_Isr
      22  PWRLib_LPTMR_ResetTicks
       4  PWRLib_LVD_CollectLevel
      40  PWRLib_MCU_Enter_LLS
      36  PWRLib_MCU_Enter_STOP
      48  PWRLib_MCU_Enter_VLLS0
      48  PWRLib_MCU_Enter_VLLS1
      48  PWRLib_MCU_Enter_VLLS2
      48  PWRLib_MCU_Enter_VLLS3
      40  PWRLib_MCU_Enter_VLPS
      20  PWRLib_MCU_Enter_WAIT
       4  PWRLib_MCU_WakeupReason
      58  PWRLib_RTC_ClockCheck
      76  PWRLib_RTC_ClockStart
      90  PWRLib_RTC_ClockStop
     152  PWRLib_RTC_Init
      28  PWRLib_RTC_IsOscStarted
      44  PWRLib_RTC_Isr
      30  PWRLib_RTC_OscInitCallback
      22  PWRLib_RTC_ResetTicks
      92  PWRLib_Radio_Enter_AutoDoze
     178  PWRLib_Radio_Enter_Doze
     124  PWRLib_Radio_Enter_Hibernate
     182  PWRLib_Radio_Enter_Idle
       8  PWRLib_Reset
       1  PWRLib_StackPS
       1  mPWRLib_RTC_IsOscStarted
       1  mPWRLib_RTC_OscInitTmrID
       4  mPWRLib_RTIRemainingTicks

 
    11 bytes in section .bss
   378 bytes in section .isr_handler
 2 244 bytes in section .text
 
 2 622 bytes of CODE memory
    11 bytes of DATA memory

Errors: none
Warnings: none
