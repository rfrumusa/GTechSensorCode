///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM       02/Sep/2018  14:19:42
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\Class\usb_cdc.c
//    Command line =  
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\Class\usb_cdc.c" -D IAR --preprocess
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\" -lC
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\" -lB
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\"
//        --diag_suppress Pe014,Pe001,Pe991,Pa039,Pe520,Pe550,Pe177,Pa082 -o
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\Obj\" --no_cse
//        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
//        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Configure\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Environment\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Interface\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\Generic Services\Interface\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\Uart\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\" -I "F:\Guardrail
//        Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit
//        Origional Code\Connectivity Test\PLM\Source\USB\APP\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\USB\APP\CDC\" -I "F:\Guardrail Work\Sensor Code\Git
//        Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\USB\APP\Descriptor\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Class\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Driver\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\TMR\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity
//        Test\PLM\Source\Radio\MC1324x\PHY\" -I "F:\Guardrail Work\Sensor
//        Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional
//        Code\Connectivity Test\PLM\Source\Radio\MC1324x\DRV\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\Sys Common\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Interface\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\SMAC\Configure\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Source\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Application\Configure\"
//        -I "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\NVM\" -I
//        "C:\Users\Robert\SkyDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "C:\Users\rfrum\OneDrive\2018 Spring Semester\Senior Design\Sensor
//        Code\Shanit Origional Code\Connectivity Test\PLM\Source\ADC\" -I
//        "F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\PLM\Source\LPM\" -On
//    List file    =  
//        F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC
//        Reads\Shanit Origional Code\Connectivity Test\Debug\List\usb_cdc.s
//
///////////////////////////////////////////////////////////////////////////////

        #define SHT_PROGBITS 0x1

        EXTERN USB_ClassDeInit
        EXTERN USB_ClassInit
        EXTERN USB_Class_CDC_PSTN_GetCommFeature
        EXTERN USB_Class_CDC_PSTN_GetLineCoding
        EXTERN USB_Class_CDC_PSTN_SendBreak
        EXTERN USB_Class_CDC_PSTN_SetCommFeature
        EXTERN USB_Class_CDC_PSTN_SetCtrlLineState
        EXTERN USB_Class_CDC_PSTN_SetLineCoding
        EXTERN USB_DeviceDeinitEndpoint
        EXTERN USB_DeviceInit
        EXTERN USB_DeviceInitEndpoint
        EXTERN USB_DeviceRegisterService
        EXTERN USB_DeviceSetStatus
        EXTERN USB_IsrEvent
        EXTERN gDTEStatus
        EXTERN gNotifyEndpoint
        EXTERN gpaUsbClassDescriptor

        PUBLIC USB_Class_CDC_DeInit
        PUBLIC USB_Class_CDC_Init
        PUBLIC USB_Class_CDC_SetDicInServiceCallback
        PUBLIC USB_Class_CDC_SetDicOutServiceCallback

// F:\Guardrail Work\Sensor Code\Git Repo\Sensor Code Sequential ADC Reads\Shanit Origional Code\Connectivity Test\PLM\Source\USB\Class\usb_cdc.c
//    1 /******************************************************************************
//    2  *
//    3  * Freescale Semiconductor Inc.
//    4  * (c) Copyright 2004-2009 Freescale Semiconductor, Inc.
//    5  * ALL RIGHTS RESERVED.
//    6  *
//    7  ******************************************************************************
//    8  *
//    9  * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR 
//   10  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
//   11  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
//   12  * IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
//   13  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
//   14  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
//   15  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
//   16  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
//   17  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
//   18  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
//   19  * THE POSSIBILITY OF SUCH DAMAGE.
//   20  *
//   21  **************************************************************************//*!
//   22  *
//   23  * @file usb_cdc.c
//   24  *
//   25  * @author
//   26  *
//   27  * @version
//   28  *
//   29  * @date May-28-2009
//   30  *
//   31  * @brief The file contains USB stack CDC layer implementation.
//   32  *
//   33  *****************************************************************************/
//   34 
//   35 /******************************************************************************
//   36  * Includes
//   37  *****************************************************************************/
//   38 #include "USB.h" 
//   39 #include "usb_cdc.h"    /* USB CDC Class Header File */
//   40 #include "usb_cdc_pstn.h"
//   41 /*****************************************************************************
//   42  * Constant and Macro's
//   43  *****************************************************************************/
//   44 
//   45 /****************************************************************************
//   46  * Global Variables
//   47 ***************************************************************************/
//   48 #if gUsbCdcEnabled_d
//   49 
//   50 #if (gUsbIncluded_d == FALSE)
//   51  #error If gUsbCdcEnabled_d == TRUE, gUsbIncluded_d must be TRUE
//   52 #endif
//   53 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   54 static void (*pfCDCDicInServiceCallBack)(usbDeviceEvent_t* event);
pfCDCDicInServiceCallBack:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   55 static void (*pfCDCDicOutServiceCallBack)(usbDeviceEvent_t* event);
pfCDCDicOutServiceCallBack:
        DS8 4
//   56 extern uint8_t gDTEStatus;
//   57 /*****************************************************************************
//   58  * Local Types - None
//   59  *****************************************************************************/
//   60 #if gUSB_CDC_CIC_NotifElemSupport_d
//   61 extern uint8_t gNotifyEndpoint;
//   62 #endif
//   63 /*****************************************************************************
//   64  * Local Functions Prototypes
//   65  *****************************************************************************/
//   66 #if gUSB_CDC_CIC_NotifElemSupport_d
//   67 static void USB_Class_CDC_ServiceCicNotify(usbDeviceEvent_t* event);
//   68 #endif
//   69 
//   70 static void USB_Class_CDC_ServiceDicBulkIn(usbDeviceEvent_t* event);
//   71 static void USB_Class_CDC_ServiceDicBulkOut(usbDeviceEvent_t* event);
//   72 static uint8_t USB_CDC_OtherRequests
//   73 (
//   74   uint8_t controllerId,
//   75   usbSetupPacket_t * setupPacket,
//   76   uint8_t* *data,
//   77   usbPacketSize_t *size
//   78 );
//   79 static void USB_CDC_ClassEvent
//   80 (
//   81   uint8_t controllerId,
//   82   gUsbToAppEvent_t event,
//   83   void* val
//   84 );
//   85 
//   86 /*****************************************************************************
//   87  * Local Variables - None
//   88  *****************************************************************************/
//   89 
//   90  /*****************************************************************************
//   91  * Local Functions
//   92  *****************************************************************************/
//   93 #if gUSB_CDC_CIC_NotifElemSupport_d
//   94 /**************************************************************************//*!
//   95  *
//   96  * @name  USB_Class_CDC_Service_Cic_Notify
//   97  *
//   98  * @brief The funtion is callback function of CIC Notification endpoint
//   99  *
//  100  * @param event : Pointer to USB Event Structure
//  101  *
//  102  * @return None
//  103  *
//  104  ******************************************************************************
//  105  * Called by Lower layer when data on CIC Endpoint is sent
//  106  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  107 static void USB_Class_CDC_ServiceCicNotify 
//  108 (
//  109     usbDeviceEvent_t* event  /* [IN] Pointer to USB Event Structure */
//  110 )
//  111 {
USB_Class_CDC_ServiceCicNotify:
        PUSH     {R4,R5,LR}
        SUB      SP,SP,#+20
        MOVS     R4,R0
//  112   pfUsbToAppEventHandler_t cdcClassCallback;
//  113   cdcClassCallback = gpaUsbClassDescriptor[event->controllerId]->pfUsbToAppEventHandler;
        LDR.W    R0,??DataTable7
        LDRB     R1,[R4, #+0]
        LDR      R0,[R0, R1, LSL #+2]
        LDR      R0,[R0, #+4]
        MOVS     R5,R0
//  114   if(cdcClassCallback != NULL)
        MOVS     R0,R5
        CMP      R0,#+0
        BEQ.N    ??USB_Class_CDC_ServiceCicNotify_0
//  115   {
//  116     usbMsg_t usbMsg;
//  117     usbMsg.controllerId = event->controllerId;
        LDRB     R0,[R4, #+0]
        STRB     R0,[SP, #+0]
//  118     if(event->errors != 0)
        LDRB     R0,[R4, #+10]
        CMP      R0,#+0
        BEQ.N    ??USB_Class_CDC_ServiceCicNotify_1
//  119     {
//  120       usbMsg.eventType = gUsbToAppEvent_Error_c;
        MOVS     R0,#+5
        STRB     R0,[SP, #+1]
//  121       usbMsg.eventParam.errorEvent.errors = event->errors;
        LDRB     R0,[R4, #+10]
        STRB     R0,[SP, #+4]
        B.N      ??USB_Class_CDC_ServiceCicNotify_2
//  122     }
//  123     else
//  124     {
//  125       usbMsg.eventType = gUsbToAppEvent_SendComplete_c;
??USB_Class_CDC_ServiceCicNotify_1:
        MOVS     R0,#+3
        STRB     R0,[SP, #+1]
//  126       usbMsg.eventParam.sendCompleteEvent.epNum = event->epNum;
        LDRB     R0,[R4, #+1]
        STRB     R0,[SP, #+4]
//  127       usbMsg.eventParam.sendCompleteEvent.pBuffer = event->pBuffer;
        LDR      R0,[R4, #+4]
        STR      R0,[SP, #+8]
//  128       usbMsg.eventParam.sendCompleteEvent.len = event->len;
        LDRH     R0,[R4, #+8]
        STRH     R0,[SP, #+12]
//  129     }
//  130     USB_IsrEvent(&usbMsg);
??USB_Class_CDC_ServiceCicNotify_2:
        ADD      R0,SP,#+0
        BL       USB_IsrEvent
//  131   }
//  132 }
??USB_Class_CDC_ServiceCicNotify_0:
        ADD      SP,SP,#+20
        POP      {R4,R5,PC}       ;; return
//  133 #endif
//  134 
//  135 
//  136 /**************************************************************************//*!
//  137  *
//  138  * @name  USB_Class_CDC_Service_Dic_Bulk_In
//  139  *
//  140  * @brief The funtion is callback function of DIC Bulk In Endpoint
//  141  *
//  142  * @param event : Pointer to USB Event Structure
//  143  *
//  144  * @return None
//  145  *
//  146  ******************************************************************************
//  147  * Called by Lower Layer when Data on DIC SEND Interface is sent
//  148  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  149 static void USB_Class_CDC_ServiceDicBulkIn 
//  150 (
//  151   usbDeviceEvent_t* event /* [IN] Pointer to USB Event Structure */
//  152 )
//  153 {
USB_Class_CDC_ServiceDicBulkIn:
        PUSH     {R4,R5,LR}
        SUB      SP,SP,#+20
        MOVS     R4,R0
//  154   if(pfCDCDicInServiceCallBack != NULL)
        LDR.N    R0,??DataTable7_1
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??USB_Class_CDC_ServiceDicBulkIn_0
//  155   {
//  156     pfCDCDicInServiceCallBack(event);  
        MOVS     R0,R4
        LDR.N    R1,??DataTable7_1
        LDR      R1,[R1, #+0]
        BLX      R1
        B.N      ??USB_Class_CDC_ServiceDicBulkIn_1
//  157   }
//  158   else
//  159   {
//  160     pfUsbToAppEventHandler_t cdcClassCallback;
//  161     cdcClassCallback = gpaUsbClassDescriptor[event->controllerId]->pfUsbToAppEventHandler;
??USB_Class_CDC_ServiceDicBulkIn_0:
        LDR.N    R0,??DataTable7
        LDRB     R1,[R4, #+0]
        LDR      R0,[R0, R1, LSL #+2]
        LDR      R0,[R0, #+4]
        MOVS     R5,R0
//  162     if(cdcClassCallback != NULL)
        MOVS     R0,R5
        CMP      R0,#+0
        BEQ.N    ??USB_Class_CDC_ServiceDicBulkIn_1
//  163     {
//  164       usbMsg_t usbMsg;
//  165       usbMsg.controllerId = event->controllerId;
        LDRB     R0,[R4, #+0]
        STRB     R0,[SP, #+0]
//  166       if(event->errors != 0)
        LDRB     R0,[R4, #+10]
        CMP      R0,#+0
        BEQ.N    ??USB_Class_CDC_ServiceDicBulkIn_2
//  167       {
//  168         usbMsg.eventType = gUsbToAppEvent_Error_c;
        MOVS     R0,#+5
        STRB     R0,[SP, #+1]
//  169         usbMsg.eventParam.errorEvent.errors = event->errors;
        LDRB     R0,[R4, #+10]
        STRB     R0,[SP, #+4]
        B.N      ??USB_Class_CDC_ServiceDicBulkIn_3
//  170       }
//  171       else
//  172       {
//  173         usbMsg.eventType = gUsbToAppEvent_SendComplete_c;
??USB_Class_CDC_ServiceDicBulkIn_2:
        MOVS     R0,#+3
        STRB     R0,[SP, #+1]
//  174         usbMsg.eventParam.sendCompleteEvent.epNum = event->epNum;
        LDRB     R0,[R4, #+1]
        STRB     R0,[SP, #+4]
//  175         usbMsg.eventParam.sendCompleteEvent.pBuffer = event->pBuffer;
        LDR      R0,[R4, #+4]
        STR      R0,[SP, #+8]
//  176         usbMsg.eventParam.sendCompleteEvent.len = event->len;
        LDRH     R0,[R4, #+8]
        STRH     R0,[SP, #+12]
//  177       }
//  178       USB_IsrEvent(&usbMsg);
??USB_Class_CDC_ServiceDicBulkIn_3:
        ADD      R0,SP,#+0
        BL       USB_IsrEvent
//  179     }
//  180   }
//  181 }
??USB_Class_CDC_ServiceDicBulkIn_1:
        ADD      SP,SP,#+20
        POP      {R4,R5,PC}       ;; return
//  182 
//  183 /**************************************************************************//*!
//  184  *
//  185  * @name  USB_Class_CDC_Service_Dic_Bulk_Out
//  186  *
//  187  * @brief The funtion is callback function of DIC Bulk Out Endpoint
//  188  *
//  189  * @param event : Pointer to USB Event Structure
//  190  *
//  191  * @return None
//  192  *
//  193  ******************************************************************************
//  194  * Called by Lower Layer when Data on DIC RECV Interface is received
//  195  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  196 static void USB_Class_CDC_ServiceDicBulkOut 
//  197 (
//  198     usbDeviceEvent_t* event  /* [IN] Pointer to USB Event Structure */
//  199 )
//  200 {   
USB_Class_CDC_ServiceDicBulkOut:
        PUSH     {R4,R5,LR}
        SUB      SP,SP,#+20
        MOVS     R4,R0
//  201   if(pfCDCDicOutServiceCallBack != NULL)
        LDR.N    R0,??DataTable7_2
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??USB_Class_CDC_ServiceDicBulkOut_0
//  202   {
//  203     pfCDCDicOutServiceCallBack(event);  
        MOVS     R0,R4
        LDR.N    R1,??DataTable7_2
        LDR      R1,[R1, #+0]
        BLX      R1
        B.N      ??USB_Class_CDC_ServiceDicBulkOut_1
//  204   }
//  205   else
//  206   {
//  207     pfUsbToAppEventHandler_t cdcClassCallback;
//  208     cdcClassCallback = gpaUsbClassDescriptor[event->controllerId]->pfUsbToAppEventHandler;
??USB_Class_CDC_ServiceDicBulkOut_0:
        LDR.N    R0,??DataTable7
        LDRB     R1,[R4, #+0]
        LDR      R0,[R0, R1, LSL #+2]
        LDR      R0,[R0, #+4]
        MOVS     R5,R0
//  209     if(cdcClassCallback != NULL)
        MOVS     R0,R5
        CMP      R0,#+0
        BEQ.N    ??USB_Class_CDC_ServiceDicBulkOut_1
//  210     {
//  211       usbMsg_t usbMsg;
//  212       usbMsg.controllerId = event->controllerId;
        LDRB     R0,[R4, #+0]
        STRB     R0,[SP, #+0]
//  213       if(event->errors != 0)
        LDRB     R0,[R4, #+10]
        CMP      R0,#+0
        BEQ.N    ??USB_Class_CDC_ServiceDicBulkOut_2
//  214       {
//  215         usbMsg.eventType = gUsbToAppEvent_Error_c;
        MOVS     R0,#+5
        STRB     R0,[SP, #+1]
//  216         usbMsg.eventParam.errorEvent.errors = event->errors;
        LDRB     R0,[R4, #+10]
        STRB     R0,[SP, #+4]
        B.N      ??USB_Class_CDC_ServiceDicBulkOut_3
//  217       }
//  218       else
//  219       {
//  220         usbMsg.eventType = gUsbToAppEvent_DataReceived_c;
??USB_Class_CDC_ServiceDicBulkOut_2:
        MOVS     R0,#+4
        STRB     R0,[SP, #+1]
//  221         usbMsg.eventParam.dataReceivedEvent.epNum = event->epNum;
        LDRB     R0,[R4, #+1]
        STRB     R0,[SP, #+4]
//  222         usbMsg.eventParam.dataReceivedEvent.pBuffer = event->pBuffer;
        LDR      R0,[R4, #+4]
        STR      R0,[SP, #+8]
//  223         usbMsg.eventParam.dataReceivedEvent.len = event->len;
        LDRH     R0,[R4, #+8]
        STRH     R0,[SP, #+12]
//  224       }
//  225         USB_IsrEvent(&usbMsg);
??USB_Class_CDC_ServiceDicBulkOut_3:
        ADD      R0,SP,#+0
        BL       USB_IsrEvent
//  226     }   
//  227   }
//  228 }
??USB_Class_CDC_ServiceDicBulkOut_1:
        ADD      SP,SP,#+20
        POP      {R4,R5,PC}       ;; return
//  229 
//  230 
//  231 /**************************************************************************//*!
//  232  *
//  233  * @name  USB_Class_CDC_Event
//  234  *
//  235  * @brief The funtion initializes CDC endpoints
//  236  *
//  237  * @param controller_ID : Controller ID
//  238  * @param event         : Event Type
//  239  * @param val           : Pointer to configuration Value
//  240  *
//  241  * @return None
//  242  *
//  243  ******************************************************************************
//  244  *
//  245  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  246 static void USB_CDC_ClassEvent 
//  247 (
//  248     uint8_t controllerId,   /* [IN] Controller ID */
//  249     gUsbToAppEvent_t event,           /* [IN] Event Type */
//  250     void* val               /* [OUT] Pointer to configuration Value */
//  251 )
//  252 {
USB_CDC_ClassEvent:
        PUSH     {R3-R11,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
//  253   pfUsbToAppEventHandler_t cdcClassCallback;
//  254   uint8_t index;
//  255   usbEpStruct_t* usbNCEpDptr = gpaUsbClassDescriptor[controllerId]->usbNonControlEpDescriptor;    
        LDR.N    R0,??DataTable7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDR      R0,[R0, R4, LSL #+2]
        LDR      R8,[R0, #+44]
//  256   uint8_t count = gpaUsbClassDescriptor[controllerId]->numNonControlEp;
        LDR.N    R0,??DataTable7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDR      R0,[R0, R4, LSL #+2]
        LDRB     R9,[R0, #+41]
//  257   if(event == gUsbToAppEvent_EnumComplete_c)
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+2
        BNE.N    ??USB_CDC_ClassEvent_0
//  258   {
//  259 	  /* deinitialize all endpoints in case they were initialized */
//  260 		index = count;
        MOV      R10,R9
//  261 		while(index > 0) 
??USB_CDC_ClassEvent_1:
        UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
        CMP      R10,#+0
        BEQ.N    ??USB_CDC_ClassEvent_2
//  262 		{   
//  263 		  index--;
        SUBS     R10,R10,#+1
//  264 			(void)USB_DeviceDeinitEndpoint(controllerId,usbNCEpDptr[index].number, usbNCEpDptr[index].direction);
        UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
        MOVS     R0,#+6
        MLA      R0,R0,R10,R8
        LDRB     R2,[R0, #+2]
        UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
        MOVS     R0,#+6
        MLA      R0,R0,R10,R8
        LDRB     R1,[R0, #+0]
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceDeinitEndpoint
        B.N      ??USB_CDC_ClassEvent_1
//  265 		}
//  266         
//  267    /* intialize all non control endpoints */
//  268     while(index < count)
??USB_CDC_ClassEvent_2:
        UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R10,R9
        BCS.N    ??USB_CDC_ClassEvent_3
//  269     {
//  270       usbEpStruct_t* epStruct = usbNCEpDptr + index;
        UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
        MOVS     R0,#+6
        MLA      R11,R0,R10,R8
//  271       (void)USB_DeviceInitEndpoint(controllerId, epStruct, TRUE);
        MOVS     R2,#+1
        MOV      R1,R11
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceInitEndpoint
//  272       /* register callback service for Non Control EndPoints */
//  273       switch(epStruct->type)
        LDRB     R1,[R11, #+1]
        CMP      R1,#+2
        BEQ.N    ??USB_CDC_ClassEvent_4
        CMP      R1,#+3
        BNE.N    ??USB_CDC_ClassEvent_5
//  274       {
//  275         #if gUSB_CDC_CIC_NotifElemSupport_d
//  276         case gUsbEpType_Interrupt_c :
//  277                gNotifyEndpoint = epStruct->number;  
??USB_CDC_ClassEvent_6:
        LDRB     R0,[R11, #+0]
        LDR.N    R1,??DataTable7_3
        STRB     R0,[R1, #+0]
//  278                (void)USB_DeviceRegisterService(controllerId,
//  279                  (uint8_t)(gUsbService_Ep0_d+epStruct->number),USB_Class_CDC_ServiceCicNotify);
        LDR.N    R2,??DataTable7_4
        LDRB     R1,[R11, #+0]
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceRegisterService
//  280         break;
        B.N      ??USB_CDC_ClassEvent_7
//  281         #endif
//  282         case gUsbEpType_Bulk_c :
//  283                if(epStruct->direction == gUsbEpDirection_Out_c)
??USB_CDC_ClassEvent_4:
        LDRB     R0,[R11, #+2]
        CMP      R0,#+0
        BNE.N    ??USB_CDC_ClassEvent_8
//  284                {
//  285                  (void)USB_DeviceRegisterService(controllerId,
//  286                     (uint8_t)(gUsbService_Ep0_d+epStruct->number),USB_Class_CDC_ServiceDicBulkOut);
        LDR.N    R2,??DataTable7_5
        LDRB     R1,[R11, #+0]
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceRegisterService
        B.N      ??USB_CDC_ClassEvent_9
//  287                }
//  288                else
//  289                {
//  290                  (void)USB_DeviceRegisterService(controllerId,
//  291                    (uint8_t)(gUsbService_Ep0_d+epStruct->number),USB_Class_CDC_ServiceDicBulkIn);
??USB_CDC_ClassEvent_8:
        LDR.N    R2,??DataTable7_6
        LDRB     R1,[R11, #+0]
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceRegisterService
//  292                }
//  293         break;
??USB_CDC_ClassEvent_9:
        B.N      ??USB_CDC_ClassEvent_7
//  294 
//  295         default: 
//  296         break;
//  297       }
//  298         /* set the EndPoint Status as Idle in the device layer */
//  299       (void)USB_DeviceSetStatus(controllerId,
//  300                 (uint8_t)(gUsbComponentStatus_Endpoint_d | epStruct->number |
//  301                 (epStruct->direction << gUsbComponent_DirectionShift_d)),
//  302                 (uint8_t)gUsbStatus_Idle_d);
??USB_CDC_ClassEvent_5:
??USB_CDC_ClassEvent_7:
        MOVS     R2,#+0
        LDRB     R0,[R11, #+0]
        LDRB     R1,[R11, #+2]
        ORRS     R0,R0,R1, LSL #+7
        ORRS     R1,R0,#0x10
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceSetStatus
//  303       index++;
        ADDS     R10,R10,#+1
        B.N      ??USB_CDC_ClassEvent_2
//  304     }
//  305   }
//  306   else if(event == gUsbToAppEvent_BusReset_c)
??USB_CDC_ClassEvent_0:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BNE.N    ??USB_CDC_ClassEvent_3
//  307   {
//  308     gDTEStatus = (uint8_t)gUninitialisedVal_d;
        MOVS     R0,#+255
        LDR.N    R1,??DataTable7_7
        STRB     R0,[R1, #+0]
//  309   }
//  310       
//  311   cdcClassCallback = gpaUsbClassDescriptor[controllerId]->pfUsbToAppEventHandler;
??USB_CDC_ClassEvent_3:
        LDR.N    R0,??DataTable7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDR      R0,[R0, R4, LSL #+2]
        LDR      R0,[R0, #+4]
        MOVS     R7,R0
//  312   if(cdcClassCallback != NULL)
        MOVS     R0,R7
        CMP      R0,#+0
        BEQ.N    ??USB_CDC_ClassEvent_10
//  313   {
//  314     USB_IsrEvent((usbMsg_t*) val);    
        MOVS     R0,R6
        BL       USB_IsrEvent
//  315   }
//  316 }
??USB_CDC_ClassEvent_10:
        POP      {R0,R4-R11,PC}   ;; return
//  317 
//  318 /**************************************************************************//*!
//  319  *
//  320  * @name  USB_Other_Requests
//  321  *
//  322  * @brief The funtion provides flexibilty to add class and vendor specific
//  323  *        requests
//  324  *
//  325  * @param controller_ID : Controller ID
//  326  * @param setup_packet  : Setup packet received
//  327  * @param data:         : Data to be send back
//  328  * @param size:         : Size to be returned
//  329  *
//  330  * @return status:
//  331  *                        gUsbErr_NoError_c : When Successfull
//  332  *                        Others : When Error
//  333  *
//  334  ******************************************************************************
//  335  * Handles CDC Class requests and forwards vendor specific request to the
//  336  * application
//  337  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  338 static uint8_t USB_CDC_OtherRequests 
//  339 (
//  340     uint8_t controllerId,           /* [IN] Controller ID */
//  341     usbSetupPacket_t * setupPacket,/* [IN] Pointer to Setup Packet Received */
//  342     uint8_t* *pData,           /* [OUT] Pointer to Data Buffer to be sent */
//  343     usbPacketSize_t *pSize           /* [OUT] Size of Data buffer */
//  344 )
//  345 {
USB_CDC_OtherRequests:
        PUSH     {R3-R9,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
        MOVS     R7,R3
//  346   uint8_t status = gUsbErr_InvalidReqType_c;
        MOVS     R8,#+205
//  347   if((setupPacket->requestType & gUsbRequestClassMask_d) == gUsbRequestClass_Class_d)
        LDRB     R0,[R5, #+0]
        ANDS     R0,R0,#0x60
        CMP      R0,#+32
        BNE.N    ??USB_CDC_OtherRequests_0
//  348   {  
//  349     /* class request so handle it here */
//  350     status=gUsbErr_NoError_c;
        MOVS     R0,#+0
        MOV      R8,R0
//  351 
//  352     /* call for class/subclass specific requests */
//  353     switch(setupPacket->request)
        LDRB     R0,[R5, #+1]
        CMP      R0,#+0
        BEQ.N    ??USB_CDC_OtherRequests_1
        CMP      R0,#+1
        BEQ.N    ??USB_CDC_OtherRequests_2
        CMP      R0,#+2
        BEQ.N    ??USB_CDC_OtherRequests_3
        CMP      R0,#+3
        BEQ.N    ??USB_CDC_OtherRequests_4
        CMP      R0,#+4
        BEQ.N    ??USB_CDC_OtherRequests_5
        CMP      R0,#+32
        BEQ.N    ??USB_CDC_OtherRequests_6
        CMP      R0,#+33
        BEQ.N    ??USB_CDC_OtherRequests_7
        CMP      R0,#+34
        BEQ.N    ??USB_CDC_OtherRequests_8
        CMP      R0,#+35
        BEQ.N    ??USB_CDC_OtherRequests_9
        B.N      ??USB_CDC_OtherRequests_10
//  354     {
//  355       case gUSB_CDC_ClassRequest_SendEncapsulatedCommand_d :
//  356              /* Add code to transfer Request and Acknowledgement */
//  357              *pSize=0;
??USB_CDC_OtherRequests_1:
        MOVS     R0,#+0
        STRH     R0,[R7, #+0]
//  358       break;
        B.N      ??USB_CDC_OtherRequests_11
//  359       case gUSB_CDC_ClassRequest_GetEncapsulatedResponse_d :
//  360              /* Add code for handling Transfer Response/Requests and Notification        */
//  361              *pSize=0;
??USB_CDC_OtherRequests_2:
        MOVS     R0,#+0
        STRH     R0,[R7, #+0]
//  362       break;
        B.N      ??USB_CDC_OtherRequests_11
//  363       case gUSB_CDC_ClassRequest_SetCommFeature_d :
//  364              *pData = (uint8_t*)setupPacket + gUsbSetupPacketSize_d; 
??USB_CDC_OtherRequests_3:
        ADDS     R0,R5,#+8
        STR      R0,[R6, #+0]
//  365              status = USB_Class_CDC_PSTN_SetCommFeature(controllerId,setupPacket, pData, pSize);
        MOVS     R3,R7
        MOVS     R2,R6
        MOVS     R1,R5
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_Class_CDC_PSTN_SetCommFeature
        MOV      R8,R0
//  366              
//  367       break;
        B.N      ??USB_CDC_OtherRequests_11
//  368       case gUSB_CDC_ClassRequest_GetCommFeature_d :
//  369              status = USB_Class_CDC_PSTN_GetCommFeature(controllerId, setupPacket, pData, pSize);
??USB_CDC_OtherRequests_4:
        MOVS     R3,R7
        MOVS     R2,R6
        MOVS     R1,R5
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_Class_CDC_PSTN_GetCommFeature
        MOV      R8,R0
//  370       break;
        B.N      ??USB_CDC_OtherRequests_11
//  371       case gUSB_CDC_ClassRequest_ClearCommFeature_d : 
//  372              {
//  373                uint8_t data[2] = {0,0};
??USB_CDC_OtherRequests_5:
        MOVS     R0,#+0
        STRH     R0,[SP, #+0]
//  374                *pData = data;
        ADD      R0,SP,#+0
        STR      R0,[R6, #+0]
//  375                status = USB_Class_CDC_PSTN_SetCommFeature(controllerId,setupPacket, pData, pSize);
        MOVS     R3,R7
        MOVS     R2,R6
        MOVS     R1,R5
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_Class_CDC_PSTN_SetCommFeature
        MOV      R8,R0
//  376              }
//  377       break;
        B.N      ??USB_CDC_OtherRequests_11
//  378       case gUSB_CDC_ClassRequest_GetLineCoding_d :
//  379              status = USB_Class_CDC_PSTN_GetLineCoding(controllerId, setupPacket, pData, pSize);
??USB_CDC_OtherRequests_7:
        MOVS     R3,R7
        MOVS     R2,R6
        MOVS     R1,R5
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_Class_CDC_PSTN_GetLineCoding
        MOV      R8,R0
//  380       break;
        B.N      ??USB_CDC_OtherRequests_11
//  381       case gUSB_CDC_ClassRequest_SetLineCoding_d :
//  382              status = USB_Class_CDC_PSTN_SetLineCoding(controllerId, setupPacket, pData, pSize);
??USB_CDC_OtherRequests_6:
        MOVS     R3,R7
        MOVS     R2,R6
        MOVS     R1,R5
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_Class_CDC_PSTN_SetLineCoding
        MOV      R8,R0
//  383       break;
        B.N      ??USB_CDC_OtherRequests_11
//  384       case gUSB_CDC_ClassRequest_SetControlLineState_d :
//  385              status = USB_Class_CDC_PSTN_SetCtrlLineState(controllerId, setupPacket, pData, pSize);
??USB_CDC_OtherRequests_8:
        MOVS     R3,R7
        MOVS     R2,R6
        MOVS     R1,R5
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_Class_CDC_PSTN_SetCtrlLineState
        MOV      R8,R0
//  386       break;
        B.N      ??USB_CDC_OtherRequests_11
//  387       case gUSB_CDC_ClassRequest_SendBreak_d :
//  388              status = USB_Class_CDC_PSTN_SendBreak(controllerId, setupPacket, pData, pSize);
??USB_CDC_OtherRequests_9:
        MOVS     R3,R7
        MOVS     R2,R6
        MOVS     R1,R5
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_Class_CDC_PSTN_SendBreak
        MOV      R8,R0
//  389       break;
        B.N      ??USB_CDC_OtherRequests_11
//  390       default:  
//  391              *pSize=0;
??USB_CDC_OtherRequests_10:
        MOVS     R0,#+0
        STRH     R0,[R7, #+0]
        B.N      ??USB_CDC_OtherRequests_11
//  392     }
//  393   }
//  394   else if((setupPacket->requestType & gUsbRequestClassMask_d) == gUsbRequestClass_Vendor_d)
??USB_CDC_OtherRequests_0:
        LDRB     R0,[R5, #+0]
        ANDS     R0,R0,#0x60
        CMP      R0,#+64
        BNE.N    ??USB_CDC_OtherRequests_11
//  395   {
//  396     /* vendor specific request  */
//  397     pfusbReqHandler_t       pfVendorReqCallback;
//  398     pfVendorReqCallback =  gpaUsbClassDescriptor[controllerId]->pfVendorReqHandler;
        LDR.N    R0,??DataTable7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDR      R0,[R0, R4, LSL #+2]
        LDR      R0,[R0, #+8]
        MOV      R9,R0
//  399     if(pfVendorReqCallback != NULL)
        MOV      R0,R9
        CMP      R0,#+0
        BEQ.N    ??USB_CDC_OtherRequests_11
//  400     {
//  401       status = pfVendorReqCallback(controllerId, setupPacket, pData, pSize);
        MOVS     R3,R7
        MOVS     R2,R6
        MOVS     R1,R5
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BLX      R9
        MOV      R8,R0
//  402     }   
//  403   }
//  404   return status;
??USB_CDC_OtherRequests_11:
        MOV      R0,R8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R1,R4-R9,PC}    ;; return
//  405 }
//  406 
//  407 
//  408 /*****************************************************************************
//  409  * Global Functions
//  410  *****************************************************************************/
//  411 /**************************************************************************//*!
//  412  *
//  413  * @name  USB_Class_CDC_Init
//  414  *
//  415  * @brief The funtion initializes the Device and Controller layer
//  416  *
//  417  * @param controller_ID:        Controller ID
//  418  * @param cdc_class_callback:   CDC Class Callback
//  419  * @param vendor_req_callback:  vendor specific class request callback
//  420  * @param param_callback:       PSTN Callback
//  421  *
//  422  * @return status
//  423  *         gUsbErr_NoError_c           : When Successfull
//  424  *         Others           : Errors
//  425  ******************************************************************************
//  426  * This function initializes the CDC Class layer and layers it is dependent upon
//  427  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  428 uint8_t USB_Class_CDC_Init 
//  429 (
//  430     uint8_t    controllerId                /* [IN] Controller ID */
//  431 )
//  432 {
USB_Class_CDC_Init:
        PUSH     {R4-R6,LR}
        MOVS     R4,R0
//  433         
//  434   uint8_t count = gpaUsbClassDescriptor[controllerId]->numNonControlEp;
        LDR.N    R0,??DataTable7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDR      R0,[R0, R4, LSL #+2]
        LDRB     R5,[R0, #+41]
//  435   /* Initialize the device layer*/
//  436   uint8_t status = USB_DeviceInit(controllerId, (uint8_t)(count+1));
        ADDS     R1,R5,#+1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_DeviceInit
        MOVS     R6,R0
//  437   /* +1 is for Control Endpoint */
//  438   gDTEStatus = (uint8_t)gUninitialisedVal_d;
        MOVS     R0,#+255
        LDR.N    R1,??DataTable7_7
        STRB     R0,[R1, #+0]
//  439   gNotifyEndpoint = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable7_3
        STRB     R0,[R1, #+0]
//  440   if(status == gUsbErr_NoError_c)
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BNE.N    ??USB_Class_CDC_Init_0
//  441   {
//  442     /* Initialize the generic class functions */
//  443     status = USB_ClassInit(controllerId, USB_CDC_ClassEvent, USB_CDC_OtherRequests);
        LDR.N    R2,??DataTable7_8
        LDR.N    R1,??DataTable7_9
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_ClassInit
        MOVS     R6,R0
//  444   }
//  445   return status;
??USB_Class_CDC_Init_0:
        MOVS     R0,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R4-R6,PC}       ;; return
//  446 }
//  447 
//  448 /**************************************************************************//*!
//  449  *
//  450  * @name  USB_Class_CDC_DeInit
//  451  *
//  452  * @brief   The funtion de-initializes the Device and Controller layer
//  453  *
//  454  * @param   controller_ID               : Controller ID
//  455  *
//  456  * @return status:
//  457  *                        gUsbErr_NoError_c        : When Successfull
//  458  *                        Others        : When Error
//  459  *
//  460  ******************************************************************************
//  461  *This function de-initializes the CDC Class layer
//  462  *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  463 uint8_t USB_Class_CDC_DeInit 
//  464 (
//  465   uint8_t controllerId              /* [IN] Controller ID */
//  466 ) 
//  467 {
USB_Class_CDC_DeInit:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
//  468   uint8_t status;
//  469   status = USB_ClassDeInit(controllerId); 
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       USB_ClassDeInit
        MOVS     R5,R0
//  470   return status;
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R1,R4,R5,PC}    ;; return
//  471 }
//  472 
//  473 
//  474 /******************************************************************************
//  475  *
//  476  * @name  USB_Class_CDC_SetDicInServiceCallback
//  477  *
//  478  * @brief 
//  479    
//  480  ******************************************************************************/
//  481  

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  482  void USB_Class_CDC_SetDicInServiceCallback(void (*pf)(usbDeviceEvent_t* event))
//  483  {
//  484    pfCDCDicInServiceCallBack = pf;
USB_Class_CDC_SetDicInServiceCallback:
        LDR.N    R1,??DataTable7_1
        STR      R0,[R1, #+0]
//  485  }
        BX       LR               ;; return
//  486  /******************************************************************************
//  487  *
//  488  * @name  USB_Class_CDC_SetDicOutServiceCallback
//  489  *
//  490  * @brief 
//  491    
//  492  ******************************************************************************/
//  493 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  494  void USB_Class_CDC_SetDicOutServiceCallback(void (*pf)(usbDeviceEvent_t* event))
//  495  {
//  496    pfCDCDicOutServiceCallBack = pf;
USB_Class_CDC_SetDicOutServiceCallback:
        LDR.N    R1,??DataTable7_2
        STR      R0,[R1, #+0]
//  497  }
        BX       LR               ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7:
        DC32     gpaUsbClassDescriptor

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_1:
        DC32     pfCDCDicInServiceCallBack

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_2:
        DC32     pfCDCDicOutServiceCallBack

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_3:
        DC32     gNotifyEndpoint

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_4:
        DC32     USB_Class_CDC_ServiceCicNotify

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_5:
        DC32     USB_Class_CDC_ServiceDicBulkOut

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_6:
        DC32     USB_Class_CDC_ServiceDicBulkIn

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_7:
        DC32     gDTEStatus

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_8:
        DC32     USB_CDC_OtherRequests

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_9:
        DC32     USB_CDC_ClassEvent

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(1)
        DATA
        DC8 0, 0

        END
//  498 
//  499 /* EOF */
//  500 #endif
// 
//   8 bytes in section .bss
//   2 bytes in section .rodata
// 978 bytes in section .text
// 
// 978 bytes of CODE  memory
//   2 bytes of CONST memory
//   8 bytes of DATA  memory
//
//Errors: none
//Warnings: none
